<!-- $NetBSD: plist.xml,v 1.19 2009/08/25 13:19:50 wiz Exp $ -->
<!-- Based on english version: -->
<!-- NetBSD: plist.xml,v 1.19 2009/08/25 13:19:50 wiz Exp   -->

<chapter id="plist">
  <title>PLIST 問題</title>

  <para><filename>PLIST</filename> ファイルは、パッケージの
  <quote>packing list</quote> (梱包明細) です。すなわち、
  パッケージを構成するファイルの一覧 (インストール先である
  <filename>${PREFIX}</filename> ディレクトリーからの相対位置)
  と、それに加えて、いくつかの追加情報
  (完全な一覧は &man.pkg.create.1; マニュアルページを参照) が載っています。
  この章では、<filename>PLIST</filename>ファイル
  (複数の場合もあります、以下を参照してください)を扱う場合に注意が必要な、
  いくつかの特別な問題について述べます。</para>


  <sect1 id="rcs-id">
    <title>RCS ID</title>

    <para>あなたが書いたすべての<filename>PLIST</filename>ファイルの先頭行にRCS IDが追加されていること
    を確認してください。</para>

    <programlisting>
@comment &#36;NetBSD&#36;
    </programlisting>
  </sect1>

  <sect1 id="automatic-plist-generation">
    <title><filename>PLIST</filename> の半自動生成</title>

    <para><command>make print-PLIST</command>コマンドを使って、パッケージの展開後に新しくできた全ファ
    イルにマッチするPLISTを出力することができます。このターゲットに関するさ
    らなる情報は、
    <xref linkend="build.helpful-targets"/>をご覧ください。</para>
  </sect1>


  <sect1 id="print-PLIST">
    <title><command>make print-PLIST</command> の出力を細工する</title>

    <para>*-dirs パッケージを<xref linkend="faq.common-dirs"/>で説明したように
    使った場合、<command>make print-PLIST</command> で、
    実際の <varname>@dirrm</varname> 行のかわりに
    <varname>@comment</varname> が出力されることにお気づきかもしれません。
    ここでディレクトリーやファイルを指定して、
    実際に近い結果を出力させることもできます。
    これはパッケージの更新の際に<emphasis>非常に
    </emphasis>役立ちます。</para>

    <para><varname>PRINT_PLIST_AWK</varname> 変数を、
    print-PLIST の出力をフィルターする
    AWK のパターンと動作の一式に設定します。
    AWK スクリプト塊を好きなように
    <emphasis>追加</emphasis>することができますが、
    適切にクォートするよう注意してください。</para>

    <para>たとえば、PLIST の結果から <filename>libdata/foo</filename>
    ディレクトリー内のファイルをすべて消すには、
    以下のようにします。</para>

    <programlisting>
PRINT_PLIST_AWK+=       /^libdata\/foo/ { next; }
    </programlisting>

    <para>また、特定の (共有) ディレクトリーを参照している
    <varname>@dirrm</varname> 行を <varname>@comment</varname>
    に変換するには、以下のようにします。</para>

    <programlisting>
PRINT_PLIST_AWK+=       /^@dirrm share\/specific/ { print "@comment " $$0; next; }
    </programlisting>
  </sect1>


  <sect1 id="plist.misc">
    <title>PLIST における各種の置換</title>

    <para>パッケージがシステムにインストールされる際に、
    PLIST 内のいくつもの変数が自動的に置換されます。
    置換される変数には、以下のようなものがあります。</para>

    <variablelist>
      <varlistentry>
	<term><varname>${MACHINE_ARCH}</varname>, <varname>${MACHINE_GNU_ARCH}</varname></term>

	<listitem>
	  <para>emacs、およびperlのようないくつかのパッケージは、それらが構築されたアー
	  キテクチャーに関する情報を、インストールするファイルのパス名に埋め込みま
	  す。このようなケースに対応するため、実際に使われる前に、PLISTに前処理が
	  おこなわれます。そして、シンボル
	  <quote><varname>${MACHINE_ARCH}</varname></quote>は、<command>uname -p</command>の出
	  力でおきかえられます。
	  <varname>${MACHINE_GNU_ARCH}</varname>がPLISTのどこかにうめこまれてい
	  る場合も同様の事がおこなわれます。これは、GNU autoconfで作成された
	  configureスクリプトを持つパッケージで使われます。</para>

	  <note>
	    <title>昔の話</title>

	    <para><quote><varname>$ARCH</varname></quote>シンボルは<command>uname
	    -m</command>の出力によって置きかえられていま
	    した。しかし、もはやサポートされていませんし、削除されています。</para>
	  </note>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><varname>${OPSYS}</varname>, <varname>${LOWER_OPSYS}</varname>, <varname>${OS_VERSION}</varname></term>

	<listitem>
	  <para>いくつかのパッケージでは、OS名とバージョンをいくつかのパス名に埋め込みま
	  す。このような場合、<filename>PLIST</filename>で以下の各変数を使用してください。
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para><varname>${OPSYS}</varname> - <quote><command>uname -s</command></quote>の出力</para>
	    </listitem>

	    <listitem>
	      <para><varname>${LOWER_OPSYS}</varname> - 共通名の小文字表記(例: <quote>solaris</quote>)</para>
	    </listitem>

	    <listitem>
	      <para><varname>${OS_VERSION}</varname> - <quote><command>uname -r</command></quote></para>
	    </listitem>
	  </itemizedlist>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>デフォルトで置換される値の全一覧は、
    <filename>bsd.pkg.mk</filename> を参照してください (あわせて、
    <varname>PLIST_SUBST</varname> を調べてください)。</para>

    <para>上述以外の変数を置換したい場合は、
    <varname>MESSAGE_SUBST</varname> (<xref
    linkend="components.optional"/>参照) と同様に、
    以下のようにして、変数とその展開方法を定義することができます。</para>

    <programlisting>
PLIST_SUBST+=   SOMEVAR="somevalue"
    </programlisting>

    <para>こうすると、<filename>PLIST</filename>
    内のすべての <quote>${SOMEVAR}</quote>
    が <quote>somevalue</quote> で置き換えられます。</para>


    <para><varname>PLIST_VARS</varname> 変数を使うと、
    条件に応じて <filename>PLIST</filename>
    の項目を追加することができます。
    <literal><varname>PLIST_VARS</varname>+=foo</literal>
    のように値を追加して、
    これに対応する <varname>PLIST.foo</varname> 変数を
    <literal>yes</literal> に設定します。
    このように設定すると、<filename>PLIST</filename> にある 
    <quote><varname>${PLIST.foo}</varname></quote> が
    <quote><literal>""</literal></quote> に置換されるようになります
    (設定していない場合は
    <quote><literal>"@comment "</literal></quote> に置換されます)。
    たとえば、<filename>Makefile</filename> では以下のようにします。</para>


    <programlisting>
PLIST_VARS+=	foo
.if <replaceable>condition</replaceable>
PLIST.foo=	yes
.else
    </programlisting>

    <para>こうしたうえで、<filename>PLIST</filename> では以下のようにします。</para>
    <programlisting>
@comment &#36;NetBSD&#36;
bin/bar
man/man1/bar.1
${PLIST.foo}bin/foo
${PLIST.foo}man/man1/foo.1
${PLIST.foo}share/bar/foo.data
${PLIST.foo}@dirrm share/bar
    </programlisting>



  </sect1>

  <sect1 id="manpage-compression">
    <title>マニュアルページの圧縮</title>

    <para>もし、(<filename>bsd.own.mk</filename>に)<varname>MANZ</varname>が設定されていれば、マニュアルページは圧縮形式で
    インストールされます。そうでなければ展開された形式でインストールされます。
    <filename>PLIST</filename>ファイルでこれをサポートするために、<varname>MANZ</varname>と <varname>MANCOMPRESSED</varname>の設定の有
    無に従い、<quote>.gz</quote>サフィックスがマニュアルページに自動的に追加、削除され
    ます。この<filename>PLIST</filename>ファイルに対する変更は、<filename>PLIST</filename>自身にたいしてでなく、それが
    コピーされる時におこなわれます。</para>
  </sect1>


  <sect1 id="using-PLIST_SRC">
    <title><varname>PLIST_SRC</varname> を使って PLIST のソースを変更する</title>

    <para>ひとつ以上のファイルを、バイナリーパッケージを構築するために<filename>PLIST</filename>のソース
    として使用する時は、それらのファイル名を変数<varname>PLIST_SRC</varname>に設定してください。こ
    れらのファイルは、後で&man.cat.1;によって連結されます。連結の順番は重要です。
    <varname>PLIST_SRC</varname> は、標準では <filename>${PKGDIR}/PLIST</filename> になります。</para>
  </sect1>


  <sect1 id="platform-specific-plist">
    <title>プラットフォーム別に異なるPLIST</title>

    <para>パッケージのなかには、インストールするファイルの組合せを、対象のオペレー
    ティングシステムによって変えるものがあります。このような差異は、以下のファ
    イルを使って自動的に処理することができます。</para>

    <itemizedlist>
      <listitem>
	<para><filename>PLIST.common</filename></para>
      </listitem>

      <listitem>
	<para><filename>PLIST.${OPSYS}</filename></para>
      </listitem>

      <listitem>
	<para><filename>PLIST.${MACHINE_ARCH}</filename></para>
      </listitem>

      <listitem>
	<para><filename>PLIST.${OPSYS}-${MACHINE_ARCH}</filename></para>
      </listitem>

      <listitem>
	<para><filename>PLIST.common_end</filename></para>
      </listitem>
    </itemizedlist>
  </sect1>


  <sect1 id="faq.common-dirs">
    <title>複数のパッケージでディレクトリーを共有する</title>

    <para><quote>共有ディレクトリー</quote>とは、複数の (かつ関連のない)
    パッケージがファイルをインストールするディレクトリーのことです。
    以前は、共有ディレクトリーは、条件に応じた削除のために PLIST に特殊な細工をするか、
    集権的な処理用パッケージを用意する必要があったので、
    問題を起こすことがありました。</para>

    <para>現在の pkgsrc では、話は単純になっています。
    各パッケージは、必要に応じて、ディレクトリーを作成してファイルをインストールします。
    <command>pkg_delete</command> は、パッケージのアンインストール後、
    空のディレクトリーが残っていればすべて削除します。</para>

    <para>パッケージの動作のために空のディレクトリーが必要な場合は、
    インストール時に通常と同じようにディレクトリーを作成するようにし、
    さらに PLIST に以下のような項目を追加します。
    <programlisting>
@pkgdir path/to/empty/directory
    </programlisting>
    </para>
  </sect1>

</chapter>
