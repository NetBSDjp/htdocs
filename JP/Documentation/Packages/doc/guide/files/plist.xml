<!-- $NetBSD: plist.xml,v 1.8 2005/09/02 19:12:37 rillig Exp $ -->
<!-- Based on english version: -->
<!-- NetBSD: plist.xml,v 1.8 2005/09/02 19:12:37 rillig Exp   -->

<chapter id="plist">
  <title>PLIST 問題</title>

  <para> <filename>PLIST</filename> ファイルは、パッケージの
    <quote>packing list</quote> (梱包明細) です。すなわち、
    パッケージを構成するファイルの一覧 (インストール先である
    <filename>${PREFIX}</filename> ディレクトリーからの相対位置)
    と、それに加えて、いくつかの追加情報
    (完全な一覧は &man.pkg.create.1; マニュアルページを参照) が載っています。
    この章では、<filename>PLIST</filename>ファイル
    (複数の場合もあります、以下を参照してください)を扱う場合に注意が必要な、
    いくつかの特別な問題について述べます。</para>


  <sect1 id="rcs-id">
    <title>RCS ID</title>

    <para>
      あなたが書いたすべての<filename>PLIST</filename>ファイルの先頭行にRCS IDが追加されていること
      を確認してください。
    </para>

    <programlisting>@comment &#36;NetBSD&#36;</programlisting>
  </sect1>
    
  <sect1 id="automatic-plist-generation">
    <title><filename>PLIST</filename> の半自動生成</title>
	    
    <para><command>make print-PLIST</command>コマンドを使って、パッケージの展開後に新しくできた全ファ
      イルにマッチするPLISTを出力することができます。このターゲットに関するさ
      らなる情報は、
      <xref linkend="build.helpful-targets"/>をご覧ください。</para>
  </sect1>


  <sect1 id="print-PLIST">
    <title><command>make print-PLIST</command> の出力を細工する</title>
  
    <para> *-dirs パッケージを<xref linkend="faq.common-dirs"/>で説明したように
      使った場合、<command>make print-PLIST</command> で、
      実際の <varname>@dirrm</varname> 行のかわりに
      <varname>@comment</varname> が出力されることにお気づきかもしれません。
      ここでディレクトリーやファイルを指定して、
      実際に近い結果を出力させることもできます。
      これはパッケージの更新の際に<emphasis>非常に
      </emphasis>役立ちます。 </para>
  
    <para> <varname>PRINT_PLIST_AWK</varname> 変数を、
      print-PLIST の出力をフィルターする
      AWK のパターンと動作の一式に設定します。
      AWK スクリプト塊を好きなように
      <emphasis>追加</emphasis>することができますが、
      適切にクォートするよう注意してください。 </para>
  
    <para> たとえば、PLIST の結果から <filename>libdata/foo</filename>
      ディレクトリー内のファイルをすべて消すには、
      以下のようにします。</para> 
  
    <programlisting>
      PRINT_PLIST_AWK+= /^libdata\/foo/ { next; }
    </programlisting>
  
    <para> また、特定の (共有) ディレクトリーを参照している
      <varname>@dirrm</varname> 行を <varname>@comment</varname>
      に変換するには、以下のようにします。 </para> 
  
    <programlisting>
      PRINT_PLIST_AWK+= /^@dirrm share\/specific/ { print "@comment " $$0; next; }
    </programlisting>
  </sect1>
    
  
  <sect1 id="plist.misc">
    <title>PLIST における各種の置換</title>

    <para>
      パッケージがシステムにインストールされる際に、
      PLIST 内のいくつもの変数が自動的に置換されます。
      置換される変数には、以下のようなものがあります。</para>

    <variablelist>
      <varlistentry>
    	  <term><varname>${MACHINE_ARCH}</varname>, <varname>${MACHINE_GNU_ARCH}</varname></term>

        <listitem>
          <para>emacs、およびperlのようないくつかのパッケージは、それらが構築されたアー
            キテクチャーに関する情報を、インストールするファイルのパス名に埋め込みま
            す。このようなケースに対応するため、実際に使われる前に、PLISTに前処理が
            おこなわれます。そして、シンボル
            <quote><varname>${MACHINE_ARCH}</varname></quote>は、<command>uname -p</command>の出
            力でおきかえられます。
            <varname>${MACHINE_GNU_ARCH}</varname>がPLISTのどこかにうめこまれてい
            る場合も同様の事がおこなわれます。これは、GNU autoconfで作成された
            configureスクリプトを持つパッケージで使われます。</para>

          <note>
            <title>昔の話</title>
  
            <para><quote><varname>$ARCH</varname></quote>シンボルは<command>uname
              -m</command>の出力によって置きかえられていま
              した。しかし、もはやサポートされていませんし、削除されています。</para>
          </note>
        </listitem>
      </varlistentry>
  
      <varlistentry>
        <term><varname>${OPSYS}</varname>, <varname>${LOWER_OPSYS}</varname>, <varname>${OS_VERSION}</varname></term>
  
        <listitem>
          <para>いくつかのパッケージでは、OS名とバージョンをいくつかのパス名に埋め込みま
            す。このような場合、<filename>PLIST</filename>で以下の各変数を使用してください。
          </para>

          <itemizedlist>
            <listitem>
              <para><varname>${OPSYS}</varname> - <quote><command>uname -s</command></quote>の出力</para>
            </listitem>

            <listitem>
              <para><varname>${LOWER_OPSYS}</varname> - 共通名の小文字表記(例: <quote>solaris</quote>)</para>
            </listitem>

            <listitem>
              <para><varname>${OS_VERSION}</varname> - <quote><command>uname -r</command></quote></para>
            </listitem>
          </itemizedlist>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><varname>${PKGLOCALEDIR}</varname></term>

        <listitem>
          <para>ロケールファイルをインストールするパッケージでは、ロケールファイルを
            <quote>share/locale/de/LC_MESSAGES/...</quote>ではなく
            <quote>${PKGLOCALEDIR}/locale/de/LC_MESSAGES/...</quote>という形でPLISTに列挙します。
            ロケールファイルのデフォルトの場所はオペレーティングシステムによって<filename>share</filename>か<filename>lib</filename>か異なります
            が、このような形で書くことで適切に処理することができます。</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para> デフォルトで置換される値の全一覧は、
      <filename>bsd.pkg.mk</filename> を参照してください (あわせて、
      <emphasis>PLIST_SUBST</emphasis> を調べてください)。 </para>
    
    <para> 上述以外の変数を置換したい場合は、
      <varname>MESSAGE_SUBST</varname> (<xref
      linkend="components.optional"/>参照) と同様に、
      以下のようにして、変数とその展開方法を定義することができます。 </para>

    <programlisting>PLIST_SUBST+=    SOMEVAR="somevalue"</programlisting>

    <para>こうすると、PLIST 内のすべての <quote>${SOMEVAR}</quote>
      が <quote>somevalue</quote> で置き換えられます。  </para>
  </sect1>

  <sect1 id="manpage-compression">
    <title>マニュアルページの圧縮</title>
    
    <para>もし、(<filename>bsd.own.mk</filename>に)<varname>MANZ</varname>が設定されていれば、マニュアルページは圧縮形式で
      インストールされます。そうでなければ展開された形式でインストールされます。
      <filename>PLIST</filename>ファイルでこれをサポートするために、<varname>MANZ</varname>と <varname>MANCOMPRESSED</varname>の設定の有
      無に従い、<quote>.gz</quote>サフィックスがマニュアルページに自動的に追加、削除され
      ます。この<filename>PLIST</filename>ファイルに対する変更は、<filename>PLIST</filename>自身にたいしてでなく、それが
      コピーされる時におこなわれます。</para>
  </sect1>

  
  <sect1 id="using-PLIST_SRC">
    <title><varname>PLIST_SRC</varname> を使って PLIST のソースを変更する</title>

    <para>ひとつ以上のファイルを、バイナリーパッケージを構築するために<filename>PLIST</filename>のソース
      として使用する時は、それらのファイル名を変数<varname>PLIST_SRC</varname>に設定してください。こ
      れらのファイルは、後で&man.cat.1;によって連結されます。連結の順番は重要です。</para>
  </sect1>


  <sect1 id="platform-specific-plist">
    <title>プラットフォーム別に異なるPLIST</title>
    
    <para>パッケージのなかには、インストールするファイルの組合せを、対象のオペレー
      ティングシステムによって変えるものがあります。このような差異は、以下のファ
      イルを使って自動的に処理することができます。</para>

    <itemizedlist>
      <listitem>
        <para><filename>PLIST.common</filename></para>
      </listitem>

      <listitem>
        <para><filename>PLIST.${OPSYS}</filename></para>
      </listitem>

      <listitem>
        <para><filename>PLIST.${MACHINE_ARCH}</filename></para>
      </listitem>

      <listitem>
        <para><filename>PLIST.${OPSYS}-${MACHINE_ARCH}</filename></para>
      </listitem>

      <listitem>
        <para><filename>PLIST.common_end</filename></para>
      </listitem>
    </itemizedlist>
  </sect1>


  <sect1 id="faq.common-dirs">
    <title>複数のパッケージでディレクトリーを共有する</title>
  
    <para> <quote>共有ディレクトリー</quote>とは、複数の (かつ関連のない)
      パッケージがファイルをインストールするディレクトリーのことです。
      共有ディレクトリーは、条件に応じた削除のために PLIST に特殊な細工をするか、
      集権的な処理用パッケージを用意する必要があるので、
      問題を起こすことがあります。 </para>
  
    <para> pkgsrc では、このどちらの方法も使うことができます。
      あるディレクトリーを数個の無関連なパッケージが共有していても、
      多くの場合、そのディレクトリーを削除するためにさらにパッケージを追加する必要はありません。
      このディレクトリーを使っている全パッケージの PLIST で、
      通常の "@dirrm" 行のかわりに、</para>
  
    <programlisting>
      @unexec ${RMDIR} %D/path/to/shared/directory 2>/dev/null || ${TRUE}
    </programlisting>
  
    <para> と書くだけでうまくいきます。 </para>
  
    <para> しかし、ディレクトリーを数多くのパッケージが共有している場合、
      以下の二種類の解決策を使うことができます。 </para>
  
    <orderedlist>
      <listitem>
        <para> 各パッケージが共通の依存パッケージを持つ場合、
          その依存先のパッケージでディレクトリーを削除できます。たとえば、
          <filename role="pkg">textproc/scrollkeeper</filename> を参照してください。
	  このパッケージは共有ディレクトリー
	  <filename>share/omf</filename> を削除しています。 </para>
      </listitem>
  
      <listitem>
        <para> パッケージが関連を持たずに共有ディレクトリーを使っている場合
           (つまり、共通の依存パッケージがない場合)、
          *-dirs パッケージで共有ディレクトリーを削除します。 </para>
      </listitem>
    </orderedlist>
  
    <para> 以下、二つ目の解決策について述べます。
      既存の *-dirs パッケージを把握するため、以下を実行してください。 </para>
      
    <programlisting>
      &cprompt; cd .../pkgsrc
      &cprompt; ls -d */*-dirs
    </programlisting>
  
    <para> 他のパッケージがこれらを使う方法は非常に簡単です。
      <varname>USE_DIRS</varname> 変数に、このパッケージ名 (<quote>-dirs</quote> は除く)
      と必要なバージョン番号 (常に、パッケージを新たに書いたときの最新バージョンを選びます)
      をつけたものを並べます。 </para>
  
    <para> たとえば、あるパッケージが
      <filename>share/applications</filename> 以下にファイルをインストールする場合、
      以下の行を含めておきます。
      </para>
  
    <programlisting>
      USE_DIRS+= xdg-1.1
    </programlisting>
  
    <para> <command>make
      print-PLIST</command> を使って PLIST を作り直すと、
      行が適切に (コメントアウトされて)
      得られるはずです。 </para> 
      
    <para> なお、パッケージがたとえ <filename>$X11BASE</filename>
      を使う場合であっても、*-x11-dirs パッケージに依存させてはいけません。
      この部分を除いた名前を指定するだけでよく、そうすれば
      pkgsrc (特に <filename>mk/dirs.mk</filename>)
      が処理してくれます。 </para> 
  </sect1>
  
</chapter>
