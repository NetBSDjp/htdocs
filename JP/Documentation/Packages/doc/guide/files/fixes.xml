<!-- $NetBSD: fixes.xml,v 1.92 2008/01/23 13:46:21 rillig Exp $ -->
<!-- Based on english version: -->
<!-- NetBSD: fixes.xml,v 1.92 2008/01/23 13:46:21 rillig Exp   -->

<chapter id="fixes"> <?dbhtml filename="fixes.html"?>
<title>パッケージを動くようにする</title>

<sect1 id="general-operation">
  <title>一般的な操作</title>

  <sect2 id="portability-of-packages">
    <title>パッケージの移植性</title>

    <para>pkgsrc の目玉の一つは、多くのプラットフォームで動作することです。
    そのため、pkgsrc のパッケージの移植性をできるかぎり高めることが重要になります。
    本章では、pkgsrc の作業に際して、
    注意が必要となる具体的な事項を説明します。</para>
  </sect2>

  <sect2 id="pulling-vars-from-etc-mk.conf">
    <title>&mk.conf; から利用者が設定可能な変数を捕まえる方法</title>

    <para>pkgsrc の利用者は、<varname>MAKECONF</varname>
    によって参照されるファイル (標準では &mk.conf;)
    でいくつかの変数を上書きして、pkgsrc の設定をすることができます。
    このような変数を &man.make.1; のプリプロセッサーディレクティブ
    (たとえば <literal>.if</literal> や
    <literal>.for</literal>) の内部で使いたい場合は、
    利用者の設定が読み込まれる場所より前で
    <filename>../../mk/bsd.prefs.mk</filename> をインクルードする必要があります。</para>

    <para>しかし、変数によっては、
    まだ定義されていない変数への参照を含んでいることがあるために、
    <filename>../../mk/bsd.prefs.mk</filename>
    をインクルードした後では完全に定義することができないものがあります。
    シェルコマンドの場合は、変数の実態はマクロであり、
    使われるときにしか展開されないので、このことは問題にはなりません。
    ただし、前述したプリプロセッサーディレクティブの内部や、
    依存性を記した行 (<literal>target: dependencies</literal> のような形式の行)
    においては、読み込み時に変数が展開されます。</para>

    <note><para>各変数が読み込み時に使用可能か、
    実行時にのみ使用可能かを網羅した一覧は、現在のところありませんが、
    準備をしているところです。</para></note>
  </sect2>

  <sect2 id="user-interaction">
    <title>ユーザーとの対話</title>

    <para>時々、パッケージがユーザーとの対話を必要とする場合がありますが、
    そのような状況は何通りもありえます:</para>

    <itemizedlist>

      <listitem>
	<para>distfile の取得時に、パッケージによっては、
	ユーザー名とパスワードの入力や web ページ上のライセンスへの同意のような、
	利用者の対話を必要とするものがあります。</para>
      </listitem>

      <listitem>
	<para>distfile の展開時に、
	パッケージによってはパスワードを要求することがあります。</para>
      </listitem>

      <listitem>
	<para>パッケージの構築前の設定の補助</para>
      </listitem>

      <listitem>
	<para>構築過程の最中の補助</para>
      </listitem>

      <listitem>
	<para>パッケージのインストール中の補助</para>
      </listitem>
    </itemizedlist>

    <para>どの段階で対話が必要になるかをpkgsrcの機構に知らせるため、
    <varname>INTERACTIVE_STAGE</varname> 定義が用意されており、
    パッケージの<filename>Makefile</filename>で定義します。
    たとえば以下のようにします。</para>

    <programlisting>
INTERACTIVE_STAGE=      build
    </programlisting>

    <para>複数の段階を指定することもできます:</para>

    <programlisting>
INTERACTIVE_STAGE=      configure install
    </programlisting>

    <para>利用者は、<varname>BATCH</varname> 変数を設定して、
    この定義がおこなわれているパッケージをとばすことができます。</para>
  </sect2>

  <sect2 id="handling-licenses">
    <title>ライセンスの処理</title>

    <para>ソフトウェアの作者は、
    そのソフトウェアをどのようなライセンスのもとでコピーすることができるかを、定めることができます。
    これは著作権法にもとづくことであって、ライセンス選択の理由は
    pkgsrc システムの範疇外です。pkgsrc システムでは、
    ライセンスのなかには、従うことに不服だったり、
    従うことが困難あるいは不可能だったりする利用者がいるようなライセンスがたくさんあることを認識しています。
    Free Software Foundation ではいくつかのライセンスに対して、
    それが「自由」なライセンスであると表明していますし、
    Open Source Initiative では「オープンソース」を定義しています。
    pkgsrc では、ライセンスが「自由」あるいは「オープンソース」であるといった目印をパッケージにつけたりはしないという方針をとっています。
    ただし、これらの定義にあてはまらないライセンスをもつパッケージには、
    ライセンスについて記した目印がついています。
    なお、ライセンスでコピーを認めていないパッケージは、
    明らかに、「自由」にも「オープンソース」にも該当しません。</para>

    <para>「自由」でも「オープンソース」でもないパッケージについては、
    構築してよいということを、個々のライセンスについて利用者が pkgsrc に指定しておかない限り、
    pkgsrc はパッケージを構築しません。
    なお、このドキュメンテーションでは、「ライセンスに同意する」
    ("accepted the license") という言いまわしを避けています。
    pkgsrc システムは、単に、
    フリーでないライセンスのソフトウェアを誤って構築してしまうことがないようにする仕組みを提供しているだけです。
    判断や責任は、利用者に委ねています。
    (現在のところ、バイナリーパッケージのインストールは、
    この仕組みの対象外です。これはバグです。)</para>

    <para>BSD ライセンスと GPL のパッケージだけをインストールし、
    それ以外はインストールしたくない、ということがあるかもしれません。
    pkgsrc のライセンスの目印の仕組みでは、そういうことは実現できません。
    フリーなライセンスに対して目印をつけて、
    <varname>ACCEPTABLE_LICENSES</varname>
    変数の標準状態での値を決めればそういうことも可能なのでしょうが、
    手間に対して効果が小さすぎるとの意見が多数です。</para>

    <para>ライセンスの目印の仕組みは、パッケージの構築、インストール、
    および使用にまつわる著作権関連の問題を処理するためのものであって、
    再配布にまつわる問題 (<varname>RESTRICTED</varname> および
    <varname>NO_SRC_ON_FTP</varname> などを参照) のためのものではありません。
    ただし、目印が必要なライセンスの定義は上述のとおりであり、
    「自由」あるいは「オープンソース」のプログラムは再配布を制限していないので、
    再配布に制限のあるパッケージには目印がついていることになります。</para>

    <para>パッケージのコピーが特殊なライセンスのもとで認められていることを示すには、
    そのライセンスを
    <filename>pkgsrc/licenses</filename> に置いたうえで、
    <varname>LICENSE</varname> 変数をライセンスを特定する文字列に設定します。
    たとえば、<filename
    role="pkg">graphics/xv</filename> では以下のようになります。</para>

    <programlisting>
LICENSE=        xv-license
    </programlisting>

    <para>構築しようとすると、利用者はそのパッケージに適用されているライセンスが
    <varname>ACCEPTABLE_LICENSES</varname>
    変数に設定されていないことを知らされます。</para>

    <programlisting>
&cprompt; <userinput>make</userinput>
===> xv-3.10anb9 has an unacceptable license: xv-license.
===>     To view the license, enter "/usr/bin/make show-license".
===>     To indicate acceptance, add this line to your /etc/mk.conf:
===>     ACCEPTABLE_LICENSES+=xv-license
*** Error code 1
    </programlisting>

    <para>ライセンス自体は <command>make
    show-license</command> すると見ることができます。
    そのライセンスのものを構築してよい場合は、
    pkgsrc が今後はそのライセンスを理由に構築をやめないように、
    上の表示中で指示されている行を &mk.conf;
    に追加することができます。</para>

    <programlisting>
ACCEPTABLE_LICENSES+=xv-license
    </programlisting>

    <para>新しいライセンスが適用されているパッケージを追加する場合、
    表示用のライセンスのテキストを <filename>pkgsrc/licenses</filename>
    に追加します。既知のライセンスの一覧は、
    このディレクトリーで見ることができます。</para>

    <para>ライセンスが (整形以外で) 変更された場合は、
    必ず、新しいライセンスの名前を以前のものと別の名前にします (たとえば、
    バージョン番号があればそれを、なければ日付を末尾につけるなど)。
    これは、前バージョンのライセンスのもとにあるプログラムを構築することを
    pkgsrc に指示している利用者が、
    新しいライセンスのもとにあるプログラムを構築しないようにするためです。
    もっと高度な点でいうと、
    pkgsrc はライセンスの相当性を評価しません。
    すなわち、個々のライセンスのテキストを、二組織のいずれかが
    (「自由」あるいは「オープンソース」であると) 認めているかどうかという、
    機械的な検査をしているだけなのです。</para>

    <para><varname>LICENSE=shareware</varname> や、
    <varname>LICENSE=no-commercial-use</varname> のような言いまわしは、
    ライセンスの文面を特定できないので、
    使わないことになりました。
    また、このような言いまわしを使った場合の別の問題として、
    利用者が pkgsrc に対して、同じ目印のついた複数のパッケージのうち、
    ひとつのパッケージだけは構築を続行するが、
    それ以外のパッケージは構築を続行しない、
    といった指定ができなくなるというものもあります。</para> </sect2>

  <sect2 id="restricted-packages">
    <title>制限つきパッケージ</title>

    <para>ライセンスによっては、ソフトウェアの再配布方法に制限があります。
    パッケージが「自由」あるいは「オープンソース」でない限りは、
    ライセンスの目印が必要なので、制限のあるパッケージにはすべてライセンスの目印がついているはずです。
    その制限について記述しておくと、パッケージのツールは、
    自動的に制限されたこと (たとえばバイナリーパッケージを FTP サイトに置くこと)
    を控えたりすることができます。</para>

    <para>ソース (distfile) とバイナリーそれぞれについて、
    置いていけないのが FTP サイトか CD-ROM かの組み合わせで、
    4 種類の制限を表現することができます。どのライセンスでも、
    これが厳密な文言となっていることはほとんどないことや、
    フリーでない各ライセンスはお互いに異なる傾向があることから、
    pkgsrc では FTP と CD-ROM を定義しています。
    pkgsrc では、"FTP" を、ソースやバイナリーのファイルを、
    インターネット上で料金を払わずに利用できるようにしてはいけない、
    という意味で使います。
    pkgsrc では、"CD-ROM" を、ソースやバイナリーを、
    配布料金をとるような何らかの種類の媒体に、
    他のソースやバイナリーパッケージと同梱して利用できるようにすることはできない、
    という意味で使います。
    </para>

    <para>このような
    制限を表現するため、パッケージシステムでは以下のような制限を設定で
    きる5個のmake変数を定義しています:</para>

    <itemizedlist>
      <listitem>
	<para><varname>RESTRICTED</varname></para>

	<para>なにか制限がある場合は常に、(制限の種類にかかわらず)この変数を設定します。
	この変数を、その制限の理由を含む文字列に設定してください。
	制限を理解しなければならない人は、ライセンスを読む必要がありますし、
	おそらく法的な助言も必要だと考えなければなりません。</para>
      </listitem>

      <listitem>
	<para><varname>NO_BIN_ON_CDROM</varname></para>

	<para>バイナリーを、配布料金を取れるようにして、
	他のバイナリーパッケージとともにCD-ROMに収録することができません。
	そのような場合は常に、この変数を<varname>${RESTRICTED}</varname>に設定
	してください。</para>
      </listitem>

      <listitem>
	<para><varname>NO_BIN_ON_FTP</varname></para>

	<para>バイナリーを、インターネット上で料金を払わずに利用できるようにすることができません。
	そのような場合は常に、この変数を
	<varname>${RESTRICTED}</varname>に設定してください。
	この変数を設定すると、バイナリーパッケージは
	ftp.NetBSD.org に置かれません。</para>
      </listitem>

      <listitem>
	<para><varname>NO_SRC_ON_CDROM</varname></para>

	<para>distfileを、料金を取れるようにして、
	他のdistfileとともにCD-ROMに収録することができません。
	そのような場合は、この変数を
	<varname>${RESTRICTED}</varname>に設定してください。</para>
      </listitem>

      <listitem>
	<para><varname>NO_SRC_ON_FTP</varname></para>

	<para>distfileを、インターネット上で料金を払わずに利用できるようにすることができません。
	そのような場合は、この変数を
	<varname>${RESTRICTED}</varname>に設定してください。
	この変数を設定すると、distfile は
	ftp.NetBSD.org にミラーされません。</para>
      </listitem>
    </itemizedlist>

    <para><varname>NO_PACKAGE</varname>,
    <varname>IGNORE</varname>, <varname>NO_CDROM</varname> など、制限を意味する上記以外の汎用make変数は使
    わないようにしてください。これらは、ユーザーのバイナリーパッケージ作成を、
    無条件にできないようにするからです。</para>
  </sect2>


  <sect2 id="dependencies">
    <title>依存性の処理</title>

    <para>パッケージは他のパッケージに依存するかもしれません。そして、この依存性を定
    義するためのいろいろな方法があります。pkgsrc は、<filename>buildlink3.mk</filename>を使った依存関
    係 (依存性の処理用としては、こちらが望ましい方法です。
    この方法では以下の各変数を使っています。
    さらなる情報は<xref linkend="buildlink"/>を参照してください)
    のほか、
    <varname>BUILD_DEPENDS</varname> および <varname>DEPENDS</varname> 定義、
    <varname>USE_TOOLS</varname> 定義をサポートしています。</para>

    <para>両変数の基本的な差異は、以下の通りです: <varname>DEPENDS</varname>定義では、
    その依存性がバイナリーパッケージ内に記録されるので、
    後でバイナリーパッケージをインストールする時に依存性が呼び出されます。
    一方、<varname>BUILD_DEPENDS</varname>定義ではバイナリーパッケージにそのような記録はされず、
    パッケージの構築に際して依存性があることが示されているだけです。</para>

    <para>つまり、あるパッケージが必要となるのが構築時だけである場合、そのパッケージ
    は<varname>BUILD_DEPENDS</varname>として書きます。</para>

    <para><varname>BUILD_DEPENDS</varname>および
    <varname>DEPENDS</varname>定義の書式は以下の通りです:</para>

    <programlisting>
&lt;pre-req-package-name&gt;:../../&lt;category&gt;/&lt;pre-req-package&gt;
    </programlisting>

    <para>なお、この<quote>pre-req-package-name</quote> のバージョン番号には、&man.pkg.info.1; で説明され
    ている各ワイルドカードを含めることができます。</para>

    <orderedlist>
      <listitem>
	<para>パッケージを構築または実行するために他のパッケージのバイナリーやライブラリーが必要で、
	そのパッケージに <filename>buildlink3.mk</filename> ファイルがある場合は、
	それを使ってください。</para>

	<programlisting>
.include "../../graphics/jpeg/buildlink3.mk"
	</programlisting>
      </listitem>

      <listitem>
	<para>パッケージを構築するために他のパッケージが必要で、
	そのパッケージに <filename>buildlink3.mk</filename> ファイルがない場合は、
	<varname>BUILD_DEPENDS</varname>定義を使ってください。</para>

	<programlisting>
BUILD_DEPENDS+= autoconf-2.13:../../devel/autoconf
	</programlisting>
      </listitem>

      <listitem>

	<para>パッケージがリンクのためのライブラリーを必要とし、
	そのパッケージにやはり <filename>buildlink3.mk</filename> ファイルがない場合は、
	<varname>DEPENDS</varname> 定義を使ってください。
	たとえば以下のようにします。</para>

	<programlisting>
DEPENDS+=       xpm-3.4j:../../graphics/xpm
	</programlisting>

	<para>また、パッケージ依存関係にはワイルドカードを使うことができます。</para>

	<programlisting>
DEPENDS+=       xpm-[0-9]*:../../graphics/xpm
	</programlisting>

	<para>ワイルドカード依存関係は、バイナリーパッケージを作る時には保持されること
	に注意してください。依存関係はバイナリーパッケージのインストール時にチェッ
	クされ、パターンにマッチするパッケージが使われます。ワイルドカード依存関係
	は、注意を払って使うよう気を付けてください。</para>

	<para><quote>tk-postgresql</quote>が<quote>tk-*</quote>という
	<varname>DEPENDS</varname>にマッチするなどの曖昧なマッチの可能性を排除
	するため、<quote>-*</quote>ではなく
	<quote>-[0-9]*</quote>を使うことをおすすめします。</para>

	<para>ワイルドカードは、
	依存パッケージがあるバージョン以上でないと構築できないことを指定するのにも使えます。</para>

	<programlisting>
DEPENDS+=       tiff>=3.5.4:../../graphics/tiff
	</programlisting>

	<para>以上のように書いた場合、このパッケージは tiff ライブラリーのバージョン 3.5.4
	以降とともに構築されることを意味します。このような形式の依存関係は、たとえば、
	tiff ライブラリーの API が 3.5.4 で変更されたため、それより前のバージョンの tiff
	ではパッケージがコンパイルできないような場合に、構築できることを保証することができます。</para>

	<para>なお、このような形式の依存関係は、新しい依存関係が必要となった場合のみに更新してください。
	ABI の変更などであって、構築自体は正常におこなうことができる場合、
	その推奨のために依存関係を更新したりしないでください。
	後者の場合は <varname>ABI_DEPENDS</varname> を使って推奨を示すことができます。</para>

	<programlisting>
ABI_DEPENDS+=   tiff>=3.6.1:../../graphics/tiff
	</programlisting>

	<para>これを上述の <varname>DEPENDS</varname> 行に追加することで、
	パッケージの構築は tiff&gt;=3.5.4 でおこなうことができるが、
	少なくともバージョン 3.6.1 を推奨するということを意味します。
	<varname>ABI_DEPENDS</varname> の内容は、(警告が表示された際に)
	明示的に無視された場合を除き、依存関係に反映されます。</para>

	<para>ABI の依存性に関するこの推奨を無視して、必須の
	<varname>DEPENDS</varname> を使うだけにするには、
	<varname>USE_ABI_DEPENDS=NO</varname> を設定します。
	こうすると、互換性のある古い依存性をそのまま使うことができるので、
	pkgsrc を使って構築されたパッケージの更新が簡単かつ速くできるようになります。
	これは、パッケージの再構築を念入りに観察する人にとっては便利な方法ですが、
	一般向けにはよろしくない方法です。
	この方法を使う場合は、OS に由来するものも含めて、
	起こりうる ABI の変更に十分注意する必要があります。</para>

	<para>推奨を無視して構築されたパッケージは、開発者が ftp.NetBSD.org
	へアップロードしてはいけません。また、そのようなパッケージを別のシステムで使うと、
	別バージョンのバイナリーパッケージが複数インストールされる可能性があるので、
	そのようなこともしないようにしてください。</para>

	<para>セキュリティー上の修正があった場合は、
	パッケージ脆弱性ファイルを更新してください。
	さらなる情報は、<xref
	linkend="security-handling"/>を参照してください。</para>
      </listitem>

      <listitem>
	<para>パッケージを実行するために、いくつかの実行可能ファイルが必要であり、かつ
	<filename>buildlink3.mk</filename> ファイルが存在しない場合は、
	<varname>DEPENDS</varname>変数を使ってください。<filename role="pkg">print/lyx</filename>パッケージを実行する時には、
	teTeXパッケージ由来のlatex のバイナリーが実行可能でなければなりません。これ
	は、以下のように指定します。</para>

	<programlisting>
DEPENDS+=        teTeX-[0-9]*:../../print/teTeX
	</programlisting>

	<para>上述した、ワイルドカード依存関係に関する注意は、ここにも当てはまります。</para>
      </listitem>
    </orderedlist>

    <para>パッケージの構築用に別のパッケージに含まれるファイルが必要な場合は、
    関連する配布ファイルを
    <varname>DISTFILES</varname> に追加して、
    必要なファイルが自動的に展開されるようにします。例としては <filename
    role="pkg">print/ghostscript</filename> パッケージをご覧ください。
    (このパッケージは、
    構築の際に jpeg のソースがソースの状態で存在することに依存しています。)</para>
  </sect2>


  <sect2 id="conflicts">
    <title>他のパッケージとの衝突の処理</title>

    <para>パッケージは、すでにインストール済みの別のパッケージと衝突する可能性があり
    ます。例えば、パッケージが、pkgsrcの中の別のパッケージと同じファイルをイン
    ストールするような場合です。</para>

    <para>この場合、衝突するパッケージ(バージョン文字列を含む)のリストをスペースで区
    切って<varname>CONFLICTS</varname>にセットすることができます。</para>

    <para>例えば、<filename role="pkg">x11/Xaw3d</filename>
    および<filename role="pkg">x11/Xaw-Xpm</filename>は同じ共有ライブラリーをイ
    ンストールします。したがって、<filename>pkgsrc/x11/Xaw3d/Makefile</filename>に以下のような設定を
    おこなってください。</para>

    <programlisting>
CONFLICTS=      Xaw-Xpm-[0-9]*
    </programlisting>

    <para>そして、<filename>pkgsrc/x11/Xaw-Xpm/Makefile</filename>には以下の設定が必要です。</para>

    <programlisting>
CONFLICTS=      Xaw3d-[0-9]*
    </programlisting>

    <para>パッケージは、名前のプレフィックスが同じで、異なるバージョン文字列をもつ別
    のパッケージと自動的に衝突します。例えば<quote>Xaw3d-1.5</quote>は、古いバージョンの
    <quote>Xaw3d-1.3</quote>と衝突するでしょう。</para>
  </sect2>


  <sect2 id="not-building-packages">
    <title>構築することができない、あるいはすべきでないパッケージ</title>

    <para>環境によってはパッケージを構築しないよう指示するような理由がいくつかありま
    す。パッケージが、ほとんどのプラットフォームで構築および実行できる場合は、
    <varname>NOT_FOR_PLATFORM</varname>として例外を記述します。逆に、パッケージが一部のプラットフォー
    ムでしか構築および実行できない場合は、<varname>ONLY_FOR_PLATFORM</varname>を設定します。
    <varname>ONLY_FOR_PLATFORM</varname> と
    <varname>NOT_FOR_PLATFORM</varname> の値はいずれも、OS triples
    (OS-version-platform) であり、
    グロブ形式のワイルドカードを使うことができます。</para>
    <para>パッケージのなかには、あるオペレーティングシステムの特定のバージョンに強く依存するものがあります。
    たとえば、LKM や <filename
    role="pkg">sysutils/lsof</filename> などです。
    このようなバイナリーパッケージは、同じ OS の別バージョンと後方互換ではないので、
    FTP サーバーでは対象バージョン専用のディレクトリーにアップロードするようにします。
    <varname>OSVERSION_SPECIFIC</varname> を <quote>yes</quote> に設定して、
    パッケージに印をつけてください。この変数は、現在のところ、
    パッケージシステム内部のどこでも使われませんが、
    将来は使われることになるかもしれません。</para>
    <para>パッケー
    ジをとばすべき場合(たとえば、そのパッケージが提供する機能が、すでにシステム
    で提供されている場合)は、
    <varname>PKG_SKIP_REASON</varname>にそのことを説明するメッセージを設
    定します。必要な条件が満たされていないせいでパッケージの構築が失敗するであ
    ろう場合は、<varname>PKG_FAIL_REASON</varname>にそのことを説明するメッセージを設定します。</para>
  </sect2>


  <sect2 id="undeletable-packages">
    <title>一旦インストールしたら削除すべきでないパッケージ</title>

    <para>あるパッケージを、一旦インストールしたら削除できないようにするためには、
    そのパッケージの Makefile で <varname>PKG_PRESERVE</varname>
    定義を設定します。この定義を設定した
    pkgsrc エントリーから作られたバイナリーパッケージには、その旨が記録されます。
    <quote>preserved</quote> 付きのパッケージは、
    &man.pkg.delete.1; を使っても、
    <quote>-f</quote> オプションを付けない限りは削除されません。</para>
  </sect2>


  <sect2 id="security-handling">
    <title>セキュリティー問題を持つパッケージへの対処</title>

    <para>脆弱性が発見された場合、そのことを
    <filename>localsrc/security/advisories/pkg-vulnerabilities</filename>に記載してcommitしてくださ
    い。このファイルを commit した後、同じディレクトリーで <command>make upload</command>
    して、ftp.NetBSD.org 上のファイルを更新してください。</para>

    <para>脆弱性の修正を、パッチの適用によっておこなった場合は、修正後に
    <varname>PKGREVISION</varname> を上げます (もちろん、問題の修正を、
    新しくリリースされたソフトウェアを使っておこなった場合は、
    これは必要ありません)。</para>

    <para>また、修正を安定版 pkgsrc 枝に適用したほうがよい場合は、
    pullup 要求を提出してください。</para>

    <para>ftp.NetBSD.org 上にすでに置かれているバイナリーパッケージは、
    週次の cron ジョブによって半自動的に対処されます。</para>
  </sect2>


  <sect2 id="bumping-pkgrevision">
    <title>既存パッケージ修正時に、バージョンを上げるにはどうするか</title>

    <para>既存のパッケージに修正を加えたときに、<varname>PKGNAME</varname>のバージョン番号を変えると便利
    な場合があります。元の作者による将来のバージョンと衝突しないようにするため、
    <varname>PKGREVISION=1</varname> (2, ...)を設定して、パッケージのバージョンに
    <quote>nb1</quote>, <quote>nb2</quote>, ...
    という接尾辞をつけることができます。この<quote>nb</quote>は、パッケージのツール群からは<quote>.</quote>と
    同様の扱いを受けます。たとえば、</para>

    <programlisting>
DISTNAME=       foo-17.42
PKGREVISION=    9
    </programlisting>

    <para>とすると、<varname>PKGNAME</varname>は<quote>foo-17.42nb9</quote>になります。
    たとえば <varname>DIST_SUBDIR</varname> の設定用などに、
    <varname>PKGNAME</varname> に接尾辞 <quote>nbX</quote> がつかない、
    元の値を使いたい場合は、<varname>PKGNAME_NOREV</varname> を使います。</para>

    <para>このパッケージの新しいリリース版が出た際には、
    <varname>PKGREVISION</varname>は消してください。
    たとえば、上で例示したパッケージの新しいマイナーリリースに際しては、以下の
    ようにします。</para>

    <programlisting>
DISTNAME=       foo-17.43
    </programlisting>

    <para>バイナリーパッケージに対して自明でない変化をおよぼす場合は、すべて、
    <varname>PKGREVISION</varname> を上げるようにします。
    <varname>PKGREVISION</varname> を上げないと、
    変更前のバージョンをインストールしている人が、
    そのパッケージが古くなったことを知るすべがなくなってしまいます。
    したがって、<varname>PKGREVISION</varname> を上げない変更とは、本質的に
    「誰もアップグレードする必要のない自明な変更」ということであり、
    これが <varname>PKGREVISION</varname> を上げるべきか否かを大雑把に判断する方法です。
    <varname>PKGREVISION</varname> を上げる意味のない変更には、たとえば以下のようなものがあります。</para>

    <itemizedlist><listitem>
      <para><varname>HOMEPAGE</varname>, <varname>MAINTAINER</varname>
      や、Makefile 中のコメントの変更。</para></listitem><listitem><para>
      構築変数の変更で、作成されるバイナリーパッケージに変化がない場合。</para></listitem><listitem><para>
      <filename>DESCR</filename> の変更。</para></listitem><listitem><para>
      <varname>PKG_OPTIONS</varname> の追加で、標準のオプションに変化がない場合。</para></listitem>
    </itemizedlist>

    <para><varname>PKGREVISION</varname> を上げる価値のある変更には、
    たとえば以下のようなものがあります。</para>
    <itemizedlist><listitem><para>
      セキュリティーの修正</para></listitem><listitem><para>
      パッチファイルの変更または追加</para></listitem><listitem><para>
      <filename>PLIST</filename> の変更</para></listitem>
      <listitem><para>依存性の変更や、依存先パッケージの改称。</para></listitem>
    </itemizedlist>

    <para>依存するパッケージの ABI が変更された場合にも、
    PKGREVISION を上げる必要があります。</para>
  </sect2>

  <sect2 id="fixes.subst">
    <title>パッケージのファイル中の各種テキストを置換する (SUBST の枠組)</title>

    <para>複数のファイルに含まれる同じテキストを置換したい場合や、
    テキストの置換方法を変化させたい場合には、パッチだけでは実現できません。
    そこで SUBST の枠組の出番です。この枠組では、
    ファイル内のテキストを置換するために簡単に使えるインターフェースを用意しています。
    たとえば以下のように使います。</para>

    <programlisting>
SUBST_CLASSES+=                 fix-paths
SUBST_STAGE.fix-paths=          pre-configure
SUBST_MESSAGE.fix-paths=        Fixing absolute paths.
SUBST_FILES.fix-paths=          src/*.c
SUBST_FILES.fix-paths+=         scripts/*.sh
SUBST_SED.fix-paths=            -e 's,"/usr/local,"${PREFIX},g'
SUBST_SED.fix-paths+=           -e 's,"/var/log,"${VARBASE}/log,g'
    </programlisting>

    <para><varname>SUBST_CLASSES</varname> は、ここで定義する
    SUBST の塊を区別するための識別子を並べたリストです。
    SUBST の枠組は pkgsrc で多用されているので、この変数には常に
    <literal>+=</literal> 演算子を使うことが重要です。
    そうしないと、一部の置換がおこなわれなくなることがあります。</para>

    <para>各 SUBST の塊の残りの変数は、
    最初の行の識別子 (この例では <literal>fix-paths</literal>)
    を使ってパラメーター化されています。
    これらは、関数呼び出しの引数とみなすことができます。</para>

    <para><varname>SUBST_STAGE.*</varname> は、
    この置換をどの期におこなうかを指定します。
    実際に使われるものは限られていますが、相の名前と
    <literal>pre-</literal>, <literal>do-</literal>,
    <literal>post-</literal> のあらゆる組合せを使うことができます。
    もっともよく使われるのは <literal>post-patch</literal> と
    <literal>pre-configure</literal> です。このふたつのうち、
    <literal>pre-configure</literal> を使うと、
    <command>bmake patch</command> を実行することで、
    パッチを適用したほかは一切変更されていない状態にすることができるため、
    こちらのほうが好まれます。このことは、
    新しいパッチを作成するためにパッケージのデバッグをする際に、
    特に便利です。これと同様に、<literal>pre-install</literal>
    よりも <literal>post-build</literal> のほうが好まれます。
    これは、一般的に install 相は極力簡素なものにするほうがよいからです。
    <literal>post-build</literal> を使った場合、
    後にインストールされるものと同じファイルが作業ディレクトリーにできあがるので、
    正しく置換がおこなわれたかを確認することができます。</para>

    <para><varname>SUBST_MESSAGE.*</varname> は、
    置換がおこなわれる直前に表示するテキストで、省略可能です。</para>

    <para><varname>SUBST_FILES.*</varname> は、置換の対象となるファイルを、
    シェルのグロブパターンで指定したものを並べたリストです。
    このパターンは、<varname>WRKSRC</varname>
    ディレクトリーからの相対位置として解釈されます。</para>

    <para><varname>SUBST_SED.*</varname> は置換の内容を
    &man.sed.1; への引数の形で指定したものを並べたリストです。
    各 sed コマンドの前には <literal>-e</literal> をつけて、
    SUBST の塊全体が一様に見えるようにします。</para>

    <para>以上のほかにも変数がいくつかありますが、
    それらはほとんど使われないものなので、
    <filename>mk/subst.mk</filename> ファイル内でのみ文書化されています。</para>

  </sect2>
</sect1>
<sect1 id="fixes.fetch">
  <title><emphasis>fetch</emphasis> 相での問題を修正する</title>

  <sect2 id="no-plain-download">
    <title>distfileのダウンロードが単純にできないパッケージ</title>

    <para>動的なURLからダウンロードする必要がある場合は、
    <varname>DYNAMIC_MASTER_SITES</varname>
    を設定す
    ることができます。すると、<command>make fetch</command>は、ダウンロードすべき各ファイルを引
    数として<filename>files/getsite.sh</filename>を呼び出します。このスクリプトは、ファイルをダウン
    ロードするディレクトリーのURLを出力することが前提となっています。
    <filename role="pkg">graphics/ns-cult3d</filename>が、
    この使い方の例となっています。</para>

    <para>パスワード用に個人情報の登録が必要だったり、ソースに代金を払う必要があった
    り、その他もろもろの理由により、ダウンロードが自動化できない場合は、
    <varname>FETCH_MESSAGE</varname> を、
    構築中止前にユーザーに表示する説明文を行ごとに並べたリストに設定することができます。
    たとえば以下のようにします。</para>

    <programlisting>
FETCH_MESSAGE=  "Please download the files"
FETCH_MESSAGE+= "    "${DISTFILES:Q}
FETCH_MESSAGE+= "manually from "${MASTER_SITES:Q}"."
    </programlisting>

  </sect2>


  <sect2 id="modified-distfiles-same-name">
    <title>'古い'名前のまま更新されたdistfileの取り扱い</title>

    <para>時々、ソフトウェアパッケージの作者がソフトウェアのリリース後に変更を加え、
    変更後のdistfileを、バージョン番号を変えずに公開することがあります。このと
    き、pkgsrcにそのパッケージがすでに入っていると、チェックサムが一致しない
    ことになります。distfileの更新が意図されたものであって、
    トロイの木馬などが仕込まれたのではないことを確認するため、
    新しい distfile の内容と変更前の古い distfile の内容と比較してください。
    新旧の distfile を比較したことと、何が変わったのかを、
    commit メッセージに含めてください。
    確認後、この問題の正しい回避策は、<varname>DIST_SUBDIR</varname>
    を一意な (普通は <varname>PKGNAME_NOREV</varname>
    にもとづく) ディレクトリー名に設定することです。
    これを設定すると、このパッケージの <varname>DISTFILES</varname> と
    <varname>PATCHFILES</varname> はすべて、
    distfiles ディレクトリー以下の、設定した名前のサブディレクトリーに置かれます。
    (詳細は、<xref linkend="bumping-pkgrevision"/>をご覧ください。)
    この問題がよく起きる場合は、ディレクトリー名に
    <varname>PKGNAME</varname> を使ったり
    (これにより <filename>nbX</filename> サフィックスが含まれる)、
    <varname>${PKGNAME_NOREV}-YYYYMMDD</varname> のように日付を付けたりすることができます。
    設定後は、<filename>distinfo</filename> ファイルを作り直すのを忘れないでください。
    このファイルでは、ファイル名のなかに <varname>DIST_SUBDIR</varname>
    パスが含まれているからです。
    この変更によって、インストールされるパッケージが以前のものと異なるものになる場合は、
    PKGREVISION も上げます。
    さらに、パッケージの正当な作者にメールを出して、
    リリース後に、ファイル名を変えずに
    distfile の内容を変えるのはよろしくないやり方だと伝えてください。</para>
  </sect2>
</sect1>


<sect1 id="fixes.configure">
  <title><emphasis>configure</emphasis> 相での問題を修正する</title>

  <sect2 id="fixes.libtool">
    <title>共有ライブラリー - libtool</title>

    <para>pkgsrcはさまざまな種類のマシンをサポートします。それらはa.outとELFのような
    異なるオブジェクトフォーマットを使い、共有ライブラリー、ダイナミックローディ
    ングの有無すらも異なります。これに対応するためにコマンドそのもの、およびオ
    プションがコンパイラー、リンカーなどに渡される必要があります。すべてのマシ
    ンで正しく動作させることは非常にむずかしく、テストのためにすべてのマシンを
    持っていない場合は特にそうでしょう。
    <filename role="pkg">devel/libtool</filename>パッケージはこれを助けます。
    <filename role="pkg">devel/libtool</filename>はプラットフォームによらずに、
    ソースファイルから、静的、動的なライブラリー両方を構築する方法
    を<quote>知って</quote>いるからです。</para>

    <para>以下に、libtoolをパッケージで使用するための7つの手順を記述します。</para>

    <orderedlist>
      <listitem>
	<para><varname>USE_LIBTOOL=yes</varname>をパッケージのMakefileへ追加します。</para>
      </listitem>

      <listitem>
	<para>ライブラリーオブジェクトのために、<quote>${LIBTOOL} --mode=compile ${CC}</quote>を<quote>${CC}</quote>
	に設定します。ライブラリーが、提供されたMakefileだけを使用して構築される
	のであれば、<varname>CC</varname>の定義にこれを追加するだけです。このコマンドひとつだけで、
	PICと非PICのライブラリーオブジェクトを作成します。したがって、共有ライブ
	ラリーとそうでないライブラリーの構築規則を別々に記述する必要はありません。</para>
      </listitem>

      <listitem>
	<para>ライブラリーのリンクのための<quote>ar</quote>、<quote>ranlib</quote>、<quote>ld -Bshareable</quote>コマン
	ドを削除してください。そしてその代わりに以下のコマンドを使用してください。</para>

	<programlisting>
${LIBTOOL} --mode=link \
    ${CC} -o ${.TARGET:.a=.la} \
        ${OBJS:.o=.lo} \
        -rpath ${PREFIX}/lib \
        -version-info major:minor
	</programlisting>

	<para>ライブラリーの拡張子は<filename>.la</filename>に、オブジェクトの拡張子は
	<filename>.lo</filename>に変更されることに
	注意してください。<varname>OBJS</varname>
	を必要に応じて変更してください。このコマンドは、必
	要なものすべて、
	<filename>.a</filename>、<filename>.so.major.minor</filename>、
	そしてELFのシンボリックリンク(必要
	なら)を自動的にカレントディレクトリーに作成します。特に、メジャー番号と
	マイナー番号がゼロの場合は、<quote>-version-info</quote>をかならず含めるようにしてくだ
	さい。そうしないとlibtoolは共有ライブラリーのバージョンを取り除きます。</para>

	<para>libtool のマニュアルより:</para>

	<programlisting>
libtool のライブラリーのバージョンは、以下の三つの整数で表されます。

CURRENT
このライブラリーが実装しているインターフェース番号のうち最新のもの。

REVISION
CURRENT インターフェースの実装番号。

AGE
このライブラリーが実装しているインターフェースの最新のものと最古のものの間の差。
すなわち、このライブラリーが実装しているのは、
`CURRENT - AGE' から `CURRENT' までの番号の範囲にある、
すべてのインターフェース番号です。

二つのライブラリーの CURRENT と AGE 番号がいずれも同じ場合、
ダイナミックリンカーは REVISION 番号が大きいほうのライブラリーを選びます。
	</programlisting>

	<para>また、<quote>-release</quote>オプションは、ある一つの場合に限って、a.outとELF(シンボ
	リックリンクを除く)との間で異なる結果をもたらします。
	<quote>libfoo-release.so.<emphasis>x</emphasis>.<emphasis>y</emphasis></quote>
	の形式のELFライブラリーは、a.outプラットフォーム上
	では
	<quote>libfoo.so.<emphasis>x</emphasis>.<emphasis>y</emphasis></quote>
	のシンボリックリンクを持ちます。これは自動的に処理され
	ます。</para>

	<para><quote>-rpath引数</quote>は構築されたライブラリーのインストール先ディレクトリーです。</para>

	<para><filename>PLIST</filename>には、
	<filename>.la</filename> ファイルだけを含めます。
	これ以外のファイルは自動的に追加されます。</para>
      </listitem>

      <listitem>
	<para>共有オブジェクト(<filename>.so</filename>)ファイル(すなわち、&man.dlopen.3;でロードされるファイル
	であって、共有ライブラリーでは*ありません*)のリンク時には、ファイルにバー
	ジョンが加えられないようにするため、<quote>-module -avoid-version</quote>を使ってくだ
	さい。</para>

	<para><filename>PLIST</filename>ファイルには<filename>foo.so</filename>
	の一覧が加わります。</para>
      </listitem>

      <listitem>
	<para>インストールする<emphasis>前</emphasis>のライブラリーに依存するプログラムをリンクする時に、
	&man.cc.1;か&man.ld.1;の前に
	<quote>${LIBTOOL} --mode=link</quote>を書いてください。このコマンドは、正
	しいライブラリー(静的、または共有)を見つけます。ただし、libtoolを使う時
	には-Lオプションで相対パスを指定すること(<quote>-L../somelib</quote>のように)ができない
	ことに注意してください。引数として<filename>.la</filename>ファイルを使うように修正しなければ
	なりません。例えば、</para>

	<programlisting>
${LIBTOOL} --mode=link ${CC} -o someprog -L../somelib -lsomelib
	</programlisting>

	<para>は、以下のように変更する必要があります。</para>

	<programlisting>
${LIBTOOL} --mode=link ${CC} -o <replaceable>someprog</replaceable> <replaceable>../somelib/somelib.la</replaceable>
	</programlisting>

	<para>これで、ライブラリーを正しく扱う事ができます。</para>
      </listitem>

      <listitem>
	<para>ライブラリーをインストールするときに、&man.install.1;
	あるいは&man.cp.1;コマンドの前に
	<quote>${LIBTOOL} --mode=install</quote>を書いて下さい。そしてライブラリーの名前を
	<filename>.la</filename>に変えてください。例えば、以下のように書く必要があります。</para>

	<programlisting>
${LIBTOOL} --mode=install ${BSD_INSTALL_DATA} ${SOMELIB:.a=.la} ${PREFIX}/lib
	</programlisting>

	<para>これは、静的リンクのための<filename>.a</filename>、共有ライブラリー、必要なシンボリックリンク
	をインストールし、&man.ldconfig.8;を実行します。</para>
      </listitem>

      <listitem>
	<para><filename>PLIST</filename>には、
	<filename>.la</filename> ファイルだけを含めます
	(これは、以前のものから変わった点です)。</para>
      </listitem>
    </orderedlist>
  </sect2>


  <sect2 id="using-libtool">
    <title>すでにlibtoolをサポートしているGNUパッケージでlibtoolを使う</title>

    <para><varname>USE_LIBTOOL=yes</varname> をパッケージの
    Makefile に追加します。こうするとほとんどの場合、パッケージ固有の
    libtool を無視します。古い libtool を使っているパッケージでは、
    libtool はdo-configureターゲットでltconfigスクリプトにより作られます。<command>make
    configure; find work*/ -name libtool</command>
    のようにして、libtool スクリプトの場所を確認することができます。</para>

    <para><varname>LIBTOOL_OVERRIDE</varname> で、どの libtool
    スクリプトを無視するかを、<varname>WRKSRC</varname> からの相対位置で指定します。
    指定しなかった場合、<quote>libtool */libtool
    */*/libtool</quote> に設定されますので、パッケージ固有の libtool
    スクリプトの場所がこのいずれとも異なる場合は、適宜設定してください。</para>

    <para>静的ライブラリー <filename>*.a</filename>
    の構築やインストールが必要ない場合は、かわりに
    <varname>SHLIBTOOL_OVERRIDE</varname> を使います。</para>

    <para>パッケージが動的共有オブジェクトのロードに、libtool (libltdl)のプラットフォー
    ム独立なライブラリーを使う場合は、
    devel/libltdl/buildlink3.mkをインクルードしてください。</para>

    <para>パッケージによっては、環境により動作や構築ができなくなるような、正しくない
    libtoolの使い方をしているものがあります。ありがちな間違いは以下のようなもの
    です。</para>

    <itemizedlist>
      <listitem>
	<para>実行形式やライブラリーで、共有オブジェクト(-module)を依存ライブラリーと
	してインクルードする。このこと自体は、以下の二つのうちいずれかが行なわれ
	ている場合は、問題になりません。</para>

	<orderedlist>
	  <listitem>
	    <para>その共有オブジェクトが正しく命名されている。すなわち、
	    <filename>libfoo.la</filename>ではなく
	    <filename>libfoo.la</filename>となっている。</para>
	  </listitem>

	  <listitem>
	    <para>-dlopenオプションが実行形式のリンク時に使われている。</para>
	  </listitem>
	</orderedlist>
      </listitem>

      <listitem>
	<para>ルーチンの初期化を適切に呼ばずにlibltdlを使う。関数lt_dlinit()を呼んで、
	マクロ
	<varname>LTDL_SET_PRELOADED_SYMBOLS</varname>を実行形式にインクルードするようにしましょ
	う。</para>
      </listitem>
    </itemizedlist>
  </sect2>


  <sect2 id="autoconf-automake">
    <title>GNU Autoconf/Automake</title>

    <para>パッケージが、configureスクリプトやmakefileの雛型Makefile.inを再生成するた
    めにGNU autoconfまたはautomakeを実行する必要がある場合、これらの実行は
    pre-configureターゲットでおこないます。</para>

    <para>autoconfのみを必要とするパッケージでは以下のようになります:</para>

    <programlisting>
AUTOCONF_REQD=  2.50            # if default version is not good enough
USE_TOOLS+=     autoconf        # use "autoconf213" for autoconf-2.13
...

pre-configure:
        cd ${WRKSRC} &amp;&amp; autoconf

...
    </programlisting>

    <para>また、automakeとautoconfを必要とするパッケージでは以下のようになります:</para>

    <programlisting>
AUTOMAKE_REQD=  1.7.1           # if default version is not good enough
USE_TOOLS+=     automake        # use "automake14" for automake-1.4
...

pre-configure:
        set -e; cd ${WRKSRC}; \
        aclocal; autoheader; automake -a --foreign -i; autoconf

...
    </programlisting>

    <para>GNU Automake を使うパッケージは、ほぼ確実に
    GNU Make を必要とします。</para>

    <para>生成されたファイルに対して、configureプロセスがさらに変更を加える時がありま
    すが、この時には構築プロセスが一連のautomakeの手順を再実行しようとします。
    configureの段階でさまざまなファイルに手を加えると、この挙動は止められます。
    この挙動が問題が起こす場合は、そのパッケージのMakefileで
    <varname>AUTOMAKE_OVERRIDE=NO</varname>を設定することができます。</para>
  </sect2>
</sect1>

<sect1 id="programming-languages">
  <title>プログラミング言語</title>

  <sect2 id="basic-programming-languages">
    <title>C, C++ および Fortran</title>

    <para>C, C++ および Fortran 言語用のコンパイラーは、
    NetBSD の基本システムに附属しています。標準では、
    pkgsrc はパッケージが C で書かれていると仮定し、それ以外のコンパイラーをすべて隠します
    (ラッパーの枠組による。<xref linkend="buildlink" />参照)。</para>

    <para>パッケージがどの言語のコンパイラーを必要としているかを表すには、
    <varname>USE_LANGUAGES</varname> 変数を設定します。使うことのできる値は、
    現在のところ、<quote>c</quote>, <quote>c++</quote>,
    <quote>fortran</quote> (および、これらの任意の組合せ) です。標準では
    <quote>c</quote> になります。GNU の configure スクリプトを使うパッケージでは、
    C++ で書かれているものであっても、通常は configure 相で
    C コンパイラーを必要とします。</para>
  </sect2>

  <sect2 id="java-programming-language">
    <title>Java</title>

    <para>プログラムが Java で書かれている場合は、pkgsrc における Java
    の枠組を使います。パッケージは
    <filename>../../mk/java-vm.mk</filename> をインクルードする必要があります。
    この Makefile の断片は、以下の変数を用意してくれます。</para>

    <itemizedlist>
      <listitem><para><varname>USE_JAVA</varname> は、
      JDK への依存性が追加されるかどうかを定義します。
      <varname>USE_JAVA</varname> が <quote>run</quote> に設定された場合は、
      JDK への実行時依存性があるだけです。標準では <quote>yes</quote> となり、
      この場合は JDK への構築時依存性も追加されます。</para></listitem>

      <listitem><para>パッケージが Java2 の実装を必要とすることを表すため、
      <varname>USE_JAVA2</varname> を設定します。この変数が対応している値は、
      <quote>yes</quote>, <quote>1.4</quote>,
      <quote>1.5</quote> です。 <quote>yes</quote> は任意の Java2
      の実装を受け入れます。<quote>1.4</quote> はバージョン 1.4 以上を要求し、
      <quote>1.5</quote> はバージョン 1.5 以上のみを受け入れます。
      この変数は標準では設定されません。</para></listitem>
      <!-- XXX: describe PKG_JVM_DEFAULT and PKG_JVMS_ACCEPTED, but
	   not here -->
    </itemizedlist>
  </sect2>

  <sect2 id="perl-scripts">
    <title>perl スクリプトを含むパッケージ</title>

    <para>perl スクリプトがパッケージに含まれる場合は、
    <varname>USE_TOOLS</varname> 変数に <quote>perl</quote> を追加し、
    適切なインタープリターへのパスが設定されるようにするために
    <varname>REPLACE_PERL</varname> を設定します。
    <varname>REPLACE_PERL</varname> の値には、パスを調節する対象のスクリプトを
    <varname>WRKSRC</varname> からの相対位置として並べたリストを含めるようにします。
    対象のスクリプト内に現れる <filename>*/bin/perl</filename> はすべて、
    perl の実行ファイルへのフルパスに置き換えられます。</para>

    <para>特定のバージョンの perl が必要な場合は、
    <varname>PERL5_REQD</varname> 変数をバージョン番号に設定します。
    標準では <quote>5.0</quote> になります。</para>

    <para>perl モジュールの扱いについては、
    <xref linkend="perl-modules" />をご覧ください。</para>
  </sect2>

  <sect2 id="other-programming-languages">
    <title>他のプログラミング言語</title>

    <para>現在のところ、pkgsrc では、他のプログラミング言語に対する特別な扱いはありません。
    その言語のコンパイラーのパッケージに
    <filename>buildlink3.mk</filename> ファイルがある場合は、
    このファイルをインクルードします。このファイルがない場合は、
    適切なコンパイラーのパッケージへの (構築時) 依存性を追加するだけです。</para>
  </sect2>
</sect1>

<sect1 id="fixes.build">
  <title><emphasis>build</emphasis> 相での問題を修正する</title>

	<para>パッケージ構築時に最もよくある障害は、
	プラットフォームによっては必要なヘッダーファイル、関数やライブラリーがなかったり、
	あるいは、ライブラリーで提供される関数がパッケージ作者の考えているものと違っていたりするものです。
	そのようなことを回避するために、ほとんどの場合は、
	ない関数を使わないようにしたり、代替の関数を提供したりするように
	ソースコードを書き換えることができます。</para>

<sect2 id="fixes.build.cpp">
<title>C および C++ のコードの条件つきコンパイル</title>

	<para>パッケージに最初から GNU configure スクリプトが附属している場合は、
	構築の障害の修正方法としては、コードを変更せずに configure
	スクリプトを変更するのが望ましい方法です。configure スクリプトが附属しない場合は、
	コンパイル対象のオペレーティングシステムやハードウェアアーキテクチャーに応じて必要なマクロを定義している
	C プリプロセッサーを役立てることができます。このマクロは、たとえば
	<varname>#if defined(__i386)</varname> のようにして調べることができます。
	ほとんどすべてのオペレーティングシステム、ハードウェアアーキテクチャー、
	およびコンパイラーには、独自のマクロがあります。
	たとえば、<varname>__GNUC__</varname>,
	<varname>__i386__</varname>, <varname>__NetBSD__</varname>
	の各マクロがすべて定義されている場合は、i386 互換 CPU 上の NetBSD を使っていることと、
	コンパイラーが GCC であることがわかります。</para>

	<para>以下に列挙するハードウェアおよびオペレーティングシステム用のマクロは、
	使っているコンパイラーに依存します。
	たとえば、Solaris 上でコードを条件付きコンパイルしたい場合、
	<varname>__sun__</varname> は
	SunPro コンパイラーでは定義されていないので使ってはいけません。
	かわりに <varname>__sun</varname> を使います。</para>


<sect3 id="fixes.build.cpp.os">
<title>オペレーティングシステムを特定するための C プリプロセッサーマクロ</title>

        <para>4.4 BSD から派生したシステムとそれ以外のシステムを
        見分けるには、以下のコードを使うようにしてください。</para>

<programlisting>
#include &lt;sys/param.h&gt;
#if (defined(BSD) &amp;&amp; BSD &gt;= 199306)
/* BSD-specific code goes here */
#else
/* non-BSD-specific code goes here */
#endif
</programlisting>

        <para>これでは十分正確でない場合は、
	以下のマクロを検査することもできます。</para>

<programlisting>
FreeBSD     __FreeBSD__
DragonFly   __DragonFly__
Interix     __INTERIX
IRIX        __sgi (TODO: 出典の確認)
Linux       linux, __linux, __linux__
NetBSD      __NetBSD__
OpenBSD     __OpenBSD__
Solaris     sun, __sun
</programlisting>

</sect3>
<sect3 id="fixes.build.cpp.arch">
<title>ハードウェアアーキテクチャーを特定するための C プリプロセッサーマクロ</title>

<programlisting>
i386        i386, __i386, __i386__
MIPS        __mips
SPARC       sparc, __sparc
</programlisting>

</sect3>
<sect3 id="fixes.build.cpp.compiler">
<title>コンパイラーを特定するための C プリプロセッサーマクロ</title>

<programlisting>
GCC         __GNUC__ (メジャーバージョン), __GNUC_MINOR__
MIPSpro     _COMPILER_VERSION (MIPSpro 7.41 なら 0x741)
SunPro      __SUNPRO_C (Sun C 5.7 なら 0x570)
SunPro C++  __SUNPRO_CC (Sun C++ 5.8 なら 0x580)
</programlisting>

</sect3>
</sect2>
<sect2 id="compiler-bugs">
<title>コンパイラーのバグへの対処方法</title>

	<para>ソースファイルのなかには、コンパイラーのバージョンとアーキテクチャーの組合
        せによって、また、ほとんどの場合は、最適化を有効にしたことも関係して、コン
        パイラーのバグを発現させるものがあります。よくある症状は、gccの内部エラーや、
        ファイルのコンパイルが完了しないというものです。</para>

	<para>たいていは、回避策として、<varname>MACHINE_ARCH</varname>
        とコンパイラーのバージョンを確認し、
        問題のあるファイル・<varname>MACHINE_ARCH</varname>・コンパイラーの組合せに対して最適化を無効に
	し、そのことを<filename>pkgsrc/doc/HACKS</filename>に文書化しておくことが必要となります。
	このファイルに多くの例が載っているので、参照してください。</para>

</sect2>

<sect2 id="undefined-reference">
<title>undefined reference to <quote>...</quote></title>

	<para>このエラーメッセージは、しばしば、
	パッケージが必要な共有ライブラリーにリンクしていないことを表します。
	以下の関数は、このエラーメッセージを何度も出すことがわかっているものです。</para>

    <informaltable id="undefined-reference-functions">
      <tgroup cols="3">
	<thead><row><entry>関数</entry><entry>ライブラリー</entry><entry>影響のあるプラットフォーム</entry></row></thead>
	<tbody>
	  <row><entry>accept, bind, connect</entry><entry>-lsocket</entry><entry>Solaris</entry></row>
	  <row><entry>crypt</entry><entry>-lcrypt</entry><entry>DragonFly, NetBSD</entry></row>
	  <row><entry>dlopen, dlsym</entry><entry>-ldl</entry><entry>Linux</entry></row>
	  <row><entry>gethost*</entry><entry>-lnsl</entry><entry>Solaris</entry></row>
	  <row><entry>inet_aton</entry><entry>-lresolv</entry><entry>Solaris</entry></row>
	  <row><entry>nanosleep, sem_*, timer_*</entry><entry>-lrt</entry><entry>Solaris</entry></row>
	  <row><entry>openpty</entry><entry>-lutil</entry><entry>Linux</entry></row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>このようなリンカーのエラーの修正は、多くの場合、
    パッケージの <filename>Makefile</filename> に
    <literal>LIBS.<replaceable>OperatingSystem</replaceable>+=
    -l<replaceable>foo</replaceable></literal> を追加してから <command>bmake clean;
    bmake</command> を実行すれば十分です。</para>

<sect3 id="undefined-reference-sunpro">
<title>特殊な問題: SunPro コンパイラー</title>

<para>SunPro コンパイラーを使っている場合は、別の問題の可能性があります。
このコンパイラーは、以下のようなコードを処理することができません。</para>

<programlisting>
extern int extern_func(int);

static inline int
inline_func(int x)
{
        return extern_func(x);
}

int main(void)
{
        return 0;
}
</programlisting>

<para>ここからは、<function>inline_func</function> 関数がたとえ使われていなくても、
この関数用のコードが生成され、そのコードから
<function>extern_func</function> が参照されますが、この参照は通常は解決することができません。
この問題を解決するため、
パッケージに関数のインライン化を無効化するよう指示してみることができます。</para>

</sect3>

  </sect2>

  <sect2 id="out-of-memory">
    <title>メモリーが不足する</title>

    <para>時には、コンパイラーの実行でオペレーティングシステム固有のソフトリミットに達するために、
    パッケージの構築に失敗することがあります。
    <varname>UNLIMIT_RESOURCES</varname> 変数を設定して、
    pkgsrc に資源の制限を解除するよう伝えることができます。
    現在のところ、使うことのできる値は、
    <quote>datasize</quote> と <quote>stacksize</quote> (あるいは両方) です。
    この変数を設定すると、シェル組み込みの <command>ulimit</command>
    コマンドを実行した場合と同様に、それぞれ、
    データセグメントのサイズとスタックのサイズの上限を、
    ハードリミットまで引き上げます。</para>
  </sect2>
</sect1>

<sect1 id="fixes.install">
  <title><emphasis>install</emphasis> 相での問題を修正する</title>

  <sect2 id="install-scripts">
    <title>必要なディレクトリーを作成する</title>

    <para>一部のプラットフォームに附属する BSD 互換の <command>install</command> は、
    一度に複数のディレクトリーを作成することができません。
    このため、 <literal>${INSTALL_*_DIR}</literal> を使うときは、以下のようにします。</para>

    <programlisting>
${INSTALL_DATA_DIR} ${PREFIX}/dir1
${INSTALL_DATA_DIR} ${PREFIX}/dir2
    </programlisting>

    <para>こうするかわりに、単に <quote><literal>dir1
    dir2</literal></quote> を
    <varname>INSTALLATION_DIRS</varname> 変数に追加するという方法もあります。
    こうすると、適切な処理が自動的におこなわれます。</para>

  </sect2>
  <sect2 id="where-to-install-documentation">
    <title>ドキュメンテーションのインストール場所</title>

    <para>一般的には、ドキュメンテーションは
    <filename>${PREFIX}/share/doc/${PKGBASE}</filename> または
    <filename>${PREFIX}/share/doc/${PKGNAME}</filename> (後者は、
    パッケージのバージョン番号を含んでいます) 以下にインストールします。</para>

    <para>GNU autoconf を使っている最近のパッケージの多くは、
    HTML のドキュメンテーションのインストール先を、
    <quote>--with-html-dir</quote> オプションを使って設定することができます。
    時には、このフラグを使わないとドキュメンテーションが
    <filename>${PREFIX}/share/doc/html</filename> や他の場所にインストールされるために、
    このフラグを使う必要があることがあります。</para>

    <para>例外は、<filename
    role="pkg">textproc/gtk-doc</filename> ツールによって生成される、
    ライブラリーの API のドキュメンテーションです。このドキュメンテーションは、
    専用のブラウザー (devhelp) から使うものであり、ブラウザーが標準で使う場所である
    <filename>${PREFIX}/share/gtk-doc</filename> に置くようにします。
    このようなドキュメンテーションは、ファイル名の末尾が
    <filename>.devhelp</filename> または
    <filename>.devhelp2</filename> であることから区別できます。
    (これらのファイルを
    <filename>${PREFIX}/share/doc/${PKGBASE}</filename> または
    <filename>${PREFIX}/share/doc/${PKGNAME}</filename>
    にインストールしても使うことができます。この場合、
    これらのディレクトリーの直下に
    <filename>.devhelp*</filename> ファイルを置く必要があり、
    サブディレクトリー階層を追加することはできません。通常は、
    <quote>--with-html-dir=${PREFIX}/share/doc</quote>
    を使えばそのようにすることができます。
    <filename>${PREFIX}/share/gtk-doc</filename>
    のほうが好ましいのですが。)</para>

  </sect2>

  <sect2 id="installing-score-files">
    <title>最高得点ファイルをインストールする</title>

    <para>パッケージによっては (ほとんどは games カテゴリーのもの)、
    システム上の各ユーザーが最高得点を記録できるように、
    得点ファイルをインストールします。これを実現するために、
    バイナリーは setgid してインストールし、得点ファイルは
    グループとオーナーのいずれかまたは両方を当該グループやオーナー
    (伝統的には "games" ユーザーおよびグループ) の所有とする必要があります。
    <varname>SETGIDGAME</varname>,
    <varname>GAMEDATAMODE</varname>, <varname>GAMEGRP</varname>,
    <varname>GAMEMODE</varname>, <varname>GAMEOWN</varname>
    の各変数でこの挙動を制御します。詳細は
    <filename>mk/defaults/mk.conf</filename> に書かれています。</para>

    <para>なお、games に setgid されたインストールは、標準では有効になっていません。
    <varname>SETGIDGAME=YES</varname> を設定すると、
    これに応じて他の各変数が設定されます。</para>

    <para>このため、パッケージではファイルの所有やアクセス許可属性を決してハードコードせずに、
    <varname>INSTALL_GAME</varname> および
    <varname>INSTALL_GAME_DATA</varname>
    の設定に応じて適切に設定されるようにします。</para>
  </sect2>

  <sect2 id="destdir-support">
    <title>パッケージを DESTDIR に対応させる</title>

    <itemizedlist>
      <listitem><para>すべてのインストール操作では、インストール先を
      <filename>${DESTDIR}</filename> から始まる場所にする必要があります。</para></listitem>

      <listitem><para>automake は、たいていは、この DESTDIR に対して、
      自動的に対処します。自動化されていない処理や pre/post-install
      では、不適切に処理されることが多いので、修正してください。</para></listitem>

      <listitem><para>ファイルが、特別な所有者や所有グループでインストールされる場合は、
      <filename>PLIST</filename> で @owner/@group を使う (推奨) か、
      <varname>SPECIAL_PERMS</varname> を使う (非推奨) か、いずれかの方法をとってください。
      なお、@owner/@group はインストールの間だけ有効となるものですので、
      注意してください。</para></listitem>

      <listitem><para>一般的に、各パッケージは、
      DESTDIR を使えるようにするために、
      <varname>UNPRIVILEGED</varname> に対応させるようにしてください。
</para></listitem>

    </itemizedlist>
  </sect2>


  <sect2 id="hardcoded-paths">
    <title>その他のインタープリターへのパスがハードコードされているパッケージ</title>

    <para>パッケージには perl 以外のインタープリターへのパスがハードコードされていることもあります。
      スクリプトのインタープリターへのフルパスを適切なものにするため、
      当該パッケージの <filename>Makefile</filename> で、
      以下のような定義をする必要があります
    (ここでは例として <command>tclsh</command> を使います)。</para>

    <programlisting>
REPLACE_INTERPRETER+=   tcl
REPLACE.tcl.old=        .*/bin/tclsh
REPLACE.tcl.new=        ${PREFIX}/bin/tclsh
REPLACE_FILES.tcl=      # パスを修正する必要がある tcl スクリプトを列挙します
# REPLACE_PERL と同様に、${WRKSRC} からの相対位置とします
    </programlisting>

    <note><para>2006 年 3 月より前は、この各変数は
    <varname>_REPLACE.*</varname> および
    <varname>_REPLACE_FILES.*</varname> という名前でした。</para></note>

  </sect2>


  <sect2 id="perl-modules">
    <title>perl モジュールをインストールするパッケージ</title>

    <para>perl5モジュールを提供するパッケージでは、MakefileにMakefileの断片
    <filename>../../lang/perl5/module.mk</filename>をインクルードしてください。このファイルには、perl5モ
    ジュール用の標準的なperlの構成をする<command>do-configure</command>ターゲットのほか、その構成
    を調整するためのさまざまなフックが含まれています。詳細は、このファイル中の
    コメントをご覧ください。</para>

    <para>perl5 のモジュールがインストールされる場所は、構築プロセスで使われるperl の
    バージョンに応じて変わります。これを扱うために、pkgsrc は、
    インストールされた<filename>.packlist</filename>ファイル(ほとんどの perl5 モジュールが生成します)
    に列挙された各ファイルに対応する行を、<filename>PLIST</filename> に追加します。これは、packlist
    ファイルへのパスをスペースで区切ったリストを<varname>PERL5_PACKLIST</varname>として定義するこ
    とで行なわれるようになります。たとえば以下のように定義します。</para>

    <programlisting>
PERL5_PACKLIST= ${PERL5_SITEARCH}/auto/Pg/.packlist
    </programlisting>

    <para><varname>PERL5_SITELIB</varname>, <varname>PERL5_SITEARCH</varname>,
    <varname>PERL5_ARCHLIB</varname>の各変数は、perl5モジュールがイ
    ンストールされうる三つの場所を表すもので、packlistを持たないperl5パッケージ
    で使うことができます。この3変数の置換は、<filename>PLIST</filename>でもおこなわれます。</para>
  </sect2>


  <sect2 id="faq.info-files">
    <title>infoファイルをインストールするパッケージ</title>

    <para>パッケージによっては、infoファイルをインストールしたり、<quote>makeinfo</quote>または
    <quote>install-info</quote>コマンドを使ったりします。
    このようなパッケージでは、パッケージの Makefile で
    <varname>INFO_FILES</varname> を定義するようにします。
    これを定義しておくと、info ファイルを
    Info ディレクトリーファイルに登録するために、<filename>INSTALL</filename> および
    <filename>DEINSTALL</filename> スクリプトが作られるようになります。
    info ファイルの登録用の <quote>install-info</quote> コマンドは、
    システム附属のものが使われるか、
    または、必要があればそれ用のパッケージが自動的に追加されて使われます。</para>

    <para><varname>PKGINFODIR</varname> は
    <filename>${PREFIX}</filename> 以下のディレクトリーで、
    info ファイルが置かれる主な場所です。
    <varname>PKGINFODIR</varname> は標準では
    <quote>info</quote> となっており、利用者が上書きすることができます。</para>

    <para>info ファイルは、そのパッケージの <filename>PLIST</filename>
    に列挙します。ただし、分割された
    info ファイルは列挙する必要はありません。</para>

    <para>構築時に <quote>makeinfo</quote> コマンドが必要なパッケージは、
    Makefile で <varname>USE_TOOLS</varname> 変数に <quote>makeinfo</quote> を追加する必要があります。
    あるバージョン以上の<quote>makeinfo</quote>コマンドが必要な場合は、
    パッケージの <filename>Makefile</filename> で
    <varname>TEXINFO_REQD</varname> 変数を必要な最低バージョンに設定します。
    デフォルトでは、 3.12 が最低限必要なバージョンとなります。
    <command>makeinfo</command> コマンドがシステムにないか、
    最低限必要なバージョンを満たさない場合は、
    <filename role="pkg">devel/gtexinfo</filename>
    パッケージへの構築時の依存関係が自動的に追加されます。</para>

    <para>パッケージで提供されるソフトウェアの構築やインストールの過程では、
    <command>install-info</command> コマンドを使ってはいけません。
    info ファイルの登録は <filename>INSTALL</filename> スクリプトの仕事であって、
    適切な <command>makeinfo</command> コマンドを使う必要があるからです。</para>

    <para>pkgsrc の基盤は、以上のことを実現するため、
    <varname>PATH</varname> のはじめのほうにあるディレクトリーに、
    <command>install-info</command> や <command>makeinfo</command>
    を上書きするスクリプトを作成します。</para>

    <para><command>install-info</command> を上書きするスクリプトは、メッセージを記録すること以外、
    何の効果もありません。<command>makeinfo</command> を上書きするスクリプトは、
    メッセージを記録し、<varname>TEXINFO_REQD</varname>
    の値に従って、適切な <command>makeinfo</command> コマンドを実行するか、
    または異常終了します。</para>
  </sect2>

  <sect2 id="manpages">
    <title>マニュアルページをインストールするパッケージ</title>

    <para>マニュアルページをインストールするパッケージはすべて、
    マニュアルページを同じディレクトリー内にインストールして、
    マニュアルページを共通のひとつの場所から探せるようにします。
    pkgsrc では、この場所は
    <literal>${PREFIX}/${PKGMANDIR}</literal> であり、パッケージ内ではこの表記を使うようにします。
    <varname>PKGMANDIR</varname> の値は標準では
    <quote><filename>man</filename></quote> です。これ以外によく使われる値は、
    <quote><filename>share/man</filename></quote> です。</para>

    <note><para><varname>PKGMANDIR</varname> の独自設定には、
    完全には対応していません。</para></note>

    <para><filename>PLIST</filename> ファイル内では、
    マニュアルページのファイルの最上層ディレクトリーを、
    単に <filename>man/</filename> と書くことができます。
    これは pkgsrc の枠組みが必要に応じて変換してくれます。
    これ以外の場所の場合は、正確な
    <varname>PKGMANDIR</varname> を使って書く必要があります。</para>

    <para><varname>GNU_CONFIGURE</varname> が
    <quote>yes</quote> に設定されているパッケージでは、
    標準では
    <filename>./configure</filename>
    --mandir スイッチを使って、マニュアルページをどこにインストールするかを設定します。
    このパスは <varname>GNU_CONFIGURE_MANDIR</varname> で、
    標準では <varname>${PREFIX}/${PKGMANDIR}</varname> になります。</para>

    <para>パッケージが <varname>GNU_CONFIGURE</varname> を使うが、
    --mandir は使わない場合は、<varname>CONFIGURE_HAS_MANDIR</varname> を
    <quote>no</quote> に設定することができます、
    また、<filename>./configure</filename>
    スクリプトが標準的ではない --mandir の使い方をする場合は、
    必要に応じて <varname>GNU_CONFIGURE_MANDIR</varname> を設定することができます。</para>

    <para>圧縮したマニュアルページのインストールに関する情報は、
    <xref linkend="manpage-compression"/> をご覧ください。</para>

  </sect2>

  <sect2 id="gconf-data-files">
    <title>GConf のデータファイルをインストールするパッケージ</title>

    <para>パッケージが、 GConf が使用する <filename>.schemas</filename> または
    <filename>.entries</filename> ファイルをインストールする場合は、
    これらが確実にデータベースに登録されるようにするために、
    いくつか特別な手順を踏む必要があります。</para>

    <orderedlist>
      <listitem>
	<para>GConf の <filename>buildlink3.mk</filename> ファイルではなく
	<filename>../../devel/GConf/schemas.mk</filename> をインクルードします。
	こうすると、インストールおよびアンインストール時に、 GConf
	のデータベースを再構築し、また、GConf のデータファイルのインストール場所を
	標準的な configure 引数を使ってパッケージに伝えてくれます。
	また、パッケージがデータベースに直接アクセスすることが一切できなくなります。</para>
      </listitem>

      <listitem>
	<para>パッケージが
	<filename>.schemas</filename> ファイルを必ず
	<filename>${PREFIX}/share/gconf/schemas</filename> 以下にインストールするようにします。
	<filename>${PREFIX}/etc</filename> 以下にインストールするようになっている場合は、
	手作業でパッケージを修正する必要があります。</para>
      </listitem>

      <listitem>
	<para>PLIST を確認し、etc/gconf ディレクトリー以下の項目をすべて削除します。
	これらは自動的に処理されるものだからです。詳細は
	<xref linkend="faq.conf"/>を参照してください。</para>
      </listitem>

      <listitem>
	<para><filename>Makefile</filename> で、
	<varname>GCONF_SCHEMAS</varname> 変数を定義します。変数値には
	パッケージがインストールする <filename>.schemas</filename>
	ファイルをすべて列挙します。このファイル名にディレクトリーを含めてはいけません。</para>
      </listitem>

      <listitem>
	<para><filename>Makefile</filename> で、
	<varname>GCONF_ENTRIES</varname> 変数を定義します。変数値には
	パッケージがインストールする <filename>.entries</filename>
	ファイルをすべて列挙します。
	このファイル名にディレクトリーを含めてはいけません。</para>
      </listitem>
    </orderedlist>
  </sect2>


  <sect2 id="scrollkeeper-data-files">
    <title>scrollkeeper のデータファイルをインストールするパッケージ</title>

    <para>パッケージが、 scrollkeeper が使用する <filename>.omf</filename>
    ファイルをインストールする場合は、これらが確実にデータベースに登録されるようにするために、
    いくつか特別な手順を踏む必要があります。</para>

    <orderedlist>
      <listitem>
	<para>scrollkeeper の <filename>buildlink3.mk</filename> ファイルではなく
	<filename>../../textproc/scrollkeeper/omf.mk</filename> をインクルードします。
	こうすると、インストールおよびアンインストール時に、 scrollkeeper
	のデータベースを再構築してくれます。
	また、パッケージがデータベースに直接アクセスすることが一切できなくなります。</para>
      </listitem>

      <listitem>
	<para>PLIST を確認し、<filename>libdata/scrollkeeper</filename>
	ディレクトリー以下の項目をすべて削除します。
	これらは自動的に処理されるものだからです。</para>
      </listitem>

      <listitem>
	<para>PLIST から <filename>share/omf</filename> ディレクトリーを削除します。
	これは scrollkeeper が処理します。</para>
      </listitem>
    </orderedlist>
  </sect2>


  <sect2 id="x11-fonts">
    <title>X11 のフォントをインストールするパッケージ</title>

    <para>パッケージがフォントファイルをインストールする場合は、
    インストール時とアンインストール時に、
    フォントのインストール先ディレクトリーにあるフォントデータベースを再構築する必要があります。
    この処理は pkginstall の枠組を使って自動的におこなうことができます。</para>

    <para>フォントのインストール先ディレクトリーを
    <varname>FONTS_DIRS.<replaceable>type</replaceable></varname>
    変数に列挙することができます。変数名中の <replaceable>type</replaceable> は、
    <quote>ttf</quote>, <quote>type1</quote>, <quote>x11</quote> のいずれかです。
    また、データベースファイル <filename>fonts.dir</filename>
    は PLIST に含めてはいけません。</para>

    <para>なお、フォント用のディレクトリーを新たに作らないようにしてください。
    X サーバーがフォントを見つけるための設定をユーザーが手動でおこなう必要がないようにするため、
    新しいディレクトリーではなく標準的なディレクトリーを使うようにします。</para>
  </sect2>


  <sect2 id="gtk2-modules">
    <title>GTK2 のモジュールをインストールするパッケージ</title>

    <para>パッケージが GTK2 の IM モジュールやローダーをインストールする場合は、
    これらが確実に GTK2 のデータベースに登録されるようにするために、
    いくつか特別な手順を踏む必要があります。</para>

    <orderedlist>
      <listitem><para>gtk2 の <filename>buildlink3.mk</filename> ファイルではなく
      <filename>../../x11/gtk2/modules.mk</filename> をインクルードします。
      こうすると、インストールおよびアンインストール時に、GTK2
      のデータベースを再構築してくれます。</para>
      </listitem>

      <listitem><para>GTK2 の IM モジュールをインストールするパッケージでは、
      <varname>GTK2_IMMODULES=YES</varname> を設定します。</para>
      </listitem>

      <listitem><para>GTK2 のローダーをインストールするパッケージでは、
      <varname>GTK2_LOADERS=YES</varname> を設定します。</para>
      </listitem>

      <listitem><para>パッケージが GTK2 のデータベースディレクトリーを直接いじらないよう修正します。
      データベースは以下のとおりです。</para>

	<itemizedlist>
	  <listitem><para><filename>libdata/gtk-2.0/gdk-pixbuf.loaders</filename></para></listitem>
	  <listitem><para><filename>libdata/gtk-2.0/gtk.immodules</filename></para></listitem>
	</itemizedlist>

      </listitem>

      <listitem><para><filename>PLIST</filename> を確認し、<filename>libdata/gtk-2.0</filename>
      ディレクトリー以下の項目をすべて削除します。
      これらは自動的に処理されるものだからです。</para>
      </listitem>
    </orderedlist>
  </sect2>


  <sect2 id="sgml-xml-data">
    <title>SGML または XML のデータをインストールするパッケージ</title>

    <para>パッケージが、システム全体で使われるカタログへ登録する必要のある
    SGML または XML のデータファイル (DTD, sub-catalog など) をインストールする場合は、
    いくつか特別な手順を踏む必要があります。</para>

    <orderedlist>
      <listitem>
	<para>パッケージの <filename>Makefile</filename> で
	<filename>../../textproc/xmlcatmgr/catalogs.mk</filename> をインクルードします。
	こうすると、インストールおよびアンインストール時に、
	データファイルをシステム全体で使われるカタログに登録してくれます。</para>
      </listitem>

      <listitem>
	<para><varname>SGML_CATALOGS</varname> を、このパッケージがインストールする
	SGML カタログをすべてをフルパス表記にしたものに設定します。</para>
      </listitem>

      <listitem>
	<para><varname>XML_CATALOGS</varname> を、このパッケージがインストールする
	XML カタログをすべてをフルパス表記にしたものに設定します。</para>
      </listitem>

      <listitem>
	<para><varname>SGML_ENTRIES</varname> を、SGML カタログに追加する
	個々のエントリーに設定します。各エントリーは
	3 個の文字列からなります。書き方の詳細は xmlcatmgr(1)
	(特に、'add' アクション用の引数) を参照してください。
	なお、通常はこの変数を使うことはありません。</para>
      </listitem>

      <listitem>
	<para><varname>XML_ENTRIES</varname> を、XML カタログに追加する
	個々のエントリーに設定します。各エントリーは
	3 個の文字列からなります。書き方の詳細は xmlcatmgr(1)
	(特に、'add' アクション用の引数) を参照してください。
	なお、通常はこの変数を使うことはありません。</para>
      </listitem>
    </orderedlist>
  </sect2>


  <sect2 id="mime-database">
    <title>MIME データベースの拡張をインストールするパッケージ</title>

    <para>パッケージが、<filename>.xml</filename> ファイルを
    <filename>${PREFIX}/share/mime/packages</filename>
    以下にインストールすることで MIME データベースを拡張する場合は、
    データベースがこの新規ファイルについて確実に整合性を持つようにするために、
    いくつか特別な手順を踏む必要があります。</para>

    <orderedlist>
      <listitem>
	<para><filename>../../databases/shared-mime-info/mimedb.mk</filename>
	をインクルードします (同じディレクトリーにある <filename>buildlink3.mk</filename>
	ファイルは、他の <filename>buildlink3.mk</filename>
	ファイルでインクルードするために予約されているので使いません)
	こうすると、インストールおよびアンインストール時に、MIME
	データベースを再構築してくれます。
	また、パッケージがデータベースに直接アクセスすることが一切できなくなります。</para>
      </listitem>

      <listitem>
	<para>PLIST を確認し、<filename>share/mime</filename>
	ディレクトリー以下の項目のうち、
	<filename>share/mime/packages</filename> 以下に置かれるファイル
	<emphasis>以外の</emphasis>ものをすべて削除します。
	このディレクトリーについては update-mime-database プログラムが自動的に処理しますが、
	除外したファイルはパッケージ依存のファイルなので、
	ファイルをインストールしたパッケージが自分で削除する必要があります。</para>
      </listitem>

      <listitem>
	<para>PLIST から <filename>share/mime/*</filename> ディレクトリーをすべて削除します。
	これらは shared-mime-info プログラムが処理します。</para>
      </listitem>
    </orderedlist>
  </sect2>


  <sect2 id="intltool">
    <title>intltool を使うパッケージ</title>

    <para>パッケージが構築時に intltool を使う場合は、
    <literal>intltool</literal> を <varname>USE_TOOLS</varname>
    に追加します。
    こうすると、パッケージの配布ファイルに附属する intltool ではなく、
    pkgsrc の intltool を強制的に使うようになります。</para>

    <para>この仕組みは、intltool 構築時の依存関係を追跡して、
    利用可能な最新版を使います。この方法を使うことで、
    リリース後にできたバグ修正も適用することができます。</para>
  </sect2>


  <sect2 id="startup-scripts">
    <title>起動スクリプトをインストールするパッケージ</title>
    <para>パッケージに rc.d スクリプトが附属する場合、このスクリプトは、
    標準では起動ディレクトリーにコピーされませんが、
    &mk.conf; にオプション
    <varname>PKG_RCD_SCRIPTS=YES</varname> を追加指定すると、
    パッケージのインストール時に、スクリプトが
    <filename>/etc/rc.d</filename> 以下にコピーされます。
    また、パッケージのアンインストール時には、
    自動的にスクリプトが削除されます。</para>
  </sect2>

  <sect2 id="tex-packages">
    <title>TeX モジュールをインストールするパッケージ</title>

    <para>パッケージが、TeX パッケージを texmf ツリーにインストールする場合は、
    texmf ツリーの <filename>ls-R</filename>
    データベースを更新する必要があります。</para>
    <note><para>teTeX-texmf のような主たる TeX パッケージ以外のパッケージは、
    <varname>PKG_TEXMFPREFIX</varname>
    ではなく <varname>PKG_LOCALTEXMFPREFIX</varname>
    内にファイルをインストールするようにします。</para></note>

    <orderedlist>
      <listitem><para><filename>../../mk/tex.buildlink3.mk</filename>
      のかわりに <filename>../../print/teTeX/module.mk</filename>
      をインクルードします。こうすると、インストール時とアンインストール時に
      <filename>ls-R</filename> を再構築してくれます。</para>
      </listitem>

      <listitem><para>パッケージが
      <varname>PKG_LOCALTEXMFPREFIX</varname> の texmf ツリー以外の
      texmf ツリーにファイルをインストールする場合は、
      <varname>TEXMFDIRS</varname> データベースの更新が必要となる
      texmf ツリーをすべて並べたリストに設定します。</para>
      <para>パッケージが、<command>updmap</command>
      を使って登録する必要があるフォントマップファイルもインストールする場合は、
      <varname>TEX_FONTMAPS</varname> を、
      そのようなフォントマップファイルをすべて並べたリストに設定します。
      こうすると、インストール時とアンインストール時に
      <command>updmap</command> が自動的に実行され、
      TeX 出力ドライバー用のフォントマップファイルの有効化や無効化をしてくれます。</para>
      </listitem>

      <listitem><para><filename>PLIST</filename> には
      <filename>ls-R</filename> データベースは一切含めないようにします。
      このデータベースは teTeX-bin パッケージによってのみ削除されるものだからです。</para>
      </listitem>
    </orderedlist>
  </sect2>

  <sect2 id="emulation-packages">
    <title>エミュレーションによるバイナリーの実行に対応したパッケージ</title>

    <para>パッケージのなかには、あるオペレーティングシステム用のバイナリーを
    (エミュレーションに対応した) 別のオペレーティングシステム上で実行するための、
    ライブラリーや実行ファイルを提供するものがあります。
    例としては、NetBSD 上で Linux のバイナリーを実行するものがあげられます。</para>

    <para><filename role="pkg">pkgtools/rpm2pkg</filename>
    は、Linux の rpm パッケージの展開やパッケージ化を補助するものです。</para>

    <para><varname>CHECK_SHLIBS</varname> を no に設定して、
    インストールされた実行ファイル用のライブラリーを動的リンカーがすべて見つけられることを検査する
    <command>check-shlibs</command> ターゲットを抑止することができます。
    この検査では標準の動的リンカーを実行するので、
    エミュレーションパッケージに対しては検査が失敗します。
    エミュレーションで使われるライブラリーは、
    標準のディレクトリーには置かれていないからです。</para>
  </sect2>

  <sect2 id="hicolor-theme">
    <title>ハイカラーテーマのアイコンをインストールするパッケージ</title>

    <para>パッケージが、
    <filename>share/icons/hicolor</filename> 以下に画像をインストールするか
    <filename>share/icons/hicolor/icon-theme.cache</filename> データベースを更新するかあるいはその両方をおこなう場合は、
    テーマ用の共有ディレクトリーを適切に扱い、キャッシュデータベースを確実に再構築するために、
    以下の手順を踏む必要があります。</para>

    <orderedlist>
      <listitem>
	<para><filename>../../graphics/hicolor-icon-theme/buildlink3.mk</filename>
	をインクルードします。</para>
      </listitem>

      <listitem>
	<para><filename>PLIST</filename> を確認し、
	テーマのキャッシュを参照するエントリーを削除します。</para>
      </listitem>

        <listitem>
	  <para>PLIST が <filename>share/icons/hicolor</filename>
	  階層からアイコン用の共有ディレクトリーを削除しないようにします。
	  これは自動的に処理されるものだからです。</para>
        </listitem>
      </orderedlist>

      <para>後の 2 点について、
      PLIST がこれらを守っていることを確認する最良の方法は、
      <command>make print-PLIST</command> を使って作り直すことです。</para>
    </sect2>


    <sect2 id="desktop-files">
      <title>デスクトップファイルをインストールするパッケージ</title>

      <para>パッケージが、<filename>.desktop</filename> ファイルを
      <filename>share/applications</filename> 以下にインストールし、そのファイルに
      MIME 情報が含まれている場合は、それらが MIME データベースに確実に登録されるようにするために、
      以下の手順を踏む必要があります。</para>

      <orderedlist>
        <listitem>
	  <para><filename>../../sysutils/desktop-file-utils/desktopdb.mk</filename>
	  をインクルードします。</para>
        </listitem>

        <listitem>
          <para>PLIST を確認し、
	  <filename>share/applications/mimeinfo.cache</filename> ファイルを参照するエントリーを削除します。
	  これは自動的に処理されるものだからです。</para>
        </listitem>
      </orderedlist>

      <para>最後の点について、
      PLIST がこれらを守っていることを確認する最良の方法は、<command>make
      print-PLIST</command> を使って作り直すことです。</para>
    </sect2>
</sect1>

<sect1 id="punting">
  <title>パッケージに問題があるという印をつける</title>

  <para>場合によっては、パッケージの問題をすぐに解決できないことがあります。
  現在のところ、
  パッケージに問題があることを表す方法が二通りあります。</para>
  <itemizedlist>
    <listitem><para>一つ目の方法は、単に、壊れているという印をつけるというものです。
    これをおこなうには、<varname>BROKEN</varname> 変数を、
    (<varname>RESTRICTED</varname> 変数と同様に)
    パッケージが壊れている理由に設定するだけです。
    利用者がパッケージを構築しようとすると、
    パッケージはその場でこのメッセージを表示して、
    構築をしないようになります。</para></listitem>

    <listitem><para>pkgsrc の凍結ごとに、凍結期間後 (ツリーが安定となり、
    新しい pkgsrc の枝が切られた時) に、
    最新の NetBSD リリース上の公式の枝において構築されていないパッケージは、
    その枝において壊れているという印がつけられます。
    これは、<varname>BROKEN_IN</varname> 変数に枝名を設定 (あるいは追加)
    することでおこなわれます。
    この印のついたパッケージを利用者が構築しようとして構築に失敗すると、
    それぞれの枝においてこのパッケージは壊れているというメッセージが、
    利用者に対して表示されます。</para></listitem>
  </itemizedlist>
  <para>どちらに該当するパッケージも、
  不定期的に pkgsrc から削除されます。</para>
</sect1>

</chapter>
