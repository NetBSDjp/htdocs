<!-- $NetBSD: pkginstall.xml,v 1.4 2005/07/27 21:29:50 rpaulo Exp $ -->

<chapter id="pkginstall"> <?dbhtml filename="pkginstall.html"?>
<title>The pkginstall framework</title>

<para>This chapter describes the framework known as
<literal>pkginstall</literal>, whose key features are:</para>

<itemizedlist>

  <listitem>
    <para>Generic installation and manipulation of directories and files
    outside the pkgsrc-handled tree, <varname>LOCALBASE</varname>.</para>
  </listitem>

  <listitem>
    <para>Automatic handling of configuration files during installation,
    provided that packages are correctly designed.</para>
  </listitem>

  <listitem>
    <para>Generation and installation of system startup scripts.</para>
  </listitem>

  <listitem>
    <para>Registration of system users and groups.</para>
  </listitem>

  <listitem>
    <para>Registration of system shells.</para>
  </listitem>

</itemizedlist>

<para>The following sections inspect each of the above points in detail.
Note that, in order to use any of the described functionalities, you must
add the following to your package's <filename>Makefile</filename>:</para>

<programlisting>USE_PKGINSTALL=YES</programlisting>

<para>You may be thinking that many of the things described here could be
easily done with simple code in the package's post-installation target
(<literal>post-install</literal>).  <emphasis>This is incorrect</emphasis>,
as the code in them is only executed when building from source.  Machines
using binary packages could not benefit from it at all (as the code itself
could be unavailable).  Therefore, the only way to achieve any of the items
described above is by means of the installation scripts, which are
automatically generated by pkginstall.</para>

<!-- ================================================================== -->

<sect1 id="files-and-dirs-outside-prefix">
<title>Files and directories outside the installation prefix</title>

<para>As you already know, the <filename>PLIST</filename> file holds a list
of files and directories that belong to a package.  The names used in it
are relative to the installation prefix (<filename>${PREFIX}</filename>),
which means that it cannot register files outside this directory (absolute
path names are not allowed).  Despite this restriction, some packages need
to install files outside this location; e.g., under
<filename>${VARBASE}</filename> or
<filename>${PKG_SYSCONFDIR}</filename>.</para>

<para>The only way to achieve this is to create such files during
installation time by using the installation scripts.  These scripts can run
arbitrary commands, so they have the potential to create and manage files
anywhere in the filesystem.  Here is where pkginstall comes into play: it
provides generic scripts to abstract the manipulation of such files and
directories based on variables set in the package's
<filename>Makefile</filename>.  The rest of this section describes which
these variables are.</para>

<!-- ================================================================== -->

<sect2 id="dirs-outside-prefix">
<title>Directory manipulation</title>

<para>The following variables can be set to request the creation of
directories anywhere in the filesystem:</para>

<itemizedlist>

  <listitem>
    <para><varname>MAKE_DIRS</varname> and <varname>OWN_DIRS</varname>
    contain a list of directories that should be created and should attempt
    to be destroyed by the installation scripts.  The difference between
    the two is that the latter prompts the administrator to remove any
    directories that may be left after deinstallation (because they were
    not empty), while the former does not.</para>
  </listitem>

  <listitem>
    <para><varname>MAKE_DIRS_PERMS</varname> and
    <varname>OWN_DIRS_PERMS</varname> contain a list of tuples describing
    which directories should be created and should attempt to be destroyed
    by the installation scripts.  Each tuple holds the following values,
    separated by spaces: the directory name, its owner, its group and its
    numerical mode.  For example:</para>

    <programlisting>MAKE_DIRS_PERMS+= ${VARBASE}/foo/private ${ROOT_USER} ${ROOT_GROUP} 0700</programlisting>

    <para>The difference between the two is exactly the same as their
    non-<varname>PERMS</varname> counterparts.</para>
  </listitem>

</itemizedlist>

</sect2>

<!-- ================================================================== -->

<sect2 id="files-outside-prefix">
<title>File manipulation</title>

<para>Creating non-empty files outside the installation prefix is tricky
because the <filename>PLIST</filename> forces all files to be inside it.
To overcome this problem, the only solution is to extract the file in the
known place (i.e., inside the installation prefix) and copy it to the
appropriate location during installation (done by the installation scripts
generated by pkginstall).  We will call the former the <emphasis>master
file</emphasis> in the following paragraphs, which describe the variables
that can be used to automatically and consistently handle files outside the
installation prefix:</para>

<itemizedlist>

  <listitem>
    <para><varname>CONF_FILES</varname> and
    <varname>SUPPORT_FILES</varname> are pairs of master and target files.
    During installation time, the master file is copied to the target one
    if and only if the latter does not exist.  Upon deinstallation, the
    target file is removed provided that it was not modified by the
    installation.</para>

    <para>The difference between the two is that the latter prompts the
    administrator to remove any files that may be left after
    deinstallation (because they were not empty), while the former does
    not.</para>
  </listitem>

  <listitem>
    <para><varname>CONF_FILES_PERMS</varname> and
    <varname>SUPPORT_FILES_PERMS</varname> contain tuples describing master
    files as well as their target locations.  For each of them, it also
    specifies their owner, their group and their numeric permissions, in
    this order.  For example:</para>

    <programlisting>SUPPORT_FILES_PERMS+= ${PREFIX}/share/somefile ${VARBASE}/somefile ${ROOT_USER} ${ROOT_GROUP} 0700</programlisting>

    <para>The difference between the two is exactly the same as their
    non-<varname>PERMS</varname> counterparts.</para>
  </listitem>

</itemizedlist>

</sect2>

</sect1>

<!-- ================================================================== -->

<sect1 id="conf-files">
<title>Configuration files</title>

<para>Configuration files are special in the sense that they are installed
in their own specific directory, <varname>PKG_SYSCONFDIR</varname>, and
need special treatment during installation (most of which is automated by
pkginstall).  The main concept you must bear in mind is that files marked
as configuration files are automatically copied to the right place (somewhere
inside <varname>PKG_SYSCONFDIR</varname>) during installation <emphasis>if
and only if</emphasis> they didn't exist before.  Similarly, they will not
be removed if they have local modifications.  This ensures that
administrators never lose any custom changes they may have made.</para>

<!-- ================================================================== -->

<sect2 id="conf-files-sysconfdir">
<title>How <varname>PKG_SYSCONFDIR</varname> is set</title>

<para>As said before, the <varname>PKG_SYSCONFDIR</varname> variable
specifies where configuration files shall be installed.  Its contents are
set based upon the following variables:</para>

<itemizedlist>

  <listitem>
    <para><varname>PKG_SYSCONFBASE</varname>: The configuration's root
    directory.  Defaults to <filename>${PREFIX}/etc</filename> although it may
    be overridden by the user to point to his preferred location (e.g.,
    <filename>/etc</filename>, <filename>/etc/pkg</filename>, etc.).
    Packages must not use it directly.</para>
  </listitem>

  <listitem>
    <para><varname>PKG_SYSCONFSUBDIR</varname>: A subdirectory of
    <varname>PKG_SYSCONFBASE</varname> under which the configuration files
    for the package being built shall be installed.  The definition of this
    variable only makes sense in the package's
    <filename>Makefile</filename> (i.e., it is not user
    customizable).</para>

    <para>As an example, consider the Apache package,
    <filename role="pkg">www/apache2</filename>, which places its 
    configuration files under the
    <filename>httpd/</filename> subdirectory of
    <varname>PKG_SYSCONFBASE</varname>.  This should be set in the package
    Makefile.</para>
  </listitem>

  <listitem>
    <para><varname>PKG_SYSCONFVAR</varname>: Specifies the name of the
    variable that holds this package's configuration directory (if
    different from <varname>PKG_SYSCONFBASE</varname>).  It defaults to
    <varname>PKGBASE</varname>'s value, and is always prefixed with
    <literal>PKG_SYSCONFDIR</literal>.</para>
  </listitem>

  <listitem>
    <para><varname>PKG_SYSCONFDIR.${PKG_SYSCONFVAR}</varname>: Holds the
    directory where the configuration files for the package identified by
    <varname>PKG_SYSCONFVAR</varname>'s shall be placed.</para>
  </listitem>

</itemizedlist>

<para>Based on the above variables, pkginstall determines the value of
<varname>PKG_SYSCONFDIR</varname>, which is the <emphasis>only</emphasis>
variable that can be used within a package to refer to its configuration
directory.  The algorithm used to set its value is basically the
following:</para>

<orderedlist>

  <listitem>
    <para>If <varname>PKG_SYSCONFDIR.${PKG_SYSCONFVAR}</varname> is set,
    its value is used.</para>
  </listitem>

  <listitem>
    <para>If the previous variable is not defined but
    <varname>PKG_SYSCONFSUBDIR</varname> is set in the package's
    <filename>Makefile</filename>, the resulting value is
    <filename>${PKG_SYSCONFBASE}/${PKG_SYSCONFSUBDIR}</filename>.</para>
  </listitem>

  <listitem>
    <para>Otherwise, it is set to
    <filename>${PKG_SYSCONFBASE}</filename>.</para>
  </listitem>

</orderedlist>

<para>It is worth mentioning that <filename>${PKG_SYSCONFDIR}</filename> is
automatically added to <filename>OWN_DIRS</filename>.  See <xref
linkend="dirs-outside-prefix" /> what this means.</para>

</sect2>

<!-- ================================================================== -->

<sect2 id="conf-files-configure">
<title>Telling the software were configuration files are</title>

<para>Given that pkgsrc (and users!) expect configuration files to be in a
known place, you need to teach each package where it shall install its
files.  In some cases you will have to patch the package Makefiles to
achieve it.  If you are lucky, though, it may be as easy as passing an
extra flag to the configuration script; this is the case of GNU Autoconf
generated files:</para>

<programlisting>CONFIGURE_ARGS+= --sysconfdir=${PKG_SYSCONFDIR}</programlisting>

<para>Note that this specifies where the package has to <emphasis>look
for</emphasis> its configuration files, not where they will be originally
installed (although the difference is never explicit,
unfortunately).</para>

</sect2>

<!-- ================================================================== -->

<sect2 id="conf-files-patching">
<title>Patching installations</title>

<para>As said before, pkginstall automatically handles configuration files.
This means that <emphasis role="strong">the packages themselves must not
touch the contents of <filename>${PKG_SYSCONFDIR}</filename>
directly</emphasis>.  Bad news is that many software installation scripts
will, out of the box, mess with the contents of that directory.  So what is
the correct procedure to fix this issue?</para>

<para>You must teach the package (usually by manually patching it) to
install any configuration files under the examples hierarchy,
<filename>share/examples/${PKGBASE}/</filename>.  This way, the
<filename>PLIST</filename> registers them and the administrator always
has the original copies available.</para>

<para>Once the required configuration files are in place (i.e., under the
examples hierarchy), the pkginstall framework can use them as master copies
during the package installation to update what is in
<filename>${PKG_SYSCONFDIR}</filename>.  To achieve this, the variables
<varname>CONF_FILES</varname> and <varname>CONF_FILES_PERMS</varname> are
used.  Check out <xref linkend="files-outside-prefix" /> for information
about their syntax and their purpose.  Here is an example, taken from the
<filename role="pkg">mail/mutt</filename> package:</para>

<programlisting>EGDIR=        ${PREFIX}/share/doc/mutt/samples
CONF_FILES=   ${EGDIR}/Muttrc ${PKG_SYSCONFDIR}/Muttrc</programlisting>

<para>Note that the <varname>EGDIR</varname> variable is specific to that
package and has no meaning outside it.</para>

</sect2>

<!-- ================================================================== -->

<sect2 id="conf-files-disable">
<title>Disabling handling of configuration files</title>

<!-- XXX This doesn't really belong here -->

<para>The automatic copying of config files can be toggled by setting the
environment variable <varname>PKG_CONFIG</varname> prior to package
installation.</para>

</sect2>

</sect1>

<!-- ================================================================== -->

<sect1 id="rcd-scripts">
<title>System startup scripts</title>

<para>System startup scripts are special files because they must be
installed in a place known by the underlying OS, usually outside the
installation prefix.  Therefore, the same rules described in <xref
linkend="files-and-dirs-outside-prefix" /> apply, and the same solutions
can be used.  However, pkginstall provides a special mechanism to handle
these files.</para>

<para>In order to provide system startup scripts, the package has
to:</para>

<orderedlist>

  <listitem>
    <para>Store the script inside <filename>${FILESDIR}</filename>, with
    the <literal>.sh</literal> suffix appended.  Considering the
    <filename role="pkg">print/cups</filename> package as an example, it has a
    <filename>cupsd.sh</filename> in its files directory.</para>
  </listitem>

  <listitem>
    <para>Tell pkginstall to handle it, appending the name of the script,
    without its extension, to the <varname>RCD_SCRIPTS</varname> variable.
    Continuing the previous example:</para>

    <programlisting>RCD_SCRIPTS+= cupsd</programlisting>
  </listitem>

</orderedlist>

<para>Once this is done, pkginstall will do the following steps for each
script in an automated fashion:</para>

<!-- XXX We should probably have a chapter describing how rc.d scripts are
     written. -->

<orderedlist>

  <listitem>
    <para>Process the file found in the files directory applying all the
    substitutions described in the <filename>FILES_SUBST</filename>
    variable.</para>
  </listitem>

  <listitem>
    <para>Copy the script from the files directory to the examples
    hierarchy, <filename>${PREFIX}/share/examples/rc.d/</filename>.  Note
    that this master file must be explicitly registered in the
    <filename>PLIST</filename>.</para>
  </listitem>

  <listitem>
    <para>Add code to the installation scripts to copy the startup script
    from the examples hierarchy into the system-wide startup scripts
    directory.</para>
  </listitem>

</orderedlist>

<!-- ================================================================== -->

<sect2 id="rcd-scripts-disable">
<title>Disabling handling of system startup scripts</title>

<!-- XXX This doesn't really belong here -->

<para>The automatic copying of config files can be toggled by setting the
environment variable <varname>PKG_RCD_SCRIPTS</varname> prior to package
installation.  Note that the scripts will be always copied inside the
examples hierarchy, <filename>${PREFIX}/share/examples/rc.d/</filename>, no
matter what the value of this variable is.</para>

</sect2>

</sect1>

<!-- ================================================================== -->

<sect1 id="users-and-groups">
<title>System users and groups</title>

<para>If a package needs to create special users and/or groups during
installation, it can do so by using the pkginstall framework.</para>

<para>Users can be created by adding entries to the
<varname>PKG_USERS</varname> variable.  Each entry has the following
syntax, which mimics <filename>/etc/passwd</filename>:</para>

<programlisting>user:group[:[userid][:[descr][:[home][:shell]]]]</programlisting>

<para>Only the user and group are required; everything else is optional,
but the colons must be in the right places when specifying optional bits.
By default, a new user will have home directory
<filename>/nonexistent</filename>, and login shell
<filename>/sbin/nologin</filename> unless they are specified as part of the
user element.  Note that if the description contains spaces, then spaces
should be double backslash-escaped, as in:</para>

<programlisting>foo:foogrp::The\\ Foomister</programlisting>

<para>Similarly, groups can be created using the
<varname>PKG_GROUPS</varname> variable, whose syntax is:</para>

<programlisting>group[:groupid]</programlisting>

<para>As before, only the group name is required; the numeric identifier is
optional.</para>

</sect1>

<!-- ================================================================== -->

<sect1 id="shells">
<title>System shells</title>

<para>Packages that install system shells should register them in the shell
database, <filename>/etc/shells</filename>, to make things easier to the
administrator.  This must be done from the installation scripts to keep
binary packages working on any system.  pkginstall provides an easy way to
accomplish this task.</para>

<para>When a package provides a shell interpreter, it has to set the
<varname>PKG_SHELL</varname> variable to its absolute file name.  This will
add some hooks to the installation scripts to handle it.  Consider the
following example, taken from <filename role="pkg">shells/zsh</filename>:</para>

<programlisting>USE_PKGINSTALL= YES
PKG_SHELL=      ${PREFIX}/bin/zsh</programlisting>

<!-- ================================================================== -->

<sect2 id="shells-disable">
<title>Disabling handling of configuration files</title>

<!-- XXX This doesn't really belong here -->

<para>The automatic registration of shell interpreters can be disabled by
the administrator by setting the <filename>PKG_REGISTER_SHELLS</filename>
environment variable to <literal>NO</literal>.</para>

</sect2>

</sect1>

</chapter>
