<!-- $NetBSD: pkginstall.xml,v 1.16 2009/02/10 14:50:45 joerg Exp $ -->
<!-- Based on english version: -->
<!-- NetBSD: pkginstall.xml,v 1.16 2009/02/10 14:50:45 joerg Exp   -->

<chapter id="pkginstall"> <?dbhtml filename="pkginstall.html"?>
<title>pkginstall の枠組</title>

<para>本章では、<literal>pkginstall</literal> の枠組について説明します。
主な機能は以下のとおりです。</para>

<itemizedlist>

  <listitem>
    <para>pkgsrc が扱うツリー (<varname>LOCALBASE</varname>)
    以外の場所のディレクトリーやファイルの、汎用的なインストールおよび操作。</para>
  </listitem>

  <listitem>
    <para>インストール時における、設定ファイルの自動処理
    (パッケージが正しく設計されていればですが)。</para>
  </listitem>

  <listitem>
    <para>システム起動スクリプトの作成およびインストール。</para>
  </listitem>

  <listitem>
    <para>システムユーザーおよびグループの登録。</para>
  </listitem>

  <listitem>
    <para>システムシェルの登録。</para>
  </listitem>

  <listitem>
    <para>フォントデータベースの自動更新。</para>
  </listitem>

</itemizedlist>

<para>以下の各節では、上述の各機能について詳しく見てゆきます。</para>

<para>本章で説明する機能の多くは、パッケージのインストール後のターゲット
(<literal>post-install</literal>) を使うだけで簡単に実現できるのではないか、
とお思いになるかもしれませんが、<emphasis>それは正しくありません</emphasis>。
このターゲットのコードは、パッケージをソースから構築した場合しか実行されないからです。
バイナリーパッケージを使う場合は、(コード自体が利用できないので)
このターゲットのコードでは何もできません。したがって、上述の各機能は、
pkginstall が自動生成するインストール用スクリプトでしか実現できないのです。</para>

<!-- ================================================================== -->

<sect1 id="files-and-dirs-outside-prefix">
<title>インストール用のプレフィックス以外の場所にあるファイルとディレクトリー</title>

<para>すでにご存知のとおり、<filename>PLIST</filename> ファイルには、
パッケージに属するファイルとディレクトリーの一覧が書かれています。
この一覧では、インストール用のプレフィックス
(<filename>${PREFIX}</filename>) からの相対位置を使うため、
このディレクトリー以外の場所にあるファイルを書くことはできません
(絶対パス名は使えません)。この制約がある一方で、
パッケージによってはそのような場所、たとえば
<filename>${VARBASE}</filename> や
<filename>${PKG_SYSCONFDIR}</filename>
以下にファイルをインストールする必要があります。
これをおこなう唯一の方法は、インストール時にインストール用のスクリプトを使って
インストール対象のファイルを作成することです。</para>

<para>汎用のインストール用スクリプトは、
任意のコードを含めることのできるシェルスクリプトです。
実行するスクリプトを並べたリストを <varname>INSTALL_FILE</varname> 変数で与えます。
この変数の値は標準では <filename>INSTALL</filename> です。
パッケージの削除用としても、同様の変数があります (<varname>DEINSTALL_FILE</varname>:
標準の値は <filename>DEINSTALL</filename>)。
これらのスクリプトでは任意のコマンドを実行できるので、
ファイルシステム中のどこであってもファイルの作成や管理をすることができます。</para>

<para>以上のような汎用のインストール用スクリプトを使うことはおすすめしませんが、
特殊な事例では必要となることがあります。これらを使うべきでない理由のひとつは、
インストール用スクリプト内に不必要なコードや単純に誤ったコードが入っていないことについて、
利用者がパッケージ作成者を信頼する必要があるということです。
また、以前は、同じ機能のために同様のコードがたくさん使われており、
それらに共通するエラーを修正する場合は、
同様のコードをすべて探して変更する必要がありました。</para>

<para>pkginstall の枠組では、これとは異なる標準化された方法を提供します。
パッケージの <filename>Makefile</filename> で設定された変数にもとづき、
インストール対象のファイルやディレクトリーを操作するための汎用のスクリプトを提供します。
以下、本節では、この用途で使う変数を説明します。</para>

<!-- ================================================================== -->

<sect2 id="dirs-outside-prefix">
<title>ディレクトリーの操作</title>

<para>以下の変数は、ファイルシステムの任意の場所へディレクトリーを作成するために、
設定することができます。</para>

<itemizedlist>

  <listitem>
    <para><varname>MAKE_DIRS</varname> と <varname>OWN_DIRS</varname> は、
    インストール用スクリプトが作成したり、
    削除を試みたりする対象のディレクトリーのリストを値として持ちます。
    両変数の違いは、後者はアンインストール時に (空でなかったために)
    削除できなかった各ディレクトリーを削除するよう管理者に対してうながしますが、
    前者はそうしないことです。</para>
  </listitem>

  <listitem>
    <para><varname>MAKE_DIRS_PERMS</varname> と
    <varname>OWN_DIRS_PERMS</varname> は、インストール用スクリプトが作成したり、
    削除しようとしたりする対象のディレクトリーについて記述したタプルのリストを値として持ちます。
    各タプルは、ディレクトリー名、所有者、所有グループと、
    数字で表したモードの値をスペースで区切ったものからなります。
    たとえば以下のようになります。</para>

<programlisting>
MAKE_DIRS_PERMS+=         ${VARBASE}/foo/private ${ROOT_USER} ${ROOT_GROUP} 0700
</programlisting>

    <para>両変数の違いは、<varname>PERMS</varname>
    のつかない変数の違いとまったく同じです。</para>
  </listitem>

</itemizedlist>

</sect2>

<!-- ================================================================== -->

<sect2 id="files-outside-prefix">
<title>ファイルの操作</title>

<para>インストール用プレフィックス以外の場所に空でないファイルを作ることは、やりにくいことです。
なぜなら <filename>PLIST</filename> は全ファイルをインストール用プレフィックス内にあるものとして扱うからです。
この問題に対する唯一の解決策は、インストールの際に、
ファイルをいったん既知の場所 (つまり、インストール用プレフィックス内)
に展開し、それを本来の場所にコピーすることです
(pkginstall が生成するインストール用スクリプトがおこないます)。
以下、インストール用プレフィックス以外の場所のファイルを自動的かつ首尾一貫して扱うために使える変数について説明しますが、
ここではプレフィックス内にいったん展開したファイルのことを原本ファイル (<emphasis>master
file</emphasis>) ということにします。</para>

<itemizedlist>

  <listitem>
    <para><varname>CONF_FILES</varname> と
    <varname>SUPPORT_FILES</varname> は、
    原本ファイルとコピー先ファイルの組のリストを値として持ちます。
    インストール時に、コピー先ファイルが存在しなかった場合に限って、
    原本ファイルがコピー先ファイルにコピーされます。アンインストール時は、
    コピー先ファイルがインストールにおいて変更されていなければ、
    コピー先ファイルが削除されます。</para>

    <para>両変数の違いは、後者はアンインストール時に (空でなかったために)
    削除できなかった各ファイルを削除するよう管理者に対してうながしますが、
    前者はそうしないことです。</para>
  </listitem>

  <listitem>
    <para><varname>CONF_FILES_PERMS</varname> と
    <varname>SUPPORT_FILES_PERMS</varname> は、
    原本ファイルとコピー先ファイルについて記述したタプルのリストを値として持ちます。
    各タプルは、ファイル名のほか、両ファイルの所有者、所有グループと、
    数字で表したパーミッションを、この順番で指定します。
    たとえば以下のようになります。</para>

<programlisting>
SUPPORT_FILES_PERMS+= ${PREFIX}/share/somefile ${VARBASE}/somefile ${ROOT_USER} ${ROOT_GROUP} 0700
</programlisting>

    <para>両変数の違いは、<varname>PERMS</varname>
    のつかない変数の違いとまったく同じです。</para>
  </listitem>

</itemizedlist>

</sect2>

</sect1>

<!-- ================================================================== -->

<sect1 id="conf-files">
<title>設定ファイル</title>

<para>(個々のパッケージの) 設定ファイルは、パッケージに固有のディレクトリー
<varname>PKG_SYSCONFDIR</varname> にインストールされ、また、
インストール時には特別扱いが必要である (ほとんどのことは、pkginstall
で自動化されています) という点で、特別です。主に心がける必要があることは、
設定ファイルであるとされたファイルは、インストール時に、
そのファイルがもともと存在しなかった場合<emphasis>に限って</emphasis>、
正しい場所 (<varname>PKG_SYSCONFDIR</varname>
以下のどこか) に自動的にコピーされるということです。同様にして、
設定ファイルにローカルな変更が加わっている場合には、
アンインストール時に削除されません。こうすることで、
管理者が独自に変更をおこなっても、その変更が失われることがないようにしています。</para>

<!-- ================================================================== -->

<sect2 id="conf-files-sysconfdir">
<title><varname>PKG_SYSCONFDIR</varname> はどのように設定されるか</title>

<para>前述のとおり、<varname>PKG_SYSCONFDIR</varname>
変数は設定ファイルのインストール先を指定します。この変数の値は、
以下の各変数をもとに設定されます。</para>

<itemizedlist>

  <listitem>
    <para><varname>PKG_SYSCONFBASE</varname>: 設定ディレクトリーのルートです。
    指定しなかった場合は <filename>${PREFIX}/etc</filename> となりますが、
    利用者は好みの場所 (たとえば、
    <filename>/etc</filename>, <filename>/etc/pkg</filename> など)
    を指すよう上書きすることもできます。
    パッケージがこの変数を直接使うことはできません。</para>
  </listitem>

  <listitem>
    <para><varname>PKG_SYSCONFSUBDIR</varname>: <varname>PKG_SYSCONFBASE</varname>
    のサブディレクトリーで、
    構築されたパッケージ用の設定ファイルはこの下に置かれます。
    この変数は、パッケージの
    <filename>Makefile</filename> で定義された場合にのみ意味を持ちます (つまり、
    利用者がカスタマイズすることはできません)。</para>

    <para>例としては、Apache のパッケージ
    <filename role="pkg">www/apache2</filename> をご覧ください。Apache では、設定ファイルを
    <varname>PKG_SYSCONFBASE</varname> のサブディレクトリー
    <filename>httpd/</filename> に置いています。この変数は、パッケージの
    Makefile で設定します。</para>
  </listitem>

  <listitem>
    <para><varname>PKG_SYSCONFVAR</varname>: このパッケージの設定ディレクトリー
    (<varname>PKG_SYSCONFBASE</varname> と異なる場合) を保持する変数の名前を指定します。
    指定しなかった場合は、<varname>PKGBASE</varname> の値となります。
    また、常に <literal>PKG_SYSCONFDIR</literal> が前につきます。</para>
  </listitem>

  <listitem>
    <para><varname>PKG_SYSCONFDIR.${PKG_SYSCONFVAR}</varname>:
    <varname>PKG_SYSCONFVAR</varname>
    で区別されるパッケージの設定ファイルをどのディレクトリーに置くかを保持します。</para>
  </listitem>

</itemizedlist>

<para>以上の各変数をもとに、pkginstall は <varname>PKG_SYSCONFDIR</varname>
の値を決めます。パッケージが設定ディレクトリーを参照するには、
この <varname>PKG_SYSCONFDIR</varname> 変数<emphasis>だけ</emphasis>を使うことができます。
この値の設定に使われるアルゴリズムは、
基本的には以下のとおりです。</para>

<orderedlist>

  <listitem>
    <para><varname>PKG_SYSCONFDIR.${PKG_SYSCONFVAR}</varname> が設定されている場合は、
    この値が使われます。</para>
  </listitem>

  <listitem>
    <para>前項の変数は定義されていないが、
    <varname>PKG_SYSCONFSUBDIR</varname> がパッケージの
    <filename>Makefile</filename> で設定されている場合は、
    <filename>${PKG_SYSCONFBASE}/${PKG_SYSCONFSUBDIR}</filename> が使われます。</para>
  </listitem>

  <listitem>
    <para>以上の場合以外は、
    <filename>${PKG_SYSCONFBASE}</filename> に設定されます。</para>
  </listitem>

</orderedlist>

<para>なお、<filename>${PKG_SYSCONFDIR}</filename> は自動的に
<filename>OWN_DIRS</filename> に追加されることを断っておきます。この意味については、<xref
linkend="dirs-outside-prefix" />をご覧ください。
ただし、<filename>${PKG_SYSCONFDIR}</filename> のサブディレクトリーは追加されませんので、
OWN_DIRS または MAKE_DIRS を使って作成する必要があります。</para>

</sect2>

<!-- ================================================================== -->

<sect2 id="conf-files-configure">
<title>ソフトウェアに設定ファイルの置き場所を教える</title>

<para>pkgsrc (とユーザーも) が、設定ファイルを既知の場所に置くことを前提としている場合は、
設定ファイルをインストールする場所を各パッケージに教えてやる必要があります。
場合によっては、パッケージの Makefile を修正する必要があります。
この修正は、運がよければ、
コンフィギュレーションスクリプトに渡すフラグを追加する程度ですみます。
これは、GNU Autoconf が生成したファイルの場合が該当します。</para>

<programlisting>
CONFIGURE_ARGS+= --sysconfdir=${PKG_SYSCONFDIR}
</programlisting>

<para>なお、ここで指定しているのは、
パッケージが設定ファイルを<emphasis>探す</emphasis>必要のある場所であって、
設定ファイルのもともとのインストール先ではありません (困った事に、
両者ははっきり区別できませんが)。</para>

</sect2>

<!-- ================================================================== -->

<sect2 id="conf-files-patching">
<title>インストールの過程を修正する</title>

<para>前述のとおり、pkginstall は設定ファイルを自動的に処理します。
つまり、<emphasis role="strong">パッケージ本体側では、
<filename>${PKG_SYSCONFDIR}</filename> の内容を直接いじってはいけない</emphasis>
ことになります。まずいことに、多くのソフトウェアのインストール用スクリプトは、
そのまま実行すると、このディレクトリーの内容に手を加えてしまいます。では、
この問題を適切に直すにはどうすればいいのでしょうか?</para>

<para>パッケージに対して、すべての設定ファイルを examples
階層 <filename>share/examples/${PKGBASE}/</filename> 以下にインストールするように
(ふつうは、手でパッチを当てて) 指示する必要があります。こうすると、
<filename>PLIST</filename> はこれらを登録します。
また、管理者はインストールされたままの設定ファイルを常に使うことができます。</para>

<para>必要な設定ファイルを適切な場所 (つまり、examples 階層の下) に置けば、
pkginstall の枠組は、このファイルを、パッケージのインストール時に
<filename>${PKG_SYSCONFDIR}</filename>
以下のファイルを更新するための原本として使うことができます。これをおこなうために、
<varname>CONF_FILES</varname> および <varname>CONF_FILES_PERMS</varname>
の各変数が使われます。この各変数の書式と使い方は、
<xref linkend="files-outside-prefix" />でご確認ください。
<filename role="pkg">mail/mutt</filename> パッケージから抜粋した例を以下に掲げます。</para>

<programlisting>
EGDIR=        ${PREFIX}/share/doc/mutt/samples
CONF_FILES=   ${EGDIR}/Muttrc ${PKG_SYSCONFDIR}/Muttrc
</programlisting>

<para>なお、<varname>EGDIR</varname> 変数は当該パッケージに特有のものであって、
それ以外では意味を持たないことに注意してください。</para>

</sect2>

<!-- ================================================================== -->

<sect2 id="conf-files-disable">
<title>設定ファイルの処理をしないようにする</title>

<!-- XXX This doesn't really belong here -->

<para>設定ファイルの自動コピーは、パッケージをインストールする前に環境変数
<varname>PKG_CONFIG</varname> を設定しておけば、
おこなうかどうかを切替えることができます。</para>

</sect2>

</sect1>

<!-- ================================================================== -->

<sect1 id="rcd-scripts">
<title>システム起動スクリプト</title>

<para>システムの起動スクリプトは、OS ごとに決まった場所にインストールする必要があり、
その場所はたいていインストール用のプレフィックス以外の場所にある、という点で、
特別なファイルです。したがって、<xref
linkend="files-and-dirs-outside-prefix" />で説明したのと同じ方法を適用して、
同じ解決法を使うことができます。ただし、
pkginstall では起動スクリプトの処理専用の仕組みを用意しています。</para>

<para>システムの起動スクリプトが附属するパッケージでは、
以下のことをおこなう必要があります。</para>

<orderedlist>

  <listitem>
    <para>スクリプトに <literal>.sh</literal> サフィックスを付け加えて、
    <filename>${FILESDIR}</filename> 内に置きます。例としては、
    files ディレクトリーに <filename>cupsd.sh</filename> がある
    <filename role="pkg">print/cups</filename> パッケージをご覧ください。</para>
  </listitem>

  <listitem>
    <para>スクリプト名から拡張子を抜いたものを <varname>RCD_SCRIPTS</varname>
    変数に追加して、pkginstall がこのスクリプトを処理するようにします。
    前出の例では以下のようになります。</para>

<programlisting>
RCD_SCRIPTS+=   cupsd
</programlisting>
  </listitem>

</orderedlist>

<para>以上のことをおこなえば、pkginstall は各スクリプトに対して、
以下の手順を自動的におこないます。</para>

<!-- XXX We should probably have a chapter describing how rc.d scripts are
     written. -->

<orderedlist>

  <listitem>
    <para>files ディレクトリー以下の各ファイルに対して、
    <filename>FILES_SUBST</filename>
    変数で示されている置換をすべて適用します。</para>
  </listitem>

  <listitem>
    <para>スクリプトを、files ディレクトリーから examples
    階層 <filename>${PREFIX}/share/examples/rc.d/</filename> にコピーします。
    なお、この原本ファイルは、<filename>PLIST</filename>
    に明示的に登録する必要があります。</para>
  </listitem>

  <listitem>
    <para>起動スクリプトを examples
    階層からシステム全体の起動スクリプト用ディレクトリーにコピーするためのコードを、
    インストール用スクリプトに追加します。</para>
  </listitem>

</orderedlist>

<!-- ================================================================== -->

<sect2 id="rcd-scripts-disable">
<title>システム起動スクリプトの処理をしないようにする</title>

<!-- XXX This doesn't really belong here -->

<para>設定ファイルの自動コピーは、パッケージをインストールする前に環境変数
<varname>PKG_RCD_SCRIPTS</varname> を設定しておけば、
おこなうかどうかを切替えることができます。なお、起動スクリプトは常に
examples 階層 <filename>${PREFIX}/share/examples/rc.d/</filename>
にコピーされますが、これはこの変数値の影響を受けません。</para>

</sect2>

</sect1>

<!-- ================================================================== -->

<sect1 id="users-and-groups">
<title>システムユーザーとグループ</title>

<para>パッケージのインストール時に、特別なユーザーやグループを作成する必要がある場合、
pkginstall の枠組を使って作成することができます。</para>

<para><varname>PKG_USERS</varname> 変数にユーザーのエントリーを追加すると、
ユーザーを作ることができます。各エントリーは、
以下のような書式となります。</para>

<programlisting>
user:group
</programlisting>

<para>ユーザーごとに変数を設定して、
ユーザーの属性をさらに詳しく指定することができます。
<varname>PKG_UID.<replaceable>user</replaceable></varname> は、
ユーザーの数字の UID です。
<varname>PKG_GECOS.<replaceable>user</replaceable></varname> は、
ユーザーの説明またはコメントです。
<varname>PKG_HOME.<replaceable>user</replaceable></varname> は、
ユーザーのホームディレクトリーで、指定しなかった場合は
<filename>/nonexistent</filename>
となります。
<varname>PKG_SHELL.<replaceable>user</replaceable></varname> は、
ユーザーのシェルで、指定しなかった場合は
<filename>/sbin/nologin</filename> となります。</para>

<para>同様にして、<varname>PKG_GROUPS</varname> 変数にグループのエントリーを追加すると、
グループを作ることができます。こちらの書式は以下のようになります。</para>

<programlisting>
group
</programlisting>

<para><varname>PKG_GID.<replaceable>group</replaceable></varname>
を定義すると、グループの数字の GID を設定することができます。</para>

<para>もっと前の段階でユーザーやグループを作る必要がある場合は、
どの相の直後にユーザーやグループを作るかを表すために、
<varname>USERGROUP_PHASE</varname> を
<literal>configure</literal> または <literal>build</literal> に設定することができます。
こうした場合は、作られるユーザーやグループの数字の UID や GID は、
自動的に最終的なインストール用スクリプトにハードコードされます。</para>

</sect1>

<!-- ================================================================== -->

<sect1 id="shells">
<title>システムシェル</title>

<para>パッケージがシステムシェルをインストールする場合は、管理者の手間を減らせるよう、
インストールしたシェルをシェルデータベース <filename>/etc/shells</filename>
に登録するようにします。この登録は、どのシステム上でもバイナリーパッケージが機能するようにするため、
インストール用スクリプトでおこなう必要があります。pkginstall では、
このことを簡単に実現できる方法を用意しています。</para>

<para>パッケージがシェルインタープリターを提供する場合は、
<varname>PKG_SHELL</varname> 変数を、そのシェルの絶対ファイル名に設定する必要があります。
こうすると、インストール用スクリプトに、シェル登録処理用のフックを追加します。
<filename role="pkg">shells/zsh</filename> から抜粋した例を以下に掲げますので、ご覧ください。</para>

<programlisting>
PKG_SHELL=      ${PREFIX}/bin/zsh
</programlisting>

<!-- ================================================================== -->

<sect2 id="shells-disable">
<title>シェルの登録をしないようにする</title>

<!-- XXX This doesn't really belong here -->

<para>シェルインタープリターの自動登録は、管理者が
<filename>PKG_REGISTER_SHELLS</filename> 環境変数を <literal>NO</literal>
に設定すれば、無効化することができます。</para>

</sect2>

</sect1>

<!-- ================================================================== -->

<sect1 id="fonts">
<title>フォント</title>

<para>X11 フォントをインストールするパッケージでは、
各フォントディレクトリー内のフォントの索引であるデータベースファイルを更新することが必要になります。
この更新は、pkginstall の枠組内で簡単におこなうことができます。</para>

<para>パッケージが X11 フォントをインストールする時には、
フォントをインストールするディレクトリーを、
<varname>FONTS_DIRS.<replaceable>type</replaceable></varname>
変数に列挙する必要があります。この <replaceable>type</replaceable>
は、<quote>ttf</quote>,
<quote>type1</quote>, <quote>x11</quote> のいずれかです。
こうすると、指定した各ディレクトリーのフォントデータベースファイルを更新するコマンドを実行するフックが、
インストール用スクリプトに追加されます。
利便のため、このディレクトリーのパスが相対パスで指定した場合は、
パッケージのインストール用プレフィックスからの相対位置として扱われるようになっています。<filename
role="pkg">fonts/dbz-ttf</filename> から抜粋した例を以下に掲げますので、ご覧ください。</para>

<programlisting>
FONTS_DIRS.ttf= ${PREFIX}/lib/X11/fonts/TTF
</programlisting>

<!-- ================================================================== -->

<sect2 id="fonts-disable">
<title>フォントデータベースの自動更新をしないようにする</title>

<!-- XXX This doesn't really belong here -->

<para>フォントデータベースの自動更新は、管理者が
<filename>PKG_UPDATE_FONTS_DB</filename> 環境変数を <literal>NO</literal>
に設定すれば、無効化することができます。</para>

</sect2>

</sect1>

</chapter>
