<!-- $NetBSD: faq.xml,v 1.47 2010/12/23 23:54:17 abs Exp $ -->
<!-- Based on english version: -->
<!-- NetBSD: faq.xml,v 1.47 2010/12/23 23:54:17 abs Exp   -->

<chapter id="faq"> <?dbhtml filename="faq.html"?>
<title>よくある質問</title>

<para>この節では、pkgsrc の特別な事柄に関する助言、技巧や要領のうち、
前章までに適当な掲載場所がなかったものを掲載しています。
ここでは、pkgsrc 利用者向けの情報と pkgsrc 開発者向けの情報を、どちらも掲載します。</para>

<!-- ================================================================== -->

  <sect1 id="mailing-list-pointers">
    <title>pkgについて話しあうためのメーリングリストはありますか?</title>

    <para>pkgsrc の利用者向けに、以下のようなメーリングリストがあります。</para>

    <itemizedlist>

      <listitem>
	<para><ulink
	    url="http://www.NetBSD.org/mailinglists/index.html#pkgsrc-users">pkgsrc-users</ulink>:
	  pkgsrc 関連の話題のほとんどをプラットフォームにかかわらず扱う汎用目的のメーリングリストです。
	  たとえば、pkgsrc の設定に関する助けの要請、
	  予期しない構築失敗、個々のパッケージの使用、
	  インストールした pkgsrc の更新、pkgsrc リリース枝に関する質問などです。
	  ここには、一般的なお知らせや、pkgsrc 利用者コミュニティーに影響のある変更
	  (たとえば、大規模な基盤の変更、新機能、パッケージ削除など)
	  の提案も投稿されることがあります。</para>
      </listitem>

      <listitem>
	<para><ulink
	    url="http://www.NetBSD.org/mailinglists/index.html#pkgsrc-bulk">pkgsrc-bulk</ulink>:
	  pkgsrc のバルクビルドの結果が送付され、
	  その議論がおこなわれるメーリングリストです。</para>
      </listitem>

      <listitem>
	<para><ulink
	    url="http://www.NetBSD.org/mailinglists/index.html#pkgsrc-changes">pkgsrc-changes</ulink>:
	  pkgsrc のすべての変更についての
	  commit メッセージが流れるメーリングリストです。
	  毎日、 24 時間分のすべての commit メッセージをまとめて送る、
	  ダイジェスト版もあります。</para>
      </listitem>

    </itemizedlist>

<para>参加するためには以下のようにして下さい。</para>

<programlisting>
&cprompt; echo subscribe <replaceable>listname</replaceable> | mail majordomo@NetBSD.org
</programlisting>

<para>以上の各メーリングリストのアーカイブは
<ulink url="http://mail-index.NetBSD.org/"/> から辿れます。</para>

</sect1>

<!-- ================================================================== -->

<sect1 id="pkgviews-docs">
<title>pkgviews のドキュメンテーションはどこにあるか?</title>

<para>pkgviews は buildlink に密接に統合されています。
pkgviews の利用者向けの手引きは
<filename>pkgsrc/mk/buildlink3/PKGVIEWS_UG</filename> にあります。</para>

</sect1>

<!-- ================================================================== -->

<sect1 id="faq-pkgtools">
<title>パッケージ管理用ユーティリティー (pkgtools)</title>

<para><filename>pkgsrc/pkgtools</filename> ディレクトリー以下には、
pkgsrc の利用者および開発者それぞれにとって便利なユーティリティーがいくつもあります。
この節の目的は、このユーティリティーの存在と、
どんな場合に有用かを知っていただくことだけであり、
各パッケージの附属ドキュメントを引き写すことではありません。</para>

<para>pkgsrc が使用するユーティリティー (必要に応じて自動的にインストールされます):</para>

<itemizedlist>

  <listitem>
    <para><filename role="pkg">pkgtools/x11-links</filename>:
      buildlink が使用するシンボリックリンクです。</para>
  </listitem>

</itemizedlist>

<para>OS ツールの拡張 (必要に応じて自動的にインストールされます):</para>

<itemizedlist>

  <listitem>
    <para><filename role="pkg">pkgtools/digest</filename>:
      各種チェックサム(SHA1 など) を計算します。</para>
  </listitem>

  <listitem>
    <para><filename role="pkg">pkgtools/libnbcompat</filename>:
      pkgsrc ツール用の互換ライブラリーです。</para>
  </listitem>

  <listitem>
    <para><filename role="pkg">pkgtools/mtree</filename>: BSD 以外のシステムにはネイティブの
      mtree がないため、これがインストールされます。</para>
  </listitem>

  <listitem>
    <para><filename role="pkg">pkgtools/pkg_install</filename>:
      <filename>/usr/sbin/pkg_install</filename>
      を最新版に置き換えます。または、
      pkg_install のないオペレーティングシステム用です。</para>
  </listitem>

</itemizedlist>

<para>pkgsrc が使用するユーティリティー (自動ではインストールされません):</para>

<itemizedlist>

  <listitem>
    <para><filename role="pkg">pkgtools/pkg_tarup</filename>:
      インストールされているパッケージをもとに、
      バイナリーパッケージを作成します。 <command>make replace</command>
      が古いパッケージを保存するのに使います。</para>
  </listitem>

  <listitem>
    <para><filename role="pkg">pkgtools/dfdisk</filename>:
      distfile を複数の場所から
      fetch できる機能を pkgsrc に追加します。現在のところ、
      以下の方法に対応しています: 複数の CD-ROM および FTP/HTTP
      のネットワーク接続。</para>
  </listitem>

  <listitem>
    <para><filename role="pkg">pkgtools/xpkgwedge</filename>: X11 パッケージの場所を変えます
      (標準で有効となります)。</para>
  </listitem>

  <listitem>
    <para><filename role="pkg">devel/cpuflags</filename>: お使いの CPU とコンパイラー用にコードを最適化するための
      コンパイラーのフラグを考えてくれます。 </para>
  </listitem>

</itemizedlist>

<para>インストールしたパッケージの追跡や最新への追従用などのユーティリティー:</para>

<itemizedlist>

  <listitem>
    <para><filename role="pkg">pkgtools/pkg_chk</filename>: インストールされているパッケージのバージョンが
      pkgsrc の最新バージョンと異なるものを報告します。</para>
  </listitem>

  <listitem>
    <para><filename role="pkg">pkgtools/pkgdep</filename>: パッケージ更新計画の策定を支援するため、
      パッケージの依存関係のグラフを作成します。</para>
  </listitem>

  <listitem>
    <para><filename role="pkg">pkgtools/pkgdepgraph</filename>: <filename
        role="pkg">pkgtools/pkgdep</filename> の出力をもとに
      (graphviz を使って) 図表を作成します。</para>
  </listitem>

  <listitem>
    <para><filename role="pkg">pkgtools/pkglint</filename>: pkglint(1) プログラムは
      pkgsrc の個々のパッケージに誤りがないか検査します。</para>
  </listitem>

  <listitem>
    <para><filename role="pkg">pkgtools/lintpkgsrc</filename>: lintpkgsrc(1) プログラムは
      pkgsrc システム全体に対して各種の検査をおこないます。</para>
  </listitem>

  <listitem>
    <para><filename role="pkg">pkgtools/pkgsurvey</filename>:
      インストール済みのパッケージを報告します。</para>
  </listitem>

</itemizedlist>

<para>個々のパッケージの保守や作成をする人のためのユーティリティー:</para>

<itemizedlist>

  <listitem>
    <para><filename role="pkg">pkgtools/pkgdiff</filename>: パッケージ用のパッチの作成や保守を自動化します
      (pkgdiff, pkgvi, mkpatches, ...
      が含まれます)。</para>
  </listitem>

  <listitem>
    <para><filename role="pkg">pkgtools/rpm2pkg</filename>,
      <filename role="pkg">pkgtools/url2pkg</filename>: pkgsrc
      への変換の補助ツールです。</para>
  </listitem>

  <listitem>
    <para><filename role="pkg">pkgtools/gensolpkg</filename>: pkgsrc を Solaris
      パッケージに変換します。</para>
  </listitem>

</itemizedlist>

<para>pkgsrc を保守する人のためのユーティリティー (あるいは、もっと地味な pkg
ユーティリティー)</para>

<itemizedlist>

  <listitem>
    <para><filename role="pkg">pkgtools/pkg_comp</filename>: chroot
      領域でパッケージを構築します。</para>
  </listitem>

  <listitem>
    <para><filename role="pkg">pkgtools/libkver</filename>: chroot 環境でのクロス構築用に、
      カーネルのバージョンを誤魔化します。</para>
  </listitem>

</itemizedlist>

</sect1>

<!-- ================================================================== -->

<sect1 id="non-root-pkgsrc">
<title>pkgsrc を root 以外で使う方法</title>

<para>pkgsrc を root 以外のユーザーで使いたい場合は、いくつかの変数を設定すれば、
そのような環境で pkgsrc が動くようにすることができます。
最低限、<varname>UNPRIVILEGED</varname> を <quote>yes</quote>
に設定することが必要です。こうすると非特権モードに切り替わり、
関連のある複数の変数が設定されて、
root 以外のユーザーがパッケージをインストールできるようになります。</para>

<para>標準状態の非特権モードでは不十分な場合は、
他の変数を調節するとよいでしょう。たとえば、
ユーザーやグループの自動検出により正しくない (あるいは使いたくない)
値が検出される場合は、それぞれ、
<varname>UNPRIVILEGED_USER</varname> や
<varname>UNPRIVILEGED_GROUP</varname> を設定すれば変更することができます。</para>

<para>なお、ブートストラップについては、<command>bootstrap</command>
スクリプトに <quote>--ignore-user-check</quote> フラグを与えると、
標準で使われるインストール先が
<filename>~/pkg</filename> 以下の複数のディレクトリーになるため、
非 root 用の構成にしやすくなることを覚えておいてください。このディレクトリーは、
他のディレクトリーの配置が細かく調節可能であるのと同様に、
スクリプトに <quote>--prefix</quote>
フラグを与えて上書きすることができます。</para>

</sect1>

<!-- ================================================================== -->

<sect1 id="resume-transfers">
<title>distfile 取得時に、転送を再開する方法は?</title>

<para>標準では、pkgsrc の転送再開機能は有効になっていませんが、
&mk.conf; にオプション
<varname>PKG_RESUME_TRANSFERS=YES</varname> を追加すれば、
この機能を有効にすることができます。こうすると、fetch している最中に、
不完全な distfile があった場合、pkgsrc はそのファイルの残りの部分を取得しようとします。</para>

<para>また、
<varname>FETCH_CMD</varname> 変数を変更すれば、
標準である &man.ftp.1; 以外のプログラムを使うこともできます。
この変数値を ftp, fetch, wget または curl にすると、指定したプログラムを使うことができます。
このほか、変数値を manual にすると、取得をしないようにすることができます。
変数値を custom にすると、システム標準の設定を使わないようになり、
取得プログラムに対する依存性も追わないようになります。
この場合は、<varname>FETCH_CMD</varname>, <varname>FETCH_BEFORE_ARGS</varname>,
<varname>FETCH_RESUME_ARGS</varname>, <varname>FETCH_OUTPUT_ARGS</varname>,
<varname>FETCH_AFTER_ARGS</varname> の各変数を設定する必要があります。</para>

<para>たとえば、
ダウンロードに <filename>wget</filename>
を使いたい場合は、以下のような設定が必要です。</para>

<programlisting>
FETCH_USING=	wget
</programlisting>

</sect1>

<!-- ================================================================== -->

<sect1 id="x.org-from-pkgsrc">
<title>pkgsrc の modular X.org をインストールあるいは使用する方法は?</title>

<para>システム附属の X11 (<filename>/usr/X11R6</filename>,
<filename>/usr/openwin</filename>, ...) ではなく pkgsrc の
modular X.org を使いたい場合は、&mk.conf;
に以下の行を追加する必要があります。</para>

<programlisting>
X11_TYPE=modular
</programlisting>

<note><para>DragonFly オペレーティングシステムは、標準で、
この pkgsrc の modular X.org の X11 の実装を使います。</para></note>

</sect1>

<!-- ================================================================== -->

<sect1 id="fetch-behind-firewall">
<title>防火壁の内側からファイルを取得する方法</title>

<para>もし、あなたが防火壁の内側にいて、インターネットのホストに直接接続できない
(つまりNATを使っていない)場合、適切なプロキシーホストを指定することができます。
これはURL形式の環境変数で指定します。例えば、Amdahlドメインにおいては、
<quote>orpheus.amdahl.com</quote> というマシンは防火壁のひとつで、プロキシーポート番号として、
80番のポートを使用します。この場合、proxy環境変数は以下のようになります。</para>

<programlisting>
ftp_proxy=ftp://orpheus.amdahl.com:80/
http_proxy=http://orpheus.amdahl.com:80/
</programlisting>

</sect1>

<!-- ================================================================== -->

<sect1 id="passive-ftp">
<title>どうすれば<command>make fetch</command>でpassive FTPを使用することができますか?</title>

<para>distfileの取得にどのユーティリティーを使っているかによります。
<filename>bsd.pkg.mk</filename>は、以下のリストのなかで利用可能なコマンドのうち、
最初のものを<varname>FETCH_CMD</varname>に割り当てます:</para>

<itemizedlist>
  <listitem>
    <para><filename>${LOCALBASE}/bin/ftp</filename></para>
  </listitem>
  <listitem>
    <para><filename>/usr/bin/ftp</filename></para>
  </listitem>
</itemizedlist>

<para>NetBSD のデフォルトのインストールでは、<filename>/usr/bin/ftp</filename>となり、これは自動的に、
最初はパッシブ接続を試みます。そして、サーバーがパッシブ接続を拒否した場合
は、アクティブ接続に切り替わります。これ以外のツールの場合は、
&mk.conf;に以下の設定を追加してください。
<varname>PASSIVE_FETCH=1</varname></para>

<para>これを設定すると、
<filename>/usr/bin/ftp</filename>
はアクティブ転送への切り替えをおこなわなくなります。</para>

</sect1>

<!-- ================================================================== -->

<sect1 id="fetching-all-distfiles">
<title>一度にすべてのdistfileを取得する方法</title>

<para><command>make
fetch</command>を実行できない職場や大学において、
一回のバッチ処理で、すべてのdistfileをダウンロードしたいと思うことがあるかもしれません。<ulink
url="ftp://ftp.NetBSD.org/pub/NetBSD/packages/distfiles/">ftp.NetBSD.org</ulink>
に distfile が置かれていますが、
このディレクトリーをまるごとダウンロードするのは不適切です。</para>

<para>現時点では、<command>make fetch-list</command>を
<filename>/usr/pkgsrc</filename>またはそのサブディレクトリーで実行し、
その結果のリストを職場や学校のマシンに持ってきて、使用してくださいとしかいえません。
NetBSD と互換な &man.ftp.1; (tnftpなど)が使えない場合は、
URLを指定して取得ができるコマンドを
<varname>FETCH_CMD</varname>に指定することを忘れないでください:</para>

<para>自宅で:</para>

<screen>&cprompt; <userinput>cd /usr/pkgsrc</userinput>
&cprompt; <userinput>make fetch-list FETCH_CMD=wget DISTDIR=/tmp/distfiles >/tmp/fetch.sh</userinput>
&cprompt; <userinput>scp /tmp/fetch.sh work:/tmp</userinput></screen>

<para>職場で:</para>

<screen>&cprompt; <userinput>sh /tmp/fetch.sh</userinput></screen>

<para>実行後、 <filename>/tmp/distfiles</filename> を
tar で固めて自宅に持って帰ります。</para>

<para>NetBSD で動いているマシンがあって、<emphasis>すべての</emphasis>distfile
(そのマシンのアーキテクチャー向けではないものも含む)を取得したい場合は、
上述の<command>make fetch-list</command>の方法を使うか、
以下のようにしてdistfileを直接取得することができます。</para>

<screen>&cprompt; <userinput>make mirror-distfiles</userinput></screen>

<para><varname>NO_{SRC,BIN}_ON_{FTP,CDROM}</varname>
も無視したい場合は、
以下のようにしてすべてのものを取得することができます。</para>

<screen>&cprompt; <userinput>make fetch NO_SKIP=yes</userinput></screen>

</sect1>

<!-- ================================================================== -->

<sect1 id="tmac.andoc-missing">
<title><quote>Don't know how to make
/usr/share/tmac/tmac.andoc</quote> ってどういうこと?</title>

<para><filename role="pkg">pkgtools/pkg_install</filename>パッケージのコンパイル時に、makeが
<filename>/usr/share/tmac/tmac.andoc</filename>
の作り方がわからないというエラーを出します。これは、そのマシンに
NetBSD の基本配布物の<quote>text</quote>セット(nroffなど)
がインストールされていないことを意味しています。マニュアルページの整形ができるようにするため、
<quote>text</quote>セットをインストールしてください。</para>

<para>この<filename
  role="pkg">pkgtools/pkg_install</filename>パッケージの事例は、
環境変数か&mk.conf;のどちらかで
<varname>NOMAN=YES</varname>を設定して回避することもできます。</para>

</sect1>

<!-- ================================================================== -->

<sect1 id="bsd.own.mk-missing">
<title><quote>Could not find bsd.own.mk</quote> ってどういうこと?</title>

<para>NetBSD のインストール時にコンパイラー一式<filename>comp.tgz</filename>
をインストールしなかったからです。<filename>comp.tgz</filename>を入手し、
<filename>/</filename>で展開してインストールしてください:</para>

<screen>&rprompt; <userinput>cd /</userinput>
&rprompt; <userinput>tar --unlink -zxvpf .../comp.tgz</userinput></screen>

<para><filename>comp.tgz</filename>は NetBSD のどのリリースにも含まれていますので、
あなたがインストールしたリリース (<command>uname
-r</command>で調べられます) に合ったものを入手してください。</para>

</sect1>

<!-- ================================================================== -->

<sect1 id="using-sudo-with-pkgsrc">
<title>pkgsrcで'sudo'を使う</title>

<para>パッケージのインストールをroot以外のユーザーで実行し、
root権限が必要なところではpkgsrcの &man.su.1; 機能を使う場合、
必要なパッケージをインストールするたびに
rootのパスワードを打つのは面倒かもしれません。これを避けるために、
パスワードを一定時間保持してくれるsudoパッケージを使うことができます。
sudoを使うには、sudoを(バイナリーパッケージ、または<filename role="pkg">security/sudo</filename>のいずれかから)
インストールしてから、&mk.conf; の、
<varname>LOCALBASE</varname> 変数の定義より
<emphasis>後</emphasis>の部分に、以下の内容を書いておきます。</para>

<programlisting>
.if exists(${LOCALBASE}/bin/sudo)
SU_CMD=        ${LOCALBASE}/bin/sudo /bin/sh -c
.endif
</programlisting>

</sect1>

<!-- ================================================================== -->

<sect1 id="faq.conf">
<title>設定ファイルの置き場所を変更する方法は?</title>

<para>システム管理者は、設定ファイルがインストールされる場所を選ぶことができます。
標準の設定では、設定ファイルはすべて <filename>${PREFIX}/etc</filename>
またはそのサブディレクトリー以下にインストールされます。
設定ファイルのインストール先は、あなたの都合 (たとえば、
NFS でエクスポートされた読み込み専用の <varname>PREFIX</varname>
で、パッケージの設定をマシン毎にする必要がある場合)
にあわせて調整することができます。</para>

<para>標準の設定を変えるために、(&mk.conf;
で) <varname>PKG_SYSCONFBASE</varname> 変数を、
好みの設定用ディレクトリーを指すように変えることができます。
一般的な設定例としては、<filename>/etc</filename> や
<filename>/etc/pkg</filename> などがあります。</para>

<para>さらに、<varname>PKG_SYSCONFDIR.${PKG_SYSCONFVAR}</varname>
変数を設定することで、パッケージ毎に設定用ディレクトリーを変更することができます。
<varname>PKG_SYSCONFVAR</varname> の値は、通常は変更対象のパッケージ名に合わせたもの、
つまり、<varname>PKGBASE</varname> の値にします。</para>

<para>なお、この設定を変更した後は、影響を受けるパッケージをすべて再構築し、
再インストールする必要があります。</para>

</sect1>

<!-- ================================================================== -->

<sect1 id="audit-packages">
<title>自動セキュリティーチェック</title>

<para>サードパーティーのソフトウェアにはしばしばバグがあること、
そして、バグのなかにはマシンをアタッカーの攻撃に対して脆弱な状態にするものもあることに、
どうか注意してください。そのような攻撃にさらされることを減らすために、NetBSD
パッケージチームでは、pkgsrc化されたことのあるパッケージに関する既知の攻撃のデータベースを保守しています。
このデータベースを自動的にダウンロードして、
システムにインストールされている全パッケージのセキュリティー監査をおこなうことができます。
これをおこなうには、以下の二つのツール (<filename role="pkg">pkgtools/pkg_install</filename>
パッケージの一部としてインストールされます) を使います。</para>

<orderedlist>

  <listitem>
    <para><command>pkg_admin fetch-pkg-vulnerabilities</command>: セキュリティー脆弱性情報のリストの
    ダウンロードを簡単にできるようにするものです。この脆弱性情報のリストは、
    NetBSD セキュリティーオフィサーと NetBSD パッケージチームが最新の状態に保っており、
    NetBSD ftpサーバーで配布されています。</para>

    <para><ulink
    url="ftp://ftp.NetBSD.org/pub/NetBSD/packages/distfiles/pkg-vulnerabilities"/></para>
  </listitem>

  <listitem>
    <para><command>pkg_admin audit</command>: マシンの監査を簡単にできるようにするもので、
    既知の各脆弱性の確認をします。
    脆弱性のあるパッケージがインストールされていた場合、そのことを標準出力に出力します。
    この出力には、脆弱性の種類の説明と詳細情報のURLが含まれます。</para>
  </listitem>

</orderedlist>

<para>これらのツールを使うよう強くおすすめします。
<quote>pkg_install</quote> をインストールした後に、
パッケージのメッセージを読んでください。このメッセージは <userinput>pkg_info -D
pkg_install</userinput> を実行すれば表示できます。</para>

<para>このパッケージをインストールすると、pkgsrc
は各パッケージの構築前にこのパッケージを使ってセキュリティーのチェックをするようになります。
このチェックを制御する方法については<xref
linkend="variables-affecting-build"/>をご覧ください。</para>

</sect1>

<sect1 id="ufaq-cflags">
<title><varname>CFLAGS</varname> を無視するパッケージがあるのはなぜ?</title>

	<para>&mk.conf; で
	<varname>CFLAGS</varname> 変数に独自の設定をした場合、
	設定されたフラグは環境変数によって <filename>./configure</filename>
	スクリプトに渡されてから &man.make.1; に渡されます。
	パッケージの作者によっては、
	環境変数で渡された <varname>CFLAGS</varname> を、
	パッケージの <filename>Makefile</filename> で上書きして、
	無視するようにしていることがあります。</para>

	<para>現在のところ、この問題の解決策はありません。
	独自の <varname>CFLAGS</varname> を使うことがどうしても必要な場合は、
	パッケージのディレクトリーで <command>make patch</command> を実行してから、
	<filename>Makefile</filename> と
	<filename>Makefile.in</filename> をすべて調べて、
	<varname>CFLAGS</varname> を明示的に定義していないかを調べてください。
	ふつうは、その部分を削除することができます。
	ただし、一部の<quote>小賢しい</quote>プログラマーは、
	彼らが選んだ特定の <varname>CFLAGS</varname>
	の組合せのもとでしか動作しないような、
	まずいコードを書いていることに注意してください。</para>

</sect1>

<sect1 id="ufaq-fail">
<title>パッケージが構築できません。どうすればいい?</title>

	<procedure>

	<step><para>使っている pkgsrc ツリーの一貫性を確認します。
	この問題の原因としてありがちなのは、
	時間などを節約するために pkgsrc の一部だけを更新していたというものです。
	pkgsrc は小さなシステムの寄せ集めではなく、ひとつの大きなシステムですので、
	pkgsrc ツリー全体を更新しておかないと動かなくなるような変更が時々おこなわれます。</para></step>

	<step><para>CVS の衝突が起きていないことを確認します。
	pkgsrc のファイルすべてについて、
	<quote>&lt;&lt;&lt;&lt;&lt;&lt;</quote> や
	<quote>&gt;&gt;&gt;&gt;&gt;&gt;</quote> という文字列を検索します。</para></step>

	<step><para>古いパッケージが展開されていないことを確認します。
	これを確認するには、<command>make clean clean-depends</command>
	を実行します。</para></step>

	<step><para>以上の確認をおこなってもなお問題がある場合は、
	<literal>pkgsrc-users</literal> メーリングリストにメールを出してください。</para></step>

	</procedure>
</sect1>

<sect1 id="faq.rcs-conflicts">
<title><quote>Makefile appears to contain unresolved cvs/rcs/??? merge conflicts</quote> ってどういうこと?</title>

<para>あなたが pkgsrc のファイルに変更を加えており、かつ、
他の誰かが CVS リポジトリーにおいて同じファイルに変更を加えています。
この変更がいずれもファイル内の同じ箇所に対するものであるため、
あなたが pkgsrc を更新したときに、変更が衝突したという印を
<literal>cvs</literal> コマンドがファイルにつけたのです。
この印があるために、ファイルが妥当な
<filename>Makefile</filename> ではなくなっています。</para>

<para>ファイルの内容を見てください。あなたが独自に加えた変更がもはや不要であれば、
ファイルを削除してからそのディレクトリーで <command>cvs -q update
-dP</command> を実行し、最新版のファイルをダウンロードすることができます。</para>

</sect1>
</chapter>
