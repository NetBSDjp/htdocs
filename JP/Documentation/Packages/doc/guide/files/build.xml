<!-- $NetBSD: build.xml,v 1.24 2006/02/17 20:38:17 rillig Exp $ -->
<!-- Based on english version: -->
<!-- NetBSD: build.xml,v 1.24 2006/02/17 20:38:17 rillig Exp   -->

<chapter id="build">
<title>構築の手順</title>

<sect1 id="build.intro">
<title>序</title>

<para>本章では、パッケージがどのように構築されるかについて、詳しく説明します。
パッケージの構築は、複数の<emphasis>相 (phase)</emphasis> (たとえば、<varname>fetch</varname>,
<varname>build</varname>, <varname>install</varname>) にわかれており、
そのすべてを以下の各節で説明します。それぞれの段階は、<varname>pre-</varname>,
<varname>do-</varname>, <varname>post-</varname>
のいずれかが相名の前についた、いわゆる<emphasis>期 (stage)</emphasis>
にわかれます。(たとえば、
<varname>pre-configure</varname>, <varname>post-build</varname> などです。)
実際に何かがおこなわれるのは、ほとんどが <varname>do-*</varname> 期においてです。</para>

<para>プログラムを構築するための基本的な手順は常に同じです。最初に、プログラムの
ソースファイル(<emphasis>distfile</emphasis>)をローカルシステムへ持ってきて展開します。
コンパイルするための pkgsrc 独自のパッチを適用した後に、ソフトウェアを設定
し、構築(通常、コンパイルすることによって)します。最後に作成されたバイナリー
等を、システムにインストールします。</para>

</sect1>

  <sect1 id="build.prefix">
    <title>プログラムの場所</title>

    <para>次のセクションで&os;パッケージシステムによって実行される手順の概略を述
      べる前に、プログラムがインストールされる場所、その場所に影響をおよぼす変数
      について簡単に記述します。</para>

    <para>自動変数<varname>PREFIX</varname>は、最終的にプログラムのすべてのファイルがインストールされる
      場所をしめします。通常、<varname>LOCALBASE</varname> (<filename>/usr/pkg</filename>)、または<quote>cross</quote>カテゴリーの
      パッケージのための<varname>CROSSBASE</varname>と同じ場所になっています。
      <varname>PREFIX</varname>の値は、プログラムのソース中でこれらのファイルが符号化されるさまざ
      まな場所に使用されるべきです。
      詳細に関しては、<xref linkend="components.patches"/>および<xref
      linkend="fixes.libtool"/>を参照して下さい。</para>

    <para>これらの変数のどれかを選択し使用する場合には、
      以下のルールに従ってください。</para>

    <itemizedlist>
      <listitem>
	<para><varname>PREFIX</varname>は常に現在のパッケージがインストールされる場所を指します。パッ
	  ケージ自身のインストール先のパスを参照する時に、<quote>${PREFIX}</quote>を使用してくだ
	  さい。</para>
      </listitem>

      <listitem>
	<para><varname>LOCALBASE</varname>は、すべての非X11パッケージがインストールされる場所です。他
	  の非X11パッケージによってインストールされたインクルードファイルやライブ
	  ラリーの場所をさがすためのコンパイラーの-Iや-Lオプションを指定する場合に、
	  <quote>${LOCALBASE}</quote>を使用してください。</para>
      </listitem>

      <listitem>
	<para><varname>X11BASE</varname>は、実際に(xsrcなどに由来する)X11ディストリビューションがイン
	  ストールされる場所です。
	  <emphasis>通常の</emphasis>X11のインクルードファイル(パッケージとして
	  インストールされていない)をさがす場合、<quote>${X11BASE}</quote>を使用してください。</para>
      </listitem>

      <listitem>
	<para>X11 ベースのパッケージは特別です。インストールされる場所は、
	  <varname>X11BASE</varname> と <varname>LOCALBASE</varname> のどちらに依存することもありえます。</para>

	<para>通常、X11 のパッケージは、できるかぎり <varname>LOCALBASE</varname>
	  にインストールするものです。X11 のパッケージでは、X11 が必要なことを要求し、
	  適切な編集フラグを持つようにするために、
	  <filename>../../mk/x11.buildlink3.mk</filename>
	  をインクルードする必要があります。</para>

	<para>しかし、<varname>LOCALBASE</varname> 以下にはインストールできないパッケージもあります。
	  app-defaults ファイルが附属するようなパッケージが該当します。
	  このようなパッケージは例外であり、<varname>X11BASE</varname>
	  以下にインストールする必要があります。そうするためには、
	  パッケージ側で <varname>USE_X11BASE</varname> または <varname>USE_IMAKE</varname>
	  のいずれかを設定します。</para>

	<para>註:
	  <filename>Makefile</filename> で <varname>USE_IMAKE</varname> や <varname>USE_X11BASE</varname>
	  を定義したパッケージによってインストールされたインクルードファイルやライブラリーをさがす場合、
	  <filename>${X11BASE}</filename> と
	  <filename>${LOCALBASE}</filename> を<emphasis>両方</emphasis>調べる必要があります。
	  X11 パッケージをすべて強制的に <varname>LOCALBASE</varname> にインストールさせるために、
	  <filename role="pkg">pkgtools/xpkgwedge</filename> パッケージが標準で有効になっています。</para>
      </listitem>

      <listitem>
	<para>X11パッケージのインストール場所を参照する用途には、<varname>X11PREFIX</varname>を使って
	  ください。<varname>X11PREFIX</varname>は、xpkgwedgeがインストールされていない場合は
	  <varname>X11BASE</varname>となり、xpkgwedgeがインストールされている場合は<varname>LOCALBASE</varname>と
	  なります。</para>
      </listitem>

      <listitem>
	<para>xpkgwedgeがインストールされている場合、パッケージによってインストール先
	  が<varname>X11BASE</varname>になっていたり<varname>LOCALBASE</varname>になっていたりすることがあります。インス
	  トールされているパッケージのprefixを決めるために、<varname>EVAL_PREFIX</varname>定義を使う
	  ことができます。この定義に<quote>DIRNAME=&lt;package&gt;</quote>の形式の組を書くと、&man.make.1;変
	  数<varname>DIRNAME</varname>が、インストールされているパッケージpackage &lt;package&gt;のprefixに設定され
	  ます。そのパッケージがインストールされていない場合は<quote>${X11PREFIX}</quote>に設定さ
	  れます。</para>

	<para>例を使って説明するのが一番いいでしょう。</para>

	<para>以下は、
	  <filename>pkgsrc/wm/scwm/Makefile</filename>からの抜粋です。</para>

<programlisting>
    EVAL_PREFIX+=           GTKDIR=gtk+
    CONFIGURE_ARGS+=        --with-guile-prefix=${LOCALBASE:Q}
    CONFIGURE_ARGS+=        --with-gtk-prefix=${GTKDIR:Q}
    CONFIGURE_ARGS+=        --enable-multibyte
</programlisting>

	<para><varname>EVAL_PREFIX</varname>を使って評価するパッケージに対して、以下のような定義を使って
	  デフォルトを定義することができます。</para>

<programlisting>
    GTKDIR_DEFAULT= ${LOCALBASE}
</programlisting>

	<para>ここで<varname>GTKDIR</varname>は、
	  <varname>EVAL_PREFIX</varname>
	  での最初の定義の組に対応します。</para>
      </listitem>

      <listitem>
        <para>パッケージは <filename>${PREFIX}</filename> 以下に、
          &man.hier.7; に準じてファイルをインストールするようにします。
          ただしマニュアルページは例外で、<filename>${PREFIX}/share/man</filename>
          ではなく <filename>${PREFIX}/man</filename> にインストールします。</para>
      </listitem>
    </itemizedlist>
  </sect1>

<sect1 id="build.builddirs">
<title>構築の過程で使われるディレクトリー</title>

<para>パッケージの構築時には、ソースファイル、一時ファイル、
pkgsrc 内部ファイルなどを置いておくために、多数のディレクトリーが使われます。
そのようなディレクトリーについて説明します。</para>

<para>ディレクトリーを指す変数のなかには、相対パス名を値に持つものがあります。
このような相対パス名の基点となるディレクトリーは、おもに二つあります。
一つは <varname>PKGSRCDIR/PKGPATH</varname> で、pkgsrc 特有のディレクトリー用です。
もう一つは  <varname>WRKSRC</varname> で、パッケージそのものの内部にあるディレクトリー用です。</para>

<variablelist>

<varlistentry><term><varname>PKGSRCDIR</varname></term>
<listitem><para>絶対パス名で、
pkgsrc のルートディレクトリーを指します。
通常は、この変数を使う必要はありません。</para></listitem></varlistentry>

<varlistentry><term><varname>PKGPATH</varname></term>
<listitem><para><varname>PKGSRCDIR</varname>
を基点とした相対パス名で、
当該パッケージを指します。</para></listitem></varlistentry>

<varlistentry><term><varname>WRKDIR</varname></term>
<listitem><para>絶対パス名で、全作業がおこなわれるディレクトリーを指します。
distfile はこのディレクトリーに展開されます。
一般的に、このディレクトリーには、
<emphasis>buildlink</emphasis> や
<emphasis>wrappers</emphasis> など、
pkgsrc の各種基盤が使う一時ディレクトリーも含まれます。</para></listitem></varlistentry>

<varlistentry><term><varname>WRKSRC</varname></term>
<listitem><para>絶対パス名で、distfile が展開されるディレクトリーを指します。
普通は、<varname>WRKDIR</varname> 直下のサブディレクトリーであり、
多くの場合は、このディレクトリーにおける、
唯一の隠されていないディレクトリーエントリーです。この変数は、パッケージの
<filename>Makefile</filename> で変更することができます。</para></listitem></varlistentry>

</variablelist>
</sect1>

<sect1 id="build.running">
<title>相の実行</title>

<para><command>make phase</command> (<emphasis>phase</emphasis> は相の名前) と打てば、
その相を実行することができます。
こうすると、その相のために必要な相をすべて自動的に実行します。
相を指定しない場合は <varname>build</varname> 相になります。つまり、
あるパッケージのディレクトリーで、引数なしで <command>make</command>
を実行すると、パッケージが構築されますが、インストールはされません。</para>

</sect1>

<sect1 id="build.fetch">
<title><emphasis>fetch</emphasis> 相</title>

	  <para>これは、変数<varname>DISTFILES</varname>と<varname>PATCHFILES</varname> (パッケージのMakefileで定義された)で指
	    定されたファイルが、ローカルシステムの<filename>/usr/pkgsrc/distfiles</filename>に存在するか
	    どうかをチェックします。もし、存在しなければ、そのファイルを以下のような
	    コマンドを使って取得しようとします。</para>

<programlisting>
    ${FETCH_CMD} ${FETCH_BEFORE_ARGS} ${site}${file} ${FETCH_AFTER_ARGS}
</programlisting>

	  <para>この${site}には、複数の候補が決まった順序で使われます: 最初に
	    <varname>MASTER_SITE_OVERRIDE</varname>を試み、次に、<varname>SITES_file</varname>が定義されていればそれ
	    を、定義されていなければ、<varname>MASTER_SITES</varname>か<varname>PATCH_SITES</varname>のどちらかを試
	    みます。そして、最後に<varname>MASTER_SITE_BACKUP</varname>の値を試みます。最初のもの以
	    外の順序は、<varname>MASTER_SORT_AWK</varname>か<varname>MASTER_SORT_REGEX</varname>を設定して、ユーザー
	    が入れ換えることができます。</para>

</sect1>

<sect1 id="build.checksum">
<title><emphasis>checksum</emphasis> 相</title>

	  <para>distfileを取得した後に、チェックサムを生成し、distinfoファイルに保存され
	    たチェックサムと比較します。もし、チェックサムが一致しなければ、構築は中
	    断されます。これはパッケージ作成時と同じdistfileが、構築に使用されている
	    こと、つまり、悪意や一次配布サイトでの意図的な差し替えやネットワークの損
	    失によってdistfileが変更されていないことを保証するためです。</para>

</sect1>

<sect1 id="build.extract">
<title><emphasis>extract</emphasis> 相</title>

	<para>distfileがローカルシステム上に存在している場合、
	通常、それらは圧縮アーカイブフォーマットで保存されているので、
	展開する必要があります。</para>

	<para>標準では、<varname>DISTFILES</varname> はすべて展開されます。
	一部だけを展開する必要がある場合は、
	<varname>EXTRACT_ONLY</varname> 変数を、
	展開する必要のあるファイルを並べたリストに設定することができます。</para>

	<para>通常、ファイルの展開は <filename>mk/scripts/extract</filename>
	という小さなプログラムを使っておこなわれます。このプログラムは、
	各種アーカイブ形式の展開方法を知っているので、
	何も変更する必要はないでしょう。それでも変更が必要な場合は、
	以下の変数を使うとよいでしょう。</para>

	<variablelist>

	<varlistentry><term><varname>EXTRACT_OPTS_{BIN,LHA,PAX,RAR,TAR,ZIP,ZOO}</varname></term>
	<listitem><para>この各変数を使って、展開用のコマンドのオプションを、
	標準のもの (<filename>mk/scripts/extract</filename>
	で定義されています) から上書きします。</para></listitem></varlistentry>

	<varlistentry><term><varname>EXTRACT_USING</varname></term>
	<listitem><para>この変数は、tar アーカイブ展開用のコマンドを設定するもので、
	<literal>pax</literal>, <literal>tar</literal> または、
	コマンドの絶対パス名に設定することができます。</para></listitem></varlistentry>

	</variablelist>

	<para>必要なことが <filename>extract</filename>
	プログラムではできない場合は、ファイル展開用のコマンドを保持する
	<varname>EXTRACT_CMD</varname> 変数を上書きすることもできます。
	この変数で指定された展開用コマンドは、
	<filename>${WRKSRC}</filename> ディレクトリー内で実行されます。
	このコマンドの実行中は、シェル変数 <varname>extract_file</varname>
	に、展開中のアーカイブファイルの絶対パス名が保持されます。</para>

	<para>これでもなお不十分な場合は、パッケージの Makefile で、
	<varname>do-extract</varname>
	ターゲットを上書きすることができます。</para>


</sect1>

<sect1 id="build.patch">
<title><emphasis>patch</emphasis> 相</title>

	  <para>展開の後で、<varname>PATCHFILES</varname>で指定されたパッチとパッケージのpatchesサブディレ
	    クトリーに存在するパッチ、さらに、$LOCALPATCHES/$PKGPATH (たとえば
	    <filename>/usr/local/patches/graphics/png</filename>)に存在するパッチのすべてが適用されます。
	    <filename>.Z</filename>、あるいは<filename>.gz</filename>で終る名前のパッチファイルは、適用する前に伸張されます。
	    <filename>.orig</filename>、<filename>.rej</filename>で終るものは無視されます。&man.patch.1;のためのいくつかのオプショ
	    ンは、<varname>PATCH_DIST_ARGS</varname>で指定する事ができます。
	    詳細に関しては<xref linkend="components.patches"/>を参照して下さい。</para>

	  <para>デフォルトでは、パッチに曖昧さがあった場合には&man.patch.1;が異常終了するような
	    特別な引数が渡されます。パッチを修正(再作成)して、きれいに適用できるよう
	    にしてください。そうする理由は、曖昧さがあるパッチが一見うまく適用できても、実は誤った場
	    所に適用されていて、深刻な問題を起こす可能性があるからです。</para>

</sect1>

<sect1 id="build.tools">
<title><emphasis>tools</emphasis> 相</title>

<para>この相については
<xref linkend="tools"/> で説明しています。
</para>

</sect1>

<sect1 id="build.wrapper">
<title><emphasis>wrapper</emphasis> 相</title>

<para>[TODO]</para>

</sect1>

<sect1 id="build.configure">
<title><emphasis>configure</emphasis> 相</title>

<para>ほとんどのソフトウェアは、実行対象のプラットフォームで利用できるヘッダーファイル、
システムコール、およびライブラリールーチンについての情報を必要とします。
この情報の判断はコンフィギュレーションとして知られているプロセスであり、
通常、自動化されています。
大抵の場合、スクリプトが配布物と一緒に提供され、
それを実行することによりヘッダーファイルやMakefile等が生成されます。</para>

<para>パッケージが configure スクリプトを含んでいる場合、<varname>HAS_CONFIGURE</varname>
を <quote>yes</quote> に設定することにより、実行することができます。
もし、その configure スクリプトが GNU の autoconf スクリプトである場合は、
かわりに、<varname>GNU_CONFIGURE</varname> を <quote>yes</quote> に指定してください。
大雑把にいうと、<emphasis>configure</emphasis> 相では以下のようなことをしています。</para>

<programlisting>
    .for d in ${CONFIGURE_DIRS}
            cd ${WRKSRC} && cd ${d} && env ${CONFIGURE_ENV} \
                ${CONFIGURE_SCRIPT} ${CONFIGURE_ARGS}
    .endfor
</programlisting>

<para><varname>CONFIGURE_DIRS</varname> (標準では <quote>.</quote>) は、
<varname>WRKSRC</varname> からの相対位置でのパス名を並べたリストです。
この各ディレクトリー内で、環境変数 <varname>CONFIGURE_ENV</varname> および
引数 <varname>CONFIGURE_ARGS</varname> を使って
configure スクリプトが実行されます。
<varname>CONFIGURE_ENV</varname>, <varname>CONFIGURE_SCRIPT</varname>
(標準では <quote>./configure</quote>),
<varname>CONFIGURE_ARGS</varname>
の各変数は、いずれもパッケージ側で変更することができます。</para>

<para>もし、プログラムがコンフィギュレーションのために <filename>Imakefile</filename> を使用するので
あれば、<varname>USE_IMAKE</varname> を <quote>yes</quote> に設定することにより、適切な手順が実行されます。
(もし、<varname>${X11PREFIX}</varname> にインストールされるパッケージが欲しいだけで、xmkmfを実
行したくない場合、かわりに<varname>USE_X11BASE</varname>を使用してください。)</para>

</sect1>

<sect1 id="build.build">
<title><emphasis>build</emphasis> 相</title>

<para>パッケージの構築は、大雑把にいえば、
以下のコードを実行するのと同じことです。</para>

<programlisting>
    .for d in ${BUILD_DIRS}
            cd ${WRKSRC} && cd ${d} && env ${MAKE_ENV} \
                ${MAKE_PROGRAM} ${BUILD_MAKE_FLAGS} \
                    -f ${MAKEFILE} ${BUILD_TARGET}
    .endfor
</programlisting>

<para><varname>BUILD_DIRS</varname> (標準では <quote>.</quote>) は、
<varname>WRKSRC</varname> からの相対位置でのパス名を並べたリストです。
この各ディレクトリー内で、環境変数 <varname>MAKE_ENV</varname> および
引数 <varname>BUILD_MAKE_FLAGS</varname> を使って
<varname>MAKE_PROGRAM</varname> が実行されます。
<varname>MAKE_ENV</varname>, <varname>BUILD_MAKE_FLAGS</varname>,
<varname>MAKEFILE</varname>, <varname>BUILD_TARGET</varname>
の各変数は、いずれもパッケージ側で変更することができます。</para>

<para><varname>MAKE_PROGRAM</varname> の標準の値は、
<varname>USE_TOOLS</varname> に <quote>gmake</quote> が含まれている場合は
<quote>gmake</quote>、含まれていない場合は <quote>make</quote> です。
<varname>MAKEFILE</varname> の標準の値は <quote>Makefile</quote> であり、
<varname>BUILD_TARGET</varname> の標準の値は <quote>all</quote> です。</para>

</sect1>

<sect1 id="build.test">
<title><emphasis>test</emphasis> 相</title>

<para>[TODO]</para>

</sect1>

<sect1 id="build.install">
<title><emphasis>install</emphasis> 相</title>

	<para>構築の段階が完了すると、ユーザーが構築されたプログラムやファイルを使えるようにするため、ソフトウェアをパブリックなディレ
	クトリーにインストールする必要があります。</para>

	<para><emphasis>install</emphasis> 相は、大雑把にいえば、
	以下のコードを実行するのと同じことです。これに加えて、
	このコードの前後では、整合性の検査やパッケージの登録などをするため、
	多くの操作がおこなわれます。</para>

<programlisting>
    .for d in ${INSTALL_DIRS}
            cd ${WRKSRC} && cd ${d} && env ${MAKE_ENV} \
                ${MAKE_PROGRAM} ${INSTALL_MAKE_FLAGS} \
                    -f ${MAKEFILE} ${BUILD_TARGET}
    .endfor
</programlisting>

	<para>各変数の意味は、<emphasis>build</emphasis>
	相のものと同様です。
	<varname>INSTALL_DIRS</varname> は標準では
	<varname>BUILD_DIRS</varname> です。<varname>INSTALL_TARGET</varname>
	は標準では <quote>install</quote> ですが、
	<varname>USE_IMAKE</varname> が定義されている場合は <quote>install.man</quote>
	が追加されます。</para>

	<para><emphasis>install</emphasis> 相では、以下の変数が有用です。
	これらはいずれも &man.install.1; コマンドの変種であり、
	所有者、所有グループ、パーミッションをあらかじめ決めてあるものです。
	<varname>INSTALL</varname> は、オプションを何も指定しない install コマンドです。
	用途別に特化した変種には、以下のものがあります。</para>

	<variablelist>
	<varlistentry><term><varname>INSTALL_PROGRAM_DIR</varname></term>
		<listitem><para>バイナリーを含むディレクトリー</para></listitem></varlistentry>
	<varlistentry><term><varname>INSTALL_SCRIPT_DIR</varname></term>
		<listitem><para>スクリプトを含むディレクトリー</para></listitem></varlistentry>
	<varlistentry><term><varname>INSTALL_LIB_DIR</varname></term>
		<listitem><para>共有静的ライブラリーを含むディレクトリー</para></listitem></varlistentry>
	<varlistentry><term><varname>INSTALL_DATA_DIR</varname></term>
		<listitem><para>データファイルを含むディレクトリー</para></listitem></varlistentry>
	<varlistentry><term><varname>INSTALL_MAN_DIR</varname></term>
		<listitem><para>マニュアルページを含むディレクトリー</para></listitem></varlistentry>
	<varlistentry><term><varname>INSTALL_PROGRAM</varname></term>
		<listitem><para>デバッグ用シンボルを取り除くことのできるバイナリー</para></listitem></varlistentry>
	<varlistentry><term><varname>INSTALL_SCRIPT</varname></term>
		<listitem><para>シンボルを取り除くことのできないバイナリー</para></listitem></varlistentry>
	<varlistentry><term><varname>INSTALL_GAME</varname></term>
		<listitem><para>ゲームのバイナリー</para></listitem></varlistentry>
	<varlistentry><term><varname>INSTALL_LIB</varname></term>
		<listitem><para>共有静的ライブラリー</para></listitem></varlistentry>
	<varlistentry><term><varname>INSTALL_DATA</varname></term>
		<listitem><para>データファイル</para></listitem></varlistentry>
	<varlistentry><term><varname>INSTALL_GAME_DATA</varname></term>
		<listitem><para>ゲーム用のデータファイル</para></listitem></varlistentry>
	<varlistentry><term><varname>INSTALL_MAN</varname></term>
		<listitem><para>マニュアルページ</para></listitem></varlistentry>
	</variablelist>

	<para>これらのほか、以下の変数があります。</para>

	<variablelist>
	<varlistentry><term><varname>INSTALLATION_DIRS</varname></term>
		<listitem><para>pkgsrc が <emphasis>install</emphasis>
		相の最初に作成するディレクトリーを
		<varname>PREFIX</varname> からの相対位置表記で並べたリストです。
		この変数が設定されている場合、
		<varname>NO_MTREE</varname>=<quote>yes</quote>
		が仮定されます。
		つまり、そのパッケージは、ファイルをインストールする前に、
		必要なディレクトリーをすべて自力で作成すると主張していることになります。
		従って、この変数は、パッケージ作者の制御下にある
		<filename>Makefile</filename> においてのみ設定するものです。</para></listitem></varlistentry>
	</variablelist>


</sect1>

<sect1 id="build.package">
<title><emphasis>package</emphasis> 相</title>

<para>[TODO]</para>

</sect1>

  <sect1 id="build.helpful-targets">
    <title>他の役に立つターゲット</title>

    <variablelist>
      <varlistentry>
	<term>pre/post-*</term>

	<listitem>
	  <para>前のセクションで述べた主ターゲットのために、二つの補助ターゲットが存在し
	    ます。これは主ターゲットに<quote>pre-</quote>や<quote>post-</quote>というプレフィックスをつけ
	    たものです。これらのターゲットは、特別な設定やインストール手順のために、
	    主ターゲットが実行される前や後に、パッケージの Makefile から実行されます。例えば、プログラムのコンフィ
	    ギュレーションスクリプトやインストールターゲットが省略された場合に有用で
	    す。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>do-*</term>

	<listitem>
	  <para>主なターゲットがおかしな動作をし、それを修正するための変数が存在しない場
	    合、do-*ターゲットを使用することにより、それらを再定義することができます
	    (do-*ターゲットのかわりに、ターゲット自体を再定義してはいけません。pre-*
	    やpost-*ターゲットが実行されなくなってしまいます)。通常、再定義する必要
	    はありません。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>reinstall</term>

	<listitem>
	  <para>もし、<command>make install</command>実行後に、いくつかのファイルがきちんとインストール
	    されなかった事に気がついた場合、このターゲットを使い、再びインストールす
	    る事ができます。この場合、<quote>インストール済み</quote>フラグは無視されます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>deinstall</term>

	<listitem>
	  <para>このターゲットは、パッケージをアンインストールするためにカレントディレク
	    トリーで&man.pkg.delete.1;を実行します。動作を制御するために、以下の変数を
	    使用することができます。</para>

	  <variablelist>
	    <varlistentry>
	      <term><varname>PKG_VERBOSE</varname></term>

	      <listitem>
		<para>&man.pkg.delete.1;コマンドに「-v」オプションを渡します。</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><varname>DEINSTALLDEPENDS</varname></term>

	      <listitem>
		<para>指定されたパッケージに必要な(依存する)すべてのパッケージを削除します。
		  このターゲットは、指定されたパッケージによってインストールされたパッ
		  ケージを削除するために使用されます。例えば、<command>make deinstall
		    DEINSTALLDEPENDS=1</command>が<filename>pkgsrc/x11/kde</filename>で実行された場合、KDE全体を削除し
		  ます。&man.pkg.delete.1;のコマンドラインに<quote>-R</quote>を指定すると設定されます。</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>update</term>

	<listitem>
	  <para>このターゲットは、現在のパッケージを最新のものに更新します。最初にパッケー
	    ジと、それに依存するすべてのパッケージをアンインストールします。それから
	    最新のバージョンのパッケージをコンパイル、インストールします。これは、現
	    在どのパッケージがインストールされているかを調べ、<command>make deinstall</command>、
	    <command>make install</command>(または、<varname>UPDATE_TARGET</varname>で設定されたターゲット)を続けて実
	    行するのと同じです。</para>

	  <para>以前に実行した<command>make update</command>がさまざまな理由で中断された場合、パッケー
	    ジの更新のために、このターゲットを使用することができます。ただし、この場
	    合は、<command>make clean</command>を実行していない事、あるいは<varname>WRKDIR</varname>の依存パッケー
	    ジのリストを削除していない事を確認してください。そうでなければ、インストー
	    ル済みの依存パッケージを使用し、現在のパッケージを自動更新することができ
	    ません。</para>

	  <para>中断された<command>make update</command>の再開は、パッケージツリーの他の部分が変更され
	    ていない場合に限って動作します。更新対象のパッケージのソースコードが変更
	    されていた場合は、<command>make update</command>の再開はきっと失敗するでしょう。</para>

	  <para><command>make update</command>の動作を変更するために、以下の変数をコマンドライン、また
	    は<filename>/etc/mk.conf</filename>で使うことができます。</para>

	  <variablelist>
	    <varlistentry>
	      <term><varname>UPDATE_TARGET</varname></term>

	      <listitem>
		<para>更新されたパッケージや依存パッケージのために再帰的に使用されるインス
		  トールターゲット。<command>make update</command>用のデフォルトは、<varname>DEPENDS_TARGET</varname>が
		  設定されている場合はその値、それ以外の場合は<quote>install</quote>です。
		  例えば、<command>make update UPDATE_TARGET=package</command>のように使用します。</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><varname>NOCLEAN</varname></term>

	      <listitem>
		<para>更新した後、きれいに掃除をしません。調査やその他の目的のために、更新
		  されたパッケージの作業用ソース等をそのままにしておきたい場合に役に立
		  ちます。最終的にはソースツリーを掃除してください(以下の
		  <quote>clean-update</quote>ターゲットを見てください)。そうしなければ、次回の
		  <command>make</command>や<command>make update</command>の時に古いソースコードが残っていることで
		  トラブルがおこるかもしれません。</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><varname>REINSTALL</varname></term>

	      <listitem>
		<para>インストール(make <varname>DEPENDS_TARGET</varname>)の前に各パッケージをアンインストー
		  ルします。これは、<command>make update</command>の実行中断後に<quote>clean-update</quote>ターゲット
		  (以下参照)が呼ばれた場合に必要となることがあります。</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><varname>DEPENDS_TARGET</varname></term>

	      <listitem>
		<para>再帰を無効化し、パッケージのターゲットをハードコードすることができま
		  す。updateターゲット用のデフォルトは<quote>update</quote>であり、事前に必要なパッ
		  ケージを再帰的に更新するようになっています。<varname>DEPENDS_TARGET</varname>を設定する
		  のは、再帰的な更新を無効化したいときだけにしてください。<command>make update</command>
		  (後述します)の最中にインストールされる各パッケージに対して、特定のター
		  ゲットを指定するだけの場合は、これのかわりに<varname>UPDATE_TARGET</varname>を使ってく
		  ださい。</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>clean-update</term>

	<listitem>
	  <para>カレントディレクトリーで<command>make update</command>が実行された時に更新されるすべて
	    のパッケージのソースツリーを掃除します。カレントパッケージ(あるいは、依
	    存パッケージ)がすでにアンインストールされている(例えば<command>make update</command>を実行
	    した後)場合には、このターゲットを使ってはいけません。もし使用すると、更
	    新するつもりのパッケージのいくつかを失う可能性があります。経験的には、初
	    めて<command>make update</command>を実行する<emphasis>前</emphasis>、あるいは汚れたパッケージツリーがある場
	    合(例えば<varname>NOCLEAN</varname>を使用した場合)にのみ使用するとよいでしょう。</para>

	  <para>パッケージのツリーが掃除されているかどうかわからない場合は、ツリーの最上
	    層で<command>make clean</command>を実行するか、更新しようとしているパッケージのディレクト
	    リーで以下のコマンドをこの順に使うか、どちらかをおこなうことができます。
	    (<command>make update</command>を初めて実行するより<emphasis>前</emphasis>におこなってください。それ以外の場
	    合、更新しようとしているパッケージをすべて失ってしまいます)</para>

	  <screen><prompt>#</prompt> <userinput>make clean-update</userinput>
<prompt>#</prompt> <userinput>make clean CLEANDEPENDS=YES</userinput>
<prompt>#</prompt> <userinput>make update</userinput></screen>

	  <para><command>make clean-update</command>の動作を変更するために、以下の変数をコマンドライン、
	    または<filename>/etc/mk.conf</filename>で使うことができます。</para>

	  <variablelist>
	    <varlistentry>
	      <term><varname>CLEAR_DIRLIST</varname></term>

	      <listitem>
		<para><command>make clean</command>の後で、パッケージのためのディレクトリーのリストを再構
		  築しません。<command>make update</command>で、更新したいすべてのパッケージがインストー
		  ルされた場合にのみ使用してください。通常、これは<command>make update</command>で自動
		  的に実行されます。ただし、<varname>NOCLEAN</varname>変数の設定によって実行されない事もあ
		  ります(上を参照してください)。</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>info</term>

	<listitem>
	  <para>このターゲットは、現在のパッケージに対して&man.pkg.info.1;をおこないます。これ
	    を使って、インストールされているパッケージのバージョンを調べる
	    ことができます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>readme</term>

	<listitem>
	  <para>このターゲットは、<filename>README.html</filename>ファイルを作成します。このファイルは
	    <filename role="pkg">www/mozilla</filename>や
	    <filename role="pkg">www/links</filename>のようなブラウザー
	    で閲覧することができます。作成されたファイルは、ローカルホストの
	    <varname>PACKAGES</varname>ディレクトリーにあるパッケージへの参照を含んでいます。また、
	    <varname>FTP_PKG_URL_HOST</varname>と<varname>FTP_PKG_URL_DIR</varname>を元にしたURLを参照させることもできます。
	    例えば、ローカルマシン上の<filename>/usr/packages</filename>ディレクトリーのバイナリーパッ
	    ケージを参照する<filename>README.html</filename>ファイルを作成したい場合、
	    <varname>FTP_PKG_URL_HOST=file://localhost</varname>と<varname>FTP_PKG_URL_DIR=/usr/packages</varname>をセット
	    してください。<varname>${PACKAGES}</varname>ディレクトリーと、そのサブディレクトリーはすべ
	    てのバイナリーパッケージで検索されます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>readme-all</term>

	<listitem>
	  <para>このターゲットを使い、<filename>README-all.html</filename>を作成することができます。このファ
	    イルは&os;パッケージコレクションの中の、現在利用可能なすべてのパッケー
	    ジのリスト、また、それらが属するカテゴリーと簡単な説明を含んでいます。こ
	    のファイルは<filename>pkgsrc/*/README.html</filename>から作りだされます。したがって、<command>make readme</command>
	    の<emphasis>後</emphasis>に、このターゲットを実行してください。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>cdrom-readme</term>

	<listitem>
	  <para>これは<quote>readme</quote>ターゲット(上を見てください)とほとんど同じですが、CD-ROMに焼
	    かれるpkgsrcツリーを作る時に使われます。また、このターゲットは
	    <filename>README.html</filename>ファイルを作成し、<varname>CDROM_PKG_URL_HOST</varname>と<varname>CDROM_PKG_URL_DIR</varname>に基づ
	    くURLへの参照を作ります。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>show-distfiles</term>

	<listitem>
	  <para>このターゲットは、パッケージを構築するために、どのdistfileやパッチファイ
	    ルが必要かを表示します。(<varname>DISTFILES</varname>および<varname>PATCHFILES</varname>であって、<filename>patches/*</filename>は
	    含みません)</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>show-downlevel</term>

	<listitem>
	  <para>このターゲットは、パッケージがインストールされていない場合は何も表示しま
	    せん。もし、あるバージョンのパッケージがインストールされているが、現在の
	    pkgsrcのバージョンでインストールされたものでない場合、警告メッセージを表
	    示します。このターゲットは、インストール済みのパッケージが古いバージョン
	    であり、そのバージョンが削除可能で、最新の物が追加されることを表示するた
	    めに使用されます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>show-pkgsrc-dir</term>

	<listitem>
	  <para>当該パッケージの構築とインストールが可能な、パッケージ階層におけるディレ
	    クトリーを表示します。このディレクトリーは、そのパッケージがインストール
	    された際のディレクトリーと同じとは限りません。このターゲットは、単一ホス
	    ト上で多数のパッケージの更新をしたい場合に使うためのもので、pkgsrc の最
	    上層のMakefileから<quote>show-host-specific-pkgs</quote>ターゲットで呼び出すことがで
	    きます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>show-installed-depends</term>

	<listitem>
	  <para>このターゲットは、インストールされているパッケージのうち、どれが当該パッ
	    ケージの<varname>DEPENDS</varname>と合致するかを表示します。依存関係が古いせいで構築に問題が
	    起きる場合に便利です。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>check-shlibs</term>

	<listitem>
	  <para>パッケージのインストール後に、すべてのバイナリーおよび(ELFプラットフォー
	    ムでは) 共有ライブラリーが必要な共有ライブラリーを見つけられるかどうか確
	    認します。<filename>/etc/mk.conf</filename>で<varname>PKG_DEVELOPER</varname>が設定されている場合はデフォルトで
	    実行します。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>print-PLIST</term>

	<listitem>
	  <para>パッケージを新規に、または更新のために<quote>make install</quote>した後、
	    <command>find -newer
	    work/.extract_done</command>をもとに新しい<filename>PLIST</filename>を生成して表示します。PLIST生成は、
	    共有ライブラリーなどに配慮して行われますが、生成した結果を<filename>PLIST</filename>に置く前
	    に再確認するよう<emphasis>強く</emphasis>おすすめします。パッケージ更新時には、このコマンド
	    の出力と、更新前の<filename>PLIST</filename>ファイルとを比較すると便利でしょう。</para>

	  <para>パッケージが、&man.tar.1;その他のファイルのアクセス時刻を更新しない方法を使っ
	    てファイルをインストールする場合は、それらのファイルはこのターゲットで使われる <quote>find
	    -newer</quote> コマンドで検
	    出されないので、手で<filename>PLIST</filename>に書き足すよう注意してください!</para>

	  <para> このターゲットに関するさらなる情報は、
	    <xref linkend="print-PLIST"/>を参照してください。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>bulk-package</term>

	<listitem>
	  <para>バルクビルドの実行に使われます。適切なバイナリーパッケージがすでに存在す
	    る場合は、何もしません。そうでない場合は、コンパイル、インストール、パッ
	    ケージ作成をおこないます
	    (<varname>PKG_DEPENDS</varname>が適切に設定されている場合は、依存するパッケージも。<xref linkend="binary.configuration"/>参照)。
	    バイナリーパッケージ作成後、ディスクの空き領域
	    を確保するために、ソース、インストールしたばかりのパッケージと依存パッケー
	    ジは削除されます。</para>

	  <para><emphasis>このターゲットを使うと、
	    システムにインストールされているパッケージをすべてアンインストールすることもあるので、
	    注意してください。</emphasis></para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>bulk-install</term>

	<listitem>
	  <para>依存パッケージ群をインストールするためのバルクインストールで使われます。
	    最新のバイナリーパッケージが利用可能な場合、&man.pkg.add.1;でそれをインストール
	    します。そうでない場合は、<command>make bulk-package</command>が実行されますが、インストー
	    ルされたバイナリーは削除されません。</para>

	  <para> バイナリーパッケージが<quote>最新</quote>であるとみなされる (&man.pkg.add.1; でインストールされる)
	    条件は、以下のとおりです。</para>

	  <itemizedlist>
	    <listitem>
	      <para>パッケージファイル(<filename>Makefile</filename>, ...)が、いずれも構築時から変更されていな
		いこと。</para>
	    </listitem>

	    <listitem>
	      <para>そのパッケージが依存している(バイナリー)パッケージが、いずれも構築時
		から変更されていないこと。</para>
	    </listitem>
	  </itemizedlist>

	  <para><emphasis>このターゲットを使うと、
	    システムにインストールされているパッケージをすべてアンインストールすることもあるので、
	    注意してください。</emphasis></para>
	</listitem>
      </varlistentry>
    </variablelist>
  </sect1>
</chapter>
