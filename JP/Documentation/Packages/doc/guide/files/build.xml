<!-- $NetBSD: build.xml,v 1.62 2011/07/31 08:48:22 spz Exp $ -->
<!-- Based on english version: -->
<!-- NetBSD: build.xml,v 1.62 2011/07/31 08:48:22 spz Exp   -->

<chapter id="build">
  <title>構築の手順</title>

  <sect1 id="build.intro">
    <title>序</title>

    <para>本章では、パッケージがどのように構築されるかについて、詳しく説明します。
    パッケージの構築は、複数の<emphasis>相 (phase)</emphasis> (たとえば、<varname>fetch</varname>,
    <varname>build</varname>, <varname>install</varname>) にわかれており、
    そのすべてを以下の各節で説明します。それぞれの段階は、<varname>pre-</varname>,
    <varname>do-</varname>, <varname>post-</varname>
    のいずれかが相名の前についた、いわゆる<emphasis>期 (stage)</emphasis>
    にわかれます。(たとえば、
    <varname>pre-configure</varname>, <varname>post-build</varname> などです。)
    実際に何かがおこなわれるのは、ほとんどが <varname>do-*</varname> 期においてです。</para>

    <para>標準的なターゲット (<varname>fetch</varname>
    など) は、決して上書きしないでください。変更する必要がある場合は、
    対応する <varname>do-*</varname> ターゲットを上書きしてください。</para>

    <para>プログラムを構築するための基本的な手順は常に同じです。最初に、プログラムの
    ソースファイル(<emphasis>distfile</emphasis>)をローカルシステムへ持ってきて展開します。
    コンパイルするための pkgsrc 独自のパッチを適用した後に、ソフトウェアを設定
    し、構築(通常、コンパイルすることによって)します。最後に作成されたバイナリー
    等を、システムにインストールします。</para>

    <para>それぞれの段階で何が起きているかを、もっと詳しく把握するために、
    <varname>PKG_VERBOSE</varname> 変数を設定することができます。
    または、<emphasis>patch</emphasis> の段階における詳細に関心があるだけなら、
    <varname>PATCH_DEBUG</varname> 変数を設定することもできます。</para>
  </sect1>

  <sect1 id="build.prefix">
    <title>プログラムの場所</title>

    <para>次のセクションで&os;パッケージシステムによって実行される手順の概略を述
    べる前に、プログラムがインストールされる場所、その場所に影響をおよぼす変数
    について簡単に記述します。</para>

    <para>自動変数<varname>PREFIX</varname>は、最終的にプログラムのすべてのファイルがインストールされる
    場所をしめします。通常、<varname>LOCALBASE</varname> (<filename>/usr/pkg</filename>)、または<filename>cross</filename>カテゴリーの
    パッケージのための<varname>CROSSBASE</varname>と同じ場所になっています。
    <varname>PREFIX</varname>の値は、プログラムのソース中でこれらのファイルが符号化されるさまざ
    まな場所に使用されるべきです。
    詳細に関しては、<xref linkend="components.patches"/>および<xref
    linkend="fixes.libtool"/>を参照して下さい。</para>

    <para>これらの変数のどれかを選択し使用する場合には、
    以下のルールに従ってください。</para>

    <itemizedlist>
      <listitem>
	<para><varname>PREFIX</varname>は常に現在のパッケージがインストールされる場所を指します。パッ
	ケージ自身のインストール先のパスを参照する時に、<quote>${PREFIX}</quote>を使用してくだ
	さい。</para>
      </listitem>

      <listitem>
	<para><varname>LOCALBASE</varname>は、すべての非X11パッケージがインストールされる場所です。他
	の非X11パッケージによってインストールされたインクルードファイルやライブ
	ラリーの場所をさがすためのコンパイラーの-Iや-Lオプションを指定する場合に、
	<quote>${LOCALBASE}</quote>を使用してください。
	<varname>LOCALBASE</varname> という変数名は、FreeBSD でパッケージをすべて
	<filename>/usr/local</filename> にインストールしていたことに由来します。
	pkgsrc では <filename>/usr/local</filename> をシステム管理者のために使わないようにしているので、
	この変数名は間違った名前です。</para>
      </listitem>

      <listitem>
	<para><varname>X11BASE</varname>は、実際に(xsrcなどに由来する)X11ディストリビューションがイン
	ストールされる場所です。
	<emphasis>通常の</emphasis>X11のインクルードファイル(パッケージとして
	インストールされていない)をさがす場合、<quote>${X11BASE}</quote>を使用してください。</para>
      </listitem>

      <listitem>
	<para>X11 ベースのパッケージは特別です。インストールされる場所は、
	<varname>X11BASE</varname> と <varname>LOCALBASE</varname> のどちらに依存することもありえます。</para>

	<para>通常、X11 のパッケージは、できるかぎり <varname>LOCALBASE</varname>
	にインストールするものです。X11 のパッケージでは、X11 が必要なことを要求し、
	適切な編集フラグを持つようにするために、
	<filename>../../mk/x11.buildlink3.mk</filename>
	をインクルードする必要があります。</para>

	<para>しかし、<varname>LOCALBASE</varname> 以下にはインストールできないパッケージもあります。
	app-defaults ファイルが附属するようなパッケージが該当します。
	このようなパッケージは例外であり、<varname>X11BASE</varname>
	以下にインストールする必要があります。そうするためには、
	パッケージ側で <varname>USE_X11BASE</varname> または <varname>USE_IMAKE</varname>
	のいずれかを設定します。</para>

	<para>註:
	<filename>Makefile</filename> で <varname>USE_IMAKE</varname> や <varname>USE_X11BASE</varname>
	を定義したパッケージによってインストールされたインクルードファイルやライブラリーをさがす場合、
	<filename>${X11BASE}</filename> と
	<filename>${LOCALBASE}</filename> を<emphasis>両方</emphasis>調べる必要があります。
	X11 パッケージをすべて強制的に <varname>LOCALBASE</varname> にインストールさせるために、
	<filename role="pkg">pkgtools/xpkgwedge</filename> パッケージが標準で有効になっています。</para>
      </listitem>

      <listitem>
	<para>X11パッケージのインストール場所を参照する用途には、<varname>X11PREFIX</varname>を使って
	ください。<varname>X11PREFIX</varname>は、xpkgwedgeがインストールされていない場合は
	<varname>X11BASE</varname>となり、xpkgwedgeがインストールされている場合は<varname>LOCALBASE</varname>と
	なります。</para>
      </listitem>

      <listitem>
	<para>xpkgwedgeがインストールされている場合、パッケージによってインストール先
	が<varname>X11BASE</varname>になっていたり<varname>LOCALBASE</varname>になっていたりすることがあります。インス
	トールされているパッケージのprefixを決めるために、<varname>EVAL_PREFIX</varname>定義を使う
	ことができます。この定義に<quote>DIRNAME=&lt;package&gt;</quote>の形式の組を書くと、&man.make.1;変
	数<varname>DIRNAME</varname>が、インストールされているパッケージ &lt;package&gt;のprefixに設定され
	ます。そのパッケージがインストールされていない場合は<quote>${X11PREFIX}</quote>に設定さ
	れます。</para>

	<para>例を使って説明するのが一番いいでしょう。</para>

	<para>以下は、
	<filename>pkgsrc/wm/scwm/Makefile</filename>からの抜粋です。</para>

<programlisting>
EVAL_PREFIX+=           GTKDIR=gtk+
CONFIGURE_ARGS+=        --with-guile-prefix=${LOCALBASE:Q}
CONFIGURE_ARGS+=        --with-gtk-prefix=${GTKDIR:Q}
CONFIGURE_ARGS+=        --enable-multibyte
</programlisting>

	<para><varname>EVAL_PREFIX</varname>を使って評価するパッケージに対して、以下のような定義を使って
	デフォルトを定義することができます。</para>

<programlisting>
GTKDIR_DEFAULT= ${LOCALBASE}
</programlisting>

	<para>ここで<varname>GTKDIR</varname>は、
	<varname>EVAL_PREFIX</varname>
	での最初の定義の組に対応します。</para>
      </listitem>

      <listitem>
	<para>パッケージは <filename>${PREFIX}</filename> 以下に、
	&man.hier.7; に準じてファイルをインストールするようにします。
	ただしマニュアルページは例外で、<filename>${PREFIX}/share/man</filename>
	ではなく <filename>${PREFIX}/man</filename> にインストールします。</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="build.builddirs">
    <title>構築の過程で使われるディレクトリー</title>

    <para>パッケージの構築時には、ソースファイル、一時ファイル、
    pkgsrc 内部ファイルなどを置いておくために、さまざまなディレクトリーが使われます。
    そのようなディレクトリーについて説明します。</para>

    <para>ディレクトリーを指す変数のなかには、相対パス名を値に持つものがあります。
    このような相対パス名の基点となるディレクトリーは、おもに二つあります。
    一つは <varname>PKGSRCDIR/PKGPATH</varname> で、pkgsrc 特有のディレクトリー用です。
    もう一つは  <varname>WRKSRC</varname> で、パッケージそのものの内部にあるディレクトリー用です。</para>

    <variablelist>

      <varlistentry><term><varname>PKGSRCDIR</varname></term>
      <listitem><para>絶対パス名で、
      pkgsrc のルートディレクトリーを指します。
      通常は、この変数を使う必要はありません。</para></listitem></varlistentry>

      <varlistentry><term><varname>PKGDIR</varname></term>
      <listitem><para>当該パッケージを指す
      絶対パス名です。</para></listitem></varlistentry>

      <varlistentry><term><varname>PKGPATH</varname></term>
      <listitem><para><varname>PKGSRCDIR</varname>
      を基点とした相対パス名で、
      当該パッケージを指します。</para></listitem></varlistentry>

      <varlistentry><term><varname>WRKDIR</varname></term>
      <listitem><para>絶対パス名で、全作業がおこなわれるディレクトリーを指します。
      distfile はこのディレクトリーに展開されます。
      一般的に、このディレクトリーには、
      <emphasis>buildlink</emphasis> や
      <emphasis>wrappers</emphasis> など、
      pkgsrc の各種基盤が使う一時ディレクトリーも含まれます。</para></listitem></varlistentry>

      <varlistentry><term><varname>WRKSRC</varname></term>
      <listitem><para>絶対パス名で、distfile が展開されるディレクトリーを指します。
      普通は、<varname>WRKDIR</varname> 直下のサブディレクトリーであり、
      多くの場合は、このディレクトリーにおける、
      唯一の隠されていないディレクトリーエントリーです。この変数は、パッケージの
      <filename>Makefile</filename> で変更することができます。</para></listitem></varlistentry>

    </variablelist>

    <para><varname>CREATE_WRKDIR_SYMLINK</varname> 定義は、
    <emphasis>yes</emphasis> または <emphasis>no</emphasis> のいずれかの値をとり、
    標準状態では <emphasis>no</emphasis> になります。これは、
    pkgsrc の個々のパッケージのディレクトリー内に、
    <varname>WRKDIR</varname> へのシンボリックリンクを作成するか否かを示します。
    pkgsrc ツリーを読み取り専用として使いたい場合は、
    <varname>CREATE_WRKDIR_SYMLINK</varname> の値を
    <emphasis>no</emphasis> にしてください。</para>
  </sect1>

  <sect1 id="build.running">
    <title>相の実行</title>

    <para><command>make phase</command> (<emphasis>phase</emphasis> は相の名前) と打てば、
    その相を実行することができます。
    こうすると、その相のために必要な相をすべて自動的に実行します。
    相を指定しない場合は <varname>build</varname> 相になります。つまり、
    あるパッケージのディレクトリーで、引数なしで <command>make</command>
    を実行すると、パッケージが構築されますが、インストールはされません。</para>

  </sect1>

  <sect1 id="build.fetch">
    <title><emphasis>fetch</emphasis> 相</title>

    <para>パッケージの構築の最初の段階は、配布ファイル (distfiles)
    を、そのファイルを配布しているサイトから取得することです。
    これは <emphasis>fetch</emphasis> 相がおこなう仕事です。</para>

    <sect2 id="build.fetch.what">
      <title>何を、どこから取得するか</title>

      <para>単純な場合では、<varname>MASTER_SITES</varname> で
      distfile (distfile のファイル名は <varname>DISTNAME</varname> が使われます)
      を取得する URL をすべて定義します。
      これより複雑な場合については、以下で説明します。</para>

      <para>変数 <varname>DISTFILES</varname> は、取得する必要のある
      distfile を並べたリストを指定します。この値は、標準では
      <literal>${DISTNAME}${EXTRACT_SUFX}</literal> になり、
      ほとんどのパッケージではあえて定義する必要がありません。
      <varname>EXTRACT_SUFX</varname> は、標準では <literal>.tar.gz</literal>
      になりますが、自由に変更することができます。なお、標準で定義される
      distfile に加えて別の distfile が必要な場合は、
      それを <literal>+=</literal> 演算子を使って追加することはできません。
      たとえば以下のように書く必要があります。</para>

<programlisting>
DISTFILES=      ${DISTNAME}${EXTRACT_SUFX} additional-files.tar.gz
</programlisting>

      <para>各 distfile は、通常は <varname>MASTER_SITES</varname>
      に並べられたサイトから取得されます。パッケージに複数の
      <varname>DISTFILES</varname> または複数の
      <varname>PATCHFILES</varname> があり、それらが異なるサイトで配布されている場合は、
      <filename><replaceable>distfile</replaceable></filename>
      ファイル (サフィックスを含む) の配布場所の URL を並べたリストを
      <varname>SITES.<replaceable>distfile</replaceable></varname>
      に設定することができます。</para>

<programlisting>
DISTFILES=      ${DISTNAME}${EXTRACT_SUFX}
DISTFILES+=     foo-file.tar.gz
SITES.foo-file.tar.gz= \
http://www.somewhere.com/somehow/ \
http://www.somewhereelse.com/mirror/somehow/
</programlisting>

      <para>distfile を実際に取得する際、それらは、
      <varname>MASTER_SITES</varname> または
      <varname>SITES.*</varname>
      に各 distfile のファイル名をそのまま (間にスラッシュを入れずに)
      つなげた形の URL から取得されます。このため、サイトを定義する変数の値は、
      スラッシュその他の分離記号で終わる必要があります。このため、たとえば
      <varname>MASTER_SITES</varname> を、distfile 名を引数としてとる
      CGI スクリプトの URL にすることができます。そうした場合、
      以下のような形で定義することになります。</para>

<programlisting>
MASTER_SITES=   http://www.example.com/download.cgi?file=
</programlisting>

      <para> 例外は、URL の前にダッシュ (-) がついている場合です。
      この場合、その URL を (distfile とつなげずに) そのまま使って distfile を取得し、
      取得したファイルを distfile の名前で保存します。</para>

      <para>パッケージで使うため、<varname>MASTER_SITES</varname>
      用にあらかじめ定義された値がいくつか用意されています。
      各変数の意味は、名前から明らかでしょう。</para>

      <!-- sort mk/fetch/sites.mk | sed -n 's/\(^MA[A-Z_]*\).*/    ${\1}/p' -->

<programlisting>
${MASTER_SITE_APACHE}
${MASTER_SITE_BACKUP}
${MASTER_SITE_CYGWIN}
${MASTER_SITE_DEBIAN}
${MASTER_SITE_FREEBSD}
${MASTER_SITE_FREEBSD_LOCAL}
${MASTER_SITE_GENTOO}
${MASTER_SITE_GNOME}
${MASTER_SITE_GNU}
${MASTER_SITE_GNUSTEP}
${MASTER_SITE_IFARCHIVE}
${MASTER_SITE_KDE}
${MASTER_SITE_MOZILLA}
${MASTER_SITE_MYSQL}
${MASTER_SITE_OPENOFFICE}
${MASTER_SITE_PERL_CPAN}
${MASTER_SITE_PGSQL}
${MASTER_SITE_R_CRAN}
${MASTER_SITE_SOURCEFORGE}
${MASTER_SITE_SOURCEFORGE_JP}
${MASTER_SITE_SUNSITE}
${MASTER_SITE_SUSE}
${MASTER_SITE_TEX_CTAN}
${MASTER_SITE_XCONTRIB}
${MASTER_SITE_XEMACS}
</programlisting>

      <para>名前から意味がわかりにくいものについて、説明しておきます。
      <varname>MASTER_SITE_BACKUP</varname> には、<ulink
      url="ftp://ftp.NetBSD.org/pkgsrc/distfiles/${DIST_SUBDIR}"
      /> で保守されている、パッケージのバックアップサイトが含まれます。
      <varname>MASTER_SITE_LOCAL</varname> には、<ulink
      url="ftp://ftp.NetBSD.org/pub/pkgsrc/distfiles/LOCAL_PORTS/"
      /> で保守されている、パッケージのローカルなソース配布物が含まれます。</para>

      <para>もしこれらの予め定義されたサイトの1つを選んだ場合、そのサイトのサブディレク
      トリーを指定することが必要となるかもしれません。これらのマクロは複数の実際
      のサイトに展開されるかもしれませんので、サブディレクトリーを指定する場合は、
      以下の表記を<emphasis>使わなければなりません</emphasis>:</para>

<programlisting>
MASTER_SITES=   ${MASTER_SITE_GNU:=subdirectory/name/}
MASTER_SITES=   ${MASTER_SITE_SOURCEFORGE:=project_name/}
</programlisting>

      <para>サブディレクトリー名の後のスラッシュ/に注意してください。</para>

    </sect2>
    <sect2 id="build.fetch.how">
      <title>ファイルの取得はどのようにおこなわれるか?</title>

      <para><emphasis>fetch</emphasis> 相では、distfile
      がすべてローカルディレクトリー (<varname>DISTDIR</varname>,
      pkgsrc 利用者が設定可能) に存在する状態にします。
      distfile は以下の形式のコマンドを使って取得されます。</para>

<programlisting>
${FETCH_CMD} ${FETCH_BEFORE_ARGS} ${site}${file} ${FETCH_AFTER_ARGS}
</programlisting>

      <para>この <literal>${site}</literal> には、複数の候補が決まった順序で使われます: 最初に
      <varname>MASTER_SITE_OVERRIDE</varname>を試み、次に、<varname>SITES.file</varname>が定義されていればそれ
      を、定義されていなければ、<varname>MASTER_SITES</varname>か<varname>PATCH_SITES</varname>のどちらかを試
      みます。そして、最後に<varname>MASTER_SITE_BACKUP</varname>の値を試みます。
      これらのうち最初のものと最後のもの以外の順序は、
      <varname>MASTER_SORT_RANDOM</varname> を設定し、かつ
      <varname>MASTER_SORT_AWK</varname>か
      <varname>MASTER_SORT_REGEX</varname>を設定して、ユーザー
      が入れ換えることができます。</para>

      <para> この取得用のコマンドと引数は、
      <varname>FETCH_USING</varname> 変数に応じたものが使われます。
      上述の例は、<literal>FETCH_USING=custom</literal> とした場合のものです。</para>

      <para>the NetBSD Foundation が運営している distfile
      のミラーサイトでは、自由に配布可能な distfile
      をミラーするために <emphasis>mirror-distfiles</emphasis>
      ターゲットを使っています。<varname>NO_SRC_ON_FTP</varname>
      を (たいていは <quote>${RESTRICTED}</quote> に)
      設定しているパッケージの distfile はミラーされません。</para>
    </sect2>

  </sect1>

  <sect1 id="build.checksum">
    <title><emphasis>checksum</emphasis> 相</title>

    <para>distfileを取得した後に、チェックサムを生成し、distinfoファイルに保存され
    たチェックサムと比較します。もし、チェックサムが一致しなければ、構築は中
    断されます。これはパッケージ作成時と同じdistfileが、構築に使用されている
    こと、つまり、悪意や一次配布サイトでの意図的な差し替えやネットワークの損
    失によってdistfileが変更されていないことを保証するためです。</para>

  </sect1>

  <sect1 id="build.extract">
    <title><emphasis>extract</emphasis> 相</title>

    <para>distfileがローカルシステム上に存在している場合、
    通常、それらは圧縮アーカイブフォーマットで保存されているので、
    展開する必要があります。</para>

    <para>標準では、<varname>DISTFILES</varname> はすべて展開されます。
    一部だけを展開する必要がある場合は、
    <varname>EXTRACT_ONLY</varname> 変数を、
    展開する必要のあるファイルを並べたリストに設定することができます。</para>

    <para>通常、ファイルの展開は <filename>mk/extract/extract</filename>
    という小さなプログラムを使っておこなわれます。このプログラムは、
    各種アーカイブ形式の展開方法を知っているので、
    何も変更する必要はないでしょう。それでも変更が必要な場合は、
    以下の変数を使うとよいでしょう。</para>

    <variablelist>

      <varlistentry><term><varname>EXTRACT_OPTS_{BIN,LHA,PAX,RAR,TAR,ZIP,ZOO}</varname></term>
      <listitem><para>この各変数を使って、展開用のコマンドのオプションを、
      標準のもの (<filename>mk/extract/extract</filename>
      で定義されています) から上書きします。</para></listitem></varlistentry>

      <varlistentry><term><varname>EXTRACT_USING</varname></term>
      <listitem><para>この変数は、tar アーカイブ展開用のコマンドを設定するもので、
      <literal>bsdtar</literal>, <literal>gtar</literal>, <literal>nbtar</literal>
      (標準状態での値), <literal>pax</literal> または、
      コマンドの絶対パス名に設定することができます。
      NetBSD の (tar として使われる) pax でうまく展開できない場合は、
      なるべく gtar より bsdtar を選ぶようにします。</para></listitem></varlistentry>

    </variablelist>

    <para>必要なことが <filename>extract</filename>
    プログラムではできない場合は、ファイル展開用のコマンドを保持する
    <varname>EXTRACT_CMD</varname> 変数を上書きすることもできます。
    この変数で指定された展開用コマンドは、
    <filename>${WRKSRC}</filename> ディレクトリー内で実行されます。
    このコマンドの実行中は、シェル変数 <varname>extract_file</varname>
    に、展開中のアーカイブファイルの絶対パス名が保持されます。</para>

    <para>これでもなお不十分な場合は、パッケージの Makefile で、
    <varname>do-extract</varname>
    ターゲットを上書きすることができます。</para>

  </sect1>

  <sect1 id="build.patch">
    <title><emphasis>patch</emphasis> 相</title>

    <para>展開の後で、<varname>PATCHFILES</varname>で指定されたパッチとパッケージのpatchesサブディレ
    クトリーに存在するパッチ、さらに、$LOCALPATCHES/$PKGPATH (たとえば
    <filename>/usr/local/patches/graphics/png</filename>)に存在するパッチのすべてが適用されます。
    <filename>.Z</filename>、あるいは<filename>.gz</filename>で終る名前のパッチファイルは、適用する前に伸張されます。
    <filename>.orig</filename>、<filename>.rej</filename>で終るものは無視されます。&man.patch.1;のためのいくつかのオプショ
    ンは、<varname>PATCH_DIST_ARGS</varname>で指定する事ができます。
    詳細に関しては<xref
    linkend="components.patches"/>を参照して下さい。</para>

    <para>デフォルトでは、パッチに曖昧さがあった場合には&man.patch.1;が異常終了するような
    特別な引数が渡されます。パッチを修正(再作成)して、きれいに適用できるよう
    にしてください。そうする理由は、曖昧さがあるパッチが一見うまく適用できても、実は誤った場
    所に適用されていて、深刻な問題を起こす可能性があるからです。</para>

  </sect1>

  <sect1 id="build.tools">
    <title><emphasis>tools</emphasis> 相</title>

    <para>この相については<xref linkend="tools"/> で説明しています。
    </para>

  </sect1>

  <sect1 id="build.wrapper">
    <title><emphasis>wrapper</emphasis> 相</title>

    <para>この相では、コンパイラーとリンカー用のラッパープログラムが作成されます。
    以下の変数を使って、ラッパーに手を加えることができます。</para>

    <variablelist>

      <varlistentry><term><varname>ECHO_WRAPPER_MSG</varname></term>
      <listitem><para>経過を表示するためのコマンドです。
      標準状態では何もしません。
      経過を見るには、この変数を <literal>${ECHO}</literal>
      に設定します。</para></listitem></varlistentry>

      <varlistentry><term><varname>WRAPPER_DEBUG</varname></term>
      <listitem><para>この変数は、
      ラッパーのログファイルにより詳しい情報が必要かどうかに応じて、
      <literal>yes</literal> (標準状態の値) または
      <literal>no</literal> に設定することができます。</para></listitem></varlistentry>

      <varlistentry><term><varname>WRAPPER_UPDATE_CACHE</varname></term>
      <listitem><para>この変数は、
      ラッパーの速度を改善するためキャッシュを使わせるかどうかに応じて、
      <literal>yes</literal> または <literal>no</literal>
      に設定することができます。標準状態の値は
      <literal>yes</literal> ですが、キャッシュに対応していないプラットフォームでは
      強制的に <literal>no</literal>
      になります。</para></listitem></varlistentry>

      <varlistentry><term><varname>WRAPPER_REORDER_CMDS</varname></term>

      <listitem><para>順序の並び替え用のコマンドを並べたリストです。
      並び替え用のコマンドは、
      <literal>reorder:l:<replaceable>lib1</replaceable>:<replaceable>lib2</replaceable></literal>
      のような形式をしています。これを使うと
      <literal>-l<replaceable>lib1</replaceable></literal>
      が常に
      <literal>-l<replaceable>lib2</replaceable></literal> より先に現れるようになります。
      </para></listitem></varlistentry>

      <varlistentry><term><varname>WRAPPER_TRANSFORM_CMDS</varname></term>
      <listitem><para>変換用のコマンドを並べたリストです。 [TODO:
      investigate further]</para></listitem></varlistentry>

      <!-- These should probably be internal variables
	   <varlistentry><term><varname>WRAPPEES</varname></term>
	   <listitem><para></para></listitem></varlistentry>
	   <varlistentry><term><varname>UNWRAP_PATTERNS</varname></term>
	   <listitem><para></para></listitem></varlistentry>
	   <varlistentry><term><varname>UNWRAP_FILES</varname></term>
	   <listitem><para></para></listitem></varlistentry>
      -->

    </variablelist>
  </sect1>

  <sect1 id="build.configure">
    <title><emphasis>configure</emphasis> 相</title>

    <para>ほとんどのソフトウェアは、実行対象のプラットフォームで利用できるヘッダーファイル、
    システムコール、およびライブラリールーチンについての情報を必要とします。
    この情報の判断はコンフィギュレーションとして知られているプロセスであり、
    通常、自動化されています。
    大抵の場合、スクリプトが配布物と一緒に提供され、
    それを実行することによりヘッダーファイルやMakefile等が生成されます。</para>

    <para>パッケージが configure スクリプトを含んでいる場合、<varname>HAS_CONFIGURE</varname>
    を <quote>yes</quote> に設定することにより、実行することができます。
    もし、その configure スクリプトが GNU の autoconf スクリプトである場合は、
    かわりに、<varname>GNU_CONFIGURE</varname> を <quote>yes</quote> に指定してください。
    大雑把にいうと、<emphasis>configure</emphasis> 相では以下のようなことをしています。</para>

<programlisting>
.for d in ${CONFIGURE_DIRS}
        cd ${WRKSRC} \
        &amp;&amp; cd ${d} \
        &amp;&amp; env ${CONFIGURE_ENV} ${CONFIGURE_SCRIPT} ${CONFIGURE_ARGS}
.endfor
</programlisting>

    <para><varname>CONFIGURE_DIRS</varname> (標準では <quote>.</quote>) は、
    <varname>WRKSRC</varname> からの相対位置でのパス名を並べたリストです。
    この各ディレクトリー内で、環境変数 <varname>CONFIGURE_ENV</varname> および
    引数 <varname>CONFIGURE_ARGS</varname> を使って
    configure スクリプトが実行されます。
    <varname>CONFIGURE_ENV</varname>, <varname>CONFIGURE_SCRIPT</varname>
    (標準では <quote>./configure</quote>),
    <varname>CONFIGURE_ARGS</varname>
    の各変数は、いずれもパッケージ側で変更することができます。</para>

    <para>もし、プログラムがコンフィギュレーションのために <filename>Imakefile</filename> を使用するので
    あれば、<varname>USE_IMAKE</varname> を <quote>yes</quote> に設定することにより、適切な手順が実行されます。
    (もし、<varname>${X11PREFIX}</varname> にインストールされるパッケージが欲しいだけで、xmkmfを実
    行したくない場合、かわりに<varname>USE_X11BASE</varname>を使用してください。)
    <varname>SCRIPTS_ENV</varname> に変数を設定すると、
    その変数を xmkmf の環境変数に追加することができます。</para>

    <para>プログラムがコンフィギュレーションのために <filename>cmake</filename>
    を使用するのであれば、
    <varname>USE_CMAKE</varname> を <quote>yes</quote> に設定することにより、適切な手順が実行されます。
    <varname>CONFIGURE_ENV</varname> に変数を追加すると、
    その変数を cmake の環境変数に追加することができます。
    また、<varname>CMAKE_ARGS</varname> 変数に引数を追加すると、
    cmake の引数に追加することができます。
    最上層ディレクトリーを指定する引数は
    <varname>CMAKE_ARG_PATH</varname> 変数で与えられるようになっており、
    この変数の標準の値は
    <quote>.</quote> (<varname>CONFIGURE_DIRS</varname> からの相対位置) です。</para>

    <para>configure の段階ですることが何もない場合は、
    <varname>NO_CONFIGURE</varname> を <quote>yes</quote> に設定します。</para>
  </sect1>

  <sect1 id="build.build">
    <title><emphasis>build</emphasis> 相</title>

    <para>パッケージの構築は、大雑把にいえば、
    以下のコードを実行するのと同じことです。</para>

<programlisting>
.for d in ${BUILD_DIRS}
        cd ${WRKSRC} \
        &amp;&amp; cd ${d} \
        &amp;&amp; env ${MAKE_ENV} \
            ${MAKE_PROGRAM} ${BUILD_MAKE_FLAGS} \
                -f ${MAKE_FILE} \
                ${BUILD_TARGET}
.endfor
</programlisting>

    <para><varname>BUILD_DIRS</varname> (標準では
    <quote>.</quote>) は、
    <varname>WRKSRC</varname> からの相対位置でのパス名を並べたリストです。
    この各ディレクトリー内で、環境変数
    <varname>MAKE_ENV</varname> および引数
    <varname>BUILD_MAKE_FLAGS</varname> を使って
    <varname>MAKE_PROGRAM</varname> が実行されます。
    <varname>MAKE_ENV</varname>,
    <varname>BUILD_MAKE_FLAGS</varname>,
    <varname>MAKE_FILE</varname>,
    <varname>BUILD_TARGET</varname>
    の各変数は、いずれもパッケージ側で変更することができます。</para>

    <para><varname>MAKE_PROGRAM</varname> の標準の値は、
    <varname>USE_TOOLS</varname> に <quote>gmake</quote> が含まれている場合は
    <quote>gmake</quote>、含まれていない場合は <quote>make</quote> です。
    <varname>MAKE_FILE</varname> の標準の値は <quote>Makefile</quote> であり、
    <varname>BUILD_TARGET</varname> の標準の値は <quote>all</quote> です。</para>

    <para>build の段階ですることが何もない場合は、
    <varname>NO_BUILD</varname> を <quote>yes</quote> に設定します。</para>
  </sect1>

  <sect1 id="build.test">
    <title><emphasis>test</emphasis> 相</title>

    <para>[TODO]</para>

  </sect1>

  <sect1 id="build.install">
    <title><emphasis>install</emphasis> 相</title>

    <para>構築の段階が完了すると、ユーザーが構築されたプログラムやファイルを使えるようにするため、ソフトウェアをパブリックなディレ
    クトリーにインストールする必要があります。</para>

    <para><emphasis>install</emphasis> 相は、大雑把にいえば、
    以下のコードを実行するのと同じことです。これに加えて、
    このコードの前後では、整合性の検査やパッケージの登録などをするため、
    多くの操作がおこなわれます。</para>

<programlisting>
.for d in ${INSTALL_DIRS}
        cd ${WRKSRC} \
        &amp;&amp; cd ${d} \
        &amp;&amp; env ${MAKE_ENV} \
            ${MAKE_PROGRAM} ${INSTALL_MAKE_FLAGS} \
                -f ${MAKE_FILE} \
                ${INSTALL_TARGET}
.endfor
</programlisting>

    <para>各変数の意味は、<emphasis>build</emphasis>
    相のものと同様です。
    <varname>INSTALL_DIRS</varname> は標準では
    <varname>BUILD_DIRS</varname> です。<varname>INSTALL_TARGET</varname>
    は標準では <quote>install</quote> ですが、
    <varname>USE_IMAKE</varname> が定義されており、かつ
    <varname>NO_INSTALL_MANPAGES</varname> が定義されていない場合は、
    <quote>install.man</quote>
    が追加されます。</para>

    <para><emphasis>install</emphasis> 相では、以下の変数が有用です。
    これらはいずれも &man.install.1; コマンドの変種であり、
    所有者、所有グループ、パーミッションをあらかじめ決めてあるものです。
    <varname>INSTALL</varname> は、オプションを何も指定しない install コマンドです。
    用途別に特化した変種には、以下のものがあります。</para>

    <variablelist>
      <varlistentry><term><varname>INSTALL_PROGRAM_DIR</varname></term>
      <listitem><para>バイナリーを含むディレクトリー</para></listitem></varlistentry>

      <varlistentry><term><varname>INSTALL_SCRIPT_DIR</varname></term>
      <listitem><para>スクリプトを含むディレクトリー</para></listitem></varlistentry>

      <varlistentry><term><varname>INSTALL_LIB_DIR</varname></term>
      <listitem><para>共有静的ライブラリーを含むディレクトリー</para></listitem></varlistentry>

      <varlistentry><term><varname>INSTALL_DATA_DIR</varname></term>
      <listitem><para>データファイルを含むディレクトリー</para></listitem></varlistentry>

      <varlistentry><term><varname>INSTALL_MAN_DIR</varname></term>
      <listitem><para>マニュアルページを含むディレクトリー</para></listitem></varlistentry>

      <varlistentry><term><varname>INSTALL_PROGRAM</varname></term>
      <listitem><para>デバッグ用シンボルを取り除くことのできるバイナリー</para></listitem></varlistentry>

      <varlistentry><term><varname>INSTALL_SCRIPT</varname></term>
      <listitem><para>シンボルを取り除くことのできないバイナリー</para></listitem></varlistentry>

      <varlistentry><term><varname>INSTALL_GAME</varname></term>
      <listitem><para>ゲームのバイナリー</para></listitem></varlistentry>

      <varlistentry><term><varname>INSTALL_LIB</varname></term>
      <listitem><para>共有静的ライブラリー</para></listitem></varlistentry>

      <varlistentry><term><varname>INSTALL_DATA</varname></term>
      <listitem><para>データファイル</para></listitem></varlistentry>

      <varlistentry><term><varname>INSTALL_GAME_DATA</varname></term>
      <listitem><para>ゲーム用のデータファイル</para></listitem></varlistentry>

      <varlistentry><term><varname>INSTALL_MAN</varname></term>
      <listitem><para>マニュアルページ</para></listitem></varlistentry>
    </variablelist>

    <para>これらのほか、以下の変数があります。</para>

    <variablelist>
      <varlistentry><term><varname>INSTALLATION_DIRS</varname></term>

      <listitem><para>pkgsrc が <emphasis>install</emphasis>
      相の最初に作成するディレクトリーを
      <varname>PREFIX</varname> からの相対位置表記で並べたリストです。
      パッケージは、ファイルをインストールする前に、
      必要なディレクトリーをすべて自力で作成することになるので、
      その他のディレクトリーをすべてここに列挙します。
      </para></listitem></varlistentry>

    </variablelist>

    <para>稀な場合として、パッケージが何もインストールしないような場合は、
    <varname>NO_INSTALL</varname> を <quote>yes</quote> に設定します。
    これはほとんどの場合、<filename>regress</filename>
    カテゴリーのパッケージに関するものです。</para>
  </sect1>

  <sect1 id="build.package">
    <title><emphasis>package</emphasis> 相</title>

    <para>install 期が完了すると、
    インストールされたファイルからなるバイナリーパッケージを作ることができます。
    このようなバイナリーパッケージは、たとえば
    <command>make bin-install</command> するか、
    <command>pkg_add</command> を使って、それまでのコンパイルの過程を踏まずに、
    迅速にインストールすることができます。</para>

    <para>標準では、バイナリーパッケージは
    <filename>${PACKAGES}/All</filename> に作られ、また、
    <varname>CATEGORIES</varname> 変数に設定されたカテゴリーごとに
    <filename>${PACKAGES}/<replaceable>category</replaceable></filename>
    にシンボリックリンクが作られます。<varname>PACKAGES</varname>
    は標準では <filename>pkgsrc/packages</filename> になります。</para>
  </sect1>

  <sect1 id="build.clean">
    <title>掃除をする</title>

    <para>パッケージの作業が終わったら、<command>make clean</command>
    を実行して作業ディレクトリーを掃除することができます。
    依存パッケージの作業ディレクトリーもすべて掃除したい場合は、
    <command>make clean-depends</command> を使います。</para>
  </sect1>

  <sect1 id="build.helpful-targets">
    <title>他の役に立つターゲット</title>

    <variablelist>
      <varlistentry>
	<term>pre/post-*</term>

	<listitem>
	  <para>前のセクションで述べた主ターゲットのために、二つの補助ターゲットが存在し
	  ます。これは主ターゲットに<quote>pre-</quote>や<quote>post-</quote>というプレフィックスをつけ
	  たものです。これらのターゲットは、特別な設定やインストール手順のために、
	  主ターゲットが実行される前や後に、パッケージの Makefile から実行されます。例えば、プログラムのコンフィ
	  ギュレーションスクリプトやインストールターゲットが省略された場合に有用で
	  す。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>do-*</term>

	<listitem>
	  <para>主なターゲットがおかしな動作をし、それを修正するための変数が存在しない場
	  合、do-*ターゲットを使用することにより、それらを再定義することができます
	  (do-*ターゲットのかわりに、ターゲット自体を再定義してはいけません。pre-*
	  やpost-*ターゲットが実行されなくなってしまいます)。通常、再定義する必要
	  はありません。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>reinstall</term>

	<listitem>
	  <para>もし、<command>make install</command>実行後に、いくつかのファイルがきちんとインストール
	  されなかった事に気がついた場合、このターゲットを使い、再びインストールす
	  る事ができます。この場合、<quote>インストール済み</quote>フラグは無視されます。</para>

	  <para>これは、<varname>DEPENDS_TARGET</varname>
	  の標準の値です。ただし <command>make update</command> および <command>make
	  package</command> の場合は例外であり、これらについてはそれぞれ
	  <quote>package</quote> および <quote>update</quote>
	  が標準の値になります。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>deinstall</term>

	<listitem>
	  <para>このターゲットは、パッケージをアンインストールするためにカレントディレク
	  トリーで&man.pkg.delete.1;を実行します。動作を制御するために、以下の変数を
	  使用することができます。</para>

	  <variablelist>
	    <varlistentry>
	      <term><varname>PKG_VERBOSE</varname></term>

	      <listitem>
		<para>&man.pkg.delete.1;コマンドに「-v」オプションを渡します。</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><varname>DEINSTALLDEPENDS</varname></term>

	      <listitem>
		<para>指定されたパッケージに必要な(依存する)すべてのパッケージを削除します。
		このターゲットは、指定されたパッケージによってインストールされたパッ
		ケージを削除するために使用されます。例えば、<command>make deinstall
		DEINSTALLDEPENDS=1</command>が<filename>pkgsrc/x11/kde</filename>で実行された場合、KDE全体を削除し
		ます。&man.pkg.delete.1;のコマンドラインに<quote>-R</quote>を指定すると設定されます。</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>bin-install</term>

	<listitem>
	  <para>バイナリーパッケージを、
	  ローカルディスクまたは列挙された FTP サイト
	  (<varname>BINPKG_SITES</varname> 変数を参照)
	  からインストールし、
	  利用可能なバイナリーパッケージがどこにもない場合には
	  <command>make package</command> をおこないます。
	  <command>pkg_add</command> 用の引数、たとえば饒舌な操作などを
	  <varname>BIN_INSTALL_FLAGS</varname>
	  に設定することができます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>update</term>

	<listitem>
	  <para>このターゲットは、現在のパッケージを最新のものに更新します。最初にパッケー
	  ジと、それに依存するすべてのパッケージをアンインストールします。それから
	  最新のバージョンのパッケージをコンパイル、インストールします。これは、現
	  在どのパッケージがインストールされているかを調べ、<command>make deinstall</command>、
	  <command>make install</command>(または、<varname>UPDATE_TARGET</varname>で設定されたターゲット)を続けて実
	  行するのと同じです。</para>

	  <para>以前に実行した<command>make
	  update</command>がさまざまな理由で中断された場合、パッケー
	  ジの更新のために、このターゲットを使用することができます。
	  ただし、この場
	  合は、<command>make clean</command>を実行していない事、あるいは<varname>WRKDIR</varname>の依存パッケー
	  ジのリストを削除していない事を確認してください。そうでなければ、インストー
	  ル済みの依存パッケージを使用し、現在のパッケージを自動更新することができ
	  ません。</para>

	  <para>中断された<command>make
	  update</command>の再開は、パッケージツリーの他の部分が変更され
	  ていない場合に限って動作します。更新対象のパッケージのソースコードが変更
	  されていた場合は、<command>make update</command>の再開はきっと失敗するでしょう。</para>

	  <para><command>make
	  update</command>の動作を変更するために、以下の変数をコマンドライン、また
	  は&mk.conf;で使うことができます。</para>

	  <variablelist>
	    <varlistentry>
	      <term><varname>UPDATE_TARGET</varname></term>

	      <listitem>
		<para>更新されたパッケージや依存パッケージのために再帰的に使用されるインス
		トールターゲット。
		<command>make update</command>用のデフォルトは、<varname>DEPENDS_TARGET</varname>が
		設定されている場合はその値、それ以外の場合は<quote>install</quote>です。
		これら以外のターゲットのよい例としては <quote>package</quote> や
		<quote>bin-install</quote> があります。
		ここで <quote>update</quote> を設定してはいけません
		(無限ループに陥ってしまいます)。</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><varname>NOCLEAN</varname></term>

	      <listitem>
		<para>更新した後、きれいに掃除をしません。調査やその他の目的のために、更新
		されたパッケージの作業用ソース等をそのままにしておきたい場合に役に立
		ちます。最終的にはソースツリーを掃除してください(以下の
		<quote>clean-update</quote>ターゲットを見てください)。そうしなければ、次回の
		<command>make</command>や<command>make
		update</command>の時に古いソースコードが残っていることで
		トラブルがおこるかもしれません。</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><varname>REINSTALL</varname></term>

	      <listitem>
		<para>インストール(make <varname>DEPENDS_TARGET</varname>)の前に各パッケージをアンインストー
		ルします。これは、<command>make
		update</command>の実行中断後に<quote>clean-update</quote>ターゲット
		(以下参照)が呼ばれた場合に必要となることがあります。</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><varname>DEPENDS_TARGET</varname></term>

	      <listitem>
		<para>再帰を無効化し、パッケージのターゲットをハードコードすることができま
		す。updateターゲット用のデフォルトは<quote>update</quote>であり、事前に必要なパッ
		ケージを再帰的に更新するようになっています。<varname>DEPENDS_TARGET</varname>を設定する
		のは、再帰的な更新を無効化したいときだけにしてください。<command>make update</command>
		(後述します)の最中にインストールされる各パッケージに対して、特定のター
		ゲットを指定するだけの場合は、これのかわりに<varname>UPDATE_TARGET</varname>を使ってく
		ださい。</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>clean-update</term>

	<listitem>
	  <para>カレントディレクトリーで<command>make update</command>が実行された時に更新されるすべて
	  のパッケージのソースツリーを掃除します。カレントパッケージ(あるいは、依
	  存パッケージ)がすでにアンインストールされている(例えば<command>make update</command>を実行
	  した後)場合には、このターゲットを使ってはいけません。もし使用すると、更
	  新するつもりのパッケージのいくつかを失う可能性があります。経験的には、初
	  めて<command>make update</command>を実行する<emphasis>前</emphasis>、あるいは汚れたパッケージツリーがある場
	  合(例えば<varname>NOCLEAN</varname>を使用した場合)にのみ使用するとよいでしょう。</para>

	  <para>パッケージのツリーが掃除されているかどうかわからない場合は、ツリーの最上
	  層で<command>make
	  clean</command>を実行するか、更新しようとしているパッケージのディレクト
	  リーで以下のコマンドをこの順に使うか、どちらかをおこなうことができます。
	  (<command>make update</command>を初めて実行するより<emphasis>前</emphasis>におこなってください。それ以外の場
	  合、更新しようとしているパッケージをすべて失ってしまいます)</para>

	  <screen>
&rprompt; <userinput>make clean-update</userinput>
&rprompt; <userinput>make clean CLEANDEPENDS=YES</userinput>
&rprompt; <userinput>make update</userinput>
	  </screen>

	  <para><command>make
	  clean-update</command>の動作を変更するために、以下の変数をコマンドライン、
	  または&mk.conf;で使うことができます。</para>

	  <variablelist>
	    <varlistentry>
	      <term><varname>CLEAR_DIRLIST</varname></term>

	      <listitem>
		<para><command>make clean</command>の後で、パッケージのためのディレクトリーのリストを再構
		築しません。<command>make update</command>で、更新したいすべてのパッケージがインストー
		ルされた場合にのみ使用してください。通常、これは<command>make update</command>で自動
		的に実行されます。ただし、<varname>NOCLEAN</varname>変数の設定によって実行されない事もあ
		ります(上を参照してください)。</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>replace</term>

	<listitem>
	  <para>当該パッケージのインストールを更新します。
	  依存するパッケージの置き換えをおこなわないという点で
	  update と異なります。
	  このターゲットを動作させるためには、<filename
	  role="pkg">pkgtools/pkg_tarup</filename>
	  をインストールする必要があります。</para>

	  <para><emphasis>このターゲットは注意して使ってください。
	  </emphasis> このターゲットを使って更新した後に、
	  依存するパッケージが動作するという保証はありません。
	  特に、ライブラリーのパッケージで、
	  共有ライブラリーのメジャーバージョンが変わるようなものを
	  <command>make replace</command>
	  した場合は、ほぼ確実に壊れます。
	  このため、このターゲットは公式にはサポートされておらず、
	  熟練した利用者だけが使うことを推奨します。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>info</term>

	<listitem>
	  <para>このターゲットは、現在のパッケージに対して&man.pkg.info.1;をおこないます。これ
	  を使って、インストールされているパッケージのバージョンを調べる
	  ことができます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>index</term>

	<listitem>
	  <para>これは最上層用のコマンド、つまり <filename>pkgsrc</filename>
	  ディレクトリーで使うコマンドです。
	  ローカルの pkgsrc ツリー内の全パッケージのデータベースを作成します。
	  このデータベースには、依存性、コメント、メンテナー、
	  その他の有用な情報が含まれます。
	  個々のパッケージのエントリーは、当該パッケージのディレクトリーで
	  <command>make describe</command> を実行して作成されます。
	  作成された索引ファイルは
	  <filename>pkgsrc/INDEX</filename> に保存されます。
	  この索引は、<command>make
	  print-index</command> を実行すると、饒舌な形式で表示することができます。
	  <command>make search
	  key=<replaceable>something</replaceable></command>
	  を使って、索引を検索することができます。
	  <command>make show-deps
	  PKG=<replaceable>somepackage</replaceable></command>
	  を実行して、特定のパッケージに依存するパッケージをすべて調べることができます。</para>

	  <para>このコマンドの実行には、非常に長い時間がかかります。
	  速いマシンでも数時間かかるでしょう。</para>
	</listitem>
      </varlistentry>


      <varlistentry>
	<term>readme</term>

	<listitem>
	  <para>このターゲットは、
	  <filename>README.html</filename>ファイルを作成します。このファイルは <filename
	  role="pkg">www/firefox</filename>や <filename
	  role="pkg">www/links</filename>のようなブラウザー
	  で閲覧することができます。作成されたファイルは、ローカルホストの
	  <varname>PACKAGES</varname>ディレクトリーにあるパッケージへの参照を含んでいます。また、
	  <varname>FTP_PKG_URL_HOST</varname>と<varname>FTP_PKG_URL_DIR</varname>を元にしたURLを参照させることもできます。
	  例えば、ローカルマシン上の<filename>/usr/packages</filename>ディレクトリーのバイナリーパッ
	  ケージを参照する<filename>README.html</filename>ファイルを作成したい場合、
	  <varname>FTP_PKG_URL_HOST=file://localhost</varname>と<varname>FTP_PKG_URL_DIR=/usr/packages</varname>をセット
	  してください。<varname>${PACKAGES}</varname>ディレクトリーと、そのサブディレクトリーはすべ
	  てのバイナリーパッケージで検索されます。</para>

	  <para>このターゲットは、最上層またはカテゴリーのディレクトリーで実行することもできます。
	  そうした場合は、配下のパッケージに対して再帰的に実行されます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>readme-all</term>

	<listitem>
	  <para>これは最上層用のコマンドであり、<filename>pkgsrc</filename> で実行します。
	  このターゲットを使い、<filename>README-all.html</filename>を作成することができます。このファ
	  イルは&os;パッケージコレクションの中の、現在利用可能なすべてのパッケー
	  ジのリスト、また、それらが属するカテゴリーと簡単な説明を含んでいます。こ
	  のファイルは<filename>pkgsrc/*/README.html</filename>から作りだされます。したがって、<command>make
	  readme</command>
	  の<emphasis>後</emphasis>に、このターゲットを実行してください。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>cdrom-readme</term>

	<listitem>
	  <para>これは<quote>readme</quote>ターゲット(上を見てください)とほとんど同じですが、CD-ROMに焼
	  かれるpkgsrcツリーを作る時に使われます。また、このターゲットは
	  <filename>README.html</filename>ファイルを作成し、<varname>CDROM_PKG_URL_HOST</varname>と<varname>CDROM_PKG_URL_DIR</varname>に基づ
	  くURLへの参照を作ります。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>show-distfiles</term>

	<listitem>
	  <para>このターゲットは、パッケージを構築するために、どのdistfileやパッチファイ
	  ルが必要か (<varname>ALLFILES</varname>:
	  <varname>DISTFILES</varname>および<varname>PATCHFILES</varname>をすべて含みますが、
	  <filename>patches/*</filename>は含みません) を表示します。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>show-downlevel</term>

	<listitem>
	  <para>このターゲットは、パッケージがインストールされていない場合は何も表示しま
	  せん。もし、あるバージョンのパッケージがインストールされているが、現在の
	  pkgsrcのバージョンでインストールされたものでない場合、警告メッセージを表
	  示します。このターゲットは、インストール済みのパッケージが古いバージョン
	  であり、そのバージョンが削除可能で、最新の物が追加されることを表示するた
	  めに使用されます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>show-pkgsrc-dir</term>

	<listitem>
	  <para>当該パッケージの構築とインストールが可能な、パッケージ階層におけるディレ
	  クトリーを表示します。このディレクトリーは、そのパッケージがインストール
	  された際のディレクトリーと同じとは限りません。このターゲットは、単一ホス
	  ト上で多数のパッケージの更新をしたい場合に使うためのもので、pkgsrc の最
	  上層のMakefileから<quote>show-host-specific-pkgs</quote>ターゲットで呼び出すことがで
	  きます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>show-installed-depends</term>

	<listitem>
	  <para>このターゲットは、インストールされているパッケージのうち、どれが当該パッ
	  ケージの<varname>DEPENDS</varname>と合致するかを表示します。依存関係が古いせいで構築に問題が
	  起きる場合に便利です。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>check-shlibs</term>

	<listitem>
	  <para>パッケージのインストール後に、すべてのバイナリーおよび(ELFプラットフォー
	  ムでは) 共有ライブラリーが必要な共有ライブラリーを見つけられるかどうか確
	  認します。&mk.conf;で<varname>PKG_DEVELOPER</varname>が設定されている場合はデフォルトで
	  実行します。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>print-PLIST</term>

	<listitem>
	  <para>パッケージを新規に、または更新のために<quote>make install</quote>した後、
	  <command>find -newer
	  work/.extract_done</command>をもとに新しい<filename>PLIST</filename>を生成して表示します。PLIST生成は、
	  共有ライブラリーなどに配慮して行われますが、生成した結果を<filename>PLIST</filename>に置く前
	  に再確認するよう<emphasis>強く</emphasis>おすすめします。パッケージ更新時には、このコマンド
	  の出力と、更新前の<filename>PLIST</filename>ファイルとを比較すると便利でしょう。</para>

	  <para>パッケージが、&man.tar.1;その他のファイルのアクセス時刻を更新しない方法を使っ
	  てファイルをインストールする場合は、それらのファイルはこのターゲットで使われる <quote>find
	  -newer</quote> コマンドで検
	  出されないので、手で<filename>PLIST</filename>に書き足すよう注意してください!</para>

	  <para>このターゲットに関するさらなる情報は、
	  <xref linkend="print-PLIST"/>を参照してください。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>bulk-package</term>

	<listitem>
	  <para>バルクビルドの実行に使われます。適切なバイナリーパッケージがすでに存在す
	  る場合は、何もしません。そうでない場合は、コンパイル、インストール、パッ
	  ケージ作成をおこないます
	  (<varname>PKG_DEPENDS</varname>が適切に設定されている場合は、依存するパッケージも。<xref linkend="binary.configuration"/>参照)。
	  バイナリーパッケージ作成後、ディスクの空き領域
	  を確保するために、ソース、インストールしたばかりのパッケージと依存パッケー
	  ジは削除されます。</para>

	  <para><emphasis>このターゲットを使うと、
	  システムにインストールされているパッケージをすべてアンインストールすることもあるので、
	  注意してください。</emphasis></para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>bulk-install</term>

	<listitem>
	  <para>依存パッケージ群をインストールするためのバルクインストールで使われます。
	  最新のバイナリーパッケージが利用可能な場合、&man.pkg.add.1;でそれをインストール
	  します。そうでない場合は、<command>make bulk-package</command>が実行されますが、インストー
	  ルされたバイナリーは削除されません。</para>

	  <para>バイナリーパッケージが<quote>最新</quote>であるとみなされる (&man.pkg.add.1; でインストールされる)
	  条件は、以下のとおりです。</para>

	  <itemizedlist>
	    <listitem>
	      <para>パッケージファイル
	      (<filename>Makefile</filename>, ...)が、いずれも構築時から変更されていな
	      いこと。</para>
	    </listitem>

	    <listitem>
	      <para>そのパッケージが依存している(バイナリー)
	      パッケージが、いずれも構築時から変更されていないこと。</para>
	    </listitem>
	  </itemizedlist>

	  <para><emphasis>このターゲットを使うと、
	  システムにインストールされているパッケージをすべてアンインストールすることもあるので、
	  注意してください。</emphasis></para>
	</listitem>
      </varlistentry>
    </variablelist>
  </sect1>
</chapter>
