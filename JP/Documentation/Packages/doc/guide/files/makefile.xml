<!-- $NetBSD: makefile.xml,v 1.22 2007/03/08 16:00:16 rillig Exp $ -->
<!-- Based on english version: -->
<!-- NetBSD: makefile.xml,v 1.22 2007/03/08 16:00:16 rillig Exp   -->

<chapter id="makefile"> <?dbhtml filename="makefile.html"?>
  <title><filename>Makefile</filename> におけるプログラミング</title>

  <para>pkgsrc は、多くの <filename>Makefile</filename> の断片からなっており、
  この各断片が、pkgsrc システムの各部分を明確に形成しています。
  pkgsrc のような大規模なシステムのプログラミング言語として &man.make.1;
  システムを使う場合、コードを適切かつわかりやすい状態に保つために、
  いくらかの規律が必要です。</para>

  <para><filename>Makefile</filename> プログラミングの基本的な構成要素は、
  変数 (実はマクロ) とシェルコマンドです。
  シェルコマンドは、&man.awk.1; プログラムのような複雑なものになることもあります。
  各シェルコマンドを意図どおりに動かすため、変数を使うときは、
  すべての変数を適切にクォートすることが必要です。</para>

  <para>本章では、<filename>Makefile</filename>
  で頻出するいくつかのパターンと、
  それらに伴う落とし穴を説明します。</para>

  <sect1 id="makefile.style">
  <title>警告</title>

    <itemizedlist><listitem><para>ルールのターゲットとしてファイルを作る場合、
    常に、データをまず一時ファイルに書き込んでから、
    最後にファイル名を変えるようにしてください。
    そうしておかないと、ファイルの生成の途中にエラーが起きた場合、
    利用者が &man.make.1; を 2 回目に実行したときに、
    前回のファイルが存在したままとなり、ファイルが正しく再生成されません。
    たとえば、</para>

<programlisting>
    wrong:
            @echo "line 1" > ${.TARGET}
            @echo "line 2" >> ${.TARGET}
            @false

    correct:
            @echo "line 1" > ${.TARGET}.tmp
            @echo "line 2" >> ${.TARGET}.tmp
            @false
            @mv ${.TARGET}.tmp ${.TARGET}
</programlisting>

    <para><command>make wrong</command> を 2 回実行したときに、
    1 回目の実行でエラーメッセージが出ますが、
    ファイル <filename>wrong</filename> は作られた状態になります。
    一方、<command>make
    correct</command> を実行すると、エラーメッセージが 2 回出るという、
    期待どおりの動作となります。</para>
    
    <para>エラーの場合には &man.make.1; が <literal>${.TARGET}</literal>
    を削除することがあるということをご存知かもしれませんが、
    この削除は、たとえば <literal>^C</literal> を押すなど、
    割り込みがあった場合にのみおこなわれます。コマンドのどれかが
    (上の例の &man.false.1; のように) 失敗した場合には、
    削除は<emphasis>おこなわれません</emphasis>。</para>
    
    </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="makefile.variables">
    <title><filename>Makefile</filename> 変数</title>

    <para><filename>Makefile</filename> 変数は文字列を値として持ち、
    文字列は 5 種類の演算子  ``='', ``+='', ``?='',
    ``:='', ``!='' を使って操作することができます。演算子については
    &man.make.1; マニュアルページに説明があります。</para>

    <para><filename>Makefile</filename> の変数が解釈される際、
    ハッシュ文字 ``#'' とバックスラッシュ文字  ``\'' は特別扱いされます。
    バックスラッシュに改行が続く場合、当該バックスラッシュの直前にあるあらゆる空白・
    当該バックスラッシュ・改行・改行の直後にあるあらゆる空白は、
    ひとつのスペースに置き換えられます。
    バックスラッシュ文字とその直後に続くハッシュ文字は、
    ひとつのハッシュ文字に置き換えられます。
    以上の場合以外は、バックスラッシュはそのまま渡されます。
    変数への代入の際は、ハッシュ文字 (その前にバックスラッシュがないもの)
    はコメントの開始となり、そこから論理行の最後までがコメントとなります。</para>

    <para><emphasis>註:</emphasis> このようなアルゴリズムで解釈されるせいで、
    バックスラッシュ一文字を値として持つ変数を作るには、
    ``!='' 演算子を使う方法しかありません。たとえば以下のようにします: <!-- FIXME
    --><varname>BACKSLASH!=echo "\\"</varname>.</para>

    <para>以上は、変数の定義に関する説明です。このほか、変数に関してできることは、
    変数を評価することです。変数が評価されるのは、変数が ``:='' または ``!=''
    演算子の右辺にある場合と、変数がシェルコマンドの一部となっている場合
    (コマンドが実行される直前に評価される) です。これら以外の場合、
    &man.make.1; は遅延評価をおこないます。つまり、
    変数は他の処理がすべてすんだ後に評価されます。
    このほか、マニュアルページに記載されている「修飾子」も、
    変数を評価します。</para>

    <para>修飾子のなかには、文字列を語に分割してから、分割した語に対して操作をするものがあります。
    それ以外の修飾子は、文字列全体に対して操作をします。
    文字列が語に分割される場合、その分割は、
    &man.sh.1; の解釈と同様の方式でおこなわれます。</para>

    <para>例外のない規則はありません&mdash; <command>.for</command>
    ループはシェルのクォートの規約には従わず、
    空白の並びで分離します。</para>

    <para>変数には、取り扱い方が異なる複数の種類の変数があります。
    文字列 (strings) と、二種類のリストです。</para>

    <itemizedlist>

      <listitem><para>文字列 (<emphasis>strings</emphasis>) には、
      任意の文字を含めることができます。とはいえ、
      使うのは印字可能文字だけにしておくのがよいでしょう。
      例としては <varname>PREFIX</varname> や
      <varname>COMMENT</varname> があります。</para></listitem>

      <listitem><para>内部リスト (<emphasis>internal lists</emphasis>) は、
      シェルコマンドに決して渡されることのないリストです。
      内部リストの要素は空白で区切られます。このため、
      要素自体に空白を含めることはできません。空白以外の文字はすべて使うことができます。
      内部リストは <command>.for</command> ループ内で使うことができます。
      例としては <varname>DEPENDS</varname> や
      <varname>BUILD_DEPENDS</varname> があります。</para></listitem>

      <listitem><para>外部リスト (<emphasis>external lists</emphasis>) は、
      シェルコマンドに渡すことのできるリストです。外部リストの要素には、
      空白を含む任意の文字を含めることができます。このことが理由で、
      外部リストは <command>.for</command> ループ内では使うことができません。
      例としては <varname>DISTFILES</varname> や
      <varname>MASTER_SITES</varname> があります。</para></listitem>

    </itemizedlist>

    <sect2 id="makefile.variables.names">
      <title>命名規約</title>

      <itemizedlist>

	<listitem><para>下線で始まる変数名はすべて、
	pkgsrc の基盤が使うために予約されています。
	そのような変数名はパッケージの
	<filename>Makefile</filename> では使ってはいけません。</para></listitem>

	<listitem><para><command>.for</command> ループでは、
	反復変数の変数名は小文字にします。
	</para></listitem>

	<listitem><para>リスト変数はすべて、<varname>PKG_OPTIONS</varname> や
	<varname>DISTFILES</varname> のように、
	「複数形」の名前にします。</para></listitem>

      </itemizedlist>
    </sect2>

  </sect1>

  <sect1 id="makefile.code">
    <title>コードの断片</title>

    <para>本節では、読者がコードを書く際に使うことになるコードの断片を
    いくつか説明します。適当なコードがここに載っていない場合は、
    あなたのコードをテストして、ここに追加してください。</para>

    <sect2 id="adding-to-list">
      <title>リストに要素を追加する</title>

<programlisting>
    STRING=                 foo * bar `date`
    INT_LIST=               # empty
    ANOTHER_INT_LIST=       apache-[0-9]*:../../www/apache
    EXT_LIST=               # empty
    ANOTHER_EXT_LIST=       a=b c=d

    INT_LIST+=              ${STRING}               # 1
    INT_LIST+=              ${ANOTHER_INT_LIST}     # 2
    EXT_LIST+=              ${STRING:Q}             # 3
    EXT_LIST+=              ${ANOTHER_EXT_LIST}     # 4
</programlisting>

      <para>文字列を外部リストに追加する場合 (例 3) は、
      その文字列をクォートする必要があります。それ以外の場合は、
      クォートを追加してはいけません。内部リストと外部リストは、
      その各要素がどちらのリストでも適切に処理されることが確実な場合をのぞき、
      統合してはいけません。</para>

    </sect2>

    <sect2 id="converting-internal-to-external">
      <title>内部リストを外部リストに変換する</title>

<programlisting>
    EXT_LIST=       # empty
    .for i in ${INT_LIST}
    EXT_LIST+=      ${i:Q}""
    .endfor
</programlisting>

      <para>このコードは、内部リスト
      <varname>INT_LIST</varname> を外部リスト
      <varname>EXT_LIST</varname> に変換します。内部リストの要素はクォートされていないので、
      変換に際してはクォートする必要があります。
      <varname>""</varname> を追加する理由は後述します。</para>

    </sect2>

    <sect2 id="passing-variable-to-shell">
      <title>シェルコマンドに値を渡す</title>

	<para>時には、任意の文字列を出力したいことがあるかもしれません。
	不具合を起こす方法はたくさんありますが、
	どんな複雑なものも扱えるような方法は少ししかありません。</para>

<programlisting>
    STRING=         foo bar <    > * `date` $$HOME ' "
    EXT_LIST=       string=${STRING:Q} x=second\ item

    all:
            echo ${STRING}                  # 1
            echo "${STRING}"                # 2
            echo "${STRING:Q}"              # 3
            echo ${STRING:Q}                # 4
            echo x${STRING:Q} | sed 1s,.,,  # 5
            printf "%s\\n" ${STRING:Q}""    # 6
            env ${EXT_LIST} /bin/sh -c 'echo "$$string"; echo "$$x"'
</programlisting>

      <para>例 1 は、シェルで構文エラーを起こします。
      各文字がそのままコピーされるだけだからです。</para>

      <para>例 2 も構文エラーを起こします。また、<varname>${STRING}</varname> の末尾の "
      文字を除いた場合は、&man.date.1; が実行されてしまいます。
      また、<varname>$HOME</varname> シェル変数も評価されるでしょう。</para>

      <para>例 3 は、&man.echo.1; コマンドの実装によって、
      各空白文字の前にバックスラッシュが出力されたり、
      されなかったりします。</para>

      <para>例 4 は、最初の文字がダッシュでない文字列はすべて適切に処理します。
      文字列の最初の文字がダッシュの場合、結果がどうなるかは
      &man.echo.1; コマンドの実装に依存します。
      入力される文字列の最初の文字がダッシュにならないことを保証できる限りは、この形式は適切です。</para>

      <para>例 5 は、たとえ文字列がダッシュで始まっていたとしても、
      適切に処理します。</para>

      <para>例 6 も、あらゆる文字列を適切に処理できますし、
      それ自体に問題のあるパイプを使わないので、
      より軽い方法です。</para>

      <para><varname>EXT_LIST</varname> はクォートする必要はありません。
      なぜなら、リストに要素を追加した時に、
      すでにクォートされているからです。</para>

      <para>内部リストはシェルに渡されないものなので、
      例示はありません。</para>

    </sect2>

    <sect2 id="quoting-guideline">
      <title>クォートの指針</title>

      <para>変数が不適切にクォートされたソースは、多くありえます。
      本節では、よく知られている例をいくつか掲げます。</para>

      <itemizedlist>

	<listitem><para>リストの値を使うときは常に、
	値の冒頭や末尾にある空白がどうなるかを考えてください。
	リストが整形式のシェルの式である場合、それぞれの語から冒頭や末尾の空白を取り除くために、
	<varname>:M*</varname> 修飾子を使うことができます。
	<varname>:M</varname> 演算子は、最初にその引数をシェルの規約に従って分割してから、
	シェルのグロブ式 <varname>*</varname> にマッチする語 (つまり全部)
	すべてからなるリストを新たに作ります。
	これが必要となる状況は、<varname>CPPFLAGS</varname> のような変数を
	<varname>CONFIGURE_ARGS</varname> に追加する場合です。
	configure スクリプトが別の configure スクリプトから呼び出される場合、
	呼び出された側のスクリプトは変数から冒頭と末尾の空白を取り除き、
	それを別の configure スクリプトに渡します。しかし、この両 configure
	スクリプトは、(子の) <varname>CPPFLAGS</varname> 変数が
	親の <varname>CPPFLAGS</varname> と同じものであると見込んでいます。
	これが、<varname>CPPFLAGS</varname> の値を適切に切り取ったものを
	渡したほうがよい理由です。そして、以下に掲げるのは、その方法です。</para>

<programlisting>
    CPPFLAGS=               # empty
    CPPFLAGS+=              -Wundef -DPREFIX=\"${PREFIX:Q}\"
    CPPFLAGS+=              ${MY_CPPFLAGS}

    CONFIGURE_ARGS+=        CPPFLAGS=${CPPFLAGS:M*:Q}

    all:
            echo x${CPPFLAGS:Q}x            # 前後に空白がつく
            echo x${CONFIGURE_ARGS}x        # 適切に切り取られる
</programlisting></listitem>

	<listitem><para>上の例にはバグがひとつあります:
	<varname>${PREFIX}</varname> は適切にクォートされたシェルの式ですが、
	シェルの後には C コンパイラーがあり、こちらでも適切に
	(今度は C の文法で) クォートされている必要があります。
	このため、上で例示したものは、<varname>${PREFIX}</varname>
	の値にバックスラッシュや二重引用符が含まれていない場合に限って、
	正しいものになります。これらの文字を含めたい場合、
	C の文字列リテラルとして扱われる値をすべてクォートするために、
	もう一つの層を追加する必要があります。
	<varname>:Q</varname> 演算子はシェル用のクォートしかできないので、
	C コンパイラー用のクォートには使えません。</para></listitem>

	<listitem><para>値が空になりうる場合は、
	<varname>:Q</varname> 演算子が妙な結果を出すことがあります。
	以下に 2 種類のまったく異なる事例を掲げますが、
	どちらも同じ細工をすることで解決できます。</para>

<programlisting>
    EMPTY=                  # empty
    empty_test:
            for i in a ${EMPTY:Q} c; do \
                    echo "$$i"; \
            done

    for_test:
    .for i in a:\ a:\test.txt
            echo ${i:Q}
            echo "foo"
    .endfor
</programlisting>

	<para>一つ目の例では、3 行が表示されると思うかもしれませんが、
	そのうちの 2 行しか表示されません。これは、
	<varname>${EMPTY:Q}</varname> が空の文字列に展開され、
	シェルからは見えなくなるからです。回避策は、
	<varname>${EMPTY:Q}""</varname> と書くことです。このパターンは、
	<varname>${TEST} -z ${VAR:Q}</varname> や <varname>${TEST}
	-f ${FNAME:Q}</varname> のように、しばしば見られます
	(いずれも、間違いです)。</para>

	<para>二つ目の例では、表示されるのは 4 行ではなく 3 行です。
	最初に表示される行は <varname>a:\ echo foo</varname> のようになります。
	これは、値 <varname>a:\</varname> のバックスラッシュを
	&man.make.1; が継続行として処理し、2 行目が 1 行目の
	&man.echo.1; コマンドの引数になってしまうためです。
	これを防ぐには、<varname>${i:Q}""</varname>
	と書きます。</para></listitem>

      </itemizedlist>
    </sect2>

    <sect2 id="bsd-make-bug-workaround">
      <title>BSD Make のバグの回避方法</title>

      <para>pkgsrc の bmake プログラムは、以下のような代入を適切に処理することができません。
      <varname>_othervar_</varname> が ``-'' 文字を含んでいる場合、
      以下のコードを実行すると、閉じ中括弧のひとつが
      <varname>${VAR}</varname> に含まれてしまいます。</para>

<programlisting>
    VAR:=   ${VAR:N${_othervar_:C/-//}}
</programlisting>

      <para>もっと複雑なコードの断片と回避策については、
      <filename role="pkg">regress/make-quoting</filename> パッケージのテストケース
      <varname>bug1</varname> をご覧ください。</para>

    </sect2>

  </sect1>
</chapter>
