# $NetBSD: Packages.txt,v 1.28 2006/01/11 17:14:21 kano Exp $
# $Id: Packages.txt,v 1.28 2006/01/11 17:14:21 kano Exp $
###########################################################################

			==========================
			 NetBSDパッケージシステム
			   ドキュメンテーション
			==========================

		      Hubert Feyrer, Alistair Crooks


目次:
=====

目次作成にはこのコマンドを実行します:
 sed '/^.====/{g;p;};h;d' Packages.txt


 0 イントロダクション
 ====================

Unixベースのシステムには、自由に利用できるソフトウェアが数多く存在します。
これらは普通、またはいくつかの変更でNetBSDで実行できます。NetBSDパッケージ
コレクションは、一つのコマンドでそのソフトウェアにNetBSDで実行するのに必要
ないくらかの変更を施して、ソフトウェアパッケージのインストール(および再イン
ストール)を簡単にします。

NetBSDパッケージシステムは、自由に利用できるサードパーティーのソフトウェア
を、NetBSDホストで容易に構築することを可能にします。一旦ソフトウェアが構築
されればそれらはpkg_*ツールにより操作できるので、そのパッケージのインストー
ル、アンインストール、全てのインストールされたパッケージの目録の表示、一行
コメント、あるいはより詳細な説明の情報検索が全く簡単にできます。

NetBSDパッケージコレクションおよびNetBSDパッケージシステムは、FreeBSDに由来
しています。


 0.1 概要
 ========

このドキュメントは二部に別れています。第一部は「ユーザーガイド」で、パッケー
ジコレクションの一つのパッケージを使う方法を、コンパイル済みのバイナリー・
パッケージのインストールと、自分自身でコピーしたNetBSDパッケージシステムか
ら構築する方法の両方で説明します。第二部の「パッケージ構築者ガイド」は、他
のNetBSDユーザーがその構築の詳細について知らなくても簡単にパッケージを構築
できるようにするために、パッケージを用意する方法を説明します。


 0.2 専門用語
 ============

ここまでですでに「ポート(ports)」、「パッケージ(packages)」などについて何度
も触れています。ここで、このドキュメント中に使われている用語を説明します:

 * パッケージ(Package):
   ファイルのセットで、NetBSDパッケージシステムを使用したソフトウェアを構築
   するのに必要なことが記述された構築手順書です。パッケージは、伝統的に
   /usr/pkgsrcの下に置かれます。

 * NetBSDパッケージシステム:
   これは、NetBSDオペレーティングシステムの一部分で、パッケージの構築(コン
   パイル)、インストール、および削除を扱います。

 * Distfile:
   この用語は、自由に利用できるソフトウェアの作者が、彼の仕事を配布するため
   に提供しているファイルのことを指しています。NetBSDで構築するのに必要な全
   ての変更は、対応するパッケージに反映されます。通常distfileは、圧縮された
   tarアーカイブ形式ですが、他の形式でも使用できます。Distfilesは
   /usr/pkgsrc/distfilesの下に保存されます。

 * ポート(Port):
   これはFreeBSDの人たちが、私たちがパッケージ(package)と呼んでいるものを表
   すために使われている用語です。NetBSDでは「ポート(port)」は、異なるアーキ
   テクチャーを参照する用語となります。

 * コンパイル済み(バイナリー)パッケージ:
   NetBSDパッケージシステムを使ってdistfileより作成されたバイナリーのセット
   で、ひとつの.tgzファイルに集められています。これはリコンパイルなしに同じ
   マシンアーキテクチャーのマシンにインストールすることができます。パッケー
   ジはNetBSDパッケージシステムにより、/usr/pkgsrc/packagesに生成され、それ
   はftp.netbsd.orgにもアーカイブされています。

   時々、これは、特にコンパイル済みのパッケージの文脈で、単に「パッケージ」
   と表されることもあります。

 *プログラム:
   対応するパッケージが、Distfileにあるファイルから作成した、インストールさ
   れるべきソフトウェアのひとまとまりです。

 * NetBSD RCS ID:
   パッケージに含まれるいくつかのファイルは、そのファイルのバージョンに対応
   したRCS IDが含まれています(cvsにより自動的に挿入されます)。これらのIDは、
   このドキュメントの中のいくつかの例で使用されていますが、このドキュメント
   自体がCVSによって管理されていますので、生のRCS IDを列挙することができま
   せん。かわりに、$は<$>のように記していますので、<$>NetBSD<$>や<$>Id<$>と
   なります。


 0.3 体裁
 ========

今のところ、この文書はプレインテキストで書かれているので、適用できる体裁は
あまりありません。将来の版では、HTMLやDocBookのような表現力のすぐれた形式に
移行するかもしれません。

コマンドの実行例を示す場合、そのコマンドをrootで実行しなければならない/する
ことができるか、「一般の」ユーザー権限で十分であるかを、シェルプロンプトで
区別します。Cシェルかtcshを使っているものとして、rootのシェルプロンプトには
"#"を、一般ユーザーのシェルプロンプトには"%"を使います。


======================
第一部: ユーザーガイド
======================

 1 コンパイル済みのバイナリー・パッケージのインストール
 ======================================================

このセクションは、あなたの機種用にすでに準備されたコンパイル済みのバイナリー・
パッケージを見つけ、取得してインストールする方法について説明します。


 1.1 どこから入手するか
 ======================

コンパイル済みのパッケージは、ftp.netbsd.orgおよびそのミラー上の、匿名FTPア
クセスのためのディレクトリー/pub/NetBSD/packagesに置かれています。"uname
-p"で表示されるのと同じサブディレクトリーを選択してください。このディレクト
リーの中には、カテゴリー毎のサブディレクトリーと、「All」サブディレクトリー
が存在しています。「All」サブディレクトリーの中には、.tgzファイル形式で実際
のバイナリーがあります。カテゴリー毎のサブディレクトリーは、これらのファイ
ルへのシンボリックリンクを使用しています。(/usr/pkgsrc/packagesと同じディレ
クトリー・レイアウトです)。

CDROMディストリビューションでも、このディレクトリー・レイアウトは同じで、単
にディレクトリーのルートが異なるだけです。たぶん/cdromかどこかの下でしょう。
正確なディレクトリーは、CDROMのドキュメンテーションを参照してください。


 1.2 使用方法
 ============

もし、コンパイル済みのパッケージのファイルがCDROM上にある、あるいはハードディ
スク上にダウンロードされているのであれば、以下のコマンドでインストールする
ことができます(最初にrootにsuしている事を確認してください):

	# pkg_add /path/to/package.tgz

もし、FTPアクセスが可能で、インストール前にFTPを使ってパッケージをダウンロー
ドしたくないのであれば、pkg_addにftpのURLを指定して自動でダウンロードさせる
事もできます。

	# pkg_add ftp://ftp.netbsd.org/pub/NetBSD/packages/<OS Ver>/<arch>/All/package.tgz

ここで <OS Ver> や <arch> がよくわからない場合は、unameユーティリティーを
"uname -rp"のように使って調べられます。

また、パッケージを実行するためにあらかじめ必要な他のパッケージがインストー
ルされるかもしれない事にも注意してください。一緒にインストールされる他のパッ
ケージも同じ場所に存在していると仮定されます。

パッケージをインストールした後に、$PATHに /usr/pkg/bin が含まれている事を確
認してください。これで、インストールされたプログラムを実際に使い始めること
ができます。


 1.3 警告
 ========

マニュアル・ページで警告されている、自分自身で作ったものでないバイナリー・
パッケージをインストールすることが孕む危険性、無思慮にこのようなファイルを
インストールすることにより、あなたのシステムにセキュリティーホールが生じる
事についてよく注意してください。


 2 構築しインストールする
 ========================

ここでは、パッケージがすでにNetBSDパッケージ・システムに含まれていると仮定
しています。もし、そうでなれば、このドキュメントの第二部「パッケージ構築者
ガイド」を読む事をお勧めします。


 2.1 必要なもの
 ==============

NetBSDシステム上で、ソースからパッケージを構築するためには、"comp"および
"text"配布物一式をインストールしておく必要があります。X11関連のパッケージを
構築する場合は、さらに"xbase"および"xcomp" 配布物一式も必要です。


 2.2 どこからpkgsrcを得るか
 ==========================

pkgsrcには三つの入手方法があります。tarファイル、SUP経由、そしてCVS経由です。
ここではこの三つとも説明します。

パッケージのソースを入手するためには、pkgsrc.tar.gzファイルを
ftp://ftp.netbsd.org/pub/NetBSD-current/tar_files/pkgsrc.tar.gzから取得し、
/usr/pkgsrcに展開する必要があります。

あるいは、ソフトウェア更新プロトコル(Software Update Protocol) SUPを使い
pkgsrcを入手することもできます。まず、supfileの中に「release=pkgsrc」という
行があることを確認してください。例えば、/usr/share/examples/supfilesを見て
ください。それからディレクトリー/usr/pkgsrcが存在することを確認してください。
後は「sup -v /path/to/your/supfile」を実行するだけです。

CVS経由でpkgsrcを入手するためには、cvsがインストールされていることが必要で
す。お使いのシステムにcvsがない場合は、コンパイル済バイナリーが
ftp.netbsd.orgにあります。pkgsrcを初めて(完全に)チェックアウトする際は、以
下の手順を踏みます:

	% setenv CVSROOT anoncvs@anoncvs.netbsd.org:/cvsroot
	% setenv CVS_RSH ssh 
	% cd /usr
	% cvs checkout -P pkgsrc

こうすると、/usr以下に"pkgsrc"ディレクトリーが作られ、/usr/pkgsrc以下に全パッ
ケージのソースが入った状態になります。一旦チェックアウトしたpkgsrcを更新す
るには、CVS_RSHを上のように設定してから、以下のようにします:

	% cd /usr/pkgsrc
	% cvs -q update -dP

また、pkgsrcの階層構造を、使用中の状態で複数持つことも常にできます - すべて
の作業は、pkgsrcツリーに対する相対位置で実行されます。


 2.3 配布ファイルの取得
 ======================

ひとつ注意しておくことがあります:パッケージシステムを構築するためには、ディ
ストリビューション・ファイル(未変更のソース)がシステム上に存在していなけれ
ばなりません。もし、存在しない場合は配布ファイルを取得するために自動的に
ftp(1)が実行されます。

主要なディストリビューション・サイトをあなたのところに近いサイトで上書きす
ることができます。pkgsrc/mk/bsd.pkg.defaults.mkの例の、特にMASTER_SORT,
MASTER_SORT_REGEX, INET_COUNTRY 定義を参照してください。これにより、帯域幅
と時間が節約できるかもしれません。

これらの設定は、シェルの環境変数でも変更できますし、その設定を今後も有効に
したければ、/etc/mk.confファイルにその定義を書き加えておくこともできます。

もし、インターネットへ常時接続しておらず、ダウンロードするファイルを知りた
い場合は、「make fetch-list」を実行すれば、必要なファイルがわかります。それ
らの配布ファイルを/usr/pkgsrc/distfilesに置いてください。


 2.4 構築とインストール方法
 ==========================

配布ファイルの取得(前節参照)が完了したら、rootになり適切なディレクトリーに
移動してください。そして、シェル・プロンプト上で以下のようにタイプしてくだ
さい。

	% make

これで、パッケージのさまざまなコンポーネントが構築されます。それから、

	# make install

とシェル・プロンプト上でタイプしてください。これにより、さまざまなコンポー
ネントが適切な場所にインストールされます。

topシステム・ユーティリティーを例にあげると、付録A.1のように構築することに
より、システムにインストールすることができます。

プログラムはパッケージ・ツリーのデフォルト・ルート- /usr/pkgにインストール
されます。もし、このディレクトリーが趣味にあわないのであれば、環境変数
LOCALBASEを設定してください。この値はパッケージ・ツリーのルートとして使用さ
れます。例えば、/usr/localを使う場合、

	LOCALBASE=/usr/local

と設定してください。なお、ルートにはパッケージ専用の場所を使うべきであり、
他のプログラムと共有させてはいけません(つまり、 LOCALBASE=/usr などとしては
いけません)。また、LOCALBASEツリー内には、独自のファイルやディレクトリー(た
とえば、src, obj, pkgsrcのようなもの)は一切追加しないようにしてください。こ
れは、パッケージシステムがインストールするプログラムなどのファイルが、そこ
にインストールされているかもしれない別のファイルと衝突することがないように
するためです。

もちろん、ひとつ例外があります。X11パッケージは伝
統的にX11ツリーにインストールされます。X11ツリーのルートの決定には、X11BASE
の定義が使われます。

X11パッケージをLOCALBASEツリーにインストールすることもできます。このために
は、xpkgwedgeパッケージ(pkgsrc/pkgtools/xpkgwedge)をインストールしなければ
なりません- 詳細はセクション7.1をご覧ください。

いくつかのパッケージは、構築時にいくつかのコンフィギュレーションオプション
を変えるために/etc/mk.confを参照します。デフォルトの設定項目については、
pkgsrc/mk/bsd.pkg.defaults.mkをのぞいてみてください。LOCALBASEやX11BASEといっ
た環境変数は、pkgsrc使用時に毎回使えるように/etc/mk.confで設定しておくこと
ができます。

時々、 パッケージの構築やインストールの際に、「水面下」で何が起きているかを
見たいことがあります。これは、デバッグのためなのかもしれませんし、好奇心が
高じたものかもしれません。このような用途に使うための変数がいくつも用意され
ています。

(1) makeコマンドをPKG_DEBUG_LEVEL=2付きで呼び出すと、大量の情報が表示される
ようになります。実際の例として、

	make patch PKG_DEBUG_LEVEL=2

は、"patchの段階"および、そこに至るまでに呼び出されるコマンドをすべて表示し
ます。

(2) 特定のmake(1)定義の値を知りたい場合は、show-varターゲットとともに、
VARNAME定義を使います。たとえば、

	make show-var VARNAME=DISTFILES

は、make(1)変数"DISTFILES"の展開結果を表示します。

自分で作った(次章参照)、手動でpkgsrc/packagesに置いた、またはリモートFTPサー
バーに置かれたバイナリーパッケージを、アンインストールおよび再インストール
したい場合は、"bin-install"ターゲットを使うことができます。このターゲットは、 
- もし可能ならば - pkg_addを使ってバイナリーパッケージをインストールするほ
か、"make package"をおこないます。検索先リモートFTPサーバーのリストは
BINPKG_SITE変数に保持され、デフォルトはftp.netbsd.orgです。pkg_add(8)に与え
るべきフラグはすべて、BIN_INSTALL_FLAGS変数で保持することができます。詳細は
pkgsrc/mk/bsd.pkg.defaults.mkをご覧ください。

最後に警告: 標準でないLOCALBASE(またはX11BASE)の設定をしたシステムの場合は、
各パッケージのインストール前にこれらを設定するようにしてください。複数のディ
レクトリーを同じ目的用に分散して使うことはできないからです。そのようなこと
をすると、pkgsrcはインストール済みのパッケージを正しく検出することができず、
無惨に失敗することになるでしょう。また、コンパイル済バイナリーパッケージは、
通常はデフォルトのLOCALBASEである/usr/pkgを使って構築されているので、標準で
ないLOCALBASEを使っている場合は、とにかくコンパイル済バイナリーパッケージを
インストールしては*いけません*。


 3 コンパイル済みのパッケージを作る
 ==================================


 3.1 単数のパッケージを作成する
 ==============================
 
上に述べた手順でパッケージを構築しインストールしたら、これをバイナリー・パッ
ケージにすることができます。- 他のNetBSDマシン上で作成したバイナリーを使い
たいと思うかもしれませんし、単にCPU時間を無駄に使わずにすむようにあなたのバ
イナリー・パッケージを他の人のために使わせてあげたいと思うかもしれません。- 
これは、pkgsrcツリー内の適切なディレクトリーに移動し、シェル・プロンプト上
で以下のコマンドをタイプすることにより可能です。

	# make package

これにより、パッケージが構築、インストールされます(もし、まだ済んでいなけれ
ば)。そして、pkg_*ツールを使い操作できるようにバイナリー・パッケージが構築
されます。現状ではバイナリー・パッケージは/usr/pkgsrc/packages以下にgzipさ
れたファイルとして作成されます。上記のtopの例の続きは、付録A.2を参照して下
さい。

このようなバイナリー・パッケージを提出する方法については、このドキュメント
の後の「提出」セクションを参照してください。


 3.2 全パッケージをバルクビルドする
 ================================

この章では、コンパイル済みバイナリーパッケージを全部揃えたい人のために、そ
の方法を説明します。バルクビルドを行うと、その時点でシステムにインストール
されているパッケージをすべて削除しますので注意してください! バルクビルドを
行うマシンかその近くのNFSサーバーをFTPサーバーに設定することで、構築したパッ
ケージをみんなが使えるようにできます。さらなる情報はftpd(8)をご覧ください。
リモートNFSサーバーのストレージを使っている場合、実際のコンパイルがNFSスト
レージ上で行われると非常に遅くなるので、そうなっていないことを確認してくだ
さい。


 3.2.1 設定
 ==========

 3.2.1.1 /etc/mk.conf
 ====================

/etc/mk.confで以下の設定をするとよいでしょう。デフォルト設定についての詳細
はpkgsrc/mk/bsd.pkg.defaults.mkを見てください。ACCEPTABLE_LICENSESはローカ
ルポリシーに適合するようにしておきます:

    PACKAGES?=              ${_PKGSRCDIR}/packages/${MACHINE_ARCH}
    WRKOBJDIR?=             /usr/tmp/pkgsrc   # build here instead of in pkgsrc
    BSDSRCDIR=              /usr/src
    BSDXSRCDIR=             /usr/xsrc         # for x11/xervers
    OBJHOSTNAME?=           yes               # use work.`hostname`
    FAILOVER_FETCH=         yes               # insist on the correct checksum
    PKG_DEVELOPER?=         yes
    _ACCEPTABLE=            yes

完全な構築のためにxpkgwedgeを使いたい場合は、以下を加えます:

    BULK_PREREQ+=           pkgtools/xpkgwedge

構築の振舞を変えるためにバルクビルドの最中にインストールされている必要があ
るパッケージがこれ以外にあれば、BULK_PREREQ変数に追加することができます。た
だし、BULK_PREREQに設定する意味があるパッケージは、現在のところxpkgwedgeだ
けです。

 3.2.1.2 build.conf
 ==================

pkgsrc/mk/bulkディレクトリーの``build.conf-example''を``build.conf'' にコピー
し、このファイル中のコメントに従って編集します。このファイルは、構築後に作
られるログファイルをどこに置くか、構築の報告メールをどこに出すか、pkgsrcの
場所はどこか、および、どのユーザーにsuして'cvs update'をおこなうか、を決め
る設定ファイルです。

 3.2.1.3 pre-build.local
 =======================

バルクビルドでは、ビルド前の段階の最後に、サイト独自の作業を行なうよう設定
することができます。pkgsrc/mk/bulkに``pre-build.local''ファイルがあると、ビ
ルド前の段階の最後に、このファイルが(sh(1)スクリプトとして)実行されます。
pre-build.localの使い方の例としては、このファイルに

	# echo "I do not have enough disk space to build this pig." \
		> pkgsrc/games/crafty-book-enormous/$BROKENF

のような内容を書いておいて、3 Gb近くのディスク容量が必要な個々のパッケージ
の構築をしないようにする、というものがあります。
    
 3.2.2 ほか、環境に関する考察
 ============================

/usr/pkgはバルクビルド開始時に完全に削除されるので、ログインシェルが別の場
所にあることを確認してください。ログインシェルを/usr/local/binに移して(それ
に合わせてパスワードファイルも修正して)おくか、/etc/rc.localでpkg_addを使っ
て(再)インストールするようにしておきます。これでリブート後もログインできま
す(パッケージが削除されてもシェルのプロセスは死なず、シェルを新たに起動でき
なくなるだけです)。また、1.5より前のバージョンのOSを使っていたり、何らかの
理由でpkgsrc版のsshを使いたい場合は、rc.localでsshdが起動する前にsshをイン
ストールするようにしておきます:

	( cd /usr/pkgsrc/security/ssh ; make bulk-install )
	if [ -f	/usr/pkg/etc/rc.d/sshd ]; then
	   /usr/pkg/etc/rc.d/sshd
	fi

こうしておかないと、バルクビルド終了後や、あるいはマシンがリブートやクラッ
シュした場合にsshでログインできなくなります。警告しておきましたよ! :)


 3.2.3 操作
 ==========

すでにインストールされているどのパッケージも必要ない状態にしてください。
注意: バルクビルドの過程で、 *すべての* パッケージが削除されます!!! その他、
構築の妨げになりうるもの(/usr/localにインストールされているライブラリーなど) 
もすべて削除しておいてください。root になって、以下のようにタイプします:

        # cd /usr/pkgsrc
        # sh mk/bulk/build

何らかの理由で前回の構築が完了していない場合(電源断、システムパニックなど)
は、以下を実行すると、その続きをすることができます:

	# sh mk/bulk/build restart

バルクビルド実行が終わると、その要約がメールで届きます。また、"build.conf"
ファイルの"FTP"で指定したディレクトリーに、構築ログがあります。


 3.2.4 何を実行するのか
 ======================

バルクビルドは三つの段階からなります:

1. ビルド前: スクリプトがpkgsrcを(anon)cvsで更新します。そして、壊れている
	distfileをすべて一掃し、インストールされているパッケージをすべて削
	除します。

2. バルクビルド: これは基本的に、'make bulk-package'を、パッケージの構築順
	序を最適化しておこなうものです。他のパッケージに依存しないパッケー
	ジが最初に構築され、多くの依存関係を持つパッケージは後に構築されま
	す。

3. ビルド後: 報告を作成し、build.confで指定されたディレクトリーに
	``broken.html'' という名前で置きます。あわせて、この報告の簡略版が
	構築管理者にメールで送られます。

構築中、壊れているパッケージの一覧が/usr/pkgsrc/.broken (OBJMACHINEが設定さ
れている場合は.../.broken.${MACHINE})に作られ、構築が壊れているものの個々の
構築ログは、各パッケージのディレクトリーに置かれます。これらのファイルは、
壊れているパッケージを再度構築しようとするような無駄をなくすために、bulk-ター
ゲットが構築が壊れていることを記録するのに使われます。また、壊れているパッ
ケージを後でデバッグするためにも使えます。

	
 3.2.5 必要なディスク容量
 ========================

現在、1.5/i386 ではおおむね以下の容量が必要です:

 * distfile:                          1500MB (NFSでも可)
 * 全バイナリー一式:                  1000MB (NFSでも可)
 * コンパイル用の一時領域:            1500MB (ローカルディスクを推奨)

1.5/alphaでは以下のとおりです:

 * 全バイナリー一式:                  1300MB (NFSでも可)

各パッケージは、バイナリーパッケージ作成直後にアンインストールされた上、作
業用ソースも削除されます。このため、莫大なディスク容量は必要ありません。後
になって、このパッケージがまた必要となった場合は、再度構築することなく
pkg_add でインストールされるので、無駄な再コンパイルの繰り返しは発生しませ
ん。


 3.2.6 chroot構築用の砂場を用意する
 ==================================

バルクビルドによってパッケージを全部消される(マシンがパッケージのコンパイル
以外に無用なものになってしまう)のが嫌な場合は、chroot環境下でパッケージをバ
ルクビルドすることもできます。

そうするためには、まず、chrootされた砂場を、たとえば/usr/sandboxに用意しま
す。NetBSDのインストール配布物をすべて展開するか、src/etcで
"make distribution DESTDIR=/usr/sandbox"を実行した後、以下のものを用意して
適切に設定された状態にします。

 * カーネル:
   cp /netbsd /usr/sandbox
 * /dev/*:
   cd /usr/sandbox/dev ; sh MAKEDEV all
 * /etc/resolv.conf (security/snmpdおよびメール用):
   cp /etc/resolv.conf /usr/sandbox/etc
 * 動作する(!)ようなメールの設定 (hostname, sendmail.cf):
   cp /etc/mail/sendmail.cf /usr/sandbox/etc/mail
 * /etc/localtime (security/snmpd用):
   ln -sf /usr/share/zoneinfo/GMT /usr/sandbox/etc/localtime
 * /usr/src (sysutils/aperture, net/ppp-mppe用のシステムソース):
   ln -s ../disk1/cvs .
   ln -s cvs/src-1.6 src
   ln -s cvs/pkgsrc .
 * /var/db/pkgを作成する(デフォルトのインストールには含まれません):
   mkdir /usr/sandbox/var/db/pkg
 * /usr/pkgを作成する(デフォルトのインストールには含まれません)
   mkdir /usr/sandbox/usr/pkg
 * /usr/sandbox/usr/pkgsrc内にpkgsrcをcvsからチェックアウトする
   cvs -d cvs.netbsd.org:/cvsroot co pkgsrc
 * /usr/pkgsrc/packages & .../distfiles (砂場の外を指します)
 * /etc/mk.conf, 3.2.1.1節参照
 * .../mk/bulk/build.confを調整する

!!! Xをインストールするのを忘れないでください !!!
あなたが開発者で、構築したバイナリーパッケージをftp.netbsd.orgへアップロー
ドする場合は、当該アーキテクチャーおよびリリースでのデフォルトのXバージョン
(1.6以降は、全アーキテクチャーが3.3.6)を使うようにしてください。

次に、/usr/sandbox/usr/pkgsrc以下に、(たとえばanoncvsで)チェックアウトした
ままのpkgsrcを置きます。開発用のpkgsrcツリーをここにマウントしたり、リンク
したりすると問題が起こりがちなので、そういうことはしてはいけません!
.../pkgsrc/packagesおよび.../pkgsrc/distfilesのファイルを公開したい場合は、
これらのディレクトリーが砂場の外のどこかを指すように調節します。

その後、必要に合わせて.../pkgsrc/mk/bulk/build.confを設定してください!

chroot砂場の用意ができれば、以下の手順で構築を開始できます:

	# cd /usr/sandbox/usr/pkgsrc
	# sh mk/bulk/do-sandbox-build

このコマンドは、砂場内に移動して、激しい構築を開始するものです。構築が終わ
ると、構築の結果がメールで送信されます。できあがったバイナリーパッケージは、
/usr/sandbox/usr/pkgsrc/packages (の指す/マウントされた先/元)に置かれます。


 3.3 CD-ROM複数枚に収めたパッケージコレクションの作成
 ====================================================

pkgsrcのバルクビルド完了後、できあがったバイナリーパッケージからCD-ROMを作っ
て、他のマシンへのインストール用に使うことができます。
pkgsrc/pkgtools/cdpackパッケージに、そのようなISO 9660イメージ作成用の簡単
なツールがあります。`cdpack'は、依存関係が一枚のCD内で完結するように、パッ
ケージを複数枚のCD-ROMに編集してくれます。


 3.3.1 cdpackの使用例
 ====================

cdpackの完全なドキュメンテーションはcdpack(1)にあります。以下の短い例では、
バイナリーパッケージが/usr/pkgsrc/packages/Allに置いてあり、ISO 9660イメー
ジ用の十分なディスク容量が/u2にあるものとします。

        # mkdir /u2/images
        # pkg_add /usr/pkgsrc/packages/All/cdpack
	# cdpack /usr/pkgsrc/packages/All /u2/images

各CDに共通ファイル(COPYRIGHT, README, など)を含めたい場合は、そのファイルを
含むディレクトリーを作る必要があります。たとえば以下のようにします。

	# mkdir /tmp/common
	# echo "This is a README" > /tmp/commmon/README
	# echo "Another file" > /tmp/common/COPYING
	# mkdir /tmp/common/bin
	# echo "#!/bin/sh" > /tmp/common/bin/myscript
	# echo "echo Hello world" >> /tmp/common/bin/myscript
	# chmod 755 /tmp/common/bin/myscript

ここで、以下のようにしてイメージを作成します。

	# cdpack -x /tmp/common /usr/pkgsrc/packages/All /u2/images

こうすると、各イメージのルートディレクトリーに"README", "COPYING"および
"bin/myscript"が含まれるようになります。


==============================
第二部: パッケージ構築者ガイド
==============================

 4 パッケージコンポーネント - ファイル、ディレクトリー、およびコンテンツ
 =======================================================================

パッケージを用意する際にはいつも、以下のセクションで述べられている多くのファ
イルが存在します。


 4.1 Makefile
 ============

構築、インストールおよびバイナリー・パッケージの作成は、すべてパッケージの
Makefileによりコントロールされます。

それぞれのパッケージのためのMakefileがあります。このファイルは、パッケージ
のコンパイルとインストールのために必要なすべての定義とアクションがセットさ
れた標準のbsd.pkg.mkファイル("../../mk/bsd.pkg.mk")をインクルードします。必
須となるフィールドは、インターネットのサイトからダウンロードされる配布ファ
イルのベース名を指定するDISTNAMEと、そのサイトを指定するMASTER_SITES、パッ
ケージが置かれるカテゴリーを意味するCATEGORIES、パッケージの名前である
PKGNAMEと、メンテナー名であるMAINTAINERと、パッケージの一行説明(パッケージ
名は自動的に追加されるので、含めないでください) からなるCOMMENT変数です。
maintainer変数は、そのパッケージを維持する人による(いつも完全に正しい)決定
にへりくつを言う誰かが、活発に苦情を言うことができるようにするためです。

MASTER_SITESは、定義済みのサイトの一つをセットすることもできます。

	${MASTER_SITE_XCONTRIB}
	${MASTER_SITE_GNU}
	${MASTER_SITE_PERL_CPAN}
	${MASTER_SITE_TEX_CTAN}
	${MASTER_SITE_SUNSITE}
	${MASTER_SITE_GNOME}
	${MASTER_SITE_SOURCEFORGE}

もしこれらの予め定義されたサイトの1つを選んだ場合、そのサイトのサブディレク
トリーを指定する方法が必要となるかもしれません。これらのマクロは複数の実際
のサイトに展開されるかもしれませんので、サブディレクトリーを指定する場合は、
以下の表記を使わなければなりません:

	${MASTER_SITE_GNU:=subdirectory/name/}

(サブディレクトリー名の後のスラッシュ/に注意してください)廃止された
MASTER_SITE_SUBDIRを使用しても動作しません。

パッケージに複数のDISTFILESまたは複数のPATCHFILESがあって、それらの配布元サ
イトが異なる場合は、SITES_fooを、ファイル"foo"があるURIを列挙したものに設定
します。"foo"にはサフィックスを含めます。たとえば以下のようにします。

	DISTFILES=${DISTNAME}${EXTRACT_SUFX}
	DISTFILES+=foo-file.tar.gz
	SITES_foo-file.tar.gz=http://www.somewhere.com/somehow/ \
			http://www.somewhereelse.com/mirror/somehow/

なお、通常おこなうような、DISTFILESへのファイルの(置換ではなく)追加をする場
合は、標準的なDISTFILESのデフォルト設定を明示的におこなわなければなりません。

現在CATEGORIESの値として以下が使用できます。もし複数にまたがる場合、それら
の値はスペースで分けられる必要があります:

       archivers  audio      benchmarks   biology       cad     
       chat       comms      converters   cross         databases
       devel      editors    emulators    finance       fonts
       games      graphics   ham          japanese      lang
       mail       math       mbone        misc          net
       news       parallel   print        security      shells
       sysutils   textproc   time         wm            www
       x11

全ての利用できるオプション、および変数の記述に関しては、NetBSD packages(7)
マニュアルページを参照してください。

以下の事柄に気を配ってください。:

 - もしパッケージにより(すでにそこにないとしても)マニュアルページが圧縮され
   た形式でインストールされる場合、MANCOMPRESSEDを追加してください。
   bsd.pkg.mkのコメントを参照。
 - すべてのファイルの/usr/localを${PREFIX}に変更してください。(後述のパッチ
   を参照)
 - もし、パッケージがinfoファイルをインストールするのであれば、この文書の
   `infoファイルが附属するパッケージ'節を参照してください。
 - もしあなたが将来の更新のために、そのパッケージをメンテナンスするつもりで
   あれば、MAINTAINERにあなたのメールアドレスをセットしてください。標準では
   MAINTAINERはpackages@netbsd.orgにセットします。
 - もし問題のソフトウェアにホームページが存在するのであれば、MAINTAINERの後
   ろにHOMEPAGEを追加してください。HOMEPAGEの値はホームページのURLにしてく
   ださい。
 - パッケージの短い説明をCOMMENT変数に設定してください。


 4.2 distinfo
 ============

最も重要で必須な、パッケージのコンパイルに必要なすべてのdistfileのメッセー
ジダイジェストあるいはチェックサムです。作者が配布した元のファイルに対して、
このメッセージダイジェストが一致することを確認しています。これをもとに、イ
ンターネットから取得したdistfileが転送中にファイルが壊れたり、悪意によりセ
キュリティーホールを入れられたファイルに変更されていたりしていないことを確
認します。これは"make makesum"により生成するのが最善です。ダイジェストアル
ゴリズムには md5 が使われていましたが、これはsha1に比べて弱いため、現在は
sha1がデフォルトのアルゴリズムになっています。また、distfileの容量も生成さ
れ、新しいdistinfoファイルに格納されます。pkgsrc/pkgtools/digestユーティリ
ティーは、distinfoファイル用のダイジェストをすべて計算してくれますし、さま
ざまなアルゴリズムにも対応しています。現在、以下のアルゴリズムに対応してい
ます:

	md5, rmd160, sha1, sha256, sha384 and sha512

パッケージによっては、アーキテクチャー毎にdistfileの組が異なるものがありま
す。(pkgsrc/www/navigatorがよい例です)。この情報は単一のdistinfoファイルに
書かれるので、このようなパッケージの更新時には、distfileの情報が失われない
ように注意を払ってください。

patches/ディレクトリー(セクション4.3参照)に入っている、公式なすべてのパッチ
のメッセージダイジェスト/チェックサムも、このdistinfoファイルに格納されます。
これは、パッチ中のNetBSD RCS Idを除いたすべての行のメッセージダイジェスト/
チェックサムです。このファイルは"make makepatchsum"コマンドにより生成するこ
とができます。


 4.3 patches/*
 =============

このディレクトリーは、patch(1)コマンドを使用して作られたファイルを含んでい
ます。このファイルは、配布ファイルのソースをNetBSD上で完全にコンパイルして
実行できるように変更するためのものです。これらのファイルは、アルファベット
順(シェルによる"patches/patch-*"展開順)で適用されます。つまりpatch-aaは
patch-abより前に適用されます。

問題を避けるため、patch-??ファイルは"diff -bu"フォーマットとし、かつ、曖昧
さなしで適用可能であるべきです。(曖昧さがあっても強制的にパッチを適用させる
ため、PATCH_FUZZ_FACTOR=-F2を設定することができます)。なお、将来の変更が難
しくなってしまうので、一つのパッチファイルに、複数のファイルへの変更を入れ
るのは止めてください。

同様に、一つのファイルへのパッチあては最大一回とし、複数のパッチを使って複
数回パッチをあててはいけません。もしファイルに複数のパッチが必要なら、それ
は一つのファイルにまとめるべきです。

一つ重要なこととして、NetBSD CVSツリーにチェックインした後に問題を引き起こ
すので、パッチファイルにRCS IDを含ませないように注意してください。これを避
けるためには、diffに"-U 2"または"-U 1"オプションのどちらかを使ってください。
あるいはpkgsrc/pkgtools/pkgdiffにある'pkgdiff'コマンドを使ってください。

この 2 段落で述べた問題に気を使いたくない場合は、pkgsrc/pkgtools/pkgdiffパッ
ケージのpkgdiffを使ってください。これはすべてのRCS Idをよきにはからってくれ
ます。

さらに自動化するため、同パッケージのmkpatchesを使ってパッチ一式を作ることを
おすすめします。あなたがやらねばならないことは、ファイルの編集前に"cp -p
filename filename.orig"のようにするか、あるいはさらに簡単に、同パッケージの
pkgviを使って、元のファイルを"filename.orig"の名前でバックアップしておくだ
けです。この方法でパッケージをアップグレードした場合、patchdiffを使って、新
しいパッチと既存のパッチを簡単に比較することができます。

パッケージを作り終えたとき、忘れずに"make makepatchsum"コマンドでパッチファ
イルのチェックサムを生成するようにしてください。セクション4.2を参照してくだ
さい。

置いておきたいパッチがあるがpkgsrcにcommitすべきものではない場合、それを
pkgsrcツリーの外の$LOCALPATCHESディレクトリーに置いておくことができます。こ
のディレクトリーツリーはpkgsrcと同様の"category/package"の構造を持つように
し、パッチを各パッケージのディレクトリー(すなわち$LOCALPATCHES/$PKGPATH)に
置くようになっています。たとえば、pkgsrc/graphics/pngに私的なパッチを適用す
るようにしたい場合は、そのパッチを$LOCALPATCHES/graphics/png/mypatchに置き
ます。このディレクトリーにあるファイルはすべてパッチファイルとして扱われ、
pkgsrcの「標準の」パッチが適用された後に、このパッチが適用されます。


 4.4 その他の必須のファイル
 ==========================

 * DESCR:
   ソフトウェアについての複数行の説明。このファイルには適切なクレジットを含
   めておいてください。他人があなたのユーモアのセンス(あるいは変わった綴り)
   を理解してくれない事、そしてここに書かれたものすべてを他人が読むであろう
   という事を念頭においておいてください。

 * PLIST:
   このファイルは、システムにインストールされるファイルを管理します:すべて
   のバイナリー、マニュアルページ、その他。ディレクトリーの作成、削除、イン
   サートされた(inserted)ファイルの位置を管理するための、他のディレクティブ
   もこのファイルに記述されます。


 4.5 オプション・ファイル
 ========================

 * INSTALL:
   このシェル・スクリプトはpkg_add実行中に二度起動されます。最初は、パッケー
   ジが展開された後、ファイルが移動される前に、二度目はインストールするファ
   イルが移動された後。このファイルは、PLIST内の@execコマンドでは不可能な特
   別な処理のために使うことができます。より詳細な情報はpkg_add(1)と
   pkg_create(1)を参照してください。

 * DEINSTALL:
   このスクリプトは、ファイルが削除される前後に実行されます。このスクリプト
   の責任は、パッケージのインストレーションにかかわる雑多なものをきれいにす
   ることです。なぜなら、pkg_deleteは、オリジナルのディストリビューションで
   作成されたファイルをどのように削除するかをすべて知っておかなければならな
   いからです。より詳細な情報はpkg_add(1)とpkg_create(1)を参照してください。

 * MESSAGE:
   パッケージのインストール後にこのファイルの内容が表示されます。
   完全にフリーでないソフトウェアについての法的な通知等に役立ちます。
   パッケージのMakefileでMESSAGE_SUBSTを使うことで、変数を簡単に変えられる
   ことに注意してください:
   
	MESSAGE_SUBST+=  SOMEVAR="somevalue"
	
   とすると、MESSAGE中の
   
	${SOMEVAR}
	
   は、メッセージ表示前に"somevalue"に置換されます。


 4.6 work/*
 ==========

「make」とタイプした時に、配布ファイルがこのディレクトリーに展開されます。
シェル・プロンプトで、以下のようにタイプすれば、これらを削除することができ
ます。

	# make clean

また、このディレクトリーはさまざまなタイムスタンプ・ファイルを作っておくた
めにも使用されます。


 4.7 files/*
 ===========

また、もしあなたがコンフィギュレーションまたは構築するより前に、パッケージ
中に何かファイルを置きたいならば、それらのファイルをfilesディレクトリーに置
くことができますし、pre-configureターゲットで、${CP}コマンドによりコピーす
ることができます。あるいは、/dev/nullに対するそのファイルの単純なdiffをとり、
パッチメカニズムを使用して、そのファイルを生成することもできます。


 5 PLIST*問題
 ============

このセクションでは、PLISTファイル(複数の場合もあります、以下を参照してくだ
さい)を扱う場合に注意が必要な、いくつかの特別な問題について述べます。


 5.1 その他色々
 ==============

 * NetBSD RCS Id :
   あなたが書いたすべてのPLISTファイルの先頭行にRCS IDが追加されていること
   を確認してください。

	@comment <$>NetBSD<$>

 * ${MACHINE_ARCH}、${MACHINE_GNU_ARCH}:
   emacs、およびperlのようないくつかのパッケージは、それらが構築されたアー
   キテクチャーに関する情報を、インストールするファイルのパス名に埋め込みま
   す。このようなケースに対応するため、実際に使われる前に、PLISTに前処理が
   おこなわれます。そして、シンボル「${MACHINE_ARCH}」は、「uname -p」の出
   力でおきかえられます。${MACHINE_GNU_ARCH}がPLISTのどこかにうめこまれてい
   る場合も同様の事がおこなわれます。これは、GNU autoconfで作成された
   configureスクリプトを持つパッケージで使われます。

   昔の話:「<$ARCH>」シンボルは「uname -m」の出力によって置きかえられていま
   した。しかし、もはやサポートされていませんし、削除されています。

 * ${OPSYS}、${OS_VERSION}:
   いくつかのパッケージでは、OS名とバージョンをいくつかのパス名に埋め込みま
   す。このような場合、PLISTで二つの変数を使用してください。${OPSYS}は
   「uname -s」の出力で置きかえられます。${OS_VERSION}には「uname -r」出力
   が設定されます。

 * ${PKGLOCALEDIR}:
   ロケールファイルをインストールするパッケージでは、ロケールファイルを
   "share/locale/de/LC_MESSAGES/..."ではなく
   "${PKGLOCALEDIR}/locale/de/LC_MESSAGES/..."という形でPLISTに列挙します。
   ロケールファイルのデフォルトの場所はOSによって"share"か"lib"か異なります
   が、このような形で書くことで適切に処理することができます。

 * マニュアルページの圧縮:
   もし、(bsd.own.mkに)MANZが設定されていれば、マニュアルページは圧縮形式で
   インストールされます。そうでなければ展開された形式でインストールされます。
   PLISTファイルでこれをサポートするために、MANZと MANCOMPRESSEDの設定の有
   無に従い、「.gz」サフィックスがマニュアルページに自動的に追加、削除され
   ます。このPLISTファイルに対する変更は、PLIST自身にたいしてでなく、それが
   コピーされる時におこなわれます。

 * PLIST の半自動生成:
   "make print-PLIST"コマンドを使って、パッケージの展開後に新しくできた全ファ
   イルにマッチするPLISTを出力することができます。このターゲットに関するさ
   らなる情報は、下の説明をご覧ください。


 5.2 ${PLIST_SRC}
 ================

ひとつ以上のファイルを、バイナリー・パッケージを構築するためにPLISTのソース
として使用する時は、それらのファイル名を変数PLIST_SRCに設定してください。こ
れらのファイルは、後でcat(1)によって連結されます。連結の順番は重要です。

 5.3 ${PLIST_SUBST}
 ==================

MESSAGE_SUBST(上を参照)に似ており、以下のようにして、変数とその展開結果を追
加することができます:

	   PLIST_SUBST+=    SOMEVAR="somevalue"

これは、PLIST中にある${SOMEVAR}をすべて"somevalue"に置換します。デフォルト
で置換が行なわれる値については、bsd.pkg.mkを見て(PLIST_SUBSTを調べて)くださ
い。

 5.4 Perl5 モジュール
 ====================

Perl5 のモジュールがインストールされる場所は、構築プロセスで使われるperl の
バージョンに応じて変わります。これを扱うために、NetBSD パッケージシステムは、
インストールされた.packlistファイル(ほとんどの perl5 モジュールが生成します)
に列挙された各ファイルに対応する行を、PLIST に追加します。これは、packlist
ファイルへのパスをスペースで区切ったリストをPERL5_PACKLISTとして定義するこ
とで行なわれるようになります:

	PERL5_PACKLIST=	${PERL5_SITEARCH}/auto/Pg/.packlist

PERL5_SITELIB, PERL5_SITEARCH, PERL5_ARCHLIBの各変数は、perl5モジュールがイ
ンストールされうる三つの場所を表すもので、packlistを持たないperl5パッケージ
で使うことができます。この3変数の置換は、PLISTでもおこなわれます。

 5.5 ユーザーとの対話
 ====================

時々、パッケージがユーザーとの対話を必要とする場合がありますが、そのような
状況は何通りもありえます:

+ distfileの取得に関する補助
+ パッケージの構築前の設定の補助
+ 構築過程の最中の補助
+ パッケージのインストール中の補助

どの段階で対話が必要になるかをpkgsrcの機構に知らせるため、INTERACTIVE_STAGE 
定義が用意されており、パッケージのMakefileで定義します。たとえば以下のよう
にします。

INTERACTIVE_STAGE= build

複数の段階を指定することもできます:

INTERACTIVE_STAGE= configure install


 6 パッケージの修正に関する6つの注意
 ===================================

 6.1 CPP定義
 ===========

アプリケーションをNetBSDに移植するためには、コンパイラーがコンパイルしてい
るシステムを判断する必要があります。したがって、Cのプリプロセッサーがシステ
ムを判断できるように、CPPの定義を使います。

4.4 BSDから派生したシステム上で作業しているかどうかをテストするためには、
BSD定義を使用するべきです。これは<sys/param.h>で定義されています。

        #include <sys/param.h>

また、BSDに固有の部分を、以下の条件でかこむこともできます。

	#if (defined(BSD) && BSD >= 199306)
	...
	#endif

どうか注意して__NetBSD__定義を使って下さい。4.4-liteから派生した他のBSDにな
いNetBSD固有の特徴にのみ適用してください。

 6.2 共有ライブラリー - libtool
 ==============================

pkgsrcはさまざまな種類のマシンをサポートします。それらはa.outとELFのような
異なるオブジェクトフォーマットを使い、共有ライブラリー、ダイナミックローディ
ングの有無すらも異なります。これに対応するためにコマンドそのもの、およびオ
プションがコンパイラー、リンカーなどに渡される必要があります。すべてのマシ
ンで正しく動作させることは非常にむずかしく、テストのためにすべてのマシンを
持っていない場合は特にそうでしょう。「libtool」パッケージはこれを助けます。
「libtool」はソースファイルから、静的、動的なライブラリー両方を構築する方法
を知っています。したがって、プラットフォーム独立です。

以下に、libtoolをパッケージで使用するための7つの手順を記述します。

1. USE_LIBTOOL=yesをパッケージのMakefileへ追加します。

2. ライブラリーオブジェクトのために、${LIBTOOL} --mode=compile ${CC}を${CC}
   に設定します。ライブラリーが、提供されたMakefileだけを使用して構築される
   のであれば、CCの定義にこれを追加するだけです。このコマンドひとつだけで、
   PICと非PICのライブラリーオブジェクトを作成します。したがって、共有ライブ
   ラリーとそうでないライブラリーの構築規則を別々に記述する必要はありません。

3. ライブラリーのリンクのための「ar」、「ranlib」、「ld -Bshareable」コマン
   ドを削除してください。そしてその代わりに以下のコマンドを使用してください。

	${LIBTOOL} --mode=link ${CC} -o ${.TARGET:.a=.la} ${OBJS:.o=.lo} -rpath ${PREFIX}/lib -version-info major:minor

   ライブラリーの拡張子は.laに、オブジェクトの拡張子は.loに変更されることに
   注意してください。OBJSを必要に応じて変更してください。このコマンドは、必
   要なものすべて、.a、.so.major.minor、そしてELFのシンボリックリンク(必要
   なら)を自動的にカレントディレクトリーに作成します。特に、メジャー番号と
   マイナー番号がゼロの場合は、-version-infoをかならず含めるようにしてくだ
   さい。そうしないとlibtoolは共有ライブラリーのバージョンを取り除きます。

   また、"-release"オプションは、ある一つの場合に限って、a.outとELF(シンボ
   リックリンクを除く)との間で異なる結果をもたらします。
   libfoo-release.so.x.yの形式のELFライブラリーは、a.outプラットフォーム上
   ではlibfoo.so.x.yのシンボリックリンクを持ちます。これは自動的に処理され
   ます。

   -rpath引数は構築されたライブラリーのインストール先ディレクトリーです。

   PLISTには、.a, .laおよびso, .so.major, .so.major.minorがすべて含まれるべ
   きです。

4. 共有オブジェクト(.so)ファイル(すなわち、dlopen(3)でロードされるファイル
   であって、共有ライブラリーでは*ありません*)のリンク時には、ファイルにバー
   ジョンが加えられないようにするため、"-module -avoid-version"を使ってくだ
   さい。

   PLISTにはfoo.soの一覧が加わります。

5. インストールする前のライブラリーに依存するプログラムをリンクする時に、cc
   かldの前に「${LIBTOOL} --mode=link」を書いてください。このコマンドは、正
   しいライブラリー(静的、または共有)を見つけます。ただし、libtoolを使う時
   には-Lオプションで相対パスを指定すること(-L../somelibのように)ができない
   ことに注意してください。引数として.laファイルを使うように修正しなければ
   なりません。例えば、

	${LIBTOOL} --mode=link ${CC} -o someprog -L../somelib -lsomelib

   は、以下のように変更する必要があります。

	${LIBTOOL} --mode=link ${CC} -o someprog ../somelib/somelib.la

   これで、ライブラリーを正しく扱う事ができます。

6. ライブラリーをインストールするときに、installあるいはcpコマンドの前に
   「${LIBTOOL} --mode=install」を書いて下さい。そしてライブラリーの名前を
   .laに変えてください。例えば、以下のように書く必要があります。

	${LIBTOOL} --mode=install ${BSD_INSTALL_DATA} ${SOMELIB:.a=.la} ${PREFIX}/lib

   これは、静的リンクのための.a、共有ライブラリー、必要なシンボリックリンク
   をインストールし、「ldconfig」を実行します。

7. PLIST の中に、.a、.la、そしてso, .so.major, .so.major.minor ファイルを追
   加してください(以前とはやり方が変わっています)。


 6.3 すでにlibtoolをサポートしているGNUパッケージでlibtoolを使う
 ===============================================================

パッケージのlibtoolを簡単に回避する方法として、USE_LIBTOOL=yesおよび
LTCONFIG_OVERRIDE=${WRKSRC}/ltconfigをパッケージのMakefileに追加してくださ
い。パッケージのlibtoolは、do-configureターゲットでltconfigスクリプトにより
作られます。USE_LIBTOOL および LTCONFIG_OVERRIDE が定義されている場合、指定
されたltconfigは、パッケージのlibtoolのかわりにpkgsrc/devel/libtoolを使うよ
う上書きされます。新しい(ltconfigを持たない)バージョンのlibtoolの場合は、上
で説明したもののかわりにLIBTOOL_OVERRIDE=${WRKSRC}/libtoolを使う必要がある
かもしれません。

パッケージが動的共有オブジェクトのロードに、libtool (libltdl)のプラットフォー
ム独立なライブラリーを使う場合は、libtoolのbuildlink2.mkをインクルード(さら
に、USE_BUILDLINK2をYESに設定)してください。

パッケージによっては、環境により動作や構築ができなくなるような、正しくない
libtoolの使い方をしているものがあります。ありがちな間違いは以下のようなもの
です。

 * 実行形式やライブラリーで、共有オブジェクト(-module)を依存ライブラリーと
   してインクルードする。このこと自体は、以下の二つのうちいずれかが行なわれ
   ている場合は、問題になりません。

   1. その共有オブジェクトが正しく命名されている。すなわち、foo.laではなく
      libfoo.laとなっている。

   2. -dlopenオプションが実行形式のリンク時に使われている。

 * ルーチンの初期化を適切に呼ばずにlibltdlを使う。関数lt_dlinit()を呼んで、
   マクロLTDL_SET_PRELOADED_SYMBOLSを実行形式にインクルードすべきです。


 6.4 GNU Autoconf/Automake
 =========================

パッケージが、configureスクリプトやmakefileの雛型Makefile.inを再生成するた
めにGNU autoconfまたはautomakeを実行する必要がある場合、これらの実行は
pre-configureターゲットでおこないます。autoconfのみを必要とするパッケージで
は以下のようになります:

	pre-configure:
		cd ${WRKSRC}; ${LOCALBASE}/bin/autoconf

また、automakeとautoconfを必要とするパッケージでは以下のようになります:

	pre-configure:
		cd ${WRKSRC};						\
		${LOCALBASE}/bin/aclocal;				\
		${LOCALBASE}/bin/autoheader;				\
		${LOCALBASE}/bin/automake -a --foreign -i;		\
		${LOCALBASE}/bin/autoconf

生成されたファイルに対して、configureプロセスがさらに変更を加える時がありま
すが、この時には構築プロセスが一連のautomakeの手順を再実行しようとします。
configureの段階でさまざまなファイルに手を加えると、この挙動は止められます。
この挙動が問題が起こす場合は、そのパッケージのMakefileでAUTOMAKE_OVERRIDEを
NOに設定することができます。


 6.5 パッケージの設定ファイル
 ============================

パッケージの設定ファイルの場所は、${PKG_SYSCONFDIR}として指示され、この値は
configureおよびbuildのプロセスに渡されます。PKG_SYSCONFDIRは、他のmake変数
のさまざまな設定によってカスタマイズすることができます:

* PKG_SYSCONFBASEは主たる設定ディレクトリーで、パッケージ用の設定ファイルす
  べてがこれ以下に置かれます。デフォルトは${PREFIX}/etcですが、/etc/mk.conf
  で上書きすることができます。

* PKG_SYSCONFSUBDIRはPKG_SYSCONFBASEのサブディレクトリーで、個々のパッケー
  ジ用の設定ファイルはこの下に置かれます。たとえば、Apacheの設定ファイルは
  すべて、${PKG_SYSCONFBASE}のサブディレクトリー"httpd"の下に置かれます。こ
  れは、パッケージのMakefileで設定することを想定しています。

* デフォルトではPKG_SYSCONFDIR=${PKG_SYSCONFBASE}/${PKG_SYSCONFSUBDIR}にな
  りますが、このデフォルト値は、個々のパッケージに対して 
  PKG_SYSCONFDIR.${PKG_SYSCONFVAR} を設定することで上書きすることができます。
  このPKG_SYSCONFVARは、デフォルトでは${PKGBASE}です。これは、パッケージの
  Makefileで設定するためのものではなく、ユーザーが個々のパッケージについて
  PKG_SYSCONFDIRの設定を特別な場所に上書きするために予約されているものです。

ユーザーがカスタマイズすべき変数は、PKG_SYSCONFBASEと
PKG_SYSCONFDIR.${PKG_SYSCONFVAR}だけです。通常、ユーザーはPKG_SYSCONFBASEを
/etcに設定するか、またはデフォルトの場所の${PREFIX}/etcのままにするでしょう。


 6.6 作者へのフィードバック
 ==========================

もしパッケージの不具合を発見し動作するように修正した場合、NetBSD上で動作さ
せるために特別な手順が必要だった場合、あるいはさまざまなソフトウェアの拡張
をおこなった場合、これらの修正をプログラムのオリジナルの作者へ報告してくだ
さい。このようなサポートによって、プログラムの次のリリースにそれらの修正を
反映することができます。そして、NetBSDパッケージシステムを使用していない人々
も、あなたの努力のおかげで幸せになれます。

フリー・ソフトウェアの理念をサポートして下さい。


 7 構築の手順
 ============

プログラムを構築するための基本的な手順は常に同じです。最初に、プログラムの
ソースファイル(distfile)をローカル・システムへ持ってきて展開します。NetBSD
上でコンパイルするためのいくつかのパッチを適用した後に、ソフトウェアを設定
し、構築(通常、コンパイルすることによって)します。最後に作成されたバイナリー
等を、システムにインストールします。これはまさにNetBSDパッケージ・システム
によって実行される手順です。この手順は、中心となるMakefile、
pkgsrc/mk/bsd.pkg.mkの中で一連のターゲットとして実装されています


 7.1 プログラムの場所
 ====================

次のセクションでNetBSDパッケージ・システムによって実行される手順の概略を述
べる前に、プログラムがインストールされる場所、その場所に影響をおよぼす変数
について簡単に記述します。

自動変数PREFIXは、最終的にプログラムのすべてのファイルがインストールされる
場所をしめします。通常、$LOCALBASE (/usr/pkg)、または「cross」カテゴリーの
パッケージのための$CROSSBASEと同じ場所になっています。もしUSE_IMAKE あるい
はUSE_X11BASEが定義されていれば、その値は$X11BASEと同じになります。
${PREFIX}の値は、プログラムのソース中でこれらのファイルが符号化されるさまざ
まな場所に使用されるべきです。詳細に関しては、セクション4.3および6.2を参照
して下さい。

これらの変数のどれかを選択し使用する場合には、以下のルールに従ってください。

 * ${PREFIX}は常に現在のパッケージがインストールされる場所を指します。パッ
   ケージ自身のインストール先のパスを参照する時に、${PREFIX}を使用してくだ
   さい。

 * ${LOCALBASE}は、すべての非X11パッケージがインストールされる場所です。他
   の非X11パッケージによってインストールされたインクルードファイルやライブ
   ラリーの場所をさがすためのコンパイラーの-Iや-Lオプションを指定する場合に、
   ${LOCALBASE}を使用してください。

 * ${X11BASE}は、実際に(xsrcなどに由来する)X11ディストリビューションがイン
   ストールされる場所です。通常のX11のインクルードファイル(パッケージとして
   インストールされていない)をさがす場合、${X11BASE}を使用してください。

 * X11ベースのパッケージは特別です。X11BASE、またはLOCALBASEに依存するかも
   しれません。X11パッケージをLOCALBASEにインストールする方法は、単に
   xpkgwedgeパッケージ(pkgsrc/pkgtools/xpkgwedge)をインストールするだけです。
   もし、USE_IMAKEやUSE_X11BASEをMakefileで定義したpkgとしてインストールさ
   れたインクルードファイルやライブラリーをさがす場合、${X11BASE} と
   ${LOCALBASE}の両方を使用する必要があります。

 * X11パッケージのインストール場所を参照する用途には、${X11PREFIX}を使って
   ください。X11PREFIXは、xpkgwedgeがインストールされていない場合は
   ${X11BASE}となり、xpkgwedgeがインストールされている場合は${LOCALBASE}と
   なります。

 * xpkgwedgeがインストールされている場合、パッケージによってインストール先
   がX11BASEになっていたりLOCALBASEになっていたりすることがあります。インス
   トールされているパッケージのprefixを決めるために、EVAL_PREFIX定義を使う
   ことができます。この定義にDIRNAME=<package>の形式の組を書くと、make(1)変
   数DIRNAMEが、インストールされているパッケージ<package>のprefixに設定され
   ます。そのパッケージがインストールされていない場合は${X11PREFIX}に設定さ
   れます。

   例を使って説明するのが一番いいでしょう。

   以下は、pkgsrc/wm/scwm/Makefileからの抜粋です。

	EVAL_PREFIX+=	GTKDIR=gtk+
	CONFIGURE_ARGS+=	--with-guile-prefix=${LOCALBASE}	\
				--with-gtk-prefix="${GTKDIR}"		\
				--enable-multibyte

   EVAL_PREFIXを使って評価するパッケージに対して、以下のような定義を使って
   デフォルトを定義することができます。

	GTKDIR_DEFAULT= ${LOCALBASE}

   ここで"GTKDIR"は、EVAL_PREFIXでの最初の定義の組に対応します。

 7.2 主なターゲット
 ==================

bsd.pkg.mkで定義された、構築手順で使用される主なターゲットについて述べます。

 * fetch:
   これは、変数DISTFILESとPATCHFILES (パッケージのMakefileで定義された)で指
   定されたファイルが、ローカルシステムの/usr/pkgsrc/distfilesに存在するか
   どうかをチェックします。もし、存在しなければ、そのファイルを以下のような
   コマンドを使って取得しようとします。

   ${FETCH_CMD} ${FETCH_BEFORE_ARGS} ${site}${file} ${FETCH_AFTER_ARGS}

   この${site}には、複数の候補が決まった順序で使われます: 最初に
   ${MASTER_SITE_OVERRIDE}を試み、次に、${SITES_file}が定義されていればそれ
   を、定義されていなければ、${MASTER_SITES}か${PATCH_SITES}のどちらかを試
   みます。そして、最後に${MASTER_SITE_BACKUP}の値を試みます。最初のもの以
   外の順序は、${MASTER_SORT_AWK}か${MASTER_SORT_REGEX}を設定して、ユーザー
   が入れ換えることができます。

 * checksum:
   distfileを取得した後に、チェックサムを生成し、distinfoファイルに保存され
   たチェックサムと比較します。もし、チェックサムが一致しなければ、構築は中
   断されます。これはパッケージ作成時と同じdistfileが、構築に使用されている
   こと、つまり、悪意や一次配布サイトでの意図的な差し替えやネットワークの損
   失によってdistfileが変更されていないことを保証するためです。

 * extract:
   distfileがローカルシステム上に存在している場合、通常、それらは圧縮アーカ
   イブフォーマットで保存されているので、展開する必要があります。もっとも一
   般なフォーマットは.tar.gzです。もし、すべてのdistfileを伸張する必要がな
   いのであれば、伸張するファイルをEXTRACT_ONLYに設定してください。もし
   distfileが.tar.gzフォーマットでなければ、EXTRACT_CMD、
   EXTRACT_BEFORE_ARGS、そしてEXTRACT_AFTER_ARGSを設定することにより、それ
   らを展開することができます。

 * patch:

   展開の後で、PATCHFILESで指定されたパッチとパッケージのpatchesサブディレ
   クトリーに存在するパッチ、さらに、$LOCALPATCHES/$PKGPATH (たとえば 
   /usr/local/patches/graphics/png)に存在するパッチのすべてが適用されます。
   .Z、あるいは.gzで終る名前のパッチファイルは、適用する前に伸張されます。
   .orig、.rejで終るものは無視されます。patch(1)のためのいくつかのオプショ
   ンは、PATCH_DIST_ARGSで指定する事ができます。詳細に関してはセクション4.3 
   を参照して下さい。
   
   デフォルトでは、パッチに曖昧さがあった場合にはpatchが異常終了するような
   特別な引数が渡されます。パッチを修正(再作成)して、きれいに適用できるよう
   にしてください。そうする理由は、パッチがうまく適用できても、実は誤った場
   所に適用されていて、深刻な問題を起こす可能性があるからです。

 * configure:
   ほとんどのソフトウェアは、NetBSDで利用できるヘッダーファイル、システムコー
   ル、およびライブラリールーチンについての情報を必要とします。これはコンフィ
   ギュレーションとして知られているプロセスであり、通常、自動化されています。
   大抵の場合、スクリプトがソースと一緒に提供され、それを実行することにより
   ヘッダーファイルやMakefile等が生成されます。

   もし、プログラムのdistfileが専用のconfigureスクリプトを含んでいる場合、
   HAS_CONFIGUREを設定することにより、実行することができます。もし、そのス
   クリプトがGNUのautoconfスクリプトである場合は、かわりに、GNU_CONFIGUREを
   指定してください。どちらの場合も、configureスクリプトの引数は、変数
   CONFIGURE_ARGSで指定されます。もし設定スクリプトの名前がデフォルトの
   configureでない場合は、その名前をCONFIGURE_SCRIPTに設定してください。

   もし、プログラムがコンフィギュレーションのためにImakefileを使用するので
   あれば、USE_IMAKEをYESに設定することにより、適切な手順が実行されます。
   (もし、$X11PREFIXにインストールされるパッケージが欲しいだけで、xmkmfを実
   行したくない場合、かわりにUSE_X11BASEを使用してください!)

 * build:
   コンフィギュレーションが終ったら、$MAKEFILEの中で、構築のターゲットとし
   て$ALL_TARGETを指定し$MAKE_PROGRAMを起動することにより、NetBSD上にソフト
   ウェアを構築することができます。もし、USE_GMAKEが設定されていれば、デフォ
   ルトのMAKE_PROGRAMは「gmake」です。そうでなければ、makeが使用されます。
   MAKEFILEにはデフォルトでMakefileが設定されます。そして、ALL_TARGETのデフォ
   ルトはallです。デフォルトの構築手順を変更するために、これらの変数を設定
   することができます。

 * install:
   構築の段階が完了すると、ユーザーのためにソフトウェアをパブリックなディレ
   クトリーにインストールする必要があります。buildターゲットと同様に、
   $MAKE_PROGRAMが$MAKEFILE中で起動されます。ただし、$INSTALL_TARGETが指定
   されます。この変数のデフォルトは「install」です。(もしUSE_IMAKEが設定さ
   れていれば、「install.man」も追加されます)。

   もし、ターゲットが指定されなければ、デフォルトは「build」です。手順の途
   中のターゲットが指定された場合、それ以前のすべての手順が実行されます。例
   えば「make build」は、以下と同等のことを実行します。

	make fetch
	make checksum
	make extract
	make patch
	make configure
	make build


 7.3 他の役に立つターゲット
 ==========================

 * pre/post-*
   前のセクションで述べた主ターゲットのために、二つの補助ターゲットが存在し
   ます。これは主ターゲットに「pre-」や「post-」というプレフィックスをつけ
   たものです。これらのターゲットは、特別な設定やインストール手順のために、
   主ターゲットが実行される前や後に実行されます。例えば、プログラムのコンフィ
   ギュレーションスクリプトやインストールターゲットが省略された場合に有用で
   す。

 * do-*:
   主なターゲットがおかしな動作をし、それを修正するための変数が存在しない場
   合、do-*ターゲットを使用することにより、それらを再定義することができます
   (do-*ターゲットのかわりに、ターゲット自体を再定義してはいけません。pre-*
   やpost-*ターゲットが実行されなくなってしまいます)。通常、再定義する必要
   はありません。

 * reinstall:
   もし、「make install」実行後に、いくつかのファイルがきちんとインストール
   されなかった事に気がついた場合、このターゲットを使い、再びインストールす
   る事ができます。この場合、「インストール済み」フラグは無視されます。

 * deinstall:
   このターゲットは、パッケージをアンインストールするためにカレントディレク
   トリーでpkg_delete(1)を実行します。動作を制御するために、以下の変数をコ
   マンドライン、または/etc/mk.confで使用することができます。

    - PKG_VERBOSE:
      pkg_delete(1)コマンドに「-v」オプションを渡します。

    - DEINSTALLDEPENDS:
      指定されたパッケージに必要な(依存する)すべてのパッケージを削除します。
      このターゲットは、指定されたパッケージによってインストールされたパッ
      ケージを削除するために使用されます。例えば、DEINSTALLDEPENDS=1が
      pkgsrc/x11/kdeで指定されている場合、KDE全体を削除します。pkg_deleteの
      コマンドラインに-Rを指定すると設定されます。

 * update:
   このターゲットは、現在のパッケージを最新のものに更新します。最初にパッケー
   ジと、それに依存するすべてのパッケージをアンインストールします。それから
   最新のバージョンのパッケージをコンパイル、インストールします。これは、現
   在どのパッケージがインストールされているかを調べ、「make deinstall」、
   「make install」(または、UPDATE_TARGETで設定されたターゲット)を続けて実
   行するのと同じです。

   以前に実行した「make update」がさまざまな理由で中断された場合、パッケー
   ジの更新のために、このターゲットを使用することができます。ただし、この場
   合は、「make clean」を実行していない事、あるいは${WRKDIR}の依存パッケー
   ジのリストを削除していない事を確認してください。そうでなければ、インストー
   ル済みの依存パッケージを使用し、現在のパッケージを自動更新することができ
   ません。

   中断された「make update」の再開は、パッケージツリーの他の部分が変更され
   ていない場合に限って動作します。更新対象のパッケージのソースコードが変更
   されていた場合は、「make update」の再開はきっと失敗するでしょう。

   「make update」の動作を変更するために、以下の変数をコマンドライン、また
   は/etc/mk.confで使うことができます。

    - UPDATE_TARGET:
      更新されたパッケージや依存パッケージのために再帰的に使用されるインス
      トールターゲット。"make update"用のデフォルトは、${DEPENDS_TARGET}が
      設定されている場合はその値、それ以外の場合は"install"です。
      例えば、"make update UPDATE_TARGET=package"のように使用します。

    - NOCLEAN:
      更新した後、きれいに掃除をしません。調査やその他の目的のために、更新
      されたパッケージの作業用ソース等をそのままにしておきたい場合に役に立
      ちます。最終的にはソースツリーを掃除してください(以下の
     「clean-update」ターゲットを見てください)。そうしなければ、次回の
     「make」や「make update」の時に古いソースコードが残っていることで
      トラブルがおこるかもしれません。

    - REINSTALL:
      インストール(make ${DEPENDS_TARGET})の前に各パッケージをアンインストー
      ルします。これは、"make update"の実行中断後に"clean-update"ターゲット
      (以下参照)が呼ばれた場合に必要となることがあります。

    - DEPENDS_TARGET:
      再帰を無効化し、パッケージのターゲットをハードコードすることができま
      す。updateターゲット用のデフォルトは"update"であり、事前に必要なパッ
      ケージを再帰的に更新するようになっています。DEPENDS_TARGETを設定する
      のは、再帰的な更新を無効化したいときだけにしてください。"make update"
      (後述します)の最中にインストールされる各パッケージに対して、特定のター
      ゲットを指定するだけの場合は、これのかわりに"UPDATE_TARGET"を使ってく
      ださい。

 * clean-update:
   カレントディレクトリーで「make update」が実行された時に更新されるすべて
   のパッケージのソースツリーを掃除します。カレントパッケージ(あるいは、依
   存パッケージ)がすでにアンインストールされている(例えばmake updateを実行
   した後)場合には、このターゲットを使ってはいけません。もし使用すると、更
   新するつもりのパッケージのいくつかを失う可能性があります。経験的には、初
   めて「make update」を実行する前、あるいは汚れたパッケージツリーがある場
   合(例えばNOCLEANを使用した場合)にのみ使用すべきです。

   パッケージのツリーが掃除されているかどうかわからない場合は、ツリーの最上
   層で"make clean"を実行するか、更新しようとしているパッケージのディレクト
   リーで以下のコマンドをこの順に使うか、どちらかをおこなうことができます。
   ("make update"を初めて実行するより*前*におこなってください。それ以外の場
   合、更新しようとしているパッケージをすべて失ってしまいます)

      make clean-update
      make clean CLEANDEPENDS=YES
      make update

   「make clean-update」の動作を変更するために、以下の変数をコマンドライン、
   または/etc/mk.confで使うことができます。

    - CLEAR_DIRLIST:
      「make clean」の後で、パッケージのためのディレクトリーのリストを再構
      築しません。「make update」で、更新したいすべてのパッケージがインストー
      ルされた場合にのみ使用してください。通常、これは「make update」で自動
      的に実行されます。ただし、NOCLEAN変数の設定によって実行されない事もあ
      ります(上を参照してください)。

 * info:
   このターゲットは、現在のパッケージに対して"pkg_info"をおこないます。これ
   を使って、たとえば、インストールされているパッケージのバージョンを調べる
   ことができます。

 * readme:
   このターゲットは、README.htmlファイルを作成します。このファイルは
   navigator (pkgsrc/www/navigator)やlynx (pkgsrc/www/lynx)のようなブラウザー
   で閲覧することができます。作成されたファイルは、ローカルホストの
   ${PACKAGES}ディレクトリーにあるパッケージへの参照を含んでいます。また、
   FTP_PKG_URL_HOSTとFTP_PKG_URL_DIRを元にしたURLを参照させることもできます。
   例えば、ローカルマシン上の/usr/packagesディレクトリーのバイナリー・パッ
   ケージを参照するREADME.htmlファイルを作成したい場合、
   FTP_PKG_URL_HOST=file://localhostとFTP_PKG_URL_DIR=/usr/packagesをセット
   してください。${PACKAGES}ディレクトリーと、そのサブディレクトリーはすべ
   てのバイナリー・パッケージで検索されます。

 * readme-all: 
   このターゲットを使い、README-all.htmlを作成することができます。このファ
   イルはNetBSDパッケージコレクションの中の、現在利用可能なすべてのパッケー
   ジのリスト、また、それらが属するカテゴリーと簡単な説明を含んでいます。こ
   のファイルはpkgsrc/*/README.htmlから作りだされます。したがって、「make
   readme」の後に、このターゲットを実行してください。

 * cdrom-readme:
   これはreadmeターゲット(上を見てください)とほとんど同じですが、CD-ROMに焼
   かれるpkgsrcツリーを作る時に使われます。また、このターゲットは
   README.htmlファイルを作成し、CDROM_PKG_URL_HOSTとCDROM_PKG_URL_DIRに基づ
   くURLへの参照を作ります。

 * show-distfiles:
   このターゲットは、パッケージを構築するために、どのdistfileやパッチファイ
   ルが必要かを表示します。(DISTFILESおよびPATCHFILESであって、patches/*は
   含みません)

 * show-downlevel:
   このターゲットは、パッケージがインストールされていない場合は何も表示しま
   せん。もし、あるバージョンのパッケージがインストールされているが、現在の
   pkgsrcのバージョンでインストールされたものでない場合、警告メッセージを表
   示します。このターゲットは、インストール済みのパッケージが古いバージョン
   であり、そのバージョンが削除可能で、最新の物が追加されることを表示するた
   めに使用されます。

 * show-pkgsrc-dir:
   当該パッケージの構築とインストールが可能な、パッケージ階層におけるディレ
   クトリーを表示します。このディレクトリーは、そのパッケージがインストール
   された際のディレクトリーと同じとは限りません。このターゲットは、単一ホス
   ト上で多数のパッケージの更新をしたい場合に使うためのもので、pkgsrc の最
   上層のMakefileから"show-host-specific-pkgs"ターゲットで呼び出すことがで
   きます。

 * show-installed-depends:
   このターゲットは、インストールされているパッケージのうち、どれが当該パッ
   ケージのDEPENDSと合致するかを表示します。DEPENDSが古いせいで構築に問題が
   起きる場合に便利です。

 * check-shlibs:
   パッケージのインストール後に、すべてのバイナリーおよび(ELFプラットフォー
   ムでは) 共有ライブラリーが必要な共有ライブラリーを見つけられるかどうか確
   認します。/etc/mk.confでPKG_DEVELOPERが設定されている場合はデフォルトで
   実行します。

 * print-PLIST:
   パッケージを新規に、または更新のために'make install'した後、'find -newer
   work/.extract_done'をもとに新しいPLISTを生成して表示します。PLIST生成は、
   共有ライブラリーなどに配慮して行われますが、生成した結果をPLISTに置く前
   に再確認するよう*強く*おすすめします。パッケージ更新時には、このコマンド
   の出力と、更新前のPLISTファイルとを比較すると便利でしょう。

   パッケージが、tar(1)その他のファイルのアクセス時刻を更新しない方法を使っ
   てファイルをインストールする場合は、それらのファイルは'find -newer'で検
   出されないので、手でPLISTに書き足すよう注意してください!

 * bulk-package:
   バルクビルドの実行に使われます。適切なバイナリーパッケージがすでに存在す
   る場合は、何もしません。そうでない場合は、コンパイル、インストール、パッ
   ケージ作成をおこないます。バイナリーパッケージ作成後、ディスクの空き領域
   を確保するために、ソース、インストールしたばかりのパッケージと依存パッケー
   ジは削除されます。

 * bulk-install:
   依存パッケージ群をインストールするためのバルクインストールで使われます。
   適切なバイナリーパッケージが利用可能な場合、pkg_addでそれをインストール
   します。そうでない場合は、"make bulk-package"が実行されますが、インストー
   ルされたバイナリーは削除されません。バイナリーパッケージがpkg_addでイン
   ストールされるのに"適切"である条件は、以下のとおりです:

    - パッケージファイル(Makefile, ...)が、いずれも構築時から変更されていな
      いこと
    - そのパッケージが依存している(バイナリー)パッケージが、いずれも構築時
      から変更されていないこと


 8 buildlink2 methodology
 ========================

"buildlink2" is a pkgsrc framework that controls what headers and libraries
are seen by a package's configure and build processes.  This is implemented
in a two step process:

 (1) Symlink headers and libraries for dependencies into ${BUILDLINK_DIR},
     which by default is a subdirectory of ${WRKDIR};

 (2) Create wrapper scripts that are used in place of the normal compiler
     tools that translate -I${LOCALBASE}/include and -L${LOCALBASE}/lib
     into references into ${BUILDLINK_DIR}.

This normalizes the environment in which a package is built so that the
package may be built consistently despite what may other software may
installed.  Please refer to pkgsrc/mk/buildlink2/buildlink2.txt for some
FAQs and answers regarding buildlink2, and to pkgsrc/mk/buildlink2/README
for a description of how buildlink2 is implemented in pkgsrc.


 8.1 Converting packages to use buildlink2
 =========================================

The process of converting packages to use the buildlink2 framework is
fairly straightforward.  The package Makefile must define USE_BUILDLINK2.
If a dependency on a particular package, e.g.  foo, is required for its
libraries and headers, then we replace:

	DEPENDS+=	foo>=1.1.0:../../category/foo
with
	.include "../../category/foo/buildlink2.mk"

There are several buildlink2.mk files in pkgsrc/mk that handle special
package issues:

 * motif.buildlink2.mk checks for a system-provided Motif installation
   or adds a dependency on x11/lesstif or x11/openmotif;

 * ossaudio.buildlink2.mk defines several variables that may be used by
   packages that use the Open Sound System (OSS) API;

 * pthread.buildlink2.mk uses the value of PTHREAD_OPTS and checks for
   native pthreads or adds a dependency on devel/pth as needed;

 * xaw.buildlink2.mk uses the value of XAW_TYPE to choose a particular
   Athena widgets library.

The comments in those buildlink2.mk files provide a more complete
description of how to use them properly.


 8.2 Writing buildlink2.mk files
 =============================== 

A simple example of a buildlink2.mk file for a mythical package foo
follows:

	BUILDLINK_PACKAGES+=          foo
	BUILDLINK_PKGBASE.foo=        foo
	BUILDLINK_DEPENDS.foo?=       foo>=1.0
	BUILDLINK_PKGSRCDIR.foo?=     ../../category/foo

	EVAL_PREFIX+=                 BUILDLINK_PREFIX.foo=foo
	BUILDLINK_PREFIX.foo_DEFAULT= ${LOCALBASE}
	BUILDLINK_FILES.foo=          include/foo.h
	BUILDLINK_FILES.foo+=         include/bar.h
	BUILDLINK_FILES.foo+=         lib/libfoo.*

	BUILDLINK_TARGETS+=           foo-buildlink

	foo-buildlink: _BUILDLINK_USE

The first section controls how the dependency on foo is added.  The
dependency is constructed from four parts:

 (1) BUILDLINK_PACKAGES is the global list of packages for which
     dependencies will be added by buildlink2;

 (2) BUILDLINK_DEPENDS.foo is the actual dependency recorded in the
     installed package;

 (3) BUILDLINK_PKGSRCDIR.foo is the location of the foo pkgsrc
     directory;

 (4) BUILDLINK_DEPMETHOD.foo (not shown above) controls whether we use
     BUILD_DEPENDS or DEPENDS to add the foo dependency, where the
     full dependency is added if BUILDLINK_DEPMETHOD.foo contains "full".

The second section controls which files are linked into ${BUILDLINK_DIR}:

 (1) BUILDLINK_PREFIX.foo is the installation prefix of the package which
     we derive by using EVAL_PREFIX;

 (2) BUILDLINK_FILES.foo is a list of files (shell globs allowed) relative
     to the BUILDLINK_PREFIX.foo directory and will be symlinked into
     ${BUILDLINK_DIR};

 (3) BUILDLINK_FILES_CMD.foo (not shown above) is a shell pipeline that
     outputs a list of files relative to the BUILDLINK_PREFIX.foo
     directory and will be symlinked into ${BUILDLINK_DIR}.

The remaining parts create the foo-buildlink target that actually performs
the symlinking and adds the foo-buildlink target to BUILDLINK_TARGETS,
which is the global list of targets to execute at do-buildlink time.


 9 デバッグ
 ==========

パッケージを作成する時に落ちいりやすい間違いをチェックし、パッケージを動作
させるための手順があります。これは基本的には前のセクションで説明したことと
同じですが、デバッグを助けるための方法を追加しています。

 * PKG_DEVELOPER=1 を /etc/mk.conf に含めるようにしてください
 * 新しいディレクトリーを作り、以下を実行します

	# url2pkg http://www.example.com/path/to/distfile.tar.gz

   これには、pkgsrc/pkgtools/url2pkgをインストールしておくことが必要です。
 * Makefileに、必要な編集を加えます。
 * DESCRの内容を書きます
 * ``make configure''
 * configureの段階でわかった依存関係をすべて、パッケージのMakefileに書き加
   えます。
 * 以下を繰り返しおこなって、パッケージを作り上げます

	# make
	# pkgvi ${WRKSRC}/some/file/that/does/not/compile
	# mkpatches
	# patchdiff
	# mv ${WRKDIR}/.newpatches/* patches
	# make mps
	# make clean
   [ mkpatches, patchdiff, pkgviは、pkgsrc/pkgtools/pkgdiffにあります ]

   root以外のユーザーで作業をおこなうと、改変すべきでないファイルは改変され
   ません。特に、構築の段階以外では。
 * 必要ならMakefileを修正してください。セクション4.1を参考にしてください。
 * PLISTを作成します:

	# make install
	# make print-PLIST > PLIST
	# make deinstall
	# make install
	# make deinstall

   これは通常、rootで実行する必要があります。
 * 残ったままのファイルがないか調べます:

	# make print-PLIST

   もし、なにかファイルが見つかれば、それらはPLISTに不足しているので、追加
   してください。
 * これでPLISTの修正ができました。パッケージを再度インストールして、バイナ
   リーパッケージを作ります:
   
	# make reinstall && make package
	
 * インストールしたパッケージを削除します:
 
	# pkg_delete blub
	
 * 上記のfindコマンドを繰り返します。今度は何も見つからないはずです:

	# make print-PLIST

 * バイナリーパッケージを再インストールします:
 
	# pkg_add ..../blub.tgz
	
 * 遊んでみてください。すべてが機能することを確認してください。
 * pkgsrc/pkgtools/pkglintに含まれるpkglintを実行し、報告される問題を修正し
   てください。

	# pkglint

 * 提出してください(もし cvs アクセス可能であればコミットしてください)。
   セクション 11 が参考になります。


 10 FAQとパッケージシステムの特徴
 ================================

 10.1 GNU autoconfを利用するパッケージ
 =====================================

もしパッケージがGNU autoconfで作成されたconfigureスクリプトを使うのであれば、
パッケージのMakefileに以下の設定を追加してください。

	GNU_CONFIGURE= yes

この設定がCONFIGURE_ARGSに--prefix=${PREFIX}を追加することに注意してくださ
い。したがって、あなた自身でこれを追加する必要はありません。そして、これは
あなたの望む設定とは異なるかもしれません。


 10.2 tar.gz 以外の配布方法
 ==========================

パッケージがtar.gz以外の方法で配布されている場合、pkgsrc/editors/samパッケー
ジを参考にしてください。これはgzipされたシェルアーカイブ(shar)を使っていま
す。いちおう簡単に説明すると、DISTNAMEフィールドの後でEXTRACT_SUFXに名前を
設定し、パッケージのMakefileに以下の設定を追加してください。

	EXTRACT_SUFX=   .msg.gz
	EXTRACT_CMD=            zcat
	EXTRACT_BEFORE_ARGS=
	EXTRACT_AFTER_ARGS=     |sh


 10.3 それ自身のサブディレクトリーを作り出さないパッケージ
 =========================================================

パッケージが例えばGNUソフトウェアのようにサブディレクトリーを作るのではなく、
カレントディレクトリーに展開される場合、もう一度pkgsrc/editors/samを見てく
ださい。簡単にいうと以下の設定が必要です。

	WRKSRC=		${WRKDIR}

なお、以前使われていた

	NO_WRKSUBDIR=   yes

は廃止されましたので、もう使わないでください。


 10.4 カスタムコンフィギュレーションプロセス
 ===========================================

パッケージが、かわったConfigureスクリプトを使用している場合、topのパッケー
ジを参照してください。簡単にいえば、以下の設定をおこなってください。

	HAS_CONFIGURE=          yes
	CONFIGURE_SCRIPT=       Configure
	CONFIGURE_ARGS+=        netbsd13


 10.5 DISTNAMEディレクトリーで作成されないパッケージ
 ===================================================

パッケージが、DISTNAMEをベースにしないディレクトリーで構築される場合、tcl、
およびtkパッケージを参考にしてください。

	WRKSRC=         ${WRKDIR}/${DISTNAME}/unix


 10.6 一度にすべてのdistfilesを取得する方法
 ==========================================

「make fetch」を実行できない職場や大学において、一回のバッチ処理で、すべて
のdistfilesをダウンロードしたいと思うことがあるかもしれません。しかしながら、
ftp.netbsd.orgにはdistfilesのアーカイブはありません。そしてftp.freebsd.org
上にあるアーカイブは、移植されていない多くのdistfilesを含んでいます。

現時点では、「make fetch-list」を/usr/pkgsrcで実行し、その結果のリストを職
場や学校のマシンに持ってきて、使用してくださいとしかいえません。NetBSDと互
換なftp(1)(lukemftpなど)が使えない場合は、URLを指定して取得ができるコマンド
をFETCH_CMDに指定することを忘れないでください:

自宅で:

	% cd /usr/pkgsrc
	% make fetch-list FETCH_CMD=wget DISTDIR=/tmp/distfiles >/tmp/fetch.sh
	% scp /tmp/fetch.sh work:/tmp

職場で:

	% sh /tmp/fetch.sh
	% tar up /tmp/distfiles and take it home

NetBSDで動いているマシンがあって、*すべての*distfile (そのマシンのアーキテ
クチャー向けではないものも含む)を取得したい場合は、上述の'make fetch-list'
の方法を使うか、以下のようにしてdistfileを直接取得することができます。

	% make mirror-distfiles

NO_{SRC,BIN}_ON_{FTP,CDROM}も無視したい場合は、以下のようにしてすべてのもの
を取得することができます。

	% make fetch NO_IGNORE=yes


 10.7 防火壁の内側からファイルを取得する方法
 ===========================================

もし、あなたが防火壁の内側にいて、インターネットのホストに直接接続できない
(つまりNATを使っていない)場合、適切なプロキシーホストを指定することができま
す。これはURL形式の環境変数で指定します。例えば、Amdahlドメインにおいては、
orpheus.amdahl.comというマシンは防火壁のひとつで、プロキシーポート番号とし
て、80番のポートを使用します。この場合、proxy環境変数は以下のようになります。

	ftp_proxy=ftp://orpheus.amdahl.com:80/
	http_proxy=http://orpheus.amdahl.com:80/


 10.8 パッチがRCS IDを含む場合
 =============================

パッチからRCS IDを削除する方法については、セクション4.3を参照してください。


 10.9 /etc/mk.confから変数を捕まえる方法
 =======================================

MAKECONFや/etc/mk.confで上書き可能な、パッケージで定義された変数には問題が
あります。それは、変数はmake(1)がそれを使う時に展開されるが、プリプロセッサー
風の文(.if、.ifdefそして.ifndef)は読み込み時に評価される事です。したがって、
.if*文内で変数(/etc/mk.confでセットされる可能性のある)を使う時は、その.if*
ステートメントの前に/etc/mk.confをインクルードしておかなくていけません。

/etc/mk.confやMAKECONFが存在したら、それらをインクルードするというad-hocな
方法をとらずに、すべてのプリプロセッサー風の.if、.ifdef、または.ifndef文の
前で、pkgsrc/mk/bsd.prefs.mkをインクルードしてください。

	.include "../../mk/bsd.prefs.mk"

	.if defined(USE_MENUS)
	...
	.endif


 10.10 pkgについて話しあうためのメーリングリストはありますか?
 ============================================================

はい。パッケージに関する問題を議論するためにtech-pkg@netbsd.orgが存在します。
参加するためには以下のようにして下さい。

	% echo subscribe tech-pkg | mail majordomo@netbsd.org


 10.11 どうすれば「make fetch」でpassive FTPを使用することができますか?
 ======================================================================

distfileの取得にどのユーティリティーを使っているかによります。bsd.pkg.mkは、
以下のリストのなかで利用可能なコマンドのうち、最初のものをFETCH_CMDに割り当
てます:

	/usr/bin/fetch
	${LOCALBASE}/bsd/bin/ftp
	/usr/bin/ftp

NetBSDのデフォルトのインストールでは、/usr/bin/ftpとなり、これは自動的に、
最初はパッシブ接続を試みます。そして、サーバーがパッシブ接続を拒否した場合
は、アクティブ接続に切り替わります。これ以外のツールの場合は、
/etc/mk.confに以下の設定を追加してください。PASSIVE_FETCH=1

これを設定すると、/usr/bin/ftpはアクティブ転送への切り替えをおこなわなくな
ります。


 10.12 他のパッケージへの依存
 ============================

パッケージは他のパッケージに依存するかもしれません。そして、この依存性を定
義するためのいろいろな方法があります。NetBSDは、buildlink2.mkを使った依存関
係(8 節参照)のほか、BUILD_DEPENDS、DEPENDS定義をサポートしています。

両定義の基本的な差異は、以下の通りです: DEPENDS定義では、その依存性がバイナ
リーパッケージ内に記録されますが、BUILD_DEPENDS定義では記録されません。

つまり、あるパッケージが必要となるのが構築時だけである場合、そのパッケージ
はBUILD_DEPENDSとして書くべきです。

BUILD_DEPENDSおよびDEPENDS定義の書式は以下の通りです:

	<pre-req-package-name>:../../<category>/<pre-req-package>

なお、この"pre-req-package-name"のバージョン番号には、pkg_info(1)で説明され
ている各ワイルドカードを含めることができます。

(a) パッケージを構築するために他のパッケージが必要なら、BUILD_DEPENDS定義を
使ってください。

	BUILD_DEPENDS+=  autoconf-2.13:../../devel/autoconf

(b) もし、パッケージがリンクのためのライブラリーを必要とするなら、DEPENDS定
義を使ってください。たとえば、pkgsrc/print/lyxパッケージは、作成のためにxpm
ライブラリーのバージョン3.4jを使用します。

	DEPENDS+=       xpm-3.4j:../../graphics/xpm

また、パッケージ依存関係にはワイルドカードを使うことができます。

	DEPENDS+=	xpm-[0-9]*:../../graphics/xpm

ワイルドカード依存関係は、バイナリー・パッケージを作る時には保持されること
に注意してください。依存関係はバイナリーパッケージのインストール時にチェッ
クされ、パターンにマッチするパッケージが使われます。ワイルドカード依存関係
は、注意を払って使うよう気を付けてください。

tk-postgresqlがtk-*というDEPENDにマッチするなどの曖昧なマッチの可能性を排除
するため、-*ではなく-[0-9]*を使うことをおすすめします。

(c) もし、パッケージを実行するために、いくつかの実行可能ファイルが必要なら、
DEPENDS定義を使ってください。pkgsrc/print/lyxパッケージを実行する時には、
teTexパッケージ由来のlatex のバイナリーが実行可能でなければなりません。これ
は、以下のように指定します。

	DEPENDS+=        teTex-[0-9]*:../../print/teTeX 

上述した、ワイルドカード依存関係に関する注意は、ここにも当てはまります。

パッケージの構築用に別のパッケージに含まれるファイルが必要な場合は、
pkgsrc/print/ghostscript5パッケージの"do-configure"ターゲットの最初の部分を
ご覧ください(このパッケージは、構築の際にjpegのソースがソースの状態で存在す
ることに依存しています)。

	if [ ! -e ${_PKGSRCDIR}/graphics/jpeg/${WRKDIR:T}/jpeg-6b ]; then \
		cd ${_PKGSRCDIR}/../../graphics/jpeg && ${MAKE} extract;              \
	fi

このように、別のパッケージの構築用にソースを展開する場合は、構築するパッケー
ジの作業ファイルの削除時に、展開した依存先パッケージの作業ファイルも削除す
るようにしてください。そうするための一番簡単な方法は、pre-cleanターゲットを
追加することです。

	pre-clean:
		cd ${_PKGSRCDIR}/../../graphics/jpeg && ${MAKE} clean

また、便利に使うことができるBUILD_USES_MSGFMTおよびBUILD_USES_GETTEXT_M4定
義にも注意してください。前者は、基本システムにmsgfmt(1)があるかどうか調べて、
ない場合はpkgsrc/devel/gettextパッケージをインストールします。後者は、構築
の際に、旧バージョンのgettextパッケージがインストールされていることに依存す
るようにし、これがインストールされていない場合はpkgsrc/devel/gettext-m4パッ
ケージをインストールします。


 10.13 他のパッケージとの衝突
 ============================

パッケージは、すでにインストール済みの別のパッケージと衝突する可能性があり
ます。例えば、パッケージが、pkgsrcの中の別のパッケージと同じファイルをイン
ストールするような場合です。

この場合、衝突するパッケージ(バージョン文字列を含む)のリストをスペースで区
切ってCONFLICTSにセットすることができます。

例えば、pkgsrc/x11/Xaw3dおよびpkgsrc/x11/Xaw-Xpmは同じ共有ライブラリーをイ
ンストールします。したがって、pkgsrc/x11/Xaw3d/Makefileに以下のような設定を
おこなってください。

	CONFLICTS=      Xaw-Xpm-[0-9]*

そして、pkgsrc/x11/Xaw-Xpm/Makefileには以下の設定が必要です。

	CONFLICTS=      Xaw3d-[0-9]*

パッケージは、名前のプレフィックスが同じで、異なるバージョン文字列をもつ別
のパッケージと自動的に衝突します。例えば「Xaw3d-1.5」は、古いバージョンの
「Xaw3d-1.3」と衝突するでしょう。


 10.14 WWWホームページがあるソフトウェア
 =======================================

NetBSDパッケージシステムは、HOMEPAGE変数をサポートしています。もし、パッケー
ジ化されたソフトウェアのホームページが存在するのであれば、そのページのURLを
MakefileのHOMEPAGE変数に設定するべきです。この変数はMAINTAINER変数のすぐ後
に定義してください。


 10.15 '古い'名前のまま更新されたdistfileの取り扱い
 ==================================================

時々、ソフトウェアパッケージの作者がソフトウェアのリリース後に変更を加え、
変更後のdistfileを、バージョン番号を変えずに公開することがあります。このと
き、pkgsrcにそのパッケージがすでに入っていると、md5チェックサムが一致しない
ことになります。この問題の正しい回避策は、パッケージのmd5チェックサムをマス
ターサイト(ミラーサイトでは更新されていないことがあります!)のパッケージに合
わせて変更し、古いdistfileをftp.netbsd.orgの/pub/NetBSD/packages/distfiles
ディレクトリーから削除することです。さらに、パッケージの正当な作者にメール
を出して、distfileの更新が意図されたものであって、トロイの木馬などが仕込ま
れたのではないことを確認します。


 10.16 "Don't know how to make /usr/share/tmac/tmac.andoc" ってどういうこと?
 ===========================================================================

pkgsrc/pkgtools/pkg_installパッケージのコンパイル時に、makeが
/usr/share/tmac/tmac.andoc の作り方がわからないというエラーを出します。これ
は、そのマシンに"text"セット(nroffなど)がインストールされていないことを意味
しています。"text"セットをインストールしてください。

このpkg_installパッケージの事例は、環境変数か/etc/mk.confのどちらかで
NOMAN=YESを設定して回避することもできます。

 10.17 既存パッケージ修正時に、バージョンを上げるにはどうするか
 ==============================================================

既存のパッケージに修正を加えたときに、PKGNAMEのバージョン番号を変えると便利
な場合があります。元の作者による将来のバージョンと衝突しないようにするため、
PKGREVISION=1 (2,. ..)を設定して、パッケージのバージョンに'nb1' ('nb2',
...)という接尾辞をつけることができます。この"nb"は、pkgツール群からは"."と
同様の扱いを受けます。たとえば、

DISTNAME=	foo-17.42
PKGREVISION=	9

とすると、PKGNAMEはfoo-17.42nb9になります。

このパッケージの新しいリリース版が出た際には、PKGREVISIONは消してください。
たとえば、上で例示したパッケージの新しいマイナーリリースに際しては、以下の
ようにします

DISTNAME=	foo-17.43


 10.18 "Could not find bsd.own.mk" - 何がいけないの?
 ===================================================

NetBSDのインストール時にコンパイラー一式comp.tgzをインストールしなかったか
らです。comp.tgzを入手し、/で展開してインストールしてください:

	# tar --unlink -pvxf .../comp.tgz

comp.tgzはNetBSDのどのリリースにも含まれていますので、あなたがインストール
したリリース("uname -r"で調べられます) に合ったものを入手してください。


 10.19 制限つきパッケージ
 ========================

ライセンスによっては、ソフトウェアの再配布方法に制限があります。このような
制限を満たすようにするため、パッケージシステムでは以下のような制限を設定で
きる5個のmake変数を定義しています:

 * RESTRICTED:
   なにか制限がある場合は常に、(制限の種類にかかわらず)この変数を設定す
   べきです。この変数を、その制限の理由を含む文字列に設定してください。
 
 * NO_BIN_ON_CDROM:
   バイナリーをCD-ROMに収録してはいけません。バイナリーパッケージを
   CD-ROMに含めることができない場合は常に、この変数を${RESTRICTED}に設定
   してください。
 
 * NO_BIN_ON_FTP:
   バイナリーをftpサーバーに置いてはいけません。バイナリーパッケージをイ
   ンターネット上で公開することができない場合は常に、この変数を
   ${RESTRICTED}に設定してください。
 
 * NO_SRC_ON_CDROM:
   distfileをCD-ROMに収録してはいけません。ソースコードやその他の
   distfileのCD-ROMによる再配布が許可されていない場合は、この変数を
   ${RESTRICTED}に設定してください。
 
 * NO_SRC_ON_FTP:
   distfileをFTPに置いてはいけません。ソースコードやその他のdistfileのイ
   ンターネット経由での再配布が許可されていない場合は、この変数を
   ${RESTRICTED}に設定してください。

NO_PACKAGE, IGNORE, NO_CDROMなど、制限を意味する上記以外の汎用make変数は使
うべきでないことに注意してください。これらは、ユーザーのバイナリーパッケー
ジ作成を、無条件にできないようにするからです。


 10.20 (n)cursesを使うパッケージ
 ===============================

パッケージによっては1.4Y以前のNetBSD自身のcursesにはなかった機能を必要とし
ます。

パッケージのMakefileで../../devel/ncurses/buildlink2.mkをインクルードすると、
pre-configure時に、cursesライブラリーとncurses機能用のヘッダーが
${BUILDLINK_DIR}内にリンクされます。ncursesが本当に必要な場合は、パッケージ
のMakefileでUSE_NCURSESを定義してください。


 10.21 自動セキュリティーチェック
 ================================

サードパーティーのソフトウェアにはしばしばバグがあること、そして、バグのな
かにはマシンをアタッカーの攻撃に対して脆弱な状態にするものもあることに、ど
うか注意してください。そのような攻撃にさらされることを減らすために、NetBSD
パッケージチームでは、pkgsrc化されたことのあるパッケージに関する既知の攻撃
のデータベースを保守しています。このデータベースを自動的にダウンロードして、
システムにインストールされている全パッケージのセキュリティー監査をおこなう
ことができます。これをおこなうにはpkgsrc/security/audit-packagesパッケージ
をインストールします。このパッケージは、以下の二つの構成要素からなっていま
す。

 (1) download-vulnerability-list: セキュリティー脆弱性情報のリストのダウン
     ロードを簡単にできるようにするものです。この脆弱性情報のリストは、
     NetBSDセキュリティーオフィサーとNetBSDパッケージチームが最新の状態に保っ
     ており、NetBSD ftpサーバーで配布されています。

	ftp://ftp.netbsd.org/pub/NetBSD/packages/distfiles/vulnerabilities

 (2) audit-packages: マシンの監査を簡単にできるようにするもので、既知の各脆
     弱性の確認をします。脆弱性のあるパッケージがインストールされていた場合、
     そのことを標準出力に出力します。この出力には、脆弱性の種類の説明と詳細
     情報のURLが含まれます。

audit-packagesパッケージを使うよう強くおすすめします。

audit-packagesのインストール中に以下のようなメッセージが表示されます。

        ======================================================================
	You may wish to have the vulnerabilities file downloaded daily so that
	it remains current.  This may be done by adding an appropriate entry
	to the root users crontab(5) entry.  For example the entry
	
	# download vulnerabilities file
	0 3 * * * ${PREFIX}/sbin/download-vulnerability-list >/dev/null 2>&1
	
	will update the vulnerability list every day at 3AM.
	
	In addition, you may wish to run the package audit from the daily
	security script.  This may be accomplished by adding the following
	lines to /etc/security.local
	
	if [ -x ${PREFIX}/sbin/audit-packages ]; then
	        ${PREFIX}/sbin/audit-packages
	fi
        ======================================================================


パッケージ開発者への註: 脆弱性が発見された場合、そのことを
localsrc/security/advisories/pkg-vulnerabilitiesに記載してcommitしてくださ
い。このファイルはftp.netbsd.orgの
/pub/NetBSD/packages/distfiles/vulnerabilities にコピーされます。


 10.22 パッケージでアカウントを作成する場合の適切な方法は?
 =========================================================

パッケージ特有のグループやユーザーをpre-install時に作成するよう制御するため、
二つのmake変数があります。一つ目はPKG_GROUPSで、group[:groupid]という要素
(グループIDはあってもなくてもかまいません)を列挙したものです。二つ目は
PKG_USERSで、以下のような形式の要素を列挙したものです:

	user:group[:[userid][:[description][:[home][:shell]]]]

userとgroupのみが必須であり、それ以外はあってもなくてもかまいません。簡単な
例は、以下のとおりです:

	PKG_GROUPS=	foogroup
	PKG_USERS=	foouser:foogroup

もっと複雑な、二つのグループと二つのユーザーを作成する例は、以下のとおりで
す:

	PKG_GROUPS=	group1 group2:1005
	PKG_USERS=	first:group1::First\\ User			\
			second:group2::Second\\ User:/home/second:${SH}

ユーザーのホームディレクトリーやログインシェルを指定しなかった場合の、デフォ
ルトのホームディレクトリーは/nonexistent、ログインシェルは/sbin/nologinです。

これらの変数を指定するほか、パッケージのMakefileで、bsd.pkg.mkをインクルー
ドする前に"../../mk/bsd.pkg.install.mk"をインクルードする必要があります。こ
れにより、pre-install時にユーザーとグループが作成されるようになり、
post-deinstall時にはこのユーザーとグループの削除を管理者に促すようになりま
す。パッケージのインストールの前に環境変数 PKG_CREATE_USERGROUPをonかoffに
設定しておくと、ユーザーとグループを自動で作成するかどうかを切替えることが
できます。


 10.23 コンパイラーのバグへの対処方法
 ====================================

ソースファイルのなかには、コンパイラーのバージョンとアーキテクチャーの組合
せによって、また、ほとんどの場合は、最適化を有効にしたことも関係して、コン
パイラーのバグを発現させるものがあります。よくある症状は、gccの内部エラーや、
ファイルのコンパイルが完了しないというものです。

たいていは、回避策として、MACHINE_ARCHとコンパイラーのバージョンを確認し、
問題のあるファイル/MACHINE_ARCH/コンパイラーの組合せに対して最適化を無効に
し、そのことをdoc/HACKSに文書化しておくことが必要となります。例については
doc/HACKSを参照してください。


 10.24 infoファイルが附属するパッケージ 
 ======================================

パッケージによっては、infoファイルをインストールしたり、makeinfoまたは
install-infoコマンドを使ったりします。この場合、パッケージのMakefileで、
mk/bsd.pkg.mkをインクルードする前に、makefileの断片mk/texinfo.mkをインクルー
ドする必要があります。texinfoの新しいバージョン(バージョン4以上)は、困った
ことに、それより前のバージョンとコマンド行のレベルで互換性がありません。ま
た、TeXinfoマクロセットに拡張がいくつか導入されています。このため、パッケー
ジ作者は、シェルのPATH変数の内容に依存したりせずに、適切なバイナリーが選ば
れるようにすべきです。

主たるinfoディレクトリーファイルは、infoファイルがインストールされたことを
反映するために更新する必要があります。パッケージによっては、インストール過
程でこの更新をおこなってくれます。そうしてくれないパッケージでは、NetBSDパッ
ケージコレクションのINFO_FILES定義を、この更新用に使うことができます。パッ
ケージのMakefileで、

	INFO_FILES=	ident.info

と定義するだけです。この"ident.info"は、infoディレクトリーファイルにインス
トールされるinfoファイルの名前にします。

パッケージ作者は、パッケージの構築とインストールのプロセスが、適切なバージョ
ンのmakeinfoおよびinstall-infoコマンドを使うようにするよう、注意を払うべき
です。最近のソフトウェアパッケージに附属するMakefilesやconfigureスクリプト
のなかには、makeinfoおよびinstall-infoコマンドへのパス名を含めているものが
あります。残念ながら、古いソフトウェアパッケージは、そのようにはしない傾向
があります。問題となるのはこのケースで、パッケージ作者が手間をかける必要が
あります。

makefileの断片mk/texinfo.mkは、適切なmakeinfoおよびinstall-infoコマンドをシ
ステム上で利用可能な状態にして、パッケージのconfigureおよびbuildプロセスが
これらのコマンドのバイナリーを使うようにします。

あるバージョン以上のmakeinfoおよびinstall-infoコマンドが必要な場合は、パッ
ケージのMakefileで、 TEXINFO_REQDを必要な最低バージョンに設定します。

パッケージが適切な挙動をしない(つまり、configureやbuildの際に環境変数
MAKEINFOやINSTALL_INFOを参照しない) 場合は、以下のいずれか適切な方をおこな
うべきです:
 a) パッケージのファイルにパッチを当てて、configureやbuildの際に、makeinfo
    やinstall-infoがPATH中にあることを前提にするのではなく、環境変数
    MAKEINFOやINSTALL_INFOを使うようにする;
 b) パッケージのMakefileにTEXINFO_OVERRIDE=YESを書いておき、パッケージのソー
    スファイルの内容を置換するようにする(mk/texinfo.mkの内容を参考にしてく
    ださい)。


 10.25 distfileのダウンロードが単純にできないパッケージ
 ======================================================

動的なURLからダウンロードする必要がある場合は、DYNAMIC_MASTER_SITESを設定す
ることができます。すると、'make fetch'は、ダウンロードすべき各ファイルを引
数としてfiles/getsite.shを呼び出します。このスクリプトは、ファイルをダウン
ロードするディレクトリーのURLを出力することが前提となっています。
graphics/ns-cult3dが、この使い方の例となっています。

パスワード用に個人情報の登録が必要だったり、ソースに代金を払う必要があった
り、その他もろもろの理由により、ダウンロードが自動化できない場合は、
_FETCH_MESSAGEに、説明文を表示するマクロを設定することができます。
_FETCH_MESSAGEは、説明文そのものではなく、実行可能なシェルコマンドである必
要があります。(一般的には、${ECHO}を実行します)。本稿執筆時点で、この方法を
使っているパッケージは、audio/realplayer, cad/simian, devel/ipv6socket,
emulators/vmare-module, fonts/acroread-jpnfont, sysutils/storage-manager,
www/ap-aolserver, www/openacsです。これらと一貫性のある使い方をしてください。


 10.26 NetBSD以外(Linux, Solaris, Darwin, MacOS X)でpkgsrcを使う
 ===============================================================

NetBSD以外のオペレーティングシステムでpkgsrcを使うためには、まず、必要なユー
ティリティー(BSD make, pkg_*, ...)の準備が必要です。この準備については
http://www.zoularis.org/を参照してください。


 10.27 設定ファイルの処理および配置
 ==================================

大域変数PKG_SYSCONFBASE(とその他の変数)を、システム管理者が/etc/mk.confで設
定すると、設定ファイルのインストール場所を定義することができます。このため、
各パッケージはこの機能に対応する必要があります。この変数で定義される設定ファ
イル用ディレクトリーには、本当に必要なファイルだけをインストールすべきであっ
て、$PREFIX/shareに置いてもよいファイルはそちらにインストールすべきであるこ
とに注意してください。

まず、利用可能な変数をお見せします(bsd.pkg.mkに、さらに詳しい情報があります)。
PKG_SYSCONFDIRが、パッケージの設定ファイルが置かれる場所になります(これはフ
ルパスです。たとえば、/etcや/usr/pkg/etcになります)。この変数値は、さまざま
な方法によってカスタマイズすることができます:

 1) PKG_SYSCONFBASEは主たる設定ディレクトリーで、パッケージ用の設定ファイル
    すべてがこれ以下に置かれます。ユーザーは普通はPKG_SYSCONFBASEを/etcに設
    定するか、デフォルトの場所の${PREFIX}/etcのままにするでしょう。

 2) PKG_SYSCONFSUBDIRのサブディレクトリーで、個々のパッケージ用の設定ファイ
    ルはこの下に置かれます。デフォルトでは$SYSCONFBASEになります。

 3) PKG_SYSCONFVARは、個々のパッケージの設定を上書きする値を識別するための、
    特別な接尾辞です(次の項目参照)。デフォルトでは${PKGBASE}になりますが、
    PKG_SYSCONFDIRを同じに揃えておくべき一連の関連パッケージに対しては、各
    パッケージのMakefileで、PKG_SYSCONFVARを同じ値に設定することができます。

 4) PKG_SYSCONFDIR.${PKG_SYSCONFVAR}は、同じPKG_SYSCONFVARを持つパッケージ
    の${PKG_SYSCONFDIR}を上書きします。

    たとえば、KDE関連の各パッケージでは、PKG_SYSCONFVARを"kde"に設定すると
    よいでしょう。こうしておくと、管理者が/etc/mk.confで
    ${PKG_SYSCONFDIR.kde}を設定して、KDEの設定ファイルのインストール場所を
    定義できるようになります。

プログラムの設定ディレクトリーは、configureの段階で定義すべきです。GNU
autoconfを使うパッケージでは、通常は--sysconfdirのパラメーターを使って定義
することができますが、この方法は問題を起こすことがわかっています。このパス
名をパッケージ側で変更する場合は、ファイルをディレクトリーに直接インストー
ルするようにすべきではありません。そうするかわりに、ファイルを
share/examples/${PKGNAME}以下にインストールして、PLISTにそちらを登録できる
ようにする必要があります。

必要な設定ファイルを適切な場所(share/examplesディレクトリー以下)に一旦置い
てから、この設定ファイルをPKG_SYSCONFDIRにコピーするために、CONF_FILES変数
を設定します。この変数の値は、ファイル名を二個組み合わせたものを並べたもの
です; 組合せの一つ目で、examplesディレクトリー内のファイル(PLISTに登録され
ているもの)を指定し、二つ目で、それをコピーする先のファイルを指定します。こ
れにより、バイナリーパッケージが、自動生成されるINSTALL/DEINSTALLスクリプト
を使って、ファイルを正しいディレクトリーに配置することが可能になります。ま
た、この自動生成されるスクリプトを使うために、パッケージのMakefileで
bsd.pkg.mkをインクルードする前に"../../mk/bsd.pkg.install.mk"をインクルード
しなければなりません。設定ファイルの自動コピーは、パッケージをインストール
する前に環境変数PKG_CONFIGを設定しておくことで、おこなうかどうかを切替える
ことができます。

mail/mutt/Makefileでの例を示します:

	EGDIR=	${PREFIX}/share/doc/mutt/samples
	CONF_FILES=	${EGDIR}/Muttrc ${PKG_SYSCONFDIR}/Muttrc

ご覧のとおり、このパッケージは設定ファイルをEGDIRにインストールし、この場所
がPLISTに登録されます。その後、CONF_FILES変数に、はじめにインストールされた
ファイルと、そのコピー先ファイルを列挙します。ファイルがこの方法でインストー
ルされる時には、パッケージの利用者にメッセージを自動的に表示します。


 11 提出およびコミット
 =====================

 11.1 あなたが作ったパッケージの提出
 ===================================

ここでは、バイナリーパッケージと"通常の"(ソース)パッケージとを区別する必要
があります:

 *コンパイル済みのバイナリー・パッケージ:
  我々は、トロイの木馬等を含まないことを保証するために、NetBSD開発者からし
  かバイナリーを受け取りません。これは、誰かを糞ったれ扱いするものではなく、
  むしろユーザーを保護するための方針です。しかしながら、あなたの作ったバイ
  ナリー・パッケージをどこかに置き、配布することは自由に行なってもかまいま
  せん。

 *パッケージ:
  最初にパッケージが完全かどうか、コンパイル、実行できるかどうかを確認して
  ください。このドキュメントのセクション9、その他が参考になるでしょう。次に、
  パッケージに必要なすべてのファイルのgzipされたtarファイルを作成してくださ
  い。これは、すべてのファイルをひとつのディレクトリーにおきたいためです。
  次に、そのtarファイルを、パッケージのメンテナーがFTPかHTTP (WWW)を使用し
  て取得できる場所においてください。最後に、パッケージの名前とバージョンを
  含む概要、簡単な説明(COMMENT変数の内容でもOKです)、そしてtarファイルのURL
  を書き、「pkg」カテゴリーでsend-pr (問題報告)をおこなってください。

  問題報告が処理されたら、あなたに連絡がいきます。そうすれば、tarファイルを
  削除してもかまいません。

  複数のパッケージを提出したい場合は、一つのパッケージにつき一つのPRにわけ
  て送ってください。そうすることで、私たちが追跡しやすくなります。


 11.2 コミット: パッケージのCVSへのインポート
 ============================================

このセクションは、NetBSDのpkgsrcリポジトリーへの書き込みアクセス権限を持っ
ているNetBSD開発者にのみ意味があるものです。cvsはカレントディレクトリーから
の相対位置にファイルをインポートすることと、"cvs import"コマンドに渡したパ
ス名からリポジトリー中のファイルの位置が決まることを忘れないでください。新
しく作ったパッケージは、「TNF」のベンダータグと「pkgsrc-base」のリリースタ
グでインポートしてください。例えば:

	% cd .../pkgsrc/<category>/<pkgname>
	% cvs import pkgsrc/<category>/<pkgname> TNF pkgsrc-base

また、インポートに使ったディレクトリーは、忘れずに邪魔にならないところに移
しておいてください。そうしておかないと、ソースツリーを次に"cvs update"した
ときにcvsが文句を言います。さらに、この新しいパッケージを、categoryの
Makefileに忘れずに追加してください。

初回のインポートでは、コミットメッセージにDESCRファイルの内容を含めておき、
どういうパッケージなのかがメーリングリストの読者にわかるようにしてください。

すべてのパッケージの変更や追加を、pkgsrc/doc/CHANGESに記述してください。こ
のファイルを、これまでと同じ形式のまま最新の状態に保つことは非常に重要なこ
とです。なぜなら、このファイルはスクリプトによりwww.netbsd.orgや他のサイト
のページを自動的に更新するために使用されているからです。

新しいパッケージを追加する場合は、"cvs add"ではなく"cvs import"を使うように
してください。"cvs import"なら、単一のコマンドですべて記述することができ、
また、一貫したタグを打つことができるからです。


 11.3 パッケージを新しいバージョンに更新する 
 ===========================================

パッケージを更新するときは、新旧バージョン間の変更点の簡潔で適切で意味のあ
る要約を、コミットログに必ず書いてください。そうすべき理由はいろいろありま
す:

+ URLは不安定なものであり、時間がたつと変わることがあります。完全になくなる
かもしれませんし、新しい情報に書き換わるかもしれません。

+ 新旧バージョン間の変更点をCVSリポジトリーに保持しておくと、cvsやanoncvsの
利用者にとって、非常に便利です。

+ 新旧バージョン間の変更点をCVSリポジトリーに保持しておくと、pkgsrc-changes
メーリングリストの読者が、パッケージをいつ更新するかの戦術を立てられるよう
になり、非常に便利です。

また、あるパッケージに新しいバージョンがリリースされたというだけの理由で、
CVSリポジトリー上のパッケージを更新するべきではないことを認識してください。
私たちは、pkgsrcに含まれるパッケージに関して保守的であることを好みます。と
いうのも、開発版やベータ版のパッケージは、pkgsrcが使われる場面のほとんどに
対して、まったくふさわしくないからです。どのバージョンをpkgsrcに入れるべき
か、分別をもって判断してください。新機能(テストされていない機能があるかもし
れません)よりも安定性のほうが好ましいことを念頭に置いてください。


 11.4 pkgsrcのパッケージを移動する
 =================================

 1. パッケージのディレクトリーをどこかにコピーします。
 2. コピーしたものからCVSディレクトリーをすべて削除します。
    手順1,2は、以下のようにすることもできますので、今後の作業にはこちらを使っ
    てください:
	  cvs -d user@cvs.netbsd.org:/cvsroot export -D today pkgsrc/category/package
 3. CATEGORIESを修正します。また、../../category/packageのかわりに単に
    ../packageとすることができるDEPENDSのパスをすべて修正します。
 4. 新しい場所で、修正後のパッケージを"cvs import"します。
 5. このパッケージに依存しているパッケージを調べます:
	cd /usr/pkgsrc
	grep /package */*/Makefile* */*/buildlink*
 6. 手順5で見つかったものに対して、このパッケージへのパスを、新しい場所を指
    すように修正します。
 7. 古い場所で、移動前のパッケージを"cvs rm (-f)"します
 8. oldcategory/Makefileからこのパッケージを削除します。
 9. newcategory/Makefileにこのパッケージを追加します。
10. 変更および削除されたファイルを commit します:
	cvs commit oldcategory/package oldcategory/Makefile newcategory/Makefile
    もちろん、手順5の各パッケージもです。


 12 パッケージの簡単な例: bison
 ==============================

私は、パッケージコレクションにないソフトウェアをさがし、GNU bisonを選びまし
た。バークレーのyaccがすでにソースツリーに存在するので、bisonを使いたい人は
いないでしょう。しかし、練習という意味では役にたちます。


 12.1 ファイル
 =============

このセクションのファイルの内容は、実際には「> 」というプレフィックスなしで
使用してください。


 12.1.1 Makefile
 ===============

	# <$>NetBSD<$>
	 
	DISTNAME=       bison-1.25
	CATEGORIES=     devel
	MASTER_SITES=   ${MASTER_SITE_GNU}
	MAINTAINER=     thorpej@netbsd.org
	HOMEPAGE=       http://www.gnu.org/software/bison/bison.html
	COMMENT=        GNU yacc clone
	 
	GNU_CONFIGURE=  yes
	INFO_FILES=     bison.info
	 
	.include "../../mk/texinfo.mk"
	.include "../../mk/bsd.pkg.mk"


 12.1.2 DESCR
 ================

	GNU version of yacc.  Can make re-entrant parsers, and numerous other
	improvements.  Why you would want this when Berkeley yacc(1) is part
	of the NetBSD source tree is beyond me.


 12.1.3 PLIST
 ================

	@comment <$>NetBSD<$>
	bin/bison
	man/man1/bison.1.gz
	@unexec install-info --delete %D/info/bison.info %D/info/dir
	info/bison.info
	info/bison.info-1
	info/bison.info-2
	info/bison.info-3
	info/bison.info-4
	info/bison.info-5
	@exec install-info %D/info/bison.info %D/info/dir
	share/bison.simple
	share/bison.hairy


 12.1.4 パッケージをチェックする 「pkglint」
 ==========================================

NetBSDパッケージシステムは、「pkglint」(pkgsrc/pkgtools/pkglintディレクトリー
にあります)とよばれるツールを含んでいます。このツールはこれらのファイルの内
容をチェックするのを助けてくれます。一度インストールしてしまえば、このツー
ルは非常に簡単に使うことができます。検査したいパッケージのディレクトリーに
移動し、「pkglint」を実行するだけです。

	% pkglint
	OK: checking ./DESCR.
	OK: checking Makefile.
	OK: checking distinfo.
	OK: checking patches/patch-aa.
	looks fine.

指定されたコマンド行の引数(「man pkglint」を見てください)によっては、より冗
長なチェックがおこなわれます。例えば「pkglint -v」は、大変詳細かつ冗長なチェッ
クをおこないます。


 12.2 構築、インストール、パッケージングの手順
 =============================================

パッケージのためのディレクトリーと、いくつかの追加のディレクトリーを作成し
ます。

	# cd /usr/pkgsrc/lang
	# mkdir bison
	# cd bison
	# mkdir patches pkg

セクション11.1のようにMakefile、DESCRおよびPLISTを作り、distfile を取得しま
す。

	# make fetch
	>> bison-1.25.tar.gz doesn't seem to exist on this system.
	>> Attempting to fetch from ftp://prep.ai.mit.edu/pub/gnu//.
	Requesting ftp://prep.ai.mit.edu/pub/gnu//bison-1.25.tar.gz (via ftp://orpheus.amdahl.com:80/)
	ftp: Error retrieving file: 500 Internal error
	 
	>> Attempting to fetch from ftp://wuarchive.wustl.edu/systems/gnu//.
	Requesting ftp://wuarchive.wustl.edu/systems/gnu//bison-1.25.tar.gz (via ftp://orpheus.amdahl.com:80/)
	ftp: Error retrieving file: 500 Internal error
	 
	>> Attempting to fetch from ftp://ftp.freebsd.org/pub/FreeBSD/distfiles//.
	Requesting ftp://ftp.freebsd.org/pub/FreeBSD/distfiles//bison-1.25.tar.gz (via ftp://orpheus.amdahl.com:80/)
	Successfully retrieved file.

distfileのチェックサムをdistinfoへ作成します。

	# make makesum

コンパイルします。

	# make
	>> Checksum OK for bison-1.25.tar.gz.
	===>  Extracting for bison-1.25
	===>  Patching for bison-1.25
	===>   Ignoring empty patch directory
	===>  Configuring for bison-1.25
	creating cache ./config.cache
	checking for gcc... cc
	checking whether we are using GNU C... yes
	checking for a BSD compatible install... /usr/bin/install -c -o bin -g bin
	checking how to run the C preprocessor... cc -E
	checking for minix/config.h... no
	checking for POSIXized ISC... no
	checking whether cross-compiling... no
	checking for ANSI C header files... yes
	checking for string.h... yes
	checking for stdlib.h... yes
	checking for memory.h... yes
	checking for working const... yes
	checking for working alloca.h... no
	checking for alloca... yes
	checking for strerror... yes
	updating cache ./config.cache
	creating ./config.status
	creating Makefile
	===>  Building for bison-1.25
	cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g LR0.c
	cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g allocate.c
	cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g closure.c
	cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g conflicts.c
	cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g derives.c
	cc -c -DXPFILE=\"/usr/pkg/share/bison.simple\"  -DXPFILE1=\"/usr/pkg/share/bison.hairy\" -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1  -g  ./files.c 
	cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g getargs.c
	cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g gram.c
	cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g lalr.c
	cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g lex.c
	cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g main.c
	cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g nullable.c
	cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g output.c
	cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g print.c
	cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g reader.c
	cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g reduce.c
	cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g symtab.c
	cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g warshall.c
	cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g version.c
	cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g getopt.c
	cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g getopt1.c
	cc  -g -o bison LR0.o allocate.o closure.o conflicts.o derives.o files.o         getargs.o gram.o lalr.o lex.o                                   main.o nullable.o output.o print.o reader.o reduce.o symtab.o   warshall.o version.o getopt.o getopt1.o
	./files.c:240: warning: mktemp() possibly used unsafely, consider using mkstemp()
	rm -f bison.s1
	sed -e "/^#line/ s|bison|/usr/pkg/share/bison|" < ./bison.simple > bison.s1

すべてOKのようなので、ファイルをインストールします。

	# make install
	>> Checksum OK for bison-1.25.tar.gz.
	===>  Installing for bison-1.25
	sh ./mkinstalldirs /usr/pkg/bin /usr/pkg/share  /usr/pkg/info /usr/pkg/man/man1
	rm -f /usr/pkg/bin/bison
	cd /usr/pkg/share; rm -f bison.simple bison.hairy
	rm -f /usr/pkg/man/man1/bison.1 /usr/pkg/info/bison.info*
	install -c  -o bin -g bin -m 555 bison /usr/pkg/bin/bison
	/usr/bin/install -c -o bin -g bin -m 644 bison.s1 /usr/pkg/share/bison.simple
	/usr/bin/install -c -o bin -g bin -m 644 ./bison.hairy /usr/pkg/share/bison.hairy
	cd .; for f in bison.info*;  do /usr/bin/install -c -o bin -g bin -m 644 $f /usr/pkg/info/$f; done
	/usr/bin/install -c -o bin -g bin -m 644 ./bison.1 /usr/pkg/man/man1/bison.1
	===>  Registering installation for bison-1.25

これでbisonを使用することができます。そして、「pkg_delete bison-1.25」を実
行することでbisonを削除することもできます。もし、バイナリー・パッケージが欲
しければ、以下のようにしてください。

	# make package
	>> Checksum OK for bison-1.25.tar.gz.
	===>  Building package for bison-1.25
	Creating package bison-1.25.tgz
	Registering depends:.
	Creating gzip'd tar ball in '/u/pkgsrc/lang/bison/bison-1.25.tgz'

もし、ソースやオブジェクトファイルが必要ないのであれば、掃除してください。

	# make clean
	===>  Cleaning for bison-1.25


=================
付録A: 構築のログ
=================

 A.1 topの構築
 =============

	# make
	>> top-3.5beta5.tar.gz doesn't seem to exist on this system.
	>> Attempting to fetch from ftp://ftp.groupsys.com/pub/top/.
	Requesting ftp://ftp.groupsys.com/pub/top/top-3.5beta5.tar.gz (via ftp://orpheus.amdahl.com:80/)
	Successfully retrieved file.
	>> Checksum OK for top-3.5beta5.tar.gz.
	===>  Extracting for top-3.5beta5
	===>  Patching for top-3.5beta5
	===>  Applying NetBSD patches for top-3.5beta5
	===>  Configuring for top-3.5beta5
	/bin/cp /u/pkgsrc/sysutils/top/files/defaults /u/pkgsrc/sysutils/top/work/top-3.5beta5/.defaults
	chmod a-x /u/pkgsrc/sysutils/top/work/top-3.5beta5/install
	
	Reading configuration from last time...
	
	Using these settings:
	        Bourne Shell   /bin/sh
	          C compiler   cc
	    Compiler options   -DHAVE_GETOPT -O
	         Awk command   awk
	     Install command   /usr/bin/install
	
	              Module   netbsd13
	             LoadMax   5.0
	        Default TOPN   -1
	        Nominal TOPN   18
	       Default Delay   2
	Random passwd access   yes
	          Table Size   47
	               Owner   root
	         Group Owner   kmem
	                Mode   2755
	       bin directory   $(PREFIX)/bin
	       man directory   $(PREFIX)/man/man1
	       man extension   1
	       man style       man
	
	Building Makefile...
	Building top.local.h...
	Building top.1...
	Doing a "make clean".
	rm -f *.o top core core.* sigdesc.h
	To create the executable, type "make".
	To install the executable, type "make install".
	===>  Building for top-3.5beta5
	cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c top.c
	awk -f sigconv.awk /usr/include/sys/signal.h >sigdesc.h
	cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c commands.c
	cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c display.c
	cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c screen.c
	cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c username.c
	cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c utils.c
	utils.c: In function `errmsg':
	utils.c:348: warning: return discards `const' from pointer target type
	cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c version.c
	cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c getopt.c
	cc "-DOSREV=12G" -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O -c machine.c
	rm -f top
	cc -o top top.o commands.o display.o screen.o username.o  utils.o version.o getopt.o machine.o -ltermcap -lm -lkvm
	#
	#
	#
	#
	# make install
	>> Checksum OK for top-3.5beta5.tar.gz.
	===>  Installing for top-3.5beta5
	/usr/bin/install -o root -m 2755 -g kmem top /usr/pkg/bin
	/usr/bin/install top.1 /usr/pkg/man/man1/top.1
	strip /usr/pkg/bin/top
	===>  Registering installation for top-3.5beta5
	# 


 A.2 topのパッケージング
 =======================

	# make package
	>> Checksum OK for top-3.5beta5.tar.gz.
	===>  Building package for top-3.5beta5
	Creating package top-3.5beta5.tgz
	Registering depends:.
	Creating gzip'd tar ball in '/u/pkgsrc/sysutils/top/top-3.5beta5.tgz'


===================================================
付録B:FTPサーバーのパッケージアーカイブのレイアウト
===================================================

ftp.netbsd.org上のコンパイル済みのバイナリー・パッケージのレイアウト

/pub/NetBSD/packages/
                README
                distfiles/
		pkgsrc -> /pub/NetBSD/NetBSD-current/pkgsrc
                1.5/
                        i386/
                                All/
                                archivers/
                                        foo -> ../All/foo
                                ...
                        m68k/
                                All/
                                archivers/
                                        foo -> ../All/foo
                                ...
                        amiga -> m68k
                        atari -> m68k
                        ...


作成:
 - cd /usr/pkgsrc ; make install ; make package
 - /usr/pkgsrc/packages を
   ftp://ftp.netbsd.org/pub/NetBSD/packages/\
    `uname -r | sed 's@\.\([0-9]*\)[\._].*@\.\1@'`/`uname -p`
   へアップロードする。
 - 必要ならln -s `uname -m` `uname -p`

必要なディスクスペース: 不明

NetBSDのリリースバージョン向けのパッケージは、リリースバージョンの番号にあ
わせたmajor.minorという形式の名前のディレクトリーにアップロードされるべきで
す。"1.5.1"というバージョンのNetBSD向けのパッケージをアップロードするディレ
クトリーは、tinyバージョン番号を省いた"1.5"になります。LKMなど、OSバージョ
ンに強く依存するパッケージについては、major.minor.tinyリリースディレクトリー
を作って、そこに置くことができます。このようなパッケージには、バイナリーパッ
ケージ構築者のために何らかの方法で"OSVERSION_SPECIFIC=yes" 変数をつけてくだ
さい。


###########################################################################
# Local Variables:
# mode:				Text
# fill-column:			75
# sentence-end-double-space:	nil
# End:
