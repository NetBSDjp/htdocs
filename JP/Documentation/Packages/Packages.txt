# $NetBSD: Packages.txt,v 1.13 2005/10/05 14:58:09 kano Exp $
# $Id: Packages.txt,v 1.13 2005/10/05 14:58:09 kano Exp $
###########################################################################

			==========================
			 NetBSDパッケージシステム
			   ドキュメンテーション
			==========================

		      Hubert Feyrer, Alistair Crooks


目次:
=====

目次作成にはこのコマンドを実行します:
 grep -B1 '^.====' Packages.txt | egrep -v '^.[-=]'


 0 イントロダクション
 ====================

UNIXベースのシステムには、自由に利用できるソフトウェアが数多く存在します。
これらは普通、またはいくつかの変更でNetBSDで実行できます。NetBSDパッケージ
コレクションは、一つのコマンドでそのソフトウェアにNetBSDで実行するのに必要
ないくらかの変更を施して、ソフトウェアパッケージのインストール(および再イン
ストール)を簡単にします。

NetBSDパッケージシステムは、自由に利用できるサードパーティのソフトウェアを、
NetBSDホストで容易に構築することを可能にします。一旦ソフトウェアが構築され
ればそれらはpkg_*ツールにより操作できるので、そのパッケージのインストール、
削除、全てのインストールされたパッケージの目録の表示、一行コメント、あるい
はより詳細な説明の情報検索が全く簡単にできます。

NetBSDパッケージコレクションおよびNetBSDパッケージシステムは、FreeBSDに由来
しています。


 0.1 概要
 ========

このドキュメントは二部に別れています。第一部は「ユーザーガイド」で、パッケー
ジコレクションの一つのパッケージを使う方法を、コンパイル済みのバイナリー・
パッケージのインストールと、自分自身でコピーしたNetBSDパッケージシステムか
ら構築する方法の両方で説明します。第二部の「パッケージ構築者ガイド」は、他
のNetBSDユーザーがその構築の詳細について知らなくても簡単にパッケージを構築
できるようにするために、パッケージを用意する方法を説明します。


 0.2 専門用語
 ============

ここまでですでに「ポート(ports)」、「パッケージ(packages)」などについて何度
も触れています。ここで、このドキュメント中に使われている用語を説明します:

 * パッケージ(Package):
   ファイルのセットで、NetBSDパッケージシステムを使用したソフトウェアを構築
   するのに必要なことが記述された構築手順書です。パッケージは、伝統的に
   /usr/pkgsrcの下に置かれます。

 * NetBSDパッケージシステム:
   これは、NetBSDオペレーティングシステムの一部分で、パッケージの構築(コン
   パイル)、インストール、および削除を扱います。

 * Distfile:
   この用語は、自由に利用できるソフトウェアの作者が、彼の仕事を配布するため
   に提供しているファイルのことを指しています。NetBSDで構築するのに必要な全
   ての変更は、対応するパッケージに反映されます。通常distfileは、圧縮された
   tarアーカイブ形式ですが、他の形式でも使用できます。Distfilesは
   /usr/pkgsrc/distfilesの下に保存されます。

 * ポート(Port):
   これはFreeBSDの人たちが、私たちがパッケージ(package)と呼んでいるものを表
   すために使われている用語です。NetBSDでは「ポート(port)」は、異なるアーキ
   テクチャーを参照する用語となります。

 * コンパイル済み(バイナリー)パッケージ:
   NetBSDパッケージシステムを使ってdistfileより作成されたバイナリーのセット
   で、ひとつの.tgzファイルに集められています。これはリコンパイルなしに同じ
   マシンアーキテクチャーのマシンにインストールすることができます。パッケー
   ジはNetBSDパッケージシステムにより、/usr/pkgsrc/packagesに生成され、それ
   はftp.netbsd.orgにもアーカイブされています。

   時々、これは、特にコンパイル済みのパッケージの文脈で、単に「パッケージ」
   と表されることもあります。

 *プログラム:
   対応するパッケージが、Distfileにあるファイルから作成した、インストールさ
   れるべきソフトウェアのひとまとまりです。

 * NetBSD RCS ID:
   パッケージに含まれるいくつかのファイルは、そのファイルのバージョンに対応
   したRCS IDが含まれています(cvsにより自動的に挿入されます)。これらのIDは、
   このドキュメントの中のいくつかの例で使用されていますが、このドキュメント
   自体がCVSによって管理されていますので、生のRCS IDを列挙することができま
   せん。かわりに、$は<$>のように記していますので、<$>NetBSD<$>や<$>Id<$>と
   なります。


======================
第一部: ユーザーガイド
======================

 1 コンパイル済みのバイナリー・パッケージのインストール
 ======================================================

このセクションは、あなたの機種用にすでに準備されたコンパイル済みのバイナリー・
パッケージを見つけ、取得してインストールする方法について説明します。


 1.1 どこから入手するか
 ======================

コンパイル済みのパッケージは、ftp.netbsd.orgおよびそのミラー上の、匿名FTPア
クセスのためのディレクトリー/pub/NetBSD/packagesに置かれています。"sysctl
hw.machine_arch"で表示されるのと同じサブディレクトリーを選択してください。
このディレクトリーの中には、カテゴリー毎のサブディレクトリーと、「All」サブ
ディレクトリーが存在しています。「All」サブディレクトリーの中には、.tgzファ
イル形式で実際のバイナリーがあります。カテゴリー毎のサブディレクトリーは、
これらのファイルへのシンボリックリンクを使用しています。
(/usr/pkgsrc/packagesと同じディレクトリー・レイアウトです)。

CDROMディストリビューションでも、このディレクトリー・レイアウトは同じで、単
にディレクトリーのルートが異なるだけです。たぶん/cdromかどこかの下でしょう。
正確なディレクトリーは、CDROMのドキュメンテーションを参照してください。


 1.2 使用方法
 ============

もし、コンパイル済みのパッケージのファイルがCDROM上にある、あるいはハードディ
スク上にダウンロードされているのであれば、以下のコマンドでインストールする
ことができます(最初にrootにsuしている事を確認してください):

	pkg_add /path/to/package.tgz

もし、FTPアクセスが可能で、インストール前にFTPを使ってパッケージをダウンロー
ドしたくないのであれば、pkg_addにftpのURLを指定する事もできます。

	pkg_add ftp://ftp.netbsd.org/pub/NetBSD/packages/<OS Ver>/<arch>/All/package.tgz

ここで <OS Ver> や <arch> がよくわからない場合は、sysctlユーティリティーを
"sysctl kern.osrelease hw.machine_arch"のように使って調べられます。

また、パッケージを実行するためにあらかじめ必要な他のパッケージがインストー
ルされるかもしれない事にも注意してください。一緒にインストールされる他のパッ
ケージも同じ場所に存在していると仮定されます。

パッケージをインストールした後に、$PATHに /usr/pkg/bin が含まれている事を確
認してください。これで、インストールされたプログラムを実際に使い始めること
ができます。


 1.3 警告
 ========

マニュアル・ページで警告されている、自分自身で作ったものでないバイナリー・
パッケージをインストールすることが孕む危険性、無思慮にこのようなファイルを
インストールすることにより、あなたのシステムにセキュリティーホールが生じる
事についてよく注意してください。


 2 構築しインストールする
 ========================

ここでは、パッケージがすでにNetBSDパッケージ・システムに含まれていると仮定
しています。もし、そうでなれば、このドキュメントの第二部「パッケージ構築者
ガイド」を読む事をお勧めします。


 2.1 必要なもの
 ==============

NetBSDシステム上で、ソースからパッケージを構築するためには、"comp"および
"text"配布物一式をインストールしておく必要があります。X11関連のパッケージを
構築する場合は、さらに"xbase"および"xcomp" 配布物一式も必要です。


 2.2 どこからpkgsrcを得るか
 ==========================

パッケージのソースを入手するためには、pkgsrc.tar.gzファイルを
ftp://ftp.netbsd.org/pub/NetBSD-current/tar_files/pkgsrc.tar.gzから取得し、
/usr/pkgsrcに展開する必要があります。

あるいは、ソフトウェア更新プロトコル(Software Update Protocol) SUPを使い
pkgsrcを入手することもできます。まず、supfileの中に「release=pkgsrc」という
行があることを確認してください。例えば、/usr/share/examples/supfilesを見て
ください。それからディレクトリー/usr/pkgsrcが存在することを確認してください。
後は「sup -v /path/to/your/supfile」を実行するだけです。


 2.3 配布ファイルの取得
 ======================

ひとつ注意しておくことがあります:パッケージシステムを構築するためには、ディ
ストリビューション・ファイル(未変更のソース)がシステム上に存在していなけれ
ばなりません。もし、存在しない場合は配布ファイルを取得するために自動的に
ftp(1)が実行されます。

主要なディストリビューション・サイトをあなたのところに近いサイトで上書きす
ることができます。/usr/pkgsrc/mk/mk.conf.exampleの例を参照してください。こ
れにより、帯域幅と時間が節約できるかもしれません。

上書きするサイトを選んだら、その設定を/etc/mk.confに書いておいてください。

もし、インターネットへ常時接続しておらず、ダウンロードするファイルを知りた
い場合は、「make fetch-list」を実行すれば、必要なファイルがわかります。それ
らの配布ファイルを/usr/pkgsrc/distfilesに置いてください。


 2.4 構築とインストール方法
 ==========================

上記の作業が完了したら、rootになり適切なディレクトリーに移動してください。
そして、シェル・プロンプト上で以下のようにタイプしてください。

	make

これで、パッケージのさまざまなコンポーネントが構築されます。それから、

	make install

とシェル・プロンプト上でタイプしてください。これにより、さまざまなコンポー
ネントが適切な場所にインストールされます。

topシステム・ユーティリティーを例にあげると、付録A.1のように構築することに
より、システムにインストールすることができます。

プログラムはパッケージ・ツリーのデフォルト・ルート- /usr/pkgにインストール
されます。もし、このディレクトリーが趣味にあわないのであれば、環境変数
LOCALBASEを設定してください。この値はパッケージ・ツリーのルートとして使用さ
れます。例えば、/usr/localを使う場合、

	LOCALBASE=/usr/local

と設定してください。なお、ルートにはパッケージ専用の場所を使うべきであり、
他のプログラムと共有させてはいけません(つまり、 LOCALBASE=/usr などとしては
いけません)。これは、パッケージシステムがインストールするプログラムなどのファ
イルが、そこにインストールされているかもしれない別のファイルと衝突すること
がないようにするためです。もちろん、ひとつ例外があります。X11パッケージは伝
統的にX11ツリーにインストールされます。X11ツリーのルートの決定には、X11BASE
の定義が使われます。

X11パッケージをLOCALBASEツリーにインストールすることもできます。このために
は、xpkgwedgeパッケージ(pkgsrc/pkgtools/xpkgwedge)をインストールしなければ
なりません- 詳細はセクション7.1をご覧ください。

いくつかのパッケージは、構築時にいくつかのコンフィギュレーションオプション
を変えるために/etc/mk.confを参照します。設定可能な項目については、
/usr/pkgsrc/mk/mk.conf.exampleをのぞいてみてください。LOCALBASEやX11BASEと
いった環境変数は、pkgsrc使用時に毎回使えるように/etc/mk.confで設定しておく
こともできます。

自分で作った(次章参照)または手動でpkgsrc/packagesに置いたバイナリーパッケー
ジを、デインストールおよび再インストールしたい場合は、"bin-install"ターゲッ
トを使うことができます。このターゲットは、 - もし可能ならば - pkg_addを使っ
てバイナリーパッケージをインストールするほか、"make package"をおこないます。

最後に警告: 標準でないLOCALBASE(またはX11BASE)の設定をしたシステムの場合は、
各パッケージのインストール前にこれらを設定するようにしてください。複数のディ
レクトリーを同じ目的用に分散して使うことはできないからです。そのようなこと
をすると、pkgsrcはインストール済みのパッケージを正しく検出することができず、
無惨に失敗することになるでしょう。また、コンパイル済バイナリーパッケージは、
通常はデフォルトのLOCALBASEである/usr/pkgを使って構築されているので、標準で
ないLOCALBASEを使っている場合は、とにかくコンパイル済バイナリーパッケージを
インストールしては*いけません*。


 3 コンパイル済みのパッケージを作る
 ==================================

 3.1 単数のパッケージを作成する
 ==============================
 
上に述べた手順でパッケージを構築しインストールしたら、これをバイナリー・パッ
ケージにすることができます。- 他のNetBSDマシン上で作成したバイナリーを使い
たいと思うかもしれませんし、単にCPU時間を無駄に使わずにすむようにあなたのバ
イナリー・パッケージを他の人のために使わせてあげたいと思うかもしれません。- 
これは、pkgsrcツリー内の適切なディレクトリーに移動し、シェル・プロンプト上
で以下のコマンドをタイプすることにより可能です。

	make package

これにより、パッケージが構築、インストールされます(もし、まだ済んでいなけれ
ば)。そして、pkg_*ツールを使い操作できるようにバイナリー・パッケージが構築
されます。現状ではバイナリー・パッケージは/usr/pkgsrc/packages以下にgzipさ
れたファイルとして作成されます。上記のtopの例の続きは、付録A.2を参照して下
さい。

このようなバイナリー・パッケージを提出する方法については、このドキュメント
の後の「提出」セクションを参照してください。


 3.2 全パッケージをバルクビルドする
 ================================

この章では、コンパイル済みバイナリーパッケージを全部揃えたい人のために、そ
の方法を説明します。バルクビルドを行うと、その時点でシステムにインストール
されているパッケージをすべて削除しますので注意してください! バルクビルドを
行うマシンかその近くのNFSサーバーをFTPサーバーに設定することで、構築したパッ
ケージをみんなが使えるようにできます。さらなる情報はftpd(8)をご覧ください。
リモートNFSサーバーのストレージを使っている場合、実際のコンパイルがNFSスト
レージ上で行われると非常に遅くなるので、そうなっていないことを確認してくだ
さい。


 3.2.1 設定
 ==========

 3.2.1.1 /etc/mk.conf
 ====================

/etc/mk.confで以下の設定をするとよいでしょう。詳細は
pkgsrc/mk/mk.conf.exampleを見てください。ACCEPTABLE_LICENSESはローカルポリ
シーに適合するようにしておきます:

    BATCH=                  yes          # required for bulk builds 
    DEPENDS_TARGET?=        bulk-install
    PACKAGES?=              ${PKGSRCDIR}/packages/${MACHINE_ARCH}
    OBJMACHINE?=            1                 # use work.${MACHINE_ARCH}
    WRKOBJDIR?=             /usr/tmp/pkgsrc   # build here instead of in pkgsrc
    FAILOVER_FETCH=         yes               # insist on the correct checksum
    PKG_DEVELOPER?=         yes
    ACCEPTABLE_LICENSES=    shareware \
                            fee-based-commercial-use \
                            no-profit \
                            no-commercial-use \
                            non-commercial-use \
                            limited-redistribution \
			    kermit-license \
			    sun-swing-license \
			    sun-jsdk20-license

完全な構築のためにxpkgwedgeを使いたい場合は、以下を加えます:

    BULK_PREREQ+=           pkgtools/xpkgwedge

構築の振舞を変えるためにバルクビルドの最中にインストールされている必要があ
るパッケージがこれ以外にあれば、BULK_PREREQ変数に追加することができます。た
だし、BULK_PREREQに設定する意味があるパッケージは、現在のところxpkgwedgeだ
けです。

 3.2.1.2 build.conf
 ==================

pkgsrc/mk/bulkディレクトリーの``build.conf-example''を``build.conf'' にコピー
し、このファイル中のコメントに従って編集します。このファイルは、構築後に作
られるログファイルをどこに置くか、構築の報告メールをどこに出すか、pkgsrcの
場所はどこか、および、どのユーザーにsuして'cvs update'をおこなうか、を決め
る設定ファイルです。

    
 3.2.2 ほか、環境に関する考察
 ============================

あなた好みのログインシェルを/usr/localに移しておくか、/etc/rc.localでインス
トールするようにしておきます。また、1.5より前のバージョンのOSを使っていたり、
何らかの理由でpkgsrc版のsshを使いたい場合は、rc.localでsshdが起動する前に
sshをインストールするようにしておきます:

    ( cd /usr/pkgsrc/security/ssh ; make bulk-install )
    if [ -f /usr/pkg/etc/rc.d/sshd ]; then
            /usr/pkg/etc/rc.d/sshd
    fi

こうしておかないと、バルクビルド終了後や、あるいはマシンがリブートやクラッ
シュした場合にsshでログインできなくなります。警告しておきましたよ! :)


 3.2.3 操作
 ==========

すでにインストールされているどのパッケージも必要ない状態にしてください。
注意: バルクビルドの過程で、 *すべての* パッケージが削除されます!!! その他
のものも(/usr/local, ...から)すべて削除しておいてください。root になって、
以下のようにタイプします:

        # cd /usr/pkgsrc
        # sh mk/bulk/build

何らかの理由で前回の構築が完了していない場合(電源断、システムパニックなど)
は、以下を実行すると、その続きをすることができます:

	# sh mk/bulk/build restart

バルクビルド実行が終わると、その要約がメールで届きます。また、"build.conf"
ファイルの"FTP"で指定したディレクトリーに、構築ログがあります。


 3.2.4 何を実行するのか
 ======================

バルクビルドは三つの段階からなります:

1. ビルド前: スクリプトがpkgsrcを(anon)cvsで更新します。そして、壊れている
	distfileをすべて一掃し、インストールされているパッケージをすべて削
	除します。

2. バルクビルド: これは基本的に、'make bulk-package'を、パッケージの構築順
	序を最適化しておこなうものです。他のパッケージに依存しないパッケー
	ジが最初に構築され、多くの依存関係を持つパッケージは後に構築されま
	す。

3. ビルド後: 報告を作成し、build.confで指定されたディレクトリーに
	`broken.html'' という名前で置きます。あわせて、この報告の簡略版が構
	築管理者にメールで送られます。

構築中、壊れているパッケージの一覧が/usr/pkgsrc/.broken (OBJMACHINEが設定さ
れている場合は.../.broken.${MACHINE})に作られ、構築が壊れているものの個々の
構築ログは、各パッケージのディレクトリーに置かれます。これらのファイルは、
壊れているパッケージを再度構築しようとするような無駄をなくすために、bulk-ター
ゲットが構築が壊れていることを記録するのに使われます。また、壊れているパッ
ケージを後でデバッグするためにも使えます。

	
 3.2.5 必要なディスク容量
 ========================

現在、1.5/i386 ではおおむね以下の容量が必要です:

 * distfile:                          1500MB (NFSでも可)
 * 全バイナリー一式:                  1000MB (NFSでも可)
 * コンパイル用の一時領域:            1500MB (ローカルディスクが必要)

各パッケージは、バイナリーパッケージ作成直後にデインストールされた上、作業
用ソースも削除されます。このため、莫大なディスク容量は必要ありません。後に
なって、このパッケージがまた必要となった場合は、再度構築することなくpkg_add
でインストールされるので、無駄な再コンパイルの繰り返しは発生しません。


==============================
第二部: パッケージ構築者ガイド
==============================

 4 パッケージコンポーネント - ファイル、ディレクトリー、およびコンテンツ
 =======================================================================

FreeBSD Portsコレクションからパッケージを用意しても、ゼロからパッケージを用
意する場合でも、いつも以下のセクションで述べられている多くのファイルが存在
します。特に、それぞれのファイルがどうFreeBSD Portsと違うのかも説明していき
ます。


 4.1 Makefile
 ============

構築、インストールおよびバイナリー・パッケージの作成は、すべてパッケージの
Makefileによりコントロールされます。

それぞれのパッケージのためのMakefileがあります。このファイルは、パッケージ
のコンパイルとインストールのために必要なすべての定義とアクションがセットさ
れた標準のbsd.pkg.mkファイル("../../mk/bsd.pkg.mk")をインクルードします。必
須となるフィールドは、インターネットのサイトからダウンロードされる配布ファ
イルのベース名を指定するDISTNAMEと、そのサイトを指定するMASTER_SITES、パッ
ケージが置かれるカテゴリーを意味するCATEGORIES、パッケージの名前である
PKGNAMEと、メインテイナー名であるMAINTAINERと、パッケージの一行説明(パッケー
ジ名は自動的に追加されるので、含めないでください) からなるCOMMENT変数です。
mainainer変数は、そのパッケージを維持する人による(いつも完全に正しい)決定に
へりくつを言う誰かが、活発に苦情を言うことができるようにするためです。

MASTER_SITESは、定義済みのサイトの一つをセットすることもできます。

	${MASTER_SITE_XCONTRIB}
	${MASTER_SITE_GNU}
	${MASTER_SITE_PERL_CPAN}
	${MASTER_SITE_TEX_CTAN}
	${MASTER_SITE_SUNSITE}
	${MASTER_SITE_GNOME}
	${MASTER_SITE_SOURCEFORGE}

もしこれらの予め定義されたサイトの1つを選んだ場合、そのサイトのサブディレク
トリーを指定する方法が必要となるかもしれません。これらのマクロは一つ以上の
実際のサイトに展開されるかもしれませんので、サブディレクトリーを指定する場
合は、以下の表記を使わなければなりません:

	${MASTER_SITE_GNU:=subdirectory/name/}

(サブディレクトリー名の後のスラッシュ/に注意してください)廃止された
MASTER_SITE_SUBDIRを使用しても動作しません。

現在CATEGORIESの値として以下が使用できます。もし一つ以上にまたがる場合、そ
れらの値はスペースで分けられる必要があります:

       archivers  audio      benchmarks   biology       cad     
       chat       comms      converters   cross         databases
       devel      editors    emulators    finance       fonts
       games      graphics   ham          japanese      lang
       mail       math       mbone        misc          net
       news       parallel   print        security      shells
       sysutils   textproc   time         wm            www
       x11

全ての利用できるオプション、および変数の記述に関しては、NetBSD packages(7)
マニュアルページを参照してください。

以下の事柄に気を配ってください。FreeBSD Portsコレクションからパッケージを持っ
てきた場合は特に気を付けてください:

 - パッケージのMakefileから、すべてのMANxとCATxの定義を削除してください。-
   NetBSDではマニュアルページを自動的に取扱います。これらの定義は現在使用さ
   れていません。
 - もしパッケージにより(すでにそこにないとしても)マニュアルページが圧縮され
   た形式でインストールされる場合、MANCOMPRESSEDを追加してください。
   bsd.pkg.mkのコメントを参照。
 - すべてのファイルの/usr/localを${PREFIX}に変更してください。(後述のパッチ
   を参照)
 - どんなldconfigコマンドも削除してください - もしNetBSDプラットフォームが
   ldconfigをサポートしていれば自動的に実行されますし、ldconfigをサポートし
   ないプラットフォーム(例NetBSD/Alpha)では他の処置がとられるでしょう。
 - もしFreeBSD Portsコレクションからパッケージを持ってきて変更するならば、
   それらのRCS IDを保持してください:FreeBSDのRCS Id中の'$'を削除し、なけれ
   ば'FreeBSD'を挿入してください。そして、<$>NetBSD<$>を追加してください(<>
   は必要ありません。「専門用語」セクションを参照のこと)。すなわち:

   修正前:
	# <$>Id: Makefile,v 1.17 1997/06/16 06:39:51 max Exp <$>

   修正後:
	# <$>NetBSD<$>
	# FreeBSD Id: Makefile,v 1.17 1997/06/16 06:39:51 max Exp

 - もし、パッケージがinfoファイルをインストールするのであれば、メインのinfo
   ディレクトリーファイルにこの事実を反映するために更新する必要があります。
   NetBSDではこれを行うためのINFO_FILES定義を持っています。例えば、
   indent.infoをインストールしたことをinfoディレクトリーファイルに反映する
   には、単に

	INFO_FILES=	indent.info

   とパッケージのMakefileに定義してください。もしパッケージにこれを追加する
   ならば、必需品であるGNU texinfoパッケージがあなたのシステムにインストー
   ルされているかどうかを確認するために、USE_GTEXINFOもパッケージのMakefile
   に指定してください。
 - もしあなたが将来の更新のために、そのパッケージをメンテナンスするつもりで
   あれば、MAINTAINERにあなたのメールアドレスをセットしてください。標準では
   MAINTAINERはpackages@netbsd.orgにセットします。FreeBSDの人々はNetBSDのパッ
   ケージについて関心がないと思われます。
 - もし問題のソフトウェアにホームページが存在するのであれば、MAINTAINERの後
   ろにHOMEPAGEを追加してください。HOMEPAGEの値はホームページのURLにしてく
   ださい。
 - パッケージの短い説明をCOMMENT変数に設定してください。

 port2pkg (pkgsrc/pkgtools/port2pkg)は、上述した手順の多くをあなたのかわり
 に行なってくれます--操作は慎重にすべきではありますが。


 4.2 files/*
 ===========

 * files/md5:
   最も重要で必須な、パッケージのコンパイルに必要なすべてのdistfileのmd5チェッ
   クサムです。元のファイルやこれに対するパッチすべてに対して、このチェック
   サムと一致することを確認しています。これをもとに、インターネットから取得
   したdistfileが転送中にファイルが壊れたり、悪意によりセキュリティーホール
   を入れられたファイルに変更されていたりしていないことを確認します。これは
   md5(1)コマンドを使うか、"make makesum"により生成することができます。

 * files/patch-sum:

   そのパッケージのpatches/ディレクトリー(セクション4.3参照)に入っている、
   公式なすべてのパッチのチェックサムファイルです。このチェックサムファイル
   には、パッチ中のNetBSD RCS Idを除いたすべての行のMD5チェックサムが含まれ
   ています。このファイルは"make makepatchsum"コマンドにより生成することが
   できます。

また、もしあなたがコンフィギュレーションまたは構築するより前に、パッケージ
中に何かファイルを置きたいならば、それらのファイルをfilesディレクトリーに置
くことができますし、pre-configureターゲットで、${CP}コマンドによりコピーす
ることができます。あるいは、/dev/nullに対するそのファイルの単純なdiffをとり、
パッチメカニズムを使用して、そのファイルを生成することもできます。


 4.3 patches/*
 =============

このディレクトリーは、patch(1)コマンドを使用して作られたファイルを含んでい
ます。このファイルは、配布ファイルのソースをNetBSD上で完全にコンパイルして
実行できるように変更するためのものです。これらのファイルは、アルファベット
順(シェルによる"patches/patch-*"展開順)で適用されます。つまりpatch-aaは
patch-abより前に適用されます。

問題を避けるため、patch-??ファイルはdiff -buフォーマットとし、かつ、曖昧さ
なしで適用可能であるべきです。(曖昧さがあっても強制的にパッチを適用させるた
め、PATCH_FUZZ_FACTOR=-F2を設定することができます)。なお、将来の変更が難し
くなってしまうので、一つのパッチファイルに、複数のファイルへの変更を入れる
のは止めてください。

一つ重要なこととして、NetBSD CVSツリーにチェックインした後に問題を引き起こ
すので、パッチファイルにRCS IDを含ませないように注意してください。これを避
けるためには、diffを"-U 2"または"-U 1"オプションで使ってください。

この 2 段落で述べた問題に気を使いたくない場合は、pkgtools/pkgdiffパッケージ
のpkgdiffを使ってください。これはすべてのRCS Idをよきにはからってくれます。

さらに自動化するため、同パッケージのmkpatchesを使ってパッチ一式を作ることを
おすすめします。あなたがやらねばならないことは、ファイルの編集前に"cp -p
filename filename.orig" のようにして、元のファイルを"filename.orig"の名前で
バックアップしておくだけです。この方法でパッケージをアップグレードした場合、
patchdiffを使って、新しいパッチと既存のパッチを簡単に比較することができます。

FreeBSD PortsからNetBSDパッケージシステムに持ってくる場合、NetBSD上でもたい
ていFreeBSD Portsが使用できるでしょう。しかしながら、FreeBSDにソフトウェア
を移植した人が、当てにならない__FreeBSD__ cpp defineを使っていないかどうか
チェックしてください。これをする簡単な方法は、パッケージディレクトリーで

	grep -i freebsd patches/patch-??

としてください。

また、オリジナルパッケージ中のMakefileの/usr/localを${PREFIX}に変更するパッ
チを提供するなど、他のFreeBSDイズムにも気をつけてください。

パッケージを作り終えたとき、忘れずに"make makepatchsum"コマンドでパッチファ
イルのチェックサムを生成するようにしてください。セクション4.2を参照してくだ
さい。


 4.4 pkg/*
 =========

このディレクトリーは、バイナリー・パッケージの作成を管理するために使用され
るいくつかのファイルを含んでいます。このディレクトリー内のファイルはバイナ
リー・パッケージに含まれ、他のマシンにインストールされます。したがって、あ
なたが書いたコメントや気のきいた言葉は、あなたが考えるより多くの人々に目に
ふれる事に注意してください。

 4.4.1 必須のファイル
 =====================

 * pkg/DESCR:
   ソフトウェアについての複数行の説明。このファイルには適切なクレジットを含
   めておいてください。他人があなたのユーモアのセンス(あるいは変わった綴り)
   を理解してくれない事、そしてここに書かれたものすべてを他人が読むであろう
   という事を念頭においておいてください。

 * pkg/PLIST:
   このファイルは、システムにインストールされるファイルを管理します:すべて
   のバイナリー、マニュアルページ、その他。ディレクトリーの作成、削除、イン
   サートされた(inserted)ファイルの位置を管理するための、他のディレクティブ
   もこのファイルに記述されます。

もし、NetBSDで動作させるために、FreeBSDパッケージを更新しているのであれば、
pkg/PLISTの以下のものに細心の注意を払って下さい:

 - もし、「@exec ldconfig ...」ステートメント、あるいは「@unexec ldconfig ...」
   があれば、それらを削除して下さい。いくつかのNetBSDのアーキテクチャーは
   ldconfigを持っていないので、NetBSDはldconfigをよぶかどうかを自動的に判断
   します。
 - 不足している@dirrmステートメントの追加
 - パッケージのMakefileの中のMAN定義をすべて削除

また、port2pkgパッケージを調べてみてください(pkgsrc/pkgtools/port2pkg)。こ
のパッケージは、あなたのかわりにさまざまな退屈な作業をおこなってくれます。


 4.4.2 オプション・ファイル
 ==========================

 * pkg/INSTALL:
   このシェル・スクリプトはpkg_add実行中に二度起動されます。最初は、パッケー
   ジが展開された後、ファイルが移動される前に、二度目はインストールするファ
   イルが移動された後。このファイルは、PLIST内の@execコマンドでは不可能な特
   別な処理のために使うことができます。より詳細な情報はpkg_add(1)と
   pkg_create(1)を参照してください。

 * pkg/DEINSTALL:
   このスクリプトは、ファイルが削除される前後に実行されます。このスクリプト
   の責任は、パッケージのインスタレーションにかかわる雑多なものをきれいにす
   ることです。なぜなら、pkg_deleteは、オリジナルのディストリビューションで
   作成されたファイルをどのように削除するかをすべて知っておかなければならな
   いからです。より詳細な情報はpkg_add(1)とpkg_create(1)を参照してください。

 * pkg/MESSAGE:
   パッケージのインストール後にこのファイルの内容が表示されます。
   完全にフリーでないソフトウェアについての法的な通知等に役立ちます。
   パッケージのMakefileでMESSAGE_SUBSTを使うことで、変数を簡単に変えられる
   ことに注意してください:
	MESSAGE_SUBST+=  SOMEVAR="somevalue"
   とすると、pkg/MESSAGE中の
	${SOMEVAR}
   は、メッセージ表示前に"somevalue"に置換されます。


 4.5 scripts/*
 =============

このディレクトリーは、ソフトウェア等の設定に必要なファイルを含んでいます。
もし、以下の名前のスクリプトが存在すれば、構築プロセスの適当な時に実行され
ます:

  pre-fetch          post-fetch
  pre-extract        post-extract
  pre-patch          post-patch
  pre-configure      post-configure     configure
  pre-build          post-build
  pre-install        post-install
  pre-package        post-package

なお、Makefile内で、scripts/[pre|post]-*にマッチするスクリプトを実行するよ
うなpre-*ターゲットやpost-*ターゲットを定義しては *いけません* 。bsd.pkg.mk
は、Makefileに存在する各ターゲットの実行後、scripts/*を探してそれをsh(1)を
使って実行します。このようなスクリプトをMakefileから実行すると、スクリプト
を二重に実行することになってしまいます。

構築プロセスについてはセクション7を参照してください。


 4.6 work/*
 ==========

「make」とタイプした時に、配布ファイルがこのディレクトリーに展開されます。
シェル・プロンプトで、以下のようにタイプすれば、これらを削除することができ
ます。

	make clean

また、このディレクトリーはさまざまなタイムスタンプ・ファイルを作っておくた
めにも使用されます。


 5 PLIST*問題
 ============

このセクションでは、PLISTファイル(複数の場合もあります、以下を参照してくだ
さい)を扱う場合に注意が必要な、いくつかの特別な問題について述べます。


 5.1 その他色々
 ==============

 * NetBSD RCS Id :
   あなたが書いたすべてのPLISTファイルの先頭行にRCS IDが追加されていること
   を確認してください。

	@comment <$>NetBSD<$>

 * ranlib:
   ranlibコマンドをPLISTファイルに記述しないでください。パッケージが削除さ
   れる時にトラブルをひきおこすかもしれません。構築時にだけranlibが実行され
   ること(通常、実行します)を確認してください。そうすれば特に気にする必要は
   ありません。これはFreeBSDポートを流用する時にいつも問題となります。

 * ldconfig:
   ldconfigコマンドをPLISTファイルに記述しないでください。このコマンドは問
   題をひきおこす可能性があります。NetBSDでは、共有オブジェクトのキャッシン
   グは自動的におこなわれます(あなたが、「"Automatic shared object handling」
   メッセージの出力を見た時におこなわれています)。したがって、これに関して
   は気にする必要はありません。もしパッケージの中に共有オブジェクトが見つか
   れば、自動的に処理されます。必要であれば ldconfig を実行し、そうでなけれ
   ば実行しません。これは FreeBSD ポートを流用する時にいつも問題となります。
   この自動処理が行われないようにするには、パッケージのMakefileで
   SHLIB_HANDLINGをNOに設定してください。

 * ${MACHINE_ARCH}、${MACHINE_GNU_ARCH}:
   emacs、およびperlのようないくつかのパッケージは、それらが構築されたアー
   キテクチャーに関する情報を、インストールするファイルのパス名に埋め込みま
   す。このようなケースに対応するため、実際に使われる前に、PLISTに前処理が
   おこなわれます。そして、シンボル「${MACHINE_ARCH}」は、「sysctl -n
   hw.machine_arch」の出力でおきかえられます。${MACHINE_GNU_ARCH}がPLISTの
   どこかにうめこまれている場合も同様の事がおこなわれます。これは、GNU
   autoconfigureを使用しているパッケージで使われます。

   昔の話:「<$ARCH>」シンボルは「uname -m」の出力によって置きかえられていま
   した。しかし、もはやサポートされていませんし、削除されています。

 * ${OPSYS}、${OS_VERSION}:
   いくつかのパッケージでは、OS名とバージョンをいくつかのパス名に埋め込みま
   す。このような場合、PLISTで二つの変数を使用してください。${OPSYS}は
   「uname - s」の出力で置きかえられます。${OS_VERSION}には「uname - r」出
   力が設定されます。

 * マニュアルページの圧縮:
   もし、(bsd.own.mkに)MANZが設定されていれば、マニュアルページは圧縮形式で
   インストールされます。そうでなければ展開された形式でインストールされます。
   PLISTファイルでこれをサポートするために、MANXと MANCOMPRESSEDの設定の有
   無に従い、「.gz」サフィックスがマニュアルページに自動的に追加、削除され
   ます。このPLISTファイルに対する変更は、pkg/PLIST自身にたいしてでなく、そ
   れがコピーされる時におこなわれます。

 * PLIST の半自動生成:
   "make print-PLIST"コマンドを使って、パッケージの展開後に新しくできた全ファ
   イルにマッチするPLISTを出力することができます。このターゲットに関するさ
   らなる情報は、下の説明をご覧ください。


 5.2 ${PLIST_SRC}
 ================

ひとつ以上のファイルを、バイナリー・パッケージを構築するためにPLISTのソース
として使用する時は、それらのファイル名を変数PLIST_SRCに設定してください。こ
れらのファイルは、後でcat(1)によって連結されます。連結の順番は重要です。

 5.3 ${PLIST_SUBST}
 ==================

MESSAGE_SUBST(上を参照)に似ており、以下のようにして、変数とその展開結果を追
加することができます:

	   PLIST_SUBST+=    SOMEVAR="somevalue"

これは、PLIST中にある${SOMEVAR}をすべて"somevalue"に置換します。デフォルト
で置換が行なわれる値については、bsd.pkg.mkを見て(PLIST_SUBSTを調べて)くださ
い。

 5.4 Perl5 モジュール
 ====================

Perl5 のモジュールがインストールされる場所は、構築プロセスで使われるperl の
バージョンに応じて変わります。これを扱うために、NetBSD パッケージシステムは、
インストールされた.packlistファイル(ほとんどの perl5 モジュールが生成します)
に列挙された各ファイルに対応する行を、PLIST に追加します。これは、packlist
ファイルへのパスをスペースで区切ったリストをPERL5_PACKLISTとして定義するこ
とで行なわれるようになります:

	PERL5_PACKLIST=	${PERL5_SITEARCH}/auto/Pg/.packlist

PERL5_SITELIB, PERL5_SITEARCH, PERL5_ARCHLIBの各変数は、perl5モジュールがイ
ンストールされうる三つの場所を表すもので、packlistを持たないperl5パッケージ
で使うことができます。この3変数の置換は、PLISTでもおこなわれます。

 6 パッケージの修正に関する6つの注意
 ===================================

 6.1 CPP定義
 ===========

アプリケーションをNetBSDに移植するためには、コンパイラーがコンパイルしてい
るシステムを判断する必要があります。したがって、Cのプリプロセッサーがシステ
ムを判断できるように、CPPの定義を使います。

非常に簡単に言うと、多くのFreeBSDポート(NetBSDではパッケージとよばれる)が
CPPの定義__FreeBSD__に依存しています。この定義はFreeBSD固有の仕様のためにだ
け使用すべきですが、残念ながら今はそうなっていません。また多くのFreeBSDポー
トは、CPUがインテルベースのリトルエンディアンという事実に依存しています。

4.4 BSDから派生したシステム上で作業しているかどうかをテストするためには、
BSD定義を使用するべきです。これは<sys/param.h>で定義されています。

        #include <sys/param.h>

また、BSDに固有の部分を、以下の条件でかこむこともできます。

	#if (defined(BSD) && BSD >= 199306)
	...
	#endif

どうか注意して__NetBSD__定義を使って下さい。4.4-liteから派生した他のBSDにな
いNetBSD固有の特徴にのみ適用してください。

美的な観点からすると、__FreeBSD__=1を定義して、単純にFreeBSDポートを使うこ
とは避けるべきです。


 6.2 共有ライブラリー - libtool
 ==============================

NetBSDはさまざまな種類のマシンをサポートします。それらはa.outとELFのような
異なるオブジェクトフォーマットを使い、共有ライブラリー、ダイナミックローディ
ングの有無すらも異なります。これに対応するためにコマンドそのもの、およびオ
プションがコンパイラー、リンカーなどに渡される必要があります。すべてのマシ
ンで正しく動作させることは非常にむずかしく、テストのためにすべてのマシンを
持っていない場合は特にそうでしょう。「libtool」パッケージはこれを助けます。
「libtool」はソースファイルから、静的、動的なライブラリー両方を構築する方法
を知っています。したがって、プラットフォーム独立です。

以下に、libtoolをパッケージで使用するための7つの手順を記述します。

1. USE_LIBTOOL=yesをパッケージのMakefileへ追加します。

2. ライブラリーオブジェクトのために、${LIBTOOL} --mode=compile ${CC}を${CC}
   に設定します。ライブラリーが、提供されたMakefileだけを使用して構築される
   のであれば、CCの定義にこれを追加するだけです。このコマンドひとつだけで、
   PICと非PICのライブラリーオブジェクトを作成します。したがって、共有ライブ
   ラリーとそうでないライブラリーの構築規則を別々に記述する必要はありません。

3. ライブラリーのリンクのための「ar」、「ranlib」、「ld -Bshareable」コマン
   ドを削除してください。そしてその代わりに以下のコマンドを使用してください。

	${LIBTOOL} --mode=link cc -o ${.TARGET:.a=.la} ${OBJS:.o=.lo} -rpath ${PREFIX}/lib -version-info major:minor

   ライブラリーの拡張子は.laに、オブジェクトの拡張子は.loに変更されることに
   注意してください。OBJSを必要に応じて変更してください。このコマンドは、必
   要なものすべて、.a、.so.major.minor、そしてELFのシンボリックリンク(必要
   なら)を自動的にカレントディレクトリーに作成します。特に、メジャー番号と
   マイナー番号がゼロの場合は、-version-infoをかならず含めるようにしてくだ
   さい。そうしないとlibtoolは共有ライブラリーのバージョンを取り除きます。

   また、"-release"オプションは、ある一つの場合に限って、a.outとELF(シンボ
   リックリンクを除く)との間で異なる結果をもたらします。
   libfoo-release.so.x.yの形式のELFライブラリーは、a.outプラットフォーム上
   ではlibfoo.so.x.yのシンボリックリンクを持ちます。これは自動的に処理され
   ます。

   -rpath引数は構築されたライブラリーのインストール先ディレクトリーです。

   PLISTには、.a, .laおよびso, .so.major, .so.major.minorがすべて含まれるべ
   きです。

4. 共有オブジェクト(.so)ファイル(すなわち、dlopen(3)でロードされるファイル
   であって、共有ライブラリーでは*ありません*)のリンク時には、ファイルにバー
   ジョンが加えられないようにするため、"-module -avoid-version"を使ってくだ
   さい。

   PLISTにはfoo.soの一覧が加わります。

5. インストールする前のライブラリーに依存するプログラムをリンクする時に、cc
   かldの前に「${LIBTOOL} --mode=link」を書いてください。このコマンドは、正
   しいライブラリー(静的、または共有)を見つけます。ただし、libtoolを使う時
   には-Lオプションで相対パスを指定すること(-L../somelibのように)ができない
   ことに注意してください。引数として.laファイルを使うように修正しなければ
   なりません。例えば、

	${LIBTOOL} --mode=link ${CC} -o someprog -L../somelib -lsomelib

   は正常に動作しないので、以下のように変更する必要があります。

	${LIBTOOL} --mode=link ${CC} -o someprog ../somelib/somelib.la

   これで、ライブラリーを正しく扱う事ができます。もし、-Lで相対パスを使用し
   なければならず、インストールする前にこのプログラムを実行しない場合は、リ
   ンクおよびインストールの時にlibtoolを使用しなくてもかまいません。この場
   合、-Lでサブディレクトリー「.libs」を追加してください。

	${CC} -o someprog -L../somelib/.libs -lsomelib

6. ライブラリーをインストールするときに、installあるいはcpコマンドの前に
   「${LIBTOOL} --mode=install」を書いて下さい。そしてライブラリーの名前を
   .laに変えてください。例えば、以下のように書く必要があります。

	${LIBTOOL} --mode=install ${BSD_INSTALL_DATA} ${SOMELIB:.a=.la} ${PREFIX}/lib

   これは、静的リンクのための.a、共有ライブラリー、必要なシンボリックリンク
   をインストールし、「ldconfig」を実行します。

7. PLIST の中に、.a、.la、そしてso, .so.major, .so.major.minor ファイルを追
   加してください(以前とはやり方が変わっています)。


 6.3 すでにlibtoolをサポートしているGNUパッケージでlibtoolを使う
 ===============================================================

パッケージのlibtoolを簡単に回避する方法として、USE_LIBTOOL=yesおよび
LTCONFIG_OVERRIDE=${WRKSRC}/ltconfigをパッケージのMakefileに追加してくださ
い。パッケージのlibtoolは、do-configureターゲットでltconfigスクリプトにより
作られます。USE_LIBTOOL および LTCONFIG_OVERRIDE が定義されている場合、指定
されたltconfigは、パッケージのlibtoolのかわりにdevel/libtoolを使うよう上書
きされます。

パッケージが動的共有オブジェクトのロードにlibltdlによるプラットフォーム独立
な方法を使う場合は、MakefileにUSE_LTDL= yesを追記してください。

パッケージによっては、NetBSD上での動作や構築はできるかもしれませんが、正し
くないlibtoolの使い方をしているものがあります。ありがちな間違いは以下のよう
なものです。

 * 実行形式やライブラリーで、共有オブジェクト(-module)を依存ライブラリーと
   してインクルードする。このこと自体は、以下の二つのうちいずれかが行なわれ
   ている場合は、問題になりません。

   1. その共有オブジェクトが正しく命名されている。すなわち、foo.laではなく
      libfoo.laとなっている。

   2. -dlopenオプションが実行形式のリンク時に使われている。

 * ルーチンの初期化を適切に呼ばずにlibltdlを使う。関数lt_dlinit()を呼んで、
   マクロLTDL_SET_PRELOADED_SYMBOLSを実行形式にインクルードすべきです。

 6.4 FreeBSDポートに関する注意
 =============================

Makefileの問題(MANx、CATx、MANCOMPRESSED、ldconfig、RCS ID)については4.1を
参照してください。FreeBSDのポートからパッチを流用した場合におこなうべき作業
については4.3を参照してください。

FreeBSDポートの最も大きい問題の1つが、多くのポートが${PREFIX}の設定を無視し
/usr/localにインストールされると仮定されていることです。これを修正するため
に、パッケージのMakefileに以下のような行を追加してください。

pre-configure:
        for f in `find ${WRKDIR} -type f -print|xargs grep -l '/usr/local'`; do
\
                ${SED} -e 's:/usr/local:'${PREFIX}':g' < $$f > $$f.pdone && ${MV} $
$f.pdone $$f; \
        done

これはsysutils/rttyパッケージで使用している方法です。これがあなたのパッケー
ジでも正しく動作することを確認してください。例えば、/usr/localで何かを探す
ことは、実際には意味があるかもしれません。したがって、無条件に/usr/localを
置き換えてはいけません。

FreeBSDは、パッケージのMakefileにマニュアルページを列挙し、PLISTに対応する
エントリーを作らないことに決めました。MAN[1-8ln]の定義を削除する前に、これ
らをPLISTに追加する必要があるでしょう。MLINKSとCAT[1-8ln]エントリーも同様で
す。

PLISTのマニュアルページについての注意: .gzサフィックスについては特に注意を
はらう必要はありません。多くのFreeBSDポートは、実際には圧縮せずにマニュアル
ページをインストールする場合も、PLISTに.gzページをもっていますが、気にしな
くてもかまいません。我々は、MANZに従い.gzサフィックスを追加します。つまり、
PLISTのマニュアルページの名前が.gzサフィックスを持っているかどうかは重要で
はありません。もし、それが必要であれば自動的に追加されるし、不必要な.gzサ
フィックスがあれば自動的に削除されるでしょう。

いくつかのパッケージは、構築時にbsdスタイルの.mkファイルを使用します。した
がってMANZが設定されていれば、インストールされるマニュアルページはgzipで圧
縮されます。もし、MANZが設定されていなければ圧縮しません。もしパッケージが
bsdスタイルの.mkファイルを使う場合は、Makefileの中で変数
MANCOMPRESSED_IF_MANZにyesを設定してください。


 6.5 作者へのフィードバック
 ==========================

もしパッケージの不具合を発見し動作するように修正した場合、NetBSD上で動作さ
せるために特別な手順が必要だった場合、あるいはさまざまなソフトウェアの拡張
をおこなった場合、これらの修正をプログラムのオリジナルの作者へ報告してくだ
さい。このようなサポートによって、プログラムの次のリリースにそれらの修正を
反映することができます。そして、NetBSDパッケージシステムを使用していない人々
も、あなたの努力のおかげで幸せになれます。

フリー・ソフトウェアの理念をサポートして下さい。


 7 構築の手順
 ============

プログラムを構築するための基本的な手順は常に同じです。最初に、プログラムの
ソースファイル(distfile)をローカル・システムへ持ってきて展開します。NetBSD
上でコンパイルするためのいくつかのパッチを適用した後に、ソフトウェアを設定
し、構築(通常、コンパイルすることによって)します。最後に作成されたバイナリー
等を、システムにインストールします。これはまさにNetBSDパッケージ・システム
によって実行される手順です。この手順は、中心となるMakefile、
/usr/pkgsrc/mk/bsd.pkg.mkの中で一連のターゲットとして実装されています


 7.1 プログラムの場所
 ====================

次のセクションでNetBSDパッケージ・システムによって実行される手順の概略を述
べる前に、プログラムがインストールされる場所、その場所に影響をおよぼす変数
について簡単に記述します。

自動変数PREFIXは、最終的にプログラムのすべてのファイルがインストールされる
場所をしめします。通常、$LOCALBASE (/usr/pkg)、または「クロス」カテゴリーの
パッケージのための$CROSSBASEと同じ場所になっています。もしUSE_IMAKE、
USE_MOTIF、あるいはUSE_X11BASEが定義されていれば、その値は$X11BASEと同じに
なります。${PREFIX}の値は、プログラムのソース中でこれらのファイルが符号化さ
れるさまざまな場所に使用されるべきです。詳細に関しては、セクション4.3および
6.2を参照して下さい。

これらの変数のどれかを選択し使用する場合には、以下のルールに従ってください。

 * ${PREFIX}は常に現在のパッケージがインストールされる場所を指します。パッ
   ケージ自身のインストール先のパスを参照する時に、${PREFIX}を使用してくだ
   さい。

 * ${LOCALBASE}は、すべての非X11パッケージがインストールされる場所です。他
   の非X11パッケージによってインストールされたインクルードファイルやライブ
   ラリーの場所をさがすためのコンパイラーの-Iや-Lオプションを指定する場合に、
   ${LOCALBASE}を使用してください。

 * ${X11BASE}は、実際に(xsrcなどに由来する)X11ディストリビューションがイン
   ストールされる場所です。通常のX11のインクルードファイル(パッケージとして
   インストールされていない)をさがす場合、${X11BASE}を使用してください。

 * X11ベースのパッケージは特別です。X11BASE、またはLOCALBASEに依存するかも
   しれません。X11パッケージをLOCALBASEにインストールする方法は、単に
   xpkgwedgeパッケージ(pkgsrc/pkgtools/xpkgwedge)をインストールするだけです。
   もし、USE_IMAKEやUSE_MOTIF、USE_X11BASEをMakefileで定義したpkgとしてイン
   ストールされたインクルードファイルやライブラリーをさがす場合、${X11BASE}
   と${LOCALBASE}の両方を使用する必要があります。

 * X11パッケー
   ジのインストール場所を参照する用途には、${X11PREFIX}を使ってください。
   X11PREFIXは、xpkgwedgeがインストールされていない場合は${X11BASE}となり、
   xpkgwedgeがインストールされている場合は${LOCALBASE}となります。


 7.2 主なターゲット
 ==================

bsd.pkg.mkで定義された、構築手順で使用される主なターゲットについて述べます。

 * fetch:
   これは、変数DISTFILESとPATCHFILES (パッケージのMakefileで定義された)で指
   定されたファイルが、ローカルシステムの/usr/pkgsrc/distfilesに存在するか
   どうかをチェックします。もし、存在しなければ、変数PATCH_SITEで指定された
   サイトから、ftp(1)を使用し取得します。PATCH_SITEはURLの形式で、ftp://-、
   およびhttp://-が使用できます。これは、ftp(1)が両方の形式を解釈できるから
   です。

 * checksum:
   distfileを取得した後に、MD5チェックサムを生成し、files/md5ファイルに保存
   されたチェックサムと比較します。もし、チェックサムが一致しなければ、構築
   は中断されます。これはパッケージ作成時と同じdistfileが、構築に使用されて
   いること、つまり、悪意や一次配布サイトでの意図的な差し替えやネットワーク
   の損失によってdistfileが変更されていないことを保証するためです。

 * extract:
   distfileがローカルシステム上に存在している場合、通常、それらは圧縮アーカ
   イブフォーマットで保存されているので、展開する必要があります。もっとも一
   般なフォーマットは.tar.gzです。もし、すべてのdistfileを伸張する必要がな
   いのであれば、伸張するファイルをEXTRACE_ONLYに設定してください。もし
   distfileが.tar.gzフォーマットでなければ、EXTRACT_CMD、EXTRACT_CMD、
   EXTRACT_BEFORE_ARGS、そしてEXTRACT_AFTER_ARGSを設定することにより、それ
   らを展開することができます。

 * patch:
   展開の後で、PATCHFILESで指定されたパッチとパッケージのパッチサブディレク
   トリーに存在するパッチ、すべてが適用されます。.Z、あるいは.gzで終る名前
   のパッチファイルは、適用する前に伸張されます。.orig、.rejで終るものは無
   視されます。patch(1)のためのいくつかのオプションは、PATCH_DIST_ARGSで指
   定する事ができます。詳細に関してはセクション4.3を参照して下さい。
   
   デフォルトでは、パッチに曖昧さがあった場
   合にはpatchが異常終了するような特別な引数が渡されます。パッチを修正(再作
   成) して、きれいに適用できるようにしてください。そうする理由は、パッチが
   うまく適用できても、実は誤った場所に適用されていて、深刻な問題を起こす可
   能性があるからです。

 * configure:
   ほとんどのソフトウェアは、NetBSDで利用できるヘッダーファイル、システムコー
   ル、およびライブラリールーチンについての情報を必要とします。これはコンフィ
   ギュレーションとして知られているプロセスであり、通常、自動化されています。
   大抵の場合、スクリプトがソースと一緒に提供され、それを実行することにより
   ヘッダーファイルやMakefile等が生成されます。

   プログラムがコンフィギュレーションのためのスクリプトを提供していない場合、
   パッケージのスクリプトディレクトリーにconfigureという名前のスクリプトを
   置くことができます。そして、それはsh(1)によって実行されます。

   もし、プログラムのdistfileが専用のconfigureスクリプトを含んでいる場合、
   HAS_CONFIGUREを設定することにより、実行することができます。もし、そのス
   クリプトがGNUのautoconfスクリプトである場合は、かわりに、GNU_CONFIGUREを
   指定してください。どちらの場合も、configureスクリプトの引数は、変数
   CONFIGURE_ARGSで指定されます。もし設定スクリプトの名前がデフォルトの
   configureでない場合は、その名前をCONFIGURE_SCRIPTに設定してください。

   もし、プログラムがコンフィギュレーションのためにImakefileを使用するので
   あれば、USE_IMAKEをYESに設定することにより、適切な手順が実行されます。
   (もし、$X11PREFIXにインストールされるパッケージが欲しいだけで、xmkmfを実
   行したくない場合、かわりにUSE_X11BASEを使用してください!)

 * build:
   コンフィギュレーションが終ったら、$MAKEFILEの中で、構築のターゲットとし
   て$ALL_TARGETを指定し$MAKE_PROGRAMを起動することにより、NetBSD上にソフト
   ウェアを構築することができます。もし、USE_GMAKEが設定されていれば、デフォ
   ルトのMAKE_PROGRAMは「gmake」です。そうでなければ、makeが使用されます。
   MAKEFILEにはデフォルトでMakefileが設定されます。そして、ALL_TARGETのデフォ
   ルトはallです。デフォルトの構築手順を変更するために、これらの変数を設定
   することができます。

 * install:
   構築の段階が完了すると、ユーザーのためにソフトウェアをパブリックなディレ
   クトリーにインストールする必要があります。buildターゲットと同様に、
   $MAKE_PROGRAMが$MAKEFILE中で起動されます。ただし、$INSTALL_TARGETが指定
   されます。この変数のデフォルトは「install」です。(もしUSE_IMAKEが設定さ
   れていれば、「install.man」も追加されます)。

   もし、ターゲットが指定されなければ、デフォルトは「build」です。手順の途
   中のターゲットが指定された場合、それ以前のすべての手順が実行されます。例
   えば「make build」は、以下と同等のことを実行します。

	make fetch
	make checksum
	make extract
	make patch
	make configure
	make build


 7.3 他の役に立つターゲット
 ==========================

 * pre/post-*
   前のセクションで述べた主ターゲットのために、二つの補助ターゲットが存在し
   ます。これは主ターゲットに「pre-」や「post-」というプレフィックスをつけ
   たものです。これらのターゲットは、特別な設定やインストール手順のために、
   主ターゲットが実行される前や後に実行されます。例えば、プログラムのコンフィ
   ギュレーションスクリプトやインストールターゲットが省略された場合に有用で
   す。これらのターゲットのために、同名のスクリプトをパッケージのスクリプト
   用のサブディレクトリーに置くことができます。セクション4.5を見て下さい。

 * do-*:
   主なターゲットがおかしな動作をし、それを修正するための変数が存在しない場
   合、do-*ターゲットを使用することにより、それらを再定義することができます
   (do-*ターゲットのかわりに、ターゲット自体を再定義してはいけません。pre-*
   やpost-*ターゲットが実行されなくなってしまいます)。通常、再定義する必要
   はありません。

 * reinstall:
   もし、「make install」実行後に、いくつかのファイルがきちんとインストール
   されなかった事に気がついた場合、このターゲットを使い、再びインストールす
   る事ができます。この場合、「インストール済み」フラグは無視されます。

 * deinstall:
   このターゲットは、パッケージを削除するためにカレントディレクトリーで
   pkg_delete(1)を実行します。動作を制御するために、以下の変数をコマンドラ
   イン、または/etc/mk.confで使用することができます。

    - PKG_VERBOSE:
      pkg_delete(1)コマンドに「-v」オプションを渡します。

    - DEINSTALLDEPENDS:
      指定されたパッケージに必要な(依存する)すべてのパッケージを削除します。
      このターゲットは、指定されたパッケージによってインストールされたパッ
      ケージを削除するために使用されます。例えば、DEINSTALLDEPENDS=1が
      x11/kdeで指定されている場合、KDE全体を削除します。pkg_deleteのコマン
      ドラインに-Rを指定すると設定されます。

 * update:
   このターゲットは、現在のパッケージを最新のものに更新します。最初にパッケー
   ジと、それに依存するすべてのパッケージを削除します。それから最新のバージョ
   ンのパッケージをコンパイル、インストールします。これは、現在どのパッケー
   ジがインストールされているかを調べ、「make deinstall」、「make install」
   (または、DEPENDS_TARGETで設定されたターゲット)を続けて実行するのと同じで
   す。

   以前に実行した「make update」がさまざまな理由で中断された場合、パッケー
   ジの更新のために、このターゲットを使用することができます。ただし、この場
   合は、「make clean」を実行していない事、あるいは${WRKDIR}の依存パッケー
   ジのリストを削除していない事を確認してください。そうでなければ、インストー
   ル済みの依存パッケージを使用し、現在のパッケージを自動更新することができ
   ません。

   中断された「make update」の再開は、パッケージツリーの他の部分が変更され
   ていない場合に限って動作します。更新対象のパッケージのソースコードが変更
   されていた場合は、「make update」の再開はきっと失敗するでしょう。

   「make update」の動作を変更するために、以下の変数をコマンドライン、また
   は/etc/mk.confで使うことができます。

    - DEPENDS_TARGET:
      更新されたパッケージや依存パッケージのために使用されるインストールター
      ゲット。デフォルトは「install」です。例えば、「make update
      DEPENDS_TARGET=package」のように使用します。

    - NOCLEAN:
      更新した後、きれいに掃除をしません。調査やその他の目的のために、更新
      されたパッケージの作業用ソース等をそのままにしておきたい場合に役に立
      ちます。最終的にはソースツリーを掃除してください(以下の
     「clean-update」ターゲットを見てください)。そうしなければ、次回の
     「make」や「make update」の時に古いソースコードが残っていることで
      トラブルがおこるかもしれません。

    - REINSTALL:
      インストール(make ${DEPENDS_TARGET})の前に各パッケージをデインストー
      ルします。これは、"make update"の実行中断後に"clean-update"ターゲット
      (以下参照)が呼ばれた場合に必要となることがあります。

 * clean-update:
   カレントディレクトリーで「make update」が実行された時に更新されるすべて
   のパッケージのソースツリーを掃除します。カレントパッケージ(あるいは、依
   存パッケージ)がすでに削除されている(例えばmake updateを実行した後)場合に
   は、このターゲットを使ってはいけません。もし使用すると、更新するつもりの
   パッケージのいくつかを失う可能性があります。経験的には、初めて「make
   update」を実行する前、あるいは汚れたパッケージツリーがある場合(例えば
   NOCLEANを使用した場合)にのみ使用すべきです。「make clean-update」の動作
   を変更するために、以下の変数をコマンドライン、または/etc/mk.confで使うこ
   とができます。

    - CLEAR_DIRLIST:
      「make clean」の後で、パッケージのためのディレクトリーのリストを再構
      築しません。「make update」で、更新したいすべてのパッケージがインストー
      ルされた場合にのみ使用してください。通常、これは「make update」で自動
      的に実行されます。ただし、NOCLEAN変数の設定によって実行されない事もあ
      ります(上を参照してください)。

 * info:
   このターゲットは、現在のパッケージに対して"pkg_info"をおこないます。これ
   を使って、たとえば、インストールされているパッケージのバージョンを調べる
   ことができます。

 * readme:
   このターゲットは、README.htmlファイルを作成します。このファイルは
   navigator (pkgsrc/www/navigator)やlynx (pkgsrc/www/lynx)のようなブラウザー
   で閲覧することができます。作成されたファイルは、ローカルホストの
   ${PACKAGES}ディレクトリーにあるパッケージへの参照を含んでいます。また、
   FTP_PKG_URL_HOSTとFTP_PKG_URL_DIRを元にしたURLを参照させることもできます。
   例えば、ローカルマシン上の/usr/packagesディレクトリーのバイナリー・パッ
   ケージを参照するREADME.htmlファイルを作成したい場合、
   FTP_PKG_URL_HOST=file://localhostとFTP_PKG_URL_DIR=/usr/packagesをセット
   してください。${PACKAGES}ディレクトリーと、そのサブディレクトリーはすべ
   てのバイナリー・パッケージで検索されます。

 * readme-all: 
   このターゲットを使い、README-all.htmlを作成することができます。このファ
   イルはNetBSDパッケージコレクションの中の、現在利用可能なすべてのパッケー
   ジのリスト、また、それらが属するカテゴリーと簡単な説明を含んでいます。こ
   のファイルはpkgsrc/*/README.htmlから作りだされます。したがって、「make
   readme」の後に、このターゲットを実行してください。

 * cdrom-readme:
   これはreadmeターゲット(上を見てください)とほとんど同じですが、CD-ROMに焼
   かれるpkgsrcツリーを作る時に使われます。また、このターゲットは
   README.htmlファイルを作成し、CDROM_PKG_URL_HOSTとCDROM_PKG_URL_DIRに基づ
   くURLへの参照を作ります。

 * show-distfiles:
   このターゲットは、パッケージを構築するために、どのdistfileやパッチファイ
   ルが必要かを表示します。(DISTFILESおよびPATCHFILESであって、patches/*は
   含みません)

 * show-downlevel:
   このターゲットは、パッケージがインストールされていない場合は何も表示しま
   せん。もし、あるバージョンのパッケージがインストールされているが、現在の
   pkgsrcのバージョンでインストールされたものでない場合、警告メッセージを表
   示します。このターゲットは、インストール済みのパッケージが古いバージョン
   であり、そのバージョンが削除可能で、最新の物が追加されることを表示するた
   めに使用されます。

 * show-pkgsrc-dir:
   当該パッケージの構築とインストールが可能な、パッケージ階層におけるディレ
   クトリーを表示します。このディレクトリーは、そのパッケージがインストール
   された際のディレクトリーと同じとは限りません。このターゲットは、単一ホス
   ト上で多数のパッケージの更新をしたい場合に使うためのもので、pkgsrc の最
   上層のMakefileから"show-host-specific-pkgs"ターゲットで呼び出すことがで
   きます。

 * check-shlibs:
   パッケージのインストール後に、すべてのバイナリーおよび(ELFプラットフォー
   ムでは) 共有ライブラリーが必要な共有ライブラリーを見つけられるかどうか確
   認します。/etc/mk.confでPKG_DEVELOPERが設定されている場合はデフォルトで
   実行します。

 * print-PLIST:
   パッケージを新規に、または更新のために'make install'した後、'find -newer
   work/.extract_done'をもとに新しいPLISTを生成して表示します。PLIST生成は、
   共有ライブラリーなどに配慮して行われますが、生成した結果をpkg/PLISTに置
   く前に再確認するよう*強く*おすすめします。パッケージ更新時には、このコマ
   ンドの出力と、更新前のpkg/PLISTファイルとを比較すると便利でしょう。

   パッケージが、tar(1)その他のファイルのアクセス時刻を更新しない方法を使っ
   てファイルをインストールする場合は、それらのファイルは'find -newer'で検
   出されないので、手でpkg/PLISTに書き足すよう注意してください!

 * bulk-package:
   バルクビルドの実行に使われます。適切なバイナリーパッケージがすでに存在す
   る場合は、何もしません。そうでない場合は、コンパイル、インストール、パッ
   ケージ作成をおこないます。バイナリーパッケージ作成後、ディスクの空き領域
   を確保するために、ソース、インストールしたばかりのパッケージと依存パッケー
   ジは削除されます。

 * bulk-install:
   依存パッケージ群をインストールするためのバルクインストールで使われます。
   適切なバイナリーパッケージが利用可能な場合、pkg_addでそれをインストール
   します。そうでない場合は、"make bulk-package"が実行されますが、インストー
   ルされたバイナリーは削除されません。バイナリーパッケージがpkg_addでイン
   ストールされるのに"適切"である条件は、以下のとおりです:

    - パッケージファイル(Makefile, ...)が、いずれも構築時から変更されていな
      いこと
    - そのパッケージが依存している(バイナリー)パッケージが、いずれも構築時
      から変更されていないこと

 8 デバッグ
 ==========

(FreeBSDのportから、または一から)パッケージを作成する時に落ちいりやすい間違
いをチェックし、パッケージを動作させるための手順があります。これは基本的に
は前のセクションで説明したことと同じですが、デバッグを助けるための方法を追
加しています。

 - PKG_DEVELOPER=1 を /etc/mk.conf に含めるようにしてください
 - FreeBSDコレクションからportをさがしてください。
 - パッケージのMakefile中のRCS-IDを修正してください。
   セクション4.1を参考にしてください。
 - 未変更のFreeBSDのソースをインポートしてください(cvsアクセスが可能な場合
   だけおこなってください。そうでない場合は必要ありません)。(cd ...
   /pkgsrc/category/pkgname ; cvs import pkgsrc/category/pkgname \
	FREEBSD FreeBSD-current-yyyy-mm-dd)
 - CVSにインポートしたら、以下の修正が必要かどうか調べて下さい
   (CVSにアクセスできなければ必要ありません)。
 - 必要ならMakefileを修正してください。セクション4.1を参考にしてください。
 - パッチが適切かどうか確認してください。
 - すべてのpkg/PLISTの先頭行「@comment <$>NetBSD<$>」という行を追加してくだ
   さい(セクション5を参考にしてください)。
 - make
 - もし何かがうまくいかなければ、修正してください。パッチを作成するために、
   ファイルの修正後にdiffを再生成してください。
   「diff -bu foo.orig foo > ../../patch-xx」(作業する前に、mv patch-xx
   patch-xx.origしておいてください)もし、前のパッチでfoo.origが作成されない
   場合でも、必ず、どこかにそのファイルの古いバージョンを持っていて下さい。
   この作業を繰り返してください。:)
- 構築がすべてOKならtouch /tmp/blaして下さい。
 - make install
 - find /usr/pkg/ /usr/X11R6/ -newer /tmp/bla >/tmp/x
   (又は、LOCALBASEやX11BASEを設定したすべてのディレクトリーを対象として)
 - pkg_delete blub
 - find /usr/pkg/ /usr/X11R6/ -newer /tmp/bla
   (または 'make print-PLIST' の出力との diff をとる)
   もし、なにかファイルが見つかれば、それらはpkg/PLIST*に不足しているので、
   追加してください。
 - pkg/PLIST* と /tmp/x を比較し、前者を修正してください。
   ( sort /tmp/x >/tmp/x2 ; sort pkg/PLIST >/tmp/P ; sdiff /tmp/x2 /tmp/P )
 - make reinstall && make package
 - pkg_delete blub  
 - 「find /usr/pkg/ /usr/X11R6/ -type f -newew /tmp/bla」を実行し、何も見つ
   からないことを確認してください。
 - pkg_add .../blub.tgz  
 - 遊んでみてください。:)
 - pkg_delete - 今までと同様に、いかなるファイルも残っていてはいけません。
  (もう一度、上記のfind を実行してください)。
 - make clean && touch /tmp/bla && make install && make clean && make deinstall
   を繰り返し実行してください。そう、ソフトウェアの作者のなかには、buildター
   ゲットの最中にファイルをインストールするようなMakefileを書く人もいるので
   す。はあ……。そのようなものがあったら、再現させて、PLISTを修正してくだ
   さい。このソフトウェアが、PLISTにないファイルを一切インストールしないよ
   うになるまで、これを繰り返してください。
 - 提出してください(もし cvs アクセス可能であればコミットしてください)。
   セクション 10 が参考になります。


 9 FAQとパッケージシステムの特徴
 ===============================

 9.1 GNU autoconfigを利用するパッケージ
 ======================================

もしパッケージがGNU autoconfを使うのであれば、パッケージのMakefileに以下の
設定を追加してください。

> GNU_CONFIGURE= yes

この設定がCONFIGURE_ARGSに--prefix=${PREFIX}を追加することに注意してくださ
い。したがって、あなた自身でこれを追加する必要はありません。そして、これは
あなたの望む設定とは異なるかもしれません。


 9.2 tar.gz 以外の配布方法
 =========================

パッケージがtar.gz以外の方法で配布されている場合、editors/samパッケージを参
考にしてください。これはgzipされたシェルアーカイブ(shar)を使っています。い
ちおう簡単に説明すると、DISTNAMEフィールドの後でEXTRACT_SUFXに名前を設定し、
パッケージのMakefileに以下の設定を追加してください。

> EXTRACT_SUFX=   .msg.gz
> EXTRACT_CMD=            zcat
> EXTRACT_BEFORE_ARGS=
> EXTRACT_AFTER_ARGS=     |sh


 9.3 それ自身のサブディレクトリーを作り出さないパッケージ
 ========================================================

パッケージが例えばGNUソフトウェアのようにサブディレクトリーを作るのではなく、
カレントディレクトリーに展開される場合、もう一度editors/samを見てください。
簡単にいうと以下の設定が必要です。

> NO_WRKSUBDIR=   yes


 9.4 カスタムコンフィギュレーションプロセス
 ==========================================

パッケージが、かわったConfigureスクリプトを使用している場合、topのパッケー
ジを参照してください。簡単にいえば、以下の設定をおこなってください。

> HAS_CONFIGURE=          yes
> CONFIGURE_SCRIPT=       Configure
> CONFIGURE_ARGS+=        netbsd13


 9.5 DISTNAMEディレクトリーで作成されないパッケージ
 ==================================================

パッケージが、DISTNAMEをベースにしないディレクトリーで構築される場合、tcl、
およびtkパッケージを参考にしてください。

> WRKSRC=         ${WRKDIR}/${DISTNAME}/unix


 9.6 一度にすべてのdistfilesを取得する方法
 =========================================

「make fetch」を実行できない職場や大学において、一回のバッチ処理で、すべて
のdistfilesをダウンロードしたいと思うことがあるかもしれません。しかしながら、
ftp.netbsd.orgにはdistfilesのアーカイブはありません。そしてftp.freebsd.org
上にあるアーカイブは、移植されていない多くのdistfilesを含んでいます。

現時点では、「make fetch-list」を/usr/pkgsrcで実行し、その結果のリストを職
場や学校のマシンに持ってきて、使用してくださいとしかいえません。NetBSDと互
換なftp(1)(lukemftpなど)が使えない場合は、URLを指定して取得ができるコマンド
をFETCH_CMDに指定することを忘れないでください:

自宅で:
	cd /usr/pkgsrc
	make fetch-list FETCH_CMD=wget DISTDIR=/tmp/distfiles >/tmp/fetch.sh
	scp /tmp/fetch.sh work:/tmp

職場で:
	sh /tmp/fetch.sh
	/tmp/distfilesをtarで固めて自宅へ持っていく

NetBSDで動いているマシンがあって、*すべての*distfile (そのマシンのアーキテ
クチャー向けではないものも含む)を取得したい場合は、上述の'make fetch-list'
の方法を使うか、以下のようにしてdistfileを直接取得することができます。

	make mirror-distfiles

NO_{SRC,BIN}_ON_{FTP,CDROM}も無視したい場合は、以下のようにしてすべてのもの
を取得することができます。

	make fetch NO_IGNORE=yes


 9.7 防火壁の内側からファイルを取得する方法
 ==========================================

もし、あなたが防火壁の内側にいて、インターネットのホストに直接接続できない
(つまりNATを使っていない)場合、適切なプロキシーホストを指定することができま
す。これはURL形式の環境変数で指定します。例えば、Amdahlドメインにおいては、
orpheus.amdahl.comというマシンは防火壁のひとつで、プロキシーポート番号とし
て、80番のポートを使用します。この場合、proxy環境変数は以下のようになります。

	ftp_proxy=ftp://orpheus.amdahl.com:80/
	http_proxy=http://orpheus.amdahl.com:80/


 9.8 パッチがRCS IDを含む場合
 ============================

パッチからRCS IDを削除する方法については、セクション4.3を参照してください。


 9.9 /etc/mk.confから変数を捕まえる方法
 ======================================

MAKECONFや/etc/mk.confで上書き可能な、パッケージで定義された変数には問題が
あります。それは、変数はmake(1)がそれを使う時に展開されるが、プリプロセッサー
風の文(.if、.ifdefそして.ifndef)は読み込み時に評価される事です。したがって、.
if*文内で変数(/etc/mk.confでセットされる可能性のある)を使う時は、その.if*ス
テートメントの前に/etc/mk.confをインクルードしておかなくていけません。

/etc/mk.confやMAKECONFが存在したら、それらをインクルードするというad-hocな
方法をとらずに、すべてのプリプロセッサー風の.if、.ifdef、または.ifndef文の
前で、pkgsrc/mk/bsd.prefs.mkをインクルードしてください。

	.include "../../mk/bsd.prefs.mk"

	.if defined(USE_MENUS)
	...
	.endif


 9.10 pkgについて話しあうためのメーリングリストはありますか?
 ===========================================================

はい。パッケージに関する問題を議論するためにtech-pkg@netbsd.orgが存在します。
購読するためには以下のようにして下さい。

    echo subscribe tech-pkg | mail majordomo@netbsd.org


 9.11 どうすれば「make fetch」でpassive FTPを使用することができますか?
 =====================================================================

distfileの取得にどのユーティリティーを使っているかによります。bsd.pkg.mkは、
以下のリストのなかで利用可能なコマンドのうち、最初のものをFETCH_CMDに割り当
てます:

/usr/bin/fetch
${LOCALBASE}/bsd/bin/ftp
/usr/bin/ftp

NetBSDのデフォルトのインストールでは、/usr/bin/ftpとなり、これは自動的に、
最初はパッシブ接続を試みます。そして、サーバーがパッシブ接続を拒否した場合
は、アクティブ接続に切り替わります。これ以外のツールの場合は、
/etc/make.confに以下の設定を追加してください。PASSIVE_FETCH=1

これを設定すると、/usr/bin/ftpはアクテイブ転送への切り替えをおこなわなくな
ります。


 9.12 他のパッケージへの依存
 ===========================

パッケージは他のパッケージに依存するかもしれません。そして、この依存性を定
義するためのいろいろな方法があります。NetBSDはBUILD_DEPENDS、DEPENDS定義を
サポートしています(注意: DEPENDS定義はFreeBSDのものと同じではありません。
NetBSDはFreeBSDのLIB_DEPENDS定義をもはや使用していません。ELF化されたNetBSD
のプラットフォーム上で問題が発生することがわかりました)。

[以下の例において、BUILD_DEPENDSには、決められたフォーマットがあります。:<
ファイル>:<作成するパッケージのディレクトリー> [:<段階>]。もし、<段階>が指
定されていなければ、「install」がデフォルトとなります。ファイルが「/」を含
む場合、それは通常ファイルとして解釈されます。そうでない場合は、実行可能ファ
イルとしてあつかわれ、<ファイル>をさがすためにPATHが調べられます。もし、通
常ファイルが見つからない、あるいは実行可能ファイルがパス内に存在しなければ、
必要なパッケージが<作成するパッケージのディレクトリー>内のソースから作成さ
れます。DEPENDS定義はパッケージ名(バージョン番号を含む)と、そのバージョンの
パッケージがインストールされていない場合のために、作成するパッケージのディ
レクトリーを指定します。]

(a) パッケージを作成するために他のパッケージのファイルを必要とするなら、
print/ghostscript5パッケージを参考にしてください。(作成中にjpegのソースが存
在することを前提としています)

BUILD_DEPENDS+=  ../../graphics/jpeg/${WRKDIR:T}/jpeg-6a:../../graphics/jpeg:extract

(b) パッケージを構築するために他のパッケージが必要なら、BUILD_DEPENDS定義を
使ってください。ただし、上の説明とは異なり、「:extract」を指定してはいけま
せん。print/lyxがよい例です。このパッケージは構築中にlatexのバイナリーを使
用します。

BUILD_DEPENDS+=  latex:../../print/teTeX

(c) もし、パッケージがリンクのためのライブラリーを必要とするなら、DEPENDS定
義を使ってください。たとえば、print/lyxパッケージは、作成のためにxpmライブ
ラリーのバージョン3.4jを使用します。

DEPENDS+=       xpm-3.4j:../../graphics/xpm

また、パッケージ依存関係にはワイルドカードを使うことができます。

DEPENDS+=	xpm-*:../../graphics/xpm

ワイルドカード依存関係は、バイナリー・パッケージを作る時には保持されること
に注意してください。依存関係はバイナリーパッケージのインストール時にチェッ
クされ、パターンにマッチするパッケージが使われます。ワイルドカード依存関係
は、注意を払って使うよう気を付けてください。簡単な例として、Tkのあるバージョ
ンがインストールされていることが必要なパッケージで、正確に注意を払われてい
ないものを考えます。

DEPENDS+=	tk-*:../../x11/tk80

という依存関係は、たとえばtk-postgresql-6.5.3にもマッチしますが、これは必要
なものではありません。*常に*、ワイルドカードがマッチすべきでないものには決
してマッチしないようにしてください。

(d) もし、パッケージを実行するために、いくつかの実行可能ファイルが必要なら、
DEPENDS定義を使ってください。print/lyxパッケージを実行する時には、teTexパッ
ケージ由来のlatex のバイナリーが実行可能でなければなりません。これは、以下
のように指定します。

DEPENDS+=        teTex-*:../../print/teTeX 

上述した、ワイルドカード依存関係に関する注意は、ここにも当てはまります。

 9.13 他のパッケージとの衝突
 ===========================

パッケージは、すでにインストール済みの別のパッケージと衝突する可能性があり
ます。例えば、パッケージが、pkgsrcの中の別のパッケージと同じファイルをイン
ストールするような場合です。

この場合、衝突するパッケージ(バージョン文字列を含む)のリストをスペースで区
切ってCONFLICTSにセットすることができます。

例えば、pkgsrc/x11/Xaw3dおよびpkgsrc/x11/Xaw-Xpmは同じ共有ライブラリーをイ
ンストールします。したがって、pkgsrc/x11/Xaw3d/Makefileに以下のような設定を
おこなってください。

CONFLICTS=      Xaw-Xpm-*

そして、pkgsrc/x11/Xaw-Xpm/Makefileには以下の設定が必要です。

CONFLICTS=      Xaw3d-*

パッケージは、名前のプレフィックスが同じで、異なるバージョン文字列をもつ別
のパッケージと自動的に衝突します。例えば「Xaw3d-1.5」は、古いバージョンの
「Xaw3d-1.3」と衝突するでしょう。


 9.14 WWWホームページがあるソフトウェア
 ======================================

NetBSDパッケージシステムは、HOMEPAGE変数をサポートしています。もし、パッケー
ジ化されたソフトウェアのホームページが存在するのであれば、そのページのURLを
MakefileのHOMEPAGE変数に設定するべきです。この変数はMAINTAINER変数のすぐ後
に定義してください。


 9.15 '古い'名前のまま更新されたdistfileの取り扱い
 =================================================

時々、ソフトウェアパッケージの作者がソフトウェアのリリース後に変更を加え、
変更後のdistfileを、バージョン番号を変えずに公開することがあります。このと
き、pkgsrcにそのパッケージがすでに入っていると、md5チェックサムが一致しない
ことになります。この問題の正しい回避策は、パッケージのmd5チェックサムをマス
ターサイト(ミラーサイトでは更新されていないことがあります!)のパッケージに合
わせて変更し、古いdistfileをftp.netbsd.orgの/pub/NetBSD/packages/distfiles
ディレクトリーから削除することです。さらに、パッケージの正当な作者にメール
を出して、distfileの更新が意図されたものであって、トロイの木馬などが仕込ま
れたのではないことを確認します。


 9.16 "Don't know how to make /usr/share/tmac/tmac.andoc" ってどういうこと?
 ==========================================================================

pkgsrc/pkgtools/pkg_installパッケージのコンパイル時に、makeが
/usr/share/tmac/tmac.andoc の作り方がわからないというエラーを出します。これ
は、そのマシンに"text"セット(nroffなど)がインストールされていないことを意味
しています。"text"セットをインストールしてください。


 9.17 既存パッケージ修正時に、バージョンを上げるにはどうするか
 =============================================================

既存のパッケージに修正を加えたときに、PKGNAMEのバージョン番号を変えると便利
な場合があります。元の作者による将来のバージョンと衝突しないようにするため、
'nb1'を後に付けます(さらにバージョンを上げるときは'nb2'などとします)。


 9.18 "Could not find bsd.own.mk" - 何がいけないの?
 ==================================================

NetBSDのインストール時にコンパイラー一式comp.tgzをインストールしなかったか
らです。comp.tgzを入手し、/で展開してインストールしてください:

	tar --unlink -pvxf .../comp.tgz

comp.tgzはNetBSDのどのリリースにも含まれていますので、あなたがインストール
したリリース("uname -r"で調べられます) に合ったものを入手してください。


 9.19 制限つきパッケージ
 =======================

ライセンスによっては、ソフトウェアの再配布方法に制限があります。このような
制限を満たすようにするため、パッケージシステムでは以下のような制限を設定で
きる5個のmake変数を定義しています:

    - RESTRICTED:
      なにか制限がある場合は常に、(制限の種類にかかわらず)この変数を設定す
      べきです。この変数を、その制限の理由を含む文字列に設定してください。

    - NO_BIN_ON_CDROM:
      バイナリーをCD-ROMに収録してはいけません。バイナリーパッケージを
      CD-ROMに含めることができない場合は常に、この変数を${RESTRICTED}に設定
      してください。

    - NO_BIN_ON_FTP:
      バイナリーをftpサーバーに置いてはいけません。バイナリーパッケージをイ
      ンターネット上で公開することができない場合は常に、この変数を
      ${RESTRICTED}に設定してください。

    - NO_SRC_ON_CDROM:
      distfileをCD-ROMに収録してはいけません。ソースコードやその他の
      distfileのCD-ROMによる再配布が許可されていない場合は、この変数を
      ${RESTRICTED}に設定してください。

    - NO_SRC_ON_FTP:
      distfileをFTPに置いてはいけません。ソースコードやその他のdistfileのイ
      ンターネット経由での再配布が許可されていない場合は、この変数を
      ${RESTRICTED}に設定してください。

NO_PACKAGE, IGNORE, NO_CDROMなど、制限を意味する上記以外の汎用make変数は使
うべきでないことに注意してください。これらは、ユーザーのバイナリーパッケー
ジ作成を、無条件にできないようにするからです。

 9.20 (n)cursesを使うパッケージ
 ==============================

パッケージによっては1.4Y以前のNetBSD自身のcursesにはなかった機能を必要とし
ます。そんな機能を使うパッケージ用に、いくつかの変数が用意されています: パッ
ケージのMakefileでUSE_CURSESを設定した場合、そのシステムでのncursesへの依存
関係の必要性に応じて、自動的にNEED_NCURSESがYESかNOに設定されます。この変数
を、たとえば、ncursesを使うかどうかをパッケージに知らせるために、configure
の引数に追加して使うことができます。

さらに、いくつかのファイル名に対してREPLACE_NCURSESを設定することができます。
パッケージがncursesを必要としない場合は、これが設定された各ファイル中のすべ
ての'ncurses'が'curses'に置換されます。ncursesがインストールされていて、か
つパッケージのconfigureスクリプトがncursesを優先して使うようになっている場
合、この変数を使う必要があるかもしれません。

たとえばmail/muttでは、関連する部分は以下の各行です:
USE_CURSES=		YES
REPLACE_NCURSES=	configure configure.in
[...]
.include "../../mk/bsd.prefs.mk"

.if defined(NEED_NCURSES) && ${NEED_NCURSES} == "YES"
CONFIGURE_ARGS+=	--with-curses=${LOCALBASE}
.endif

NEED_NCURSES変数はbsd.prefs.mkで設定されるので、この変数を確認するのは
bsd.prefs.mkをインクルードした後でなければならないことに注意してください。


 10 提出およびコミット
 =====================

 10.1 あなたが作ったパッケージの提出
 ===================================

ここでは、バイナリーパッケージと"通常の"(ソース)パッケージとを区別する必要
があります:

 *コンパイル済みのバイナリー・パッケージ:
  我々は、トロイの木馬等を含まないことを保証するために、NetBSD開発者からし
  かバイナリーを受け取りません。これは、誰かを糞ったれ扱いするものではなく、
  むしろユーザーを保護するための方針です。しかしながら、あなたの作ったバイ
  ナリー・パッケージをどこかに置き、配布することは自由に行なってもかまいま
  せん。

 *パッケージ:
  最初にパッケージが完全かどうか、コンパイル、実行できるかどうかを確認して
  ください。このドキュメントのセクション8、その他を参考になるでしょう。次に、
  パッケージに必要なすべてのファイルのgzipされたtarファイルを作成してくださ
  い。これは、すべてのファイルをひとつのディレクトリーにおきたいためです。
  次に、そのtarファイルを、パッケージのメンテナーがFTPかHTTP (WWW)を使用し
  て取得できる場所においてください。最後に、パッケージの名前とバージョンを
  含む概要、簡単な説明(COMMENT変数の内容でもOKです)、そしてtarファイルのURL
  を書き、「pkg」カテゴリーでsend-pr (問題報告)をおこなってください。

  問題報告が処理されたら、あなたに連絡がいきます。そうすれば、tarファイルを
  削除してもかまいません。

  複数のパッケージを提出したい場合は、一つのパッケージにつき一つのPRにわけ
  て送ってください。そうすることで、私たちが追跡しやすくなります。


 10.2 コミット: パッケージのCVSへのインポート
 ============================================

このセクションは、NetBSDのpkgsrcリポジトリーへの書き込みアクセス権限を持っ
ているNetBSD開発者にのみ意味があるものです。cvsはカレントディレクトリーから
の相対位置にファイルをインポートすることと、"cvs import"コマンドに渡したパ
ス名からリポジトリー中のファイルの位置が決まることを忘れないでください。新
しく作ったパッケージは、「TNF」のベンダータグと「pkgsrc-base」のリリースタ
グでインポートしてください。例えば:

	cd .../pkgsrc/<category>/<pkgname>
	cvs import pkgsrc/<category>/<pkgname> TNF pkgsrc-base


また、インポートに使ったディレクトリーは、忘れずに邪魔にならないところに移
しておいてください。そうしておかないと、ソースツリーを次に"cvs update"した
ときにcvsが文句を言います。

FreeBSDポートから派生したパッケージは、「FREEBSD」のベンダータグと
「FreeBSD-current-YYYY-MM-DD」のリリースタグ(YYYY-MM-DDはFreeBSDのツリーか
らポートのスナップショットをとってきた日付)でインポートします。そして、通常
のCVSのオペレーションにより必要な変更をおこなってください。例えば:

	cd .../pkgsrc/<category>/<pkgname>
	cvs import pkgsrc/<category>/<pkgname> FREEBSD FreeBSD-current-1998-04-01
	cvs rm patches/patch-a
	cvs add patches/patch-aa
	cvs ci

すべてのパッケージの変更、追加をdoc/pkg-CHANGESに記述してください。このファ
イルを、これまでと同じ形式のまま最新の状態に保つことは非常に重要なことです。
なぜなら、このファイルはスクリプトによりwww.netbsd.orgや他のサイトのページ
を自動的に更新するために使用されているからです。


 11 パッケージの簡単な例: bison
 ==============================

私は、FreeBSDのポート(ports)にないソフトウェアをさがし、GNU bisonを選びまし
た。バークレーのyaccがすでにソースツリーに存在するので、bisonを使いたい人は
いないでしょう。しかし、練習という意味では役にたちます。


 11.1 ファイル
 =============

このセクションのファイルの内容は、実際には「> 」というプレフィックスなしで
使用してください。


 11.1.1 Makefile
 ===============

> # <$>NetBSD<$>
>  
> DISTNAME=       bison-1.25
> CATEGORIES=     devel
> MASTER_SITES=   ${MASTER_SITE_GNU}
>
> MAINTAINER=     thorpej@netbsd.org
> HOMEPAGE=       http://www.gnu.org/software/bison/bison.html
> COMMENT=        GNU yacc clone
>  
> GNU_CONFIGURE=  yes
> INFO_FILES=     bison.info
>  
> .include "../../mk/bsd.pkg.mk"


 11.1.2 pkg/DESCR
 ================

> GNU version of yacc.  Can make re-entrant parsers, and numerous other
> improvements.  Why you would want this when Berkeley yacc(1) is part
> of the NetBSD source tree is beyond me.


 11.1.3 pkg/PLIST
 ================

> @comment <$>NetBSD<$>
> bin/bison
> man/man1/bison.1.gz
> @unexec install-info --delete %D/info/bison.info %D/info/dir
> info/bison.info
> info/bison.info-1
> info/bison.info-2
> info/bison.info-3
> info/bison.info-4
> info/bison.info-5
> @exec install-info %D/info/bison.info %D/info/dir
> share/bison.simple
> share/bison.hairy


 11.1.4 パッケージをチェックする 「pkglint」
 ==========================================

NetBSDパッケージシステムは、「pkglint」(pkgsrc/pkgtools/pkglintディレクトリー
にあります)とよばれるツールを含んでいます。このツールはこれらのファイルの内
容をチェックするのを助けてくれます。一度インストールしてしまえば、このツー
ルは非常に簡単に使うことができます。検査したいパッケージのディレクトリーに
移動し、「pkglint」を実行するだけです。

> tron@lyssa:/usr/pkgsrc/devel/bison>pkglint
> OK: checking pkg/DESCR.
> OK: checking Makefile.
> OK: checking files/md5.
> OK: checking patches/patch-aa.
> looks fine.

指定されたコマンド行の引き数(「man pkglint」を見てください)によっては、より
冗長なチェックがおこなわれます。例えば「pkglint -v」は、大変詳細かつ冗長な
チェックをおこないます。


 11.2 構築、インストール、パッケージングの手順
 =============================================

パッケージのためのディレクトリーと、いくつかの追加のディレクトリーを作成し
ます。

> root@pumpy:/u/pkgsrc/lang(1765)# cd /usr/pkgsrc/lang
> root@pumpy:/u/pkgsrc/lang(1765)# mkdir bison
> root@pumpy:/u/pkgsrc/lang(1766)# cd bison
> root@pumpy:/u/pkgsrc/lang/bison(1768)# mkdir files patches pkg

セクション11.1のようにMakefile、pkg/DESCR、およびpkg/PLISTを作り、distfile
を取得します。

> root@pumpy:/u/pkgsrc/lang/bison(1769)# make fetch
> >> bison-1.25.tar.gz doesn't seem to exist on this system.
> >> Attempting to fetch from ftp://prep.ai.mit.edu/pub/gnu//.
> Requesting ftp://prep.ai.mit.edu/pub/gnu//bison-1.25.tar.gz (via ftp://orpheus.amdahl.com:80/)
> ftp: Error retrieving file: 500 Internal error
>  
> >> Attempting to fetch from ftp://wuarchive.wustl.edu/systems/gnu//.
> Requesting ftp://wuarchive.wustl.edu/systems/gnu//bison-1.25.tar.gz (via ftp://orpheus.amdahl.com:80/)
> ftp: Error retrieving file: 500 Internal error
>  
> >> Attempting to fetch from ftp://ftp.freebsd.org/pub/FreeBSD/distfiles//.
> Requesting ftp://ftp.freebsd.org/pub/FreeBSD/distfiles//bison-1.25.tar.gz (via ftp://orpheus.amdahl.com:80/)
> Successfully retrieved file.

distfileのチェックサムをfiles/md5へ作成します。

> root@pumpy:/u/pkgsrc/lang/bison(1770)# make makesum

コンパイルします。

> root@pumpy:/u/pkgsrc/lang/bison(1777)# make
> >> Checksum OK for bison-1.25.tar.gz.
> ===>  Extracting for bison-1.25
> ===>  Patching for bison-1.25
> ===>   Ignoring empty patch directory
> ===>  Configuring for bison-1.25
> creating cache ./config.cache
> checking for gcc... cc
> checking whether we are using GNU C... yes
> checking for a BSD compatible install... /usr/bin/install -c -o bin -g bin
> checking how to run the C preprocessor... cc -E
> checking for minix/config.h... no
> checking for POSIXized ISC... no
> checking whether cross-compiling... no
> checking for ANSI C header files... yes
> checking for string.h... yes
> checking for stdlib.h... yes
> checking for memory.h... yes
> checking for working const... yes
> checking for working alloca.h... no
> checking for alloca... yes
> checking for strerror... yes
> updating cache ./config.cache
> creating ./config.status
> creating Makefile
> ===>  Building for bison-1.25
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g LR0.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g allocate.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g closure.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g conflicts.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g derives.c
> cc -c -DXPFILE=\"/usr/pkg/share/bison.simple\"  -DXPFILE1=\"/usr/pkg/share/bison.hairy\" -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1  -g  ./files.c 
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g getargs.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g gram.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g lalr.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g lex.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g main.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g nullable.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g output.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g print.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g reader.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g reduce.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g symtab.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g warshall.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g version.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g getopt.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g getopt1.c
> cc  -g -o bison LR0.o allocate.o closure.o conflicts.o derives.o files.o         getargs.o gram.o lalr.o lex.o                                   main.o nullable.o output.o print.o reader.o reduce.o symtab.o   warshall.o version.o getopt.o getopt1.o
> ./files.c:240: warning: mktemp() possibly used unsafely, consider using mkstemp()
> rm -f bison.s1
> sed -e "/^#line/ s|bison|/usr/pkg/share/bison|" < ./bison.simple > bison.s1

すべてOKのようなので、ファイルをインストールします。

> root@pumpy:/u/pkgsrc/lang/bison(1785)# make install
> >> Checksum OK for bison-1.25.tar.gz.
> ===>  Installing for bison-1.25
> sh ./mkinstalldirs /usr/pkg/bin /usr/pkg/share  /usr/pkg/info /usr/pkg/man/man1
> rm -f /usr/pkg/bin/bison
> cd /usr/pkg/share; rm -f bison.simple bison.hairy
> rm -f /usr/pkg/man/man1/bison.1 /usr/pkg/info/bison.info*
> install -c  -o bin -g bin -m 555 bison /usr/pkg/bin/bison
> /usr/bin/install -c -o bin -g bin -m 644 bison.s1 /usr/pkg/share/bison.simple
> /usr/bin/install -c -o bin -g bin -m 644 ./bison.hairy /usr/pkg/share/bison.hairy
> cd .; for f in bison.info*;  do /usr/bin/install -c -o bin -g bin -m 644 $f /usr/pkg/info/$f; done
> /usr/bin/install -c -o bin -g bin -m 644 ./bison.1 /usr/pkg/man/man1/bison.1
> ===>  Registering installation for bison-1.25

これでbisonを使用することができます。そして、「pkg_delete bison-1.25」を実
行することでbisonを削除することもできます。もし、バイナリー・パッケージが欲
しければ、以下のようにしてください。

> root@pumpy:/u/pkgsrc/lang/bison(1786)# make package
> >> Checksum OK for bison-1.25.tar.gz.
> ===>  Building package for bison-1.25
> Creating package bison-1.25.tgz
> Registering depends:.
> Creating gzip'd tar ball in '/u/pkgsrc/lang/bison/bison-1.25.tgz'

もし、ソースやオブジェクトファイルが必要ないのであれば、掃除してください。

> root@pumpy:/u/pkgsrc/lang/bison(1787)# make clean
> ===>  Cleaning for bison-1.25


=================
付録A: 構築のログ
=================

 A.1 topの構築
 =============

> Script started on Fri Oct  3 13:22:31 1997
> root@pumpy:/u/pkgsrc/sysutils/top(1342)# make
> >> top-3.5beta5.tar.gz doesn't seem to exist on this system.
> >> Attempting to fetch from ftp://ftp.groupsys.com/pub/top/.
> Requesting ftp://ftp.groupsys.com/pub/top/top-3.5beta5.tar.gz (via ftp://orpheus.amdahl.com:80/)
> Successfully retrieved file.
> >> Checksum OK for top-3.5beta5.tar.gz.
> ===>  Extracting for top-3.5beta5
> ===>  Patching for top-3.5beta5
> ===>  Applying NetBSD patches for top-3.5beta5
> ===>  Configuring for top-3.5beta5
> /bin/cp /u/pkgsrc/sysutils/top/files/defaults /u/pkgsrc/sysutils/top/work/top-3.5beta5/.defaults
> chmod a-x /u/pkgsrc/sysutils/top/work/top-3.5beta5/install
> 
> Reading configuration from last time...
> 
> Using these settings:
>         Bourne Shell   /bin/sh
>           C compiler   cc
>     Compiler options   -DHAVE_GETOPT -O
>          Awk command   awk
>      Install command   /usr/bin/install
> 
>               Module   netbsd13
>              LoadMax   5.0
>         Default TOPN   -1
>         Nominal TOPN   18
>        Default Delay   2
> Random passwd access   yes
>           Table Size   47
>                Owner   root
>          Group Owner   kmem
>                 Mode   2755
>        bin directory   $(PREFIX)/bin
>        man directory   $(PREFIX)/man/man1
>        man extension   1
>        man style       man
> 
> Building Makefile...
> Building top.local.h...
> Building top.1...
> Doing a "make clean".
> rm -f *.o top core core.* sigdesc.h
> To create the executable, type "make".
> To install the executable, type "make install".
> ===>  Building for top-3.5beta5
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c top.c
> awk -f sigconv.awk /usr/include/sys/signal.h >sigdesc.h
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c commands.c
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c display.c
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c screen.c
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c username.c
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c utils.c
> utils.c: In function `errmsg':
> utils.c:348: warning: return discards `const' from pointer target type
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c version.c
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c getopt.c
> cc "-DOSREV=12G" -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O -c machine.c
> rm -f top
> cc -o top top.o commands.o display.o screen.o username.o  utils.o version.o getopt.o machine.o -ltermcap -lm -lkvm
> root@pumpy:/u/pkgsrc/sysutils/top(1343)# make install
> >> Checksum OK for top-3.5beta5.tar.gz.
> ===>  Installing for top-3.5beta5
> /usr/bin/install -o root -m 2755 -g kmem top /usr/pkg/bin
> /usr/bin/install top.1 /usr/pkg/man/man1/top.1
> strip /usr/pkg/bin/top
> ===>  Registering installation for top-3.5beta5
> root@pumpy:/u/pkgsrc/sysutils/top(1344)# 


 A.2 topのパッケージング
 =======================

> root@pumpy:/u/pkgsrc/sysutils/top(1344)# make package
 > >> Checksum OK for top-3.5beta5.tar.gz.
> ===>  Building package for top-3.5beta5
> Creating package top-3.5beta5.tgz
> Registering depends:.
> Creating gzip'd tar ball in '/u/pkgsrc/sysutils/top/top-3.5beta5.tgz'
> root@pumpy:/u/pkgsrc/sysutils/top(1345)#


=================================================
付録B:FTPサーバのパッケージアーカイブのレイアウト
=================================================

ftp.netbsd.org上のコンパイル済みのバイナリー・パッケージのレイアウト

/pub/NetBSD/packages/
                README
                distfiles/
		pkgsrc -> /pub/NetBSD/NetBSD-current/pkgsrc
                1.5/
                        i386/
                                All/
                                archivers/
                                        foo -> ../All/foo
                                ...
                        m68k/
                                All/
                                archivers/
                                        foo -> ../All/foo
                                ...
                        amiga -> m68k
                        atari -> m68k
                        ...


作成:
 - cd /usr/pkgsrc ; make install ; make package
 - /usr/pkgsrc/packages を
   ftp://ftp.netbsd.org/pub/NetBSD/packages/\
    `uname -r | sed 's@\.\([0-9]*\)[\._].*@\.\1@'`/`sysctl -n hw.machine_arch`
   へアップロードする。
 - 必要ならln -s `sysctl -n hw.machine` `sysctl -n hw.machine_arch`

必要なディスクスペース: 不明

NetBSDのリリースバージョン向けのパッケージは、リリースバージョンの番号にあ
わせたmajor.minorという形式の名前のディレクトリーにアップロードされるべきで
す。"1.5.1"というバージョンのNetBSD向けのパッケージをアップロードするディレ
クトリーは、tinyバージョン番号を省いた"1.5"になります。LKMなど、OSバージョ
ンに強く依存するパッケージについては、major.minor.tinyリリースディレクトリー
を作って、そこに置くことができます。このようなパッケージには、バイナリーパッ
ケージ構築者のために何らかの方法で"OSVERSION_SPECIFIC=yes" 変数をつけてくだ
さい。


###########################################################################
# Local Variables:
# mode:				Text
# fill-column:			75
# sentence-end-double-space:	nil
# End:
