# $NetBSD: Packages.txt,v 1.9 2001/05/06 12:06:08 kei Exp $
# $Id: Packages.txt,v 1.9 2001/05/06 12:06:08 kei Exp $
###########################################################################

			==========================
			 NetBSDパッケージシステム
			   ドキュメンテーション
			==========================

		      Hubert Feyrer, Alistair Crooks


目次:
=====

 grep -B1 '^.====' Packages.txt | egrep -v '^.[-=]'


 0 イントロダクション
 ====================

UNIXベースのシステムには、自由に利用できるソフトウェアが数多く存在します。
これらは普通、またはいくつかの変更でNetBSDで実行できます。NetBSDパッケージ
コレクションは、一つのコマンドでそのソフトウェアにNetBSDで実行するのに必要
ないくらかの変更を施して、ソフトウェアパッケージのインストール(および再イン
ストール)を簡単にします。

NetBSDパッケージシステムは、自由に利用できるサードパーティのソフトウェアを、
NetBSDホストで容易に構築することを可能にします。一旦ソフトウェアが構築され
ればそれらはpkg_*ツールにより操作できるので、そのパッケージのインストール、
削除、全てのインストールされたパッケージの目録の表示、一行コメント、あるい
はより詳細な説明の情報検索が全く簡単にできます。

NetBSDパッケージコレクションおよびNetBSDパッケージシステムは、FreeBSDに由来
しています。


 0.1 概要
 ========

このドキュメントは二部に別れています。第一部は「ユーザーガイド」で、パッケー
ジコレクションの一つのパッケージを使う方法を、コンパイル済みのバイナリー・
パッケージのインストールと、自分自身でコピーしたNetBSDパッケージシステムか
ら構築する方法の両方で説明します。第二部の「パッケージ構築者ガイド」は、他
のNetBSDユーザーがその構築の詳細について知らなくても簡単にパッケージを構築
できるようにするために、パッケージを用意する方法を説明します。


 0.2 専門用語
 ============

ここまでですでに「ポート(ports)」、「パッケージ(packages)」などについて何度
も触れています。ここで、このドキュメント中に使われている用語を説明します:

 * パッケージ(Package):
   ファイルのセットで、NetBSDパッケージシステムを使用したソフトウェアを構築
   するのに必要なことが記述された構築手順書です。パッケージは、伝統的に
   /usr/pkgsrcの下に置かれます。

 * NetBSDパッケージシステム:
   これは、NetBSDオペレーティングシステムの一部分で、パッケージの構築(コン
   パイル)、インストールおよび削除を扱います。

 * Distfile:
   この用語は、自由に利用できるソフトウェアの作者が、彼の仕事を配布するため
   に提供しているファイルのことを指しています。NetBSDで構築するのに必要な全
   ての変更は、対応するパッケージに反映されます。通常distfileは、圧縮された
   tarアーカイブ形式ですが、他の形式でも使用できます。Distfilesは
   /usr/pkgsrc/distfilesの下に保存されます。

 * ポート(Port):
   これはFreeBSDの人たちが、私たちがパッケージ(package)と呼んでいるものを表
   すために使われている用語です。NetBSDでは「ポート(port)」は、異なるアーキ
   テクチャーを参照する用語となります。

 * コンパイル済み(バイナリー)パッケージ:
   NetBSDパッケージシステムを使ってdistfileより作成されたバイナリーのセット
   で、ひとつの.tgzファイルに集められています。これはリコンパイルなしに同じ
   マシンアーキテクチャーのマシンにインストールすることができます。パッケー
   ジはNetBSDパッケージシステムにより、/usr/pkgsrc/packagesに生成され、それ
   はftp.netbsd.orgにもアーカイブされています。

   時々、これは、特にコンパイル済みのパッケージの文脈で、単に「パッケージ」
   と表されることもあります。

 *プログラム:
   対応するパッケージが、Distfileにあるファイルから作成した、インストールさ
   れるべきソフトウェアのひとまとまりです。

 * RCS ID:
   パッケージに含まれるいくつかのファイルは、そのファイルのバージョンに対応
   したRCS IDが含まれています(cvsにより自動的に挿入されます)。これらのIDは、
   このドキュメントの中のいくつかの例で使用されていますが、このドキュメント
   自体がCVSによって管理されていますので、生のRCS IDを列挙することができま
   せん。かわりに、$は<$>のように記していますので、<$>NetBSD<$>や<$>Id<$>と
   なります。


======================
第一部: ユーザーガイド
======================

 1 コンパイル済みのバイナリー・パッケージのインストール
 ======================================================

このセクションは、あなたの機種用にすでに準備されたコンパイル済みのバイナリー・
パッケージを見つけ、取得してインストールする方法について説明します。


 1.1 どこから入手するか
 ======================

コンパイル済みのパッケージは、ftp.netbsd.orgおよびそのミラー上の、匿名FTPア
クセスのためのディレクトリー/pub/NetBSD/packagesに置かれています。"sysctl
hw.machine_arch"で表示されるのと同じサブディレクトリーを選択してください。
このディレクトリーの中には、カテゴリー毎のサブディレクトリーと、「All」サブ
ディレクトリーが存在しています。「All」サブディレクトリーの中には、.tgzファ
イル形式で実際のバイナリーがあります。カテゴリー毎のサブディレクトリーは、
これらのファイルへのシンボリックリンクを使用しています。
(/usr/pkgsrc/packagesと同じディレクトリー・レイアウトです)。

CDROMディストリビューションでも、このディレクトリー・レイアウトは同じで、単
にディレクトリーのルートが異なるだけです。たぶん/cdromかどこかの下でしょう。
正確なディレクトリーは、CDROMのドキュメンテーションを参照してください。


 1.2 方法
 ========

もし、コンパイル済みのパッケージのファイルがCDROM上にある、あるいはハードディ
スク上にダウンロードされているのであれば、以下のコマンドでインストールする
ことができます(最初にrootにsuしている事を確認してください):

	pkg_add /path/to/package.tgz

もし、FTPアクセスが可能で、インストール前にFTPを使ってパッケージをダウンロー
ドしたくないのであれば、pkg_addにftpのURLを指定する事もできます。

	pkg_add ftp://ftp.netbsd.org/pub/packages/`sysctl -n hw.machine_arch`/All/package.tgz

バイナリー・ファイルの正しいセットを自動的に決定するために、ここでsysctlが
使用されている事に注意してください。また、パッケージを実行するために必要な
他のパッケージがインストールされるかもしれない事にも注意してください。一緒
にインストールされる他のパッケージも同じ場所に存在していると仮定されます。

パッケージをインストールした後に、$PATHに/usr/pkgが含まれている事を確認して
ください。これで、インストールされたプログラムを実際に使い始めることができ
ます。


 1.3 警告
 ========

マニュアル・ページで警告されている、自分自身で作ったものでないバイナリー・
パッケージをインストールすることが孕む危険性、無思慮にこのようなファイルを
インストールすることにより、あなたのシステムにセキュリティーホールが生じる
事についてよく注意してください。


 2 構築しインストールする
 ========================

ここでは、パッケージがすでにNetBSDパッケージ・システムに含まれていると仮定
しています。もし、そうでなれば、このドキュメントの第二部「パッケージ構築者
ガイド」を読む事をお勧めします。


 2.1 どこからpkgsrcを得るか
 ==========================

パッケージのソースを入手するためには、pkgsrc.tar.gzファイルを
ftp://ftp.netbsd.org/pub/NetBSD-current/tar_files/pkgsrc.tar.gzから取得し、
/usr/pkgsrcに展開する必要があります。

あるいは、ソフトウェア更新プロトコル(Software Update Protocol) SUPを使い
pkgsrcを入手することもできます。まず、supfileの中に「release=pkgsrc」という
行があることを確認してください。例えば、/usr/share/examples/supfilesを見て
ください。それからディレクトリー/usr/pkgsrcが存在することを確認してください。
後は「sup -v /path/to/your/supfile」を実行するだけです。


 2.2 配布ファイルの取得
 ======================

ひとつ注意しておくことがあります:パッケージシステムを構築するためには、ディ
ストリビューション・ファイル(未変更のソース)がシステム上に存在していなけれ
ばなりません。もし、存在しない場合は配布ファイルを取得するために自動的に
ftp(1)が実行されます。

主要なディストリビューション・サイトをあなたのところに近いサイトで上書きす
ることができます。/usr/pkgsrc/mk/mk.conf.exampleの例を参照してください。こ
れにより、帯域幅と時間が節約できるかもしれません。

もし、インターネットへ常時接続しておらず、ダウンロードするファイルを知りた
い場合は、「make fetch-list」を実行すれば、必要なファイルがわかります。それ
らの配布ファイルを/usr/pkgsrc/distfilesに置いてください。


 2.3 構築とインストール方法
 ==========================

上記の作業が完了したら、rootになり適切なディレクトリーに移動してください。
そして、シェル・プロンプト上で以下のようにタイプしてください。

	make

これで、パッケージのさまざまなコンポーネントが構築されます。それから、

	make install

とシェル・プロンプト上でタイプしてください。これにより、さまざまなコンポー
ネントが適切な場所にインストールされます。

topシステム・ユーティリティーを例にあげると、A.1のように構築することにより、
システムにインストールすることができます。

プログラムはパッケージ・ツリーのデフォルト・ルート- /usr/pkgにインストール
されます。もし、このディレクトリーが趣味にあわないのであれば、環境変数
LOCALBASEを設定してください。この値はパッケージ・ツリーのルートとして使用さ
れます。例えば、/usr/localを使う場合、

	LOCALBASE=/usr/local

と設定してください。もちろん、ひとつ例外があります。X11パッケージは伝統的に
X11ツリーにインストールされます。X11パッケージの場所を決定する環境変数は
X11BASEです。したがって、X11パッケージを/usr/local/X11R6にインストールする
場合は、

	X11BASE=/usr/local/X11R6

を設定してください。

しかしながら、X11ツリー以外にX11パッケージをインストールした場合、他のソフ
トウェアによりライブラリーやヘッダーが見つけられなかったり、アプリケーショ
ンのデフォルトが見つからなかったりして、おかしな事がおこるかもしれません。
これらの理由により、X11パッケージはX11ツリーに残しておく事をお勧めします。
現在、これを変更する方法を調査中です。

いくつかのパッケージは、構築時にいくつかのコンフィギュレーションオプション
を変えるために/etc/mk.confを参照します。設定可能な項目については、
/usr/pkgsrc/mk/mk.conf.exampleをのぞいてみてください。


 3 コンパイル済みのパッケージを作る
 ==================================

上に述べた手順でパッケージを構築しインストールしたら、これをバイナリー・パッ
ケージにすることができます。- 他のNetBSDマシン上で作成したバイナリーを使い
たいと思うかもしれませんし、単にCPU時間を無駄に使わずにすむようにあなたのバ
イナリー・パッケージを他の人のために使わせてあげたいと思うかもしれません。- 
これは、pkgsrcツリー内の適切なディレクトリーに移動し、シェル・プロンプト上
で以下のコマンドをタイプすることにより可能です。

	make package

これにより、パッケージが構築、インストールされます(もし、まだ済んでいなけれ
ば)。そして、pkg_*ツールを使い操作できるようにバイナリー・パッケージが構築
されます。現状ではバイナリー・パッケージは/usr/pkgsrc/packages以下にgzipさ
れたファイルとして作成されます。上記のtopの例の続きは、付録A.2を参照して下
さい。

このようなバイナリー・パッケージを提出する方法については、このドキュメント
の後の「提出」セクションを参照してください。


==============================
第二部: パッケージ構築者ガイド
==============================

 4 パッケージコンポーネント - ファイル、ディレクトリー、およびコンテンツ
 =======================================================================

FreeBSD Portsコレクションからパッケージを用意しても、ゼロからパッケージを用
意する場合でも、いつも以下のセクションで述べられている多くのファイルが存在
します。特に、それぞれのファイルがどうFreeBSD Portsと違うのかも説明していき
ます。


 4.1 Makefile
 ============

構築、インストールおよびバイナリー・パッケージの作成は、すべてパッケージの
Makefileによりコントロールされます。

それぞれのパッケージのためのMakefileがあります。このファイルは、パッケージ
のコンパイルとインストールのために必要なすべての定義とアクションがセットさ
れた標準のbsd.pkg.mkファイル("../../mk/bsd.pkg.mk")をインクルードします。必
須となるフィールドは、インターネットのサイトからダウンロードされる配布ファ
イルのベース名を指定するDISTNAMEと、そのサイトを指定するMASTER_SITES、パッ
ケージが置かれるカテゴリーを意味するCATEGORIES、パッケージの名前である
PKGNAMEとメインテイナー名であるMAINTAINERです。これは、そのパッケージを維持
する人による(いつも完全に正しい)決定にへりくつを言う誰かが、活発に苦情を言
うことができるようにするためです。

MASTER_SITESは、定義済みのサイトの一つをセットすることもできます。

	${MASTER_SITE_XCONTRIB}
	${MASTER_SITE_GNU}
	${MASTER_SITE_PERL_CPAN}
	${MASTER_SITE_TEX_CTAN}
	${MASTER_SITE_SUNSITE}

もしこれらの予め定義されたサイトの1つを選んだ場合、そのサイトのサブディレク
トリーを指定する方法が必要となるかもしれません。これらのマクロは一つ以上の
実際のサイトに展開されるかもしれませんので、サブディレクトリーを指定する場
合は、以下の表記を使わなければなりません:

	${MASTER_SITE_GNU:=subdirectory/name/}

(サブディレクトリー名の後のスラッシュ/に注意してください)廃止された
MASTER_SITE_SUBDIRを使用しても動作しません。

現在CATEGORIESの値として以下が使用できます。もし一つ以上にまたがる場合、そ
れらの値はスペースで分けられる必要があります:

	archivers   corba      games     meta-pkgs  security
	audio       cross      graphics  misc       shells
	benchmarks  databases  lang      net        sysutils
	cad         devel      mail      news       textproc
	comms       editors    math      plan9      www
	converters  emulators  mbone     print      x11

全ての利用できるオプション、および変数の記述に関しては、NetBSD packages(7)
マニュアルページを参照してください。

以下の事柄に気を配ってください。FreeBSD Portsコレクションからパッケージを持っ
てきた場合は特に気を付けてください:

 - パッケージのMakefileから、すべてのMANxとCATxの定義を削除してください。-
   NetBSDではマニュアルページを自動的に取扱います。これらの定義は現在使用さ
   れていません。
 - もしパッケージにより(すでにそこにないとしても)マニュアルページが圧縮され
   た形式でインストールされる場合、MANCOMPRESSEDを追加してください。
   bsd.pkg.mkのコメントを参照。
 - すべてのファイルの/usr/localを${PREFIX}に変更してください。(後述のパッチ
   を参照)
 - どんなldconfigコマンドも削除してください - もしNetBSDプラットフォームが
   ldconfigをサポートしていれば自動的に実行されますし、ldconfigをサポートし
   ないプラットフォーム(例NetBSD/Alpha)では他の処置がとられるでしょう。
 - もしFreeBSD Portsコレクションからパッケージを持ってきて変更するならば、
   それらのRCS IDを保持してください:FreeBSDのRCS Id中の'$'を削除し、なけれ
   ば'FreeBSD'を挿入してください。そして、<$>NetBSD<$>を追加してください(<>
   は必要ありません。「専門用語」セクションを参照のこと)。すなわち:

   修正前:
	# <$>Id: Makefile,v 1.17 1997/06/16 06:39:51 max Exp <$>

   修正後:
	# <$>NetBSD<$>
	# FreeBSD Id: Makefile,v 1.17 1997/06/16 06:39:51 max Exp

 - もし、パッケージがinfoファイルをインストールするのであれば、メインのinfo
   ディレクトリーファイルにこの事実を反映するために更新する必要があります。
   NetBSDではこれを行うためのINFO_FILES定義を持っています。例えば、
   indent.infoをインストールしたことをinfoディレクトリーファイルに反映する
   には、単に

	INFO_FILES=	indent.info

   とパッケージのMakefileに定義してください。もしパッケージにこれを追加する
   ならば、必需品であるGNU texinfoパッケージがあなたのシステムにインストー
   ルされているかどうかを確認するために、USE_GTEXINFOもパッケージのMakefile
   に指定してください。
 - もしあなたが将来の更新のために、そのパッケージをメンテナンスするつもりで
   あれば、MAINTAINERにあなたのメールアドレスをセットしてください。標準では
   MAINTAINERはpackages@netbsd.orgにセットします。FreeBSDの人々はNetBSDのパッ
   ケージについて関心がないと思われます。
 - もし問題のソフトウェアにホームページが存在するのであれば、MAINTAINERの後
   ろにHOMEPAGEを追加してください。HOMEPAGEの値はホームページのURLにしてく
   ださい。

 4.2 files/*
 =========== 

最も重要なことは、このディレクトリーには、パッケージのコンパイルに必要なす
べてのdistfileのmd5チェックサム(必須)が含まれているということです。このファ
イル- files/md5 - は、インターネットから取得したdistfileが悪意によりセキュ
リティーホールを入れられたファイルに変更されていたり、転送中にファイルが壊
れたりしていないことを確認するために、配布ファイルのmd5チェックサムを含んで
います。このファイルは、NetBSDパッケージを作成するために使われたオリジナル
配布ファイルやパッチなどのmd5チェックサムを含んでいます。これはmd5(1)コマン
ドを使うか、"make makesum"により生成することができます。

filesディレクトリーにはまた、そのパッケージのpatches/ディレクトリー(セクショ
ン4.3参照)に入っている、公式なすべてのパッチのチェックサムファイルも入って
います。このチェックサムファイルはpatch-sumといい、パッチ中のNetBSD RCS Id
を除いたすべての行のMD5チェックサムが含まれています。このファイルは"make
makepatchsum"コマンドにより生成することができます。

また、もしあなたがコンフィギュレーションまたは構築するより前に、パッケージ
中に何かファイルを置きたいならば、それらのファイルをfilesディレクトリーに置
くことができますし、pre-configureターゲットで、cpコマンドによりコピーするこ
とができます。あるいは、/dev/nullに対するそのファイルの単純なdiffをとり、パッ
チメカニズムを使用して、そのファイルを生成することもできます。


 4.3 patches/*
 =============

このディレクトリーは、patch(1)コマンドを使用して作られたファイルを含んでい
ます。このファイルは、配布ファイルのソースをNetBSD上で完全にコンパイルして
実行できるように変更するためのものです。これらのファイルは、アルファベット
順(シェルによる"patches/patch-*"展開順)で適用されます。つまりpatch-aaは
patch-abより前に適用されます。

patch-??ファイルはdiff -uフォーマットであるべきです。これは、FreeBSD Ports
のtsarがcontext diffよりもこの形式の方が読みやすいことを見つけたからです。
ですから、もしあなたが同じ流儀でdiffを作れば、あなたのNetBSDパッケージは、
FreeBSD Portsシステムの一部として受け入れられるチャンスが多くなります。

なお、将来の変更が難しくなってしまうので、一つのパッチファイルに、複数のファ
イルへの変更を入れるのは止めてください。

一つ重要なこととして、NetBSD CVSツリーにチェックインした後に問題を引き起こ
すので、パッチファイルにRCS IDを含ませないように注意してください。これを避
けるためには、diffを"-U 2"または"-U 1"オプションで使ってください。

FreeBSD PortsからNetBSDパッケージシステムに持ってくる場合、NetBSD上でもたい
ていFreeBSD Portsが使用できるでしょう。しかしながら、FreeBSDにソフトウェア
を移植した人が、当てにならない__FreeBSD__ cpp defineを使っていないかどうか
チェックしてください。これをする簡単な方法は、パッケージディレクトリーで

	grep -i freebsd patches/patch-??

としてください。

また、オリジナルパッケージ中のMakefileの/usr/localを${PREFIX}に変更するパッ
チを提供するなど、他のFreeBSDイズムにも気をつけてください。

パッケージを作り終えたとき、忘れずに"make makepatchsum"コマンドでパッチファ
イルのチェックサムを生成するようにしてください。セクション4.2を参照してくだ
さい。


 4.4 pkg/*  
 ========= 

このディレクトリーは、バイナリー・パッケージの作成を管理するために使用され
るいくつかのファイルを含んでいます。このディレクトリー内のファイルはバイナ
リー・パッケージに含まれ、他のマシンにインストールされます。したがって、あ
なたが書いたコメントや気のきいた言葉は、あなたが考えるより多くの人々に目に
ふれる事に注意してください。

 4.4.1 必須のファイル
 =====================

 * pkg/COMMENT:
   ソフトウェアについての一行の説明。この中でパッケージの名前を記述する必要
   はありません。- 名前はpkg_*ツールが起動された時に自動的に追加されます。

 * pkg/DESCR:
   ソフトウェアについての複数行の説明。このファイルには適切なクレジットを含
   めておいてください。他人があなたのユーモアのセンス(あるいは変わった綴り)
   を理解してくれない事、そしてここに書かれたものすべてを他人が読むであろう
   という事を念頭においておいてください。

 * pkg/PLIST:
   このファイルは、システムにインストールされるファイルを管理します:すべて
   のバイナリー、マニュアルページ、その他。ディレクトリーの作成、削除、イン
   サートされた(inserted)ファイルの位置を管理するための、他のディレクティブ
   もこのファイルに記述されます。

もし、NetBSDで動作させるために、FreeBSDパッケージを更新しているのであれば、
pkg/PLISTの以下のものに細心の注意を払って下さい:

 - もし、「@exec ldconfig ...」ステートメント、あるいは「@unexec ldconfig ...」
   があれば、それらを削除して下さい。いくつかのNetBSDのアーキテクチャーは
   ldconfigを持っていないので、NetBSDはldconfigをよぶかどうかを自動的に判断
   します。
 - 不足している@dirrmステートメントの追加
 - パッケージのMakefileの中のMAN定義

また、port2pkgパッケージを調べてみてください(pkgsrc/pkgtools/port2pkg)。こ
のパッケージは、あなたのかわりにさまざまな退屈な作業をおこなってくれます。


 4.4.2 オプション・ファイル
 ==========================

 * pkg/INSTALL:
   このシェル・スクリプトはpkg_add実行中に二度起動されます。最初は、パッケー
   ジが展開された後、ファイルが移動される前に、二度目はインストールするファ
   イルが移動された後。このファイルは、PLIST内の@execコマンドでは不可能な特
   別な処理のために使うことができます。より詳細な情報はpkg_add(1)と
   pkg_create(1)を参照してください。

 * pkg/DEINSTALL:
   このスクリプトは、ファイルが削除される前後に実行されます。このスクリプト
   の責任は、パッケージのインスタレーションにかかわる雑多なものをきれいにす
   ることです。なぜなら、pkg_deleteは、オリジナルのディストリビューションで
   作成されたファイルをどのように削除するかをすべて知っておかなければならな
   いからです。より詳細な情報はpkg_add(1)とpkg_create(1)を参照してください。

 * pkg/REQ:
   インストール、アンインストール(de-install)前に、アカウントが存在するかど
   うか、ユーザーあるいはシステム管理者が使用ポリシーに同意するかどうか等を
   確認するために起動される要求スクリプトです。

 * pkg/MESSAGE
   パッケージのインストール後にこのファイルの内容が表示されます。完全にフリー
   でないソフトウェアについての法的な通知等に役立ちます。


 4.5 scripts/*
 =============

このディレクトリーは、ソフトウェア等の設定に必要なファイルを含んでいます。
もし、以下の名前のスクリプトが存在すれば、構築プロセスの適当な時に実行され
ます:

  pre-fetch          post-fetch
  pre-extract        post-extract
  pre-patch          post-patch
  pre-configure      post-configure     configure
  pre-build          post-build
  pre-install        post-install
  pre-package        post-package

構築プロセスについてはセクション7を参照してください。


 4.6 work/*
 ==========

「make」とタイプした時に、配布ファイルがこのディレクトリーに展開されます。
シェル・プロンプトで、以下のようにタイプすれば、これらを削除することができ
ます。

	make clean

また、このディレクトリーはさまざまなタイムスタンプ・ファイルを作っておくた
めにも使用されます。


 4.7 パッケージのCVSへのインポート
 ===================================

新しく作ったパッケージは、「TNF」のベンダータグと「pkgsrc-base」のリリース
タグでインポートしてください。例えば:

	cvs import pkgsrc/<category>/frobnitz TNF pkgsrc-base

FreeBSDポートから派生したパッケージは、「FREEBSD」のベンダータグと
「FreeBSD-current-YYYY-MM-DD」のリリースタグ(YYYY-MM-DDはFreeBSDのツリーか
らポートのスナップショットをとってきた日付)でインポートします。そして、通常
のCVSのオペレーションにより必要は変更をおこなってください。例えば:

	cvs import pkgsrc/<category>/mumbler FREEBSD FreeBSD-current-1998-04-01
	cvs rm patches/patch-a
	cvs add patches/patch-aa
	cvs ci

すべてのパッケージの変更、追加をdoc/pkg-CHANGESに記述してください。このファ
イルを最新の状態に保つことは非常に重要なことです。なぜなら、このファイルは
スクリプトによりwww.netbsd.orgのいくつかのページを自動的に更新するために使
用されているからです。


 5 PLIST*問題
 ============

このセクションでは、PLISTファイル(複数の場合もあります、以下を参照してくだ
さい)を扱う場合に注意が必要な、いくつかの特別な問題について述べます。


 5.1 その他色々
 ==============

 * RCS Id :
   あなたが書いたすべてのPLISTファイルの先頭行にRCS IDが追加されていること
   を確認してください。

	@comment <$>NetBSD<$>

 * ranlib:
   ranlibコマンドをPLISTファイルに記述しないでください。パッケージが削除さ
   れる時にトラブルをひきおこすかもしれません。構築時にだけranlibが実行され
   ること(通常、実行します)を確認してください。そうすれば特に気にする必要は
   ありません。これはFreeBSDポートを流用する時にいつも問題となります。

 * ldconfig:
   ldconfigコマンドをPLISTファイルに記述しないでください。このコマンドは問
   題をひきおこす可能性があります。NetBSDでは、共有オブジェクトのキャッシン
   グは自動的におこなわれます(あなたが、「"Automatic shared object handling」
   メッセージの出力を見た時におこなわれています)。したがって、これに関して
   は気にする必要はありません。もしパッケージの中に共有オブジェクトが見つか
   れば、自動的に処理されます。必要であれば ldconfig を実行し、そうでなけれ
   ば実行しません。これは FreeBSD ポートを流用する時にいつも問題となります。

 * ${MACHINE_ARCH}、${MACHINE_GNU_ARCH}:
   emacs、およびperlのようないくつかのパッケージは、それらが構築されたアー
   キテクチャーに関する情報を、インストールするファイルのパス名に埋め込みま
   す。このようなケースに対応するため、実際に使われる前に、PLISTに前処理が
   おこなわれます。そして、シンボル「${MACHINE_ARCH}」は、「sysctl -n
   hw.machine_arch」の出力でおきかえられます。${MACHINE_GNU_ARCH}がPLISTの
   どこかにうめこまれている場合も同様の事がおこなわれます。これは、GNU
   autoconfigureを使用しているパッケージで使われます。

   昔の話:「<$ARCH>」シンボルは「uname -m」の出力によって置きかえられていま
   した。しかし、もはやサポートされていませんし、削除されています。

 * ${OPSYS}、${OS_VERSION}:
   いくつかのパッケージでは、OS名とバージョンをいくつかのパス名に埋め込みま
   す。このような場合、PLISTで二つの変数を使用してください。${OPSYS}は
   「uname - s」の出力で置きかえられます。${OS_VERSION}には「uname - r」出
   力が設定されます。

 * マニュアルページの圧縮:
   もし、(bsd.own.mkに)MANZが設定されていれば、マニュアルページは圧縮形式で
   インストールされます。そうでなければ展開された形式でインストールされます。
   PLISTファイルでこれをサポートするために、MANXと MANCOMPRESSEDの設定の有
   無に従い、「.gz」サフィックスがマニュアルページに自動的に追加、削除され
   ます。このPLISTファイルに対する変更は、pkg/PLIST自身にたいしてでなく、そ
   れがコピーされる時におこなわれます。


 5.2 MD/MI 対 汎用のPLIST
 ========================

pkg/PLISTのパッケージング・リストは、プラットフォーム間で時々異なります。例
えば、あるプラットフォームが共有ライブラリーをサポートして、それ以外ではサ
ポートしていない場合です。これに対応するために、パッケージのMakefile中で条
件に従い自由にPLISTファイルを定義できるフックが、NetBSDパッケージシステムへ
導入されました。


 5.2.1 $PLIST_SRC
 ================

ひとつ以上のファイルを、バイナリー・パッケージを構築するためにPLISTのソース
として使用する時は、それらのファイル名を変数PLIST_SRCに設定してください。こ
れらのファイルは、後でcat(1)によって連結されます。連結の順番は重要な問題な
ので、以下を参照してください。


 5.2.2 PLIST-mi、PLIST-md.shared、PLIST-md.static
 ================================================

もし、PLIST_SRCが設定されていない(通常の場合)、あるいは、pkg/PLISTが存在し
ない場合、パッケージシステムは、各プラットフォーム間の共有ライブラリーのサ
ポートの有無を吸収するために、pkg/PLIST-mi、pkg/PLIST-md.shared、
pkg/PLIST-md.staticを検索します。PLIST-miは機種独立なファイルを含みます。
PLIST-md*は機種依存のファイルを含んでいます。これは動的ライブラリーと共有ロー
ディングをサポートしていないアーキテクチャー間で異なります。現在、これは
perlのパッケージでのみ使用されています。alpha上のperl5は、まだperl/TKのよう
な拡張された動的ローディングをサポートしていません。PLIST-mi.staticも又、
(pmax、powerpc以外では) alphaで使用されています。perlの動的ローディングが修
正されたら、alphaでは使われなくなるでしょう。

(このMI/MD PLISTファイルの扱いは、PLIST_SRCに「PLIST-mi PLIST-md.static」が
設定されているか、あるいは「PLIST-mi PLIST-md.shared」が設定されているかに
よって異なります。/usr/pkgsrc/mk/bsd.pkg.mkを見て下さい)。


 5.2.3 PLIST* ファイルの順番
 ===========================

@dirrmステートメントの順番については間違いやすいので注意する必要があります。
MD @dirrmディレクティブの後に実行されるMI @dirrmディレクティブは、
PLIST.md-*に記述しなければなりません。これはPLIST-miと
PLIST.md-{shared/static}が、この順番で連結されるためです。もしMIディレクト
リーがPLIST-miにリストされれば、それは、MDディレクトリーの前に削除され、う
まく動作しないでしょう。

例えば、以下のディレクトリーが存在する場合、

        foo/mi
        foo/mi/md

PLIST-miは以下のものを含みます。
        <nothing>

そして、PLIST-md.*は以下のものを含みます。
        @dirrm foo/mi/md
        @dirrm foo/mi

これは、いくつかの@dirrmステートメントの重複をまねくでしょう。しかし、すべ
てが適切に削除されることを保証する唯一の方法です。PLIST_SRCがパッケージ固有
の設定のために使用される場合にも、同じ注意が必要です。


 6 パッケージの修正に関する6つの注意
 ===================================

 6.1 CPP定義
 ===========

アプリケーションをNetBSDに移植するためには、コンパイラーがコンパイルしてい
るシステムを判断する必要があります。したがって、Cのプリプロセッサーがシステ
ムを判断できるように、CPPの定義を使います。

非常に簡単に言うと、多くのFreeBSDポート(NetBSDではパッケージとよばれる)が
CPPの定義__FreeBSD__に依存しています。この定義はFreeBSD固有の仕様のためにだ
け使用すべきですが、残念ながら今はそうなっていません。また多くのFreeBSDポー
トは、CPUがインテルベースのリトルエンディアンという事実に依存しています。

4.4 BSDから派生したシステム上で作業しているかどうかをテストするためには、
BSD定義を使用するべきです。これは<sys/param.h>で定義されています。

        #include <sys/param.h>

また、BSDに固有の部分を、以下の条件でかこむこともできます。

	#if (defined(BSD) && BSD >= 199306)
	...
	#endif

どうか注意して__NetBSD__定義を使って下さい。4.4-liteから派生した他のBSDにな
いNetBSD固有の特徴にのみ適用してください。

美的な観点からすると、__FreeBSD__=1を定義して、単純にFreeBSDポートを使うこ
とは避けるべきです。


 6.2 共有ライブラリー - libtool
 ==============================

NetBSDはさまざまな種類のマシンをサポートします。それらはa.outとELFのような
異なるオブジェクトフォーマットを使い、共有ライブラリー、ダイナミックローディ
ングの有無すらも異なります。これに対応するためにコマンドそのもの、およびオ
プションがコンパイラー、リンカーなどに渡される必要があります。すべてのマシ
ンで正しく動作させることは非常にむずかしく、テストのためにすべてのマシンを
持っていない場合は特にそうでしょう。「libtool」パッケージはこれを助けます。
「libtool」はソースファイルから、静的、動的なライブラリー両方を構築する方法
を知っています。したがって、プラットフォーム独立です。

「libtool」を使うためには、まずlibtool-pkgへの構築依存性を追加してください。
それからライブラリー構築時にlibtoolを使用するように、パッケージのソースを変
更してください。最後に変更の結果をパッチとして、パッケージのpatchesディレク
トリーにおいてください。

以下に、libtoolをパッケージで使用するための7つの手順を記述します。

1. USE_LIBTOOL=yesをパッケージのMakefileへ追加します。

2. ライブラリーオブジェクトのために、${LIBTOOL} --mode=compile ${CC}を${CC}
   に設定します。ライブラリーが、提供されたMakefileだけを使用して構築される
   のであれば、CCの定義にこれを追加するだけです。このコマンドひとつだけで、
   PICと非PICのライブラリーオブジェクトを作成します。したがって、共有ライブ
   ラリーとそうでないライブラリーの構築規則を別々に記述する必要はありません。

3. ライブラリーのリンクのための「ar」、「ranlib」、「ld -Bshareble」コマン
   ドを削除してください。そしてその代わりに以下のコマンドを使用してください。

	${LIBTOOL} --mode=link cc -o ${.TARGET:.a=.la} ${OBJS:.o=.lo} -rpath ${PREFIX}/lib -version-info major:minor

   ライブラリーの拡張子は.laに、オブジェクトの拡張子は.loに変更されることに
   注意してください。OBJSを必要に応じて変更してください。このコマンドは、必
   要なものすべて、.a、.so.major.minor、そしてELFのsymlink (必要なら)を自動
   的にカレントディレクトリーに作成します。

4. インストールする前のライブラリーに依存するプログラムをリンクする時に、cc
   かldの前に「${LIBTOOL} --mode=link」を書いてください。このコマンドは、正
   しいライブラリー(静的、または共有)を見つけます。ただし、libtoolを使う時
   には-Lオプションで相対パスを指定すること(-L../somelibのように)ができない
   ことに注意してください。引数として.laファイルを使うように修正しなければ
   なりません。例えば、

	${LIBTOOL} --mode=link ${CC} -o someprog -L../somelib -lsomelib

   は正常に動作しないので、以下のように変更する必要があります。

	${LIBTOOL} --mode=link ${CC} -o someprog ../somelib/somelib.la

   これで、ライブラリーを正しく扱う事ができます。もし、-Lで相対パスを使用し
   なければならず、インストールする前にこのプログラムを実行しない場合は、リ
   ンクおよびインストールの時にlibtoolを使用しなくてもかまいません。この場
   合、-Lでサブディレクトリー「.libs」を追加してください。

	${CC} -o someprog -L../somelib/.libs -lsomelib

5. ライブラリーをインストールするときに、installあるいはcpコマンドの前に
   「${LIBTOOL} --mode=install」を書いて下さい。そしてライブラリーの名前を
   .laに変えてください。例えば、以下のように書く必要があります。

	${LIBTOOL} --mode=install ${BSD_INSTALL_DATA} ${SOMELIB:.a=.la} ${PREFIX}/lib

   これは、静的リンクのための.a、共用ライブラリー、必要なsymlinkをインストー
   ルし、「ldconfig」を実行します。

6. PLIST の中に、.a、.la、そしてso.major.minorファイルを追加してください。
   ただし、ELFのsymlinkは追加しないでください。これは自動的に作成されます。

すでにlibtoolをサポートしているGNUパッケージのための注意
USE_LIBTOOL=yesをパッケージのMakefileに追加してください。パッケージに含まれ
ているlibtoolをチェックしない、または構成しないように、configureスクリプト
を修正する必要があるでしょう。パッケージのlibtoolを回避する簡単な例は、
libwwwパッケージ、patch-abを参考にしてください。

 6.3 FreeBSDポートに関する注意
 =============================

Makefileの問題(MANx、CATx、MANCOMPRESSED、ldconfig、RCS ID)については4.1を
参照してください。FreeBSDのポートからパッチを流用した場合におこなうべき作業
については4.3を参照してください。

FreeBSDポートの最も大きい問題の1つが、多くのポートが${PREFIX}の設定を無視し
/usr/localにインストールされると仮定されていることです。これを修正するため
に、パッケージのMakefileに以下のような行を追加してください。

pre-configure:
        for f in `find ${WRKDIR} -type f -print|xargs grep -l '/usr/local'`; do
\
                ${SED} -e 's:/usr/local:'${PREFIX}':g' < $$f > $$f.pdone && ${MV} $
$f.pdone $$f; \
        done

これはsysutils/rttyパッケージで使用している方法です。これがあなたのパッケー
ジでも正しく動作することを確認してください。例えば、/usr/localで何かを探す
ことは、実際には意味があるかもしれません。したがって、無条件に/usr/localを
置き換えてはいけません。

FreeBSDは、パッケージのMakefileにマニュアルページを列挙し、PLISTに対応する
エントリーを作らないことに決めました。MAN[1-8ln]の定義を削除する前に、これ
らをPLISTに追加する必要があるでしょう。MLINKSとCAT[1-8ln]エントリーも同様で
す。

PLISTのマニュアルページについての注意: .gzサフィックスについては特に注意を
はらう必要はありません。多くのFreeBSDポートは、実際には圧縮せずにマニュアル
ページをインストールする場合も、PLISTに.gzページをもっていますが、気にしな
くてもかまいません。我々は、MANZに従い.gzサフィックスを追加します。つまり、
PLISTのマニュアルページの名前が.gzサフィックスを持っているかどうかは重要で
はありません。もし、それが必要であれば自動的に追加されるし、不必要な.gzサ
フィックスがあれば自動的に削除されるでしょう。

いくつかのパッケージは、構築時にbsdスタイルの.mkファイルを使用します。した
がってMANZが設定されていれば、インストールされるマニュアルページはgzipで圧
縮されます。もし、MANZが設定されていなければ圧縮しません。もしパッケージが
bsdスタイルの.mkファイルを使う場合は、Makefileの中で変数
MANCOMPRESSED_IF_MANZにyesを設定してください。


 6.4 作者へのフィードバック
 ==========================

もしパッケージの不具合を発見し動作するように修正した場合、NetBSD上で動作さ
せるために特別な手順が必要だった場合、あるいはさまざまなソフトウェアの拡張
をおこなった場合、これらの修正をプログラムのオリジナルの作者へ報告してくだ
さい。このようなサポートによってのみ、プログラムの次のリリースにそれらの修
正を反映することができます。そして、NetBSDパッケージシステムを使用していな
い人々も、あなたの努力でのおかげで幸せになれます。

フリー・ソフトウェアの理念をサポートして下さい。


 7 構築の手順
 ============

プログラムを構築するための基本的な手順は常に同じです。最初に、プログラムの
ソースファイル(distfile)をローカル・システムへ持ってきて展開します。NetBSD
上でコンパイルするためのいくつかのパッチを適用した後に、ソフトウェアを設定
し、構築(通常、コンパイルすることによって)します。最後に作成されたバイナリー
等を、システムにインストールします。これはまさにNetBSDパッケージ・システム
によって実行される手順です。この手順は、中心となるMakefile、
/usr/pkgsrc/mk/bsd.pkg.mkの中で一連のターゲットとして実装されています


 7.1 プログラムの場所
 ====================

次のセクションでNetBSDパッケージ・システムによって実行される手順の概略を述
べる前に、プログラムがインストールされる場所、その場所に影響をおよぼす変数
について簡単に記述します。

自動変数PREFIXは、最終的にプログラムのすべてのファイルがインストールされる
場所をしめします。通常、$LOCALBASE (/usr/pkg)、または「クロス」カテゴリーの
パッケージのための$CROSSBASEと同じ場所になっています。もしUSE_IMAKE、
USE_MOTIF、あるいはUSE_X11BASEが定義されていれば、その値は$X11BASEと同じに
なります。${PREFIX}の値は、プログラムのソース中でこれらのファイルが符号化さ
れるさまざまな場所に使用されるべきです。詳細に関しては、セクション4.3および
6.2を参照して下さい。

これらの変数のどれかを選択し使用する場合には、以下のルールに従ってください。

 * ${PREFIX}は常に現在のパッケージがインストールされる場所を指します。パッ
   ケージ自身のインストール先のパスを参照する時に、${PREFIX}を使用してくだ
   さい。

 * ${LOCALBASE}は、すべての非X11パッケージがインストールされる場所です。他
   の非X11パッケージによってインストールされたインクルードファイルやライブ
   ラリーの場所をさがすためのコンパイラーの-Iや-Lオプションを指定する場合に、
   ${LOCALBASE}を使用してください。

 * ${X11BASE}は、実際にX11ディストリビューションがインストールされる場所で
   す。通常のX11のインクルードファイル(パッケージとしてインストールされてい
   ない)をさがす場合、${X11BASE}を使用してください。

 * X11ベースのパッケージは特別です。/etc/mk.confの設定によっては、X11BASE、
   またはLOCALBASEに依存するかもしれません。もし、USE_IMAKEやUSE_MOTIF、
   USE_X11BASEをMakefileで定義したpkgとしてインストールされたインクルードファ
   イルやライブラリーをさがす場合、${X11BASE}と${LOCALBASE}の両方を使用する
   必要があります。


 7.2 主なターゲット
 ==================

bsd.pkg.mkで定義された、構築手順で使用される主なターゲットについて述べます。

 * fetch:
   これは、変数DISTFILESとPATCHFILES (パッケージのMakefileで定義された)で指
   定されたファイルが、ローカルシステムの/usr/pkgsrc/distfilesに存在するか
   どうかをチェックします。もし、存在しなければ、変数PATCH_SITEで指定された
   サイトから、ftp(1)を使用し取得します。PATCH_SITEはURLの形式で、ftp://-、
   およびhttp://-が使用できます。これは、ftp(1)が両方の形式を解釈できるから
   です。

 * checksum:
   distfileを取得した後に、MD5チェックサムを生成し、files/md5ファイルに保存
   されたチェックサムと比較します。もし、チェックサムが一致しなければ、構築
   は中断されます。これはパッケージ作成時と同じdistfileが、構築に使用されて
   いること、つまり、悪意やネットワークの損失によってdistfileが変更されてい
   ないことを保証するためです。

 * extract:
   distfileがローカルシステム上に存在している場合、通常、それらは圧縮アーカ
   イブフォーマットで保存されているので、展開する必要があります。もっとも一
   般なフォーマットは.tar.gzです。もし、すべてのdistfileを伸張する必要がな
   いのであれば、伸張するファイルをEXTRACE_ONLYに設定してください。もし
   distfileが.tar.gzフォーマットでなければ、EXTRACT_CMD、EXTRACT_CMD、
   EXTRACT_BEFORE_ARGS、そしてEXTRACT_AFTER_ARGSを設定することにより、それ
   らを展開することができます。

 * patch:
   展開の後で、PATCHFILESで指定されたパッチとパッケージのパッチサブディレク
   トリーに存在するパッチ、すべてが適用されます。.Z、あるいは.gzで終る名前
   のパッチファイルは、適用する前に伸張されます。.orig、.rejで終るものは無
   視されます。patch(1)のためのいくつかのオプションは、PATCH_DIST_ARGSで指
   定する事ができます。詳細に関してはセクション4.3を参照して下さい。

 * configure:
   ほとんどのソフトウェアは、NetBSDで利用できるヘッダーファイル、システムコー
   ル、およびライブラリールーチンについての情報を必要とします。これはコンフィ
   ギュレーションとして知られているプロセスであり、通常、自動化されています。
   大抵の場合、スクリプトがソースと一緒に提供され、それを実行することにより
   ヘッダーファイルやMakefile等が生成されます。

   プログラムがコンフィギュレーションのためのスクリプトを提供していない場合、
   パッケージのスクリプトディレクトリーにconfigureという名前のスクリプトを
   置くことができます。そして、それはsh(1)によって実行されます。

   もし、プログラムのdistfileが専用のconfigureスクリプトを含んでいる場合、
   HAS_CONFIGUREを設定することにより、実行することができます。もし、そのス
   クリプトがGNUのautoconfスクリプトである場合は、かわりに、GNU_CONFIGUREを
   指定してください。どちらの場合も、configureスクリプトの引数は、変数
   CONFIGURE_ARGSで指定されます。もし設定スクリプトの名前がデフォルトの
   configureでない場合は、その名前をCONFIGURE_SCRIPTに設定してください。

   もし、プログラムがコンフィギュレーションのためにImakefileを使用するので
   あれば、USE_IMAKEをYESに設定することにより、適切な手順が実行されます。
   (もし、$X11BASEにインストールされるパッケージが欲しいだけで、xmkmfを実行
   したくない場合、かわりにUSE_X11BASEを使用してください!)

 * build:
   コンフィギュレーションが終ったら、$MAKEFILEの中で、構築のターゲットとし
   て$ALL_TARGETを指定し$MAKE_PROGRAMを起動することにより、NetBSD上にソフト
   ウェアを構築することができます。もし、USE_GMAKEが設定されていれば、デフォ
   ルトのMAKE_PROGRAMは「gmake」です。そうでなければ、makeが使用されます。
   MAKEFILEにはデフォルトでMakefileが設定されます。そして、ALL_TARGETのデフォ
   ルトはallです。デフォルトの構築手順を変更するために、これらの変数を設定
   することができます。

 * install:
   構築の段階が完了すると、ユーザーのためにソフトウェアをパブリックなディレ
   クトリーにインストールする必要があります。buildターゲットと同様に、
   $MAKE_PROGRAMが$MAKEFILE中で起動されます。ただし、$INSTALL_TARGETが指定
   されます。この変数のデフォルトは「install」です。(もしUSE_IMAKEが設定さ
   れていれば、「install.man」も追加されます)。

   もし、ターゲットが指定されなければ、デフォルトは「build」です。手順の途
   中のターゲットが指定された場合、それ以前のすべての手順が実行されます。例
   えば「make build」は、以下と同等のことを実行します。

	make fetch
        make checksum
	make extract
	make patch
	make configure
	make build


 7.3 他の役に立つターゲット
 ==========================

 * pre/post-*
   前のセクションで述べた主ターゲットのために、二つの補助ターゲットが存在し
   ます。これは主ターゲットに「pre-」や「post-」というプレフィックスをつけ
   たものです。これらのターゲットは、特別な設定やインストール手順のために、
   主ターゲットが実行される前や後に実行されます。例えば、プログラムのコンフィ
   ギュレーションスクリプトやインストールターゲットが省略された場合に有用で
   す。これらのターゲットのために、同名のスクリプトをパッケージのスクリプト
   用のサブディレクトリーに置くことができます。セクション4.5を見て下さい。

 * do-*:
   主なターゲットがおかしな動作をし、それを修正するための変数が存在しない場
   合、do-*ターゲットを使用することにより、それらを再定義することができます
   (do-*ターゲットのかわりに、ターゲット自体を再定義してはいけません。pre-*
   やpost-*ターゲットが実行されなくなってしまいます)。通常、再定義する必要
   はありません。

 *reinstall:
   もし、「make install」実行後に、いくつかのファイルがきちんとインストール
   されなかった事に気がついた場合、このターゲットを使い、再びインストールす
   る事ができます。この場合、「インストール済み」フラグは無視されます。

 * deinstall:
   このターゲットは、パッケージを削除するためにカレントディレクトリーで
   pkg_delete(1)を実行します。動作を制御するために、以下の変数をコマンドラ
   イン、または/etc/mk.confで使用することができます。

    - PKG_VERBOSE:
      pkg_delete(1)コマンドに「-v」オプションを渡します。

    - DEINSTALLDEPENDS:
      指定されたパッケージに必要な(依存する)すべてのパッケージを削除します。
      このターゲットは、指定されたパッケージによってインストールされたパッ
      ケージを削除するために使用されます。例えば、DEINSTALLDEPENDS=1が
      x11/kdeで指定されている場合、KDE全体を削除します。pkg_deleteのコマン
      ドラインに-Rを指定すると設定されます。

 *update:
   このターゲットは、現在のパッケージを最新のものに更新します。最初にパッケー
   ジと、それに依存するすべてのパッケージを削除します。それから最新のバージョ
   ンのパッケージをコンパイル、インストールします。これは、現在どのパッケー
   ジがインストールされているかを調べ、「make deinstall」、「make clean」、
   「make install」を続けて実行するのと同じです。

   以前に実行した「make uddate」がさまざまな理由で中断された場合、パッケー
   ジの更新のために、このターゲットを使用することができます。ただし、「make
   clean」を実行していない事、あるいは${WRKDIR}の依存パッケージのリストを削
   除していない事を確認してください。そうでなければ、インストール済みの依存
   パッケージを使用し、現在のパッケージを自動更新することができません。

   「make update」の動作を変更するために、以下の変数をコマンドライン、また
   は/etc/mk.confで使うことができます。

    - DEPENDS_TARGET:
      更新されたパッケージや依存パッケージのために使用されるインストールター
      ゲット。デフォルトは「install」です。例えば、「make update
      DEPENDS_TARGET=package」のように使用します。

    - NOCLEAN:
      更新した後、きれいに掃除をしません。調査やその他の目的のために、更新
      されたパッケージの作業用ソース等をそのままにしておきたい場合に役に立
      ちます。最終的にはソースツリーを掃除してください(以下の
     「clean-update」ターゲットを見てください)。そうしなければ、次回の
     「make」や「make update」の時に古いソースコードが残っていることで
      トラブルがおこるかもしれません。

    - REINSTALL:
      すべてのパッケージを更新する場合は、${DEPEND_TARGET}でなく「reinstall」
      を使用してください。この変数を使用する時には、「reinstall」ターゲット
      が使用される事を覚えておいてください。

 *clean-update:
   カレントディレクトリーで「make update」が実行された時に更新されるすべて
   のパッケージのソースツリーを掃除します。カレントパッケージ(あるいは、依
   存パッケージ)がすでに削除されている(例えばmake updateを実行した後)場合に
   は、このターゲットを使ってはいけません。もし使用すると、更新するつもりの
   パッケージのいくつかを失う可能性があります。経験的には、初めて「make
   update」を実行する前、あるいは汚れたパッケージツリーがある場合(例えば
   NOCLEANを使用した場合)にのみ使用すべきです。「make clean-update」の動作
   を変更するために、以下の変数をコマンドライン、または/etc/mk.confで使うこ
   とができます。

    - CLEAR_DIRLIST:
      「make clean」の後で、パッケージのためのディレクトリーのリストを再構
      築しません。「make update」で、更新したいすべてのパッケージがインストー
      ルされた場合にのみ使用してください。通常、これは「make update」で自動
      的に実行されます。ただし、NOCLEAN変数の設定によって実行されない事もあ
      ります(上を参照してください)。

 * readme:
   このターゲットは、README.htmlファイルを作成します。このファイルは
   netscape (pkgsrc/www/mozilla)やlynx (pkgsrc/www/lynx)のようなブラウザー
   で閲覧することができます。作成されたファイルは、ローカルホストの
   ${PACKAGES}ディレクトリーにあるパッケージへの参照を含んでいます。また、
   FTP_PKG_URL_HOSTとFTP_PKG_URL_DIRを元にしたURLを参照させることもできます。
   (例えば、ローカルマシン上の/usr/packagesディレクトリーのバイナリー・パッ
   ケージを参照するREADME.htmlファイルを作成したい場合、
   FTP_PKG_URL_HOST=file://localhostとFTP_PKG_URL_DIR=/usr/packagesをセット
   してください。${PACKAGES}ディレクトリーと、そのサブディレクトリーはすべ
   てのバイナリー・パッケージで検索されます。

 * readme-all:
   このターゲットを使い、README-all.htmlを作成することができます。このファ
   イルはNetBSDパッケージコレクションの中の、現在利用可能なすべてのパッケー
   ジのリスト、また、それらが属するカテゴリーと簡単な説明を含んでいます。こ
   のファイルはpkgsrc/*/README.htmlから作りだされます。したがって、「make
   readme」の後に、このターゲットを実行してください。

 * cdrom-readme:
   これはreadmeターゲット(上を見てください)とほとんど同じですが、CD-ROMに焼
   かれるpkgsrcツリーを作る時に使われます。また、このターゲットは
   README.htmlファイルを作成し、CDROM_PKG_URL_HOSTとCDROM_PKG_URL_DIRに基づ
   くURLへの参照を作ります。

 * show-distfiles:
   このターゲットは、パッケージを構築するために、どのdistfileやパッチファイ
   ルが必要かを表示します。

 * show-downlevel:
   このターゲットは、パッケージがインストールされていない場合は何も表示しま
   せん。もし、あるバージョンのパッケージがインストールされているが、現在の
   pkgsrcのバージョンでインストールされたものでない場合、警告メッセージを表
   示します。このターゲットは、インストール済みのパッケージが古いバージョン
   であり、そのバージョンが削除可能で、最新の物が追加されることを表示するた
   めに使用されます。


 8 デバッグ
 ==========

FreeBSDのportからパッケージを作成する時に落ちいりやすい間違いをチェックし、
パッケージを動作させるための手順があります。これは基本的には前のセクション
で説明したことと同じですが、デバッグを助けるための方法を追加しています。

 - FreeBSDコレクションからportをさがしてください。
 - パッケージのMakefile中のRCS-IDを修正してください。
   セクション4.1を参考にしてください。
 - 未変更のFreeBSDのソースをインポートしてください(cvsアクセスが可能な場合
   だけおこなってください。そうでない場合は必要ありません)。(cd ...
   /pkgsrc/category/pkgname ; cvs import pkgsrc/category/pkgname \
	FREEBSD FreeBSD-current-yyyy-mm-dd)
 - CVSにインポートしたら、以下の修正が必要かどうか調べて下さい
   (CVSにアクセスできなければ必要ありません)。
 - 必要ならMakefileを修正してください。セクション4.1を参考にしてください。
 - パッチが適切かどうか確認してください。
 - すべてのpkg/PLISTの先頭行「@comment <$>NetBSD<$>」という行を追加してくだ
   さい(セクション5を参考にしてください)。
 - make
 - もし何かがうまくいかなければ、修正してください。パッチを作成するために、
   ファイルの修正後にdiffを再生成してください。
   「diff -bu foo.orig foo > ../../patch-xx」(作業する前に、mv patch-xx
   patch-xx.origしておいてください)もし、前のパッチでfoo.origが作成されない
   場合でも、必ず、どこかにそのファイルの古いバージョンを持っていて下さい。
   この作業を繰り返してください。:)
- 構築がすべてOKならtouch/tmp/blaして下さい。
 - make install
 - find /usr/pkg/ /usr/X11R6/ -newer /tmp/bla >/tmp/x
   (又は、LOCALBASEやX11BASEを設定したすべてのディレクトリーを対象として)
 - pkg_delete blub
 - find /usr/pkg/ /usr/X11R6/ -newer /tmp/bla
   もし、なにかファイルが見つかれば、それらはpkg/PLIST*に不足しているので、
   追加してください。
 - pkg/PLIST* と /tmp/x を比較し、前者を修正してください。
   ( sort /tmp/x >/tmp/x2 ; sort pkg/PLIST >/tmp/P ; sdiff /tmp/x2 /tmp/P )
 - make reinstall && make package
 - pkg_delete blub  
 - 「find /usr/pkg/ /usr/X11R6/ -type f -newew /tmp/bla」を実行し、何も見つ
   からないことを確認してください。
 - pkg_add .../blub.tgz  
 - 遊んでみてください。:)
 - pkg_delete - 今までと同様に、いかなるファイルも残っていてはいけません。
  (もう一度、上記のfind を実行してください)。
 - 提出してください(もし cvs アクセス可能であればコミットしてください)。
   セクション 10 が参考になります。


 9 FAQとパッケージシステムの特徴
 ===============================

 9.1 GNU autoconfigを利用するパッケージ
 ======================================

もしパッケージがGNU autoconfを使うのであれば、パッケージのMakefileに以下の
設定を追加してください。

> GNU_CONFIGURE= yes

この設定がCONFIGURE_ARGSに--prefix=${PREFIX}を追加することに注意してくださ
い。したがって、あなた自身でこれを追加する必要はありません。そして、これは
あなたの望む設定とは異なるかもしれません。


 9.2 tar.gz 以外の配布方法
 =========================

パッケージがtar.gz以外の方法で配布されている場合、plan9/samパッケージを参考
にしてください。これはgzipされたシェルアーカイブ(shar)を使っています。いち
おう簡単に説明すると、DISTNAMEフィールドの後でEXTRACT_SUFXに名前を設定し、
パッケージのMakefileに以下の設定を追加してください。

> EXTRACT_SUFX=   .msg.gz
> EXTRACT_CMD=            zcat
> EXTRACT_BEFORE_ARGS=
> EXTRACT_AFTER_ARGS=     |sh


 9.3 それ自身のサブディレクトリーを作り出さないパッケージ
 ========================================================

パッケージが例えばGNUソフトウェアのようにサブディレクトリーを作るのではなく、
カレントディレクトリーに展開される場合、もう一度plan9/samを見てください。簡
単にいうと以下の設定が必要です。

> NO_WRKSUBDIR=   yes


 9.4 カスタムコンフィギュレーションプロセス
 ==========================================

パッケージが、かわったConfigureスクリプトを使用している場合、topのパッケー
ジを参照してください。簡単にいえば、以下の設定をおこなってください。

> HAS_CONFIGURE=          yes
> CONFIGURE_SCRIPT=       Configure
> CONFIGURE_ARGS+=        netbsd13


 9.5 DISTNAMEディレクトリーで作成されないパッケージ
 ==================================================

パッケージが、DISTNAMEをベースにしないディレクトリーで構築される場合、tcl、
およびtkパッケージを参考にしてください。

> WRKSRC=         ${WRKDIR}/${DISTNAME}/unix


 9.6 一度にすべてのdistfilesを取得する方法
 =========================================

「make fecth」を実行できない職場や大学において、一回のバッチ処理で、すべて
のdistfilesをダウンロードしたいと思うことがあるかもしれません。しかしながら、
ftp.netbsd.orgにはdistfilesのアーカイブはありません。そしてftp.freebsd.org
上にあるアーカイブは、移植されていない多くのdistfilesを含んでいます。

現時点では、「make fetch-list」を/usr/pkgsrcで実行し、その結果のリストを使
用してくださいとしかいえません、


 9.7 防火壁の内側からファイルを取得する方法
 ==========================================

もし、あなたが防火壁の内側にいる場合、防火壁の内側にないインターネット上の
他のマシンとの通信をおこなうために、適切なプロキシーホストを指定する必要が
あります。これはURL形式の環境変数で指定します。例えば、Amdahlドメインにおい
ては、orpheus.amdahl.comというマシンは防火壁のひとつで、プロキシーポート番
号として、80番のポートを使用します。この場合、proxy環境変数は以下のようにな
ります。

	ftp_proxy=ftp://orpheus.amdahl.com:80/
	http_proxy=http://orpheus.amdahl.com:80/


 9.8 パッチがRCS IDを含む場合
 ============================

パッチからRCS IDを削除する方法については、セクション4.3を参照してください。


 9.9 /etc/mk.confから変数を捕まえる方法
 ======================================

MAKECONFや/etc/mk.confで上書き可能な、パッケージで定義された変数には問題が
あります。それは、変数はmake(1)がそれを使う時に展開されるが、プリプロセッサー
風の文(.if、.ifdefそして.ifndef)は読み込み時に評価される事です。したがって、.
if*文内で変数(/etc/mk.confでセットされる可能性のある)を使う時は、その.if*ス
テートメントの前に/etc/mk.confをインクルードしておかなくていけません。

/etc/mk.confやMAKECONFが存在したら、それらをインクルードするというad-hocな
方法をとらずに、すべてのプリプロセッサー風の.if、.ifdef、または.ifndef文の
前で、pkgsrc/mk/bsd.prefs.mkをインクルードしてください。

	.include "../../mk/bsd.prefs.mk"

	.if defined(USE_MENUS)
	...
	.endif


 9.10 pkgについて話しあうためのメーリングリストはありますか?
 ===========================================================

はい。パッケージに関する問題を議論するためにtech-pkg@netbsd.orgが存在します。
購読するためには以下のようにして下さい。

    echo subscribe tech-pkg | mail majordomo@netbsd.org


 9.11 どうすれば「make fetch」でpassive FTPを使用することができますか?
 =====================================================================

/etc/make.confに以下の設定を追加してください。PASSIVE_FETCH=1


 9.12 他のパッケージへの依存
 ===========================

パッケージは他のパッケージに依存するかもしれません。そして、この依存性を定
義するためのいろいろな方法があります。NetBSDはBUILD_DEPENDS、RUN_DEPENDS、
DEPENDS定義をサポートしています(注意: DEPENDS定義はFreeBSDのものと同じでは
ありません。NetBSDはFreeBSDのLIB_DEPENDS定義をもはや使用していません。ELF化
されたNetBSDのプラットフォーム上で問題が発生することがわかりました)。

[以下の例において、BUILD_DEPENDSおよびRUN_DEPENDSには、決められたフォーマッ
トがあります。:<ファイル>:<作成するパッケージのディレクトリー> [:<段階>]。
もし、<段階>が指定されていなければ、「install」がデフォルトとなります。ファ
イルが「/」を含む場合、それは通常ファイルとして解釈されます。そうでない場合
は、実行可能ファイルとしてあつかわれ、<ファイル>をさがすためにPATHが調べら
れます。もし、通常ファイルが見つからない、あるいは実行可能ファイルがパス内
に存在しなければ、必要なパッケージが<作成するパッケージのディレクトリー>内
のソースから作成されます。DEPENDS定義はパッケージ名(バージョン番号を含む)と、
そのバージョンのパッケージがインストールされていない場合のために、作成する
パッケージのディレクトリーを指定します。]

(a) パッケージを作成するために他のパッケージのファイルを必要とするなら、
print/ghostscript5パッケージを参考にしてください。(作成中にjpegのソースが存
在することを前提としています)

BUILD_DEPENDS=	../../graphics/jpeg/${WRKDIR:T}/jpeg-6a:../../graphics/jpeg:extract

(b) パッケージを構築するために他のパッケージが必要なら、BUILD_DEPENDS定義を
使ってください。ただし、上の説明とは異なり、「:extract」を指定してはいけま
せん。print/lyxがよい例です。このパッケージは構築中にlatexのバイナリーを使
用します。

BUILD_DEPENDS=	latex:../../print/teTeX

(c) もし、パッケージがリンクのためのライブラリーを必要とするなら、DEPENDS定
義を使ってください。たとえば、print/lyxパッケージは、作成のためにxpmライブ
ラリーのバージョン3.4jを使用します。

DEPENDS+=	xpm-3.4j:../../graphics/xpm

また、パッケージ依存関係にはワイルドカードを使うことができます。

DEPENDS+=	xpm-*:../../graphics/xpm

ワイルドカードは、バイナリー・パッケージを作る時に展開されることに注意して
ください。したがって、バイナリー・パッケージは、作成時にインストールされて
いたライブラリーのバージョンに依存します。

(d) もし、パッケージを実行するために、いくつかの実行可能ファイルが必要なら、
RUN_DEPENDS定義を使ってください。print/lyxパッケージを実行する時には、latex
とispellのバイナリーが実行可能でなければなりません。これは、以下のように指
定します。

RUN_DEPENDS=    latex:../../print/teTeX \
                ispell:../../textproc/ispell


 9.13 他のパッケージとの衝突
 ===========================

パッケージは、すでにインストール済みの別のパッケージと衝突する可能性があり
ます。例えば、パッケージが、pkgsrcの中の別のパッケージと同じファイルをイン
ストールするような場合です。

この場合、衝突するパッケージ(バージョン文字列を含む)のリストをスペースで区
切ってCONFLICTSにセットすることができます。

例えば、pkgsrc/x11/Xaw3dおよびpkgsrc/x11/Xaw-Xpmは同じ共有ライブラリーをイ
ンストールします。したがって、pkgsrc/x11/Xaw3d/Makefileに以下のような設定を
おこなってください。

CONFLICTS=      Xaw-Xpm-*

そして、pkgsrc/x11/Xaw-Xpm/Makefileには以下の設定が必要です。

CONFLICTS=      Xaw3d-*

パッケージは、名前のプレフィックスが同じで、異なるバージョン文字列をもつ別
のパッケージと自動的に衝突します。例えば「Xaw3d-1.5」は、古いバージョンの
「Xaw3d-1.3」と衝突するでしょう。

 9.14 WWWホームページがあるソフトウェア
 ======================================

NetBSDパッケージシステムは、HOMEPAGE変数をサポートしています。もし、パッケー
ジ化されたソフトウェアのホームページが存在するのであれば、そのページのURLを
MakefileのHOMEPAGE変数に設定するべきです。この変数はMAINTAINER変数のすぐ後
に定義してください。


 10 提出
 =======

 *コンパイル済みのバイナリー・パッケージ:
  我々は、トロイの木馬等を含まないことを保証するために、NetBSD開発者からし
  かバイナリーを受け取りません。これは、誰かを糞ったれ扱いするものではなく、
  むしろユーザーを保護するための方針です。しかしながら、あなたの作ったバイ
  ナリー・パッケージをどこかに置き、配布することは自由に行なってもかまいま
  せん。

 *パッケージ:
  最初にパッケージが完全かどうか、コンパイル、実行できるかどうかを確認して
  ください。このドキュメントのセクション8、その他を参考になるでしょう。次に、
  パッケージに必要なすべてのファイルのgzipされたtarファイルを作成してくださ
  い。これは、すべてのファイルをひとつのディレクトリーにおきたいためです。
  次に、そのtarファイルを、パッケージのメンテナーがFTPかHTTP (WWW)を使用し
  て取得できる場所においてください。最後に、パッケージの名前とバージョンを
  含む概要、簡単な説明(pkg/COMMENTの内容でもOKです)、そしてtarファイルのURL
  を書き、「pkg」カテゴリーでsend-pr (問題報告)をおこなってください。

  問題報告が処理されたら、あなたに連絡がいきます。そうすれば、tarファイルを
  削除してもかまいません。


 11 パッケージの簡単な例: bison
 ==============================

私は、FreeBSDのポート(ports)にないソフトウェアをさがし、GNU bisonを選びまし
た。バークレーのyaccがすでにソースツリーに存在するので、bisonを使いたい人は
いないでしょう。しかし、練習という意味では役にたちます。


 11.1 ファイル
 =============

このセクションのファイルの内容は、実際には「> 」というプレフィックスなしで
使用してください。


 11.1.1 Makefile
 =============== 

> # <$>NetBSD<$>
>  
> DISTNAME=       bison-1.25
> CATEGORIES=     devel
> MASTER_SITES=   ${MASTER_SITE_GNU}
>
> MAINTAINER=     thorpej@netbsd.org
> HOMEPAGE=       http://www.gnu.org/software/bison/bison.html
>  
> GNU_CONFIGURE=  yes
> INFO_FILES=     bison.info
>  
> .include "../../mk/bsd.pkg.mk"


 11.1.2 pkg/COMMENT
 ================== 

> GNU yacc clone.


 11.1.3 pkg/DESCR
 ================ 

> GNU version of yacc.  Can make re-entrant parsers, and numerous other
> improvements.  Why you would want this when Berkeley yacc(1) is part
> of the NetBSD source tree is beyond me.


 11.1.4 pkg/PLIST
 ================ 

> @comment <$>NetBSD<$>
> bin/bison
> man/man1/bison.1.gz
> @unexec install-info --delete %D/info/bison.info %D/info/dir
> info/bison.info
> info/bison.info-1
> info/bison.info-2
> info/bison.info-3
> info/bison.info-4
> info/bison.info-5
> @exec install-info %D/info/bison.info %D/info/dir
> share/bison.simple
> share/bison.hairy


 11.1.5 パッケージをチェックする 「pkglint」
 ==========================================

NetBSDパッケージシステムは、「pkglint」(pkgsrc/pkgtools/pkglintディレクトリー
にあります)とよばれるツールを含んでいます。このツールはこれらのファイルの内
容をチェックするのを助けてくれます。一度インストールしてしまえば、このツー
ルは非常に簡単に使うことができます。検査したいパッケージのディレクトリーに
移動し、「pkglint」を実行するだけです。

> tron@lyssa:/usr/pkgsrc/devel/bison>pkglint
> OK: checking pkg/COMMENT.
> OK: checking pkg/DESCR.
> OK: checking Makefile.
> OK: checking files/md5.
> OK: checking patches/patch-aa.
> looks fine.

指定されたコマンド行の引き数(「man pkglint」を見てください)によっては、より
きびしいチェックがおこなわれます。例えば「pkglint -a -v」は、大変詳細かつ冗
長なチェックをおこないます。


 11.2 構築、インストール、パッケージングの手順
 =============================================

パッケージのためのディレクトリーと、いくつかの追加のディレクトリーを作成し
ます。

> root@pumpy:/u/pkgsrc/lang(1765)# cd /usr/pkgsrc/lang
> root@pumpy:/u/pkgsrc/lang(1765)# mkdir bison
> root@pumpy:/u/pkgsrc/lang(1766)# cd bison
> root@pumpy:/u/pkgsrc/lang/bison(1768)# mkdir files patches pkg

セクション11.1のようにMakefile、pkg/COMMENT、pkg/DESCR、およびpkg/PLISTを作
り、distfileを取得します。

> root@pumpy:/u/pkgsrc/lang/bison(1769)# make fetch
> >> bison-1.25.tar.gz doesn't seem to exist on this system.
> >> Attempting to fetch from ftp://prep.ai.mit.edu/pub/gnu//.
> Requesting ftp://prep.ai.mit.edu/pub/gnu//bison-1.25.tar.gz (via ftp://orpheus.amdahl.com:80/)
> ftp: Error retrieving file: 500 Internal error
>  
> >> Attempting to fetch from ftp://wuarchive.wustl.edu/systems/gnu//.
> Requesting ftp://wuarchive.wustl.edu/systems/gnu//bison-1.25.tar.gz (via ftp://orpheus.amdahl.com:80/)
> ftp: Error retrieving file: 500 Internal error
>  
> >> Attempting to fetch from ftp://ftp.freebsd.org/pub/FreeBSD/distfiles//.
> Requesting ftp://ftp.freebsd.org/pub/FreeBSD/distfiles//bison-1.25.tar.gz (via ftp://orpheus.amdahl.com:80/)
> Successfully retrieved file.

distfileのチェックサムをfiles/md5へ作成します。

> root@pumpy:/u/pkgsrc/lang/bison(1770)# make makesum

コンパイルします。

> root@pumpy:/u/pkgsrc/lang/bison(1777)# make
> >> Checksum OK for bison-1.25.tar.gz.
> ===>  Extracting for bison-1.25
> ===>  Patching for bison-1.25
> ===>   Ignoring empty patch directory
> ===>  Configuring for bison-1.25
> creating cache ./config.cache
> checking for gcc... cc
> checking whether we are using GNU C... yes
> checking for a BSD compatible install... /usr/bin/install -c -o bin -g bin
> checking how to run the C preprocessor... cc -E
> checking for minix/config.h... no
> checking for POSIXized ISC... no
> checking whether cross-compiling... no
> checking for ANSI C header files... yes
> checking for string.h... yes
> checking for stdlib.h... yes
> checking for memory.h... yes
> checking for working const... yes
> checking for working alloca.h... no
> checking for alloca... yes
> checking for strerror... yes
> updating cache ./config.cache
> creating ./config.status
> creating Makefile
> ===>  Building for bison-1.25
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g LR0.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g allocate.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g closure.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g conflicts.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g derives.c
> cc -c -DXPFILE=\"/usr/pkg/share/bison.simple\"  -DXPFILE1=\"/usr/pkg/share/bison.hairy\" -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1  -g  ./files.c 
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g getargs.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g gram.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g lalr.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g lex.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g main.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g nullable.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g output.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g print.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g reader.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g reduce.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g symtab.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g warshall.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g version.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g getopt.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g getopt1.c
> cc  -g -o bison LR0.o allocate.o closure.o conflicts.o derives.o files.o         getargs.o gram.o lalr.o lex.o                                   main.o nullable.o output.o print.o reader.o reduce.o symtab.o   warshall.o version.o                        
                    getopt.o getopt1.o  
> ./files.c:240: warning: mktemp() possibly used unsafely, consider using mkstemp()
> rm -f bison.s1
> sed -e "/^#line/ s|bison|/usr/pkg/share/bison|" < ./bison.simple > bison.s1

すべてOKのようなので、ファイルをインストールします。

> root@pumpy:/u/pkgsrc/lang/bison(1785)# make install
> >> Checksum OK for bison-1.25.tar.gz.
> ===>  Installing for bison-1.25
> sh ./mkinstalldirs /usr/pkg/bin /usr/pkg/share  /usr/pkg/info /usr/pkg/man/man1
> rm -f /usr/pkg/bin/bison
> cd /usr/pkg/share; rm -f bison.simple bison.hairy
> rm -f /usr/pkg/man/man1/bison.1 /usr/pkg/info/bison.info*
> install -c  -o bin -g bin -m 555 bison /usr/pkg/bin/bison
> /usr/bin/install -c -o bin -g bin -m 644 bison.s1 /usr/pkg/share/bison.simple
> /usr/bin/install -c -o bin -g bin -m 644 ./bison.hairy /usr/pkg/share/bison.hairy
> cd .; for f in bison.info*;  do /usr/bin/install -c -o bin -g bin -m 644 $f /usr/pkg/info/$f; done
> /usr/bin/install -c -o bin -g bin -m 644 ./bison.1 /usr/pkg/man/man1/bison.1
> ===>  Registering installation for bison-1.25

これでbisonを使用することができます。そして、「pkg_delete bison-1.25」を実
行することでbisonを削除することもできます。もし、バイナリー・パッケージが欲
しければ、以下のようにしてください。

> root@pumpy:/u/pkgsrc/lang/bison(1786)# make package
> >> Checksum OK for bison-1.25.tar.gz.
> ===>  Building package for bison-1.25
> Creating package bison-1.25.tgz
> Registering depends:.
> Creating gzip'd tar ball in '/u/pkgsrc/lang/bison/bison-1.25.tgz'

もし、ソースやオブジェクトファイルが必要ないのであれば、掃除してください。

> root@pumpy:/u/pkgsrc/lang/bison(1787)# make clean
> ===>  Cleaning for bison-1.25


=================
付録A: 構築のログ
=================

 A.1 topの構築
 =============

> Script started on Fri Oct  3 13:22:31 1997
> root@pumpy:/u/pkgsrc/sysutils/top(1342)# make
> >> top-3.5beta5.tar.gz doesn't seem to exist on this system.
> >> Attempting to fetch from ftp://ftp.groupsys.com/pub/top/.
> Requesting ftp://ftp.groupsys.com/pub/top/top-3.5beta5.tar.gz (via ftp://orpheus.amdahl.com:80/)
> Successfully retrieved file.
> >> Checksum OK for top-3.5beta5.tar.gz.
> ===>  Extracting for top-3.5beta5
> ===>  Patching for top-3.5beta5
> ===>  Applying NetBSD patches for top-3.5beta5
> ===>  Configuring for top-3.5beta5
> /bin/cp /u/pkgsrc/sysutils/top/files/defaults /u/pkgsrc/sysutils/top/work/top-3.5beta5/.defaults
> chmod a-x /u/pkgsrc/sysutils/top/work/top-3.5beta5/install
> 
> Reading configuration from last time...
> 
> Using these settings:
>         Bourne Shell   /bin/sh
>           C compiler   cc
>     Compiler options   -DHAVE_GETOPT -O
>          Awk command   awk
>      Install command   /usr/bin/install
> 
>               Module   netbsd13
>              LoadMax   5.0
>         Default TOPN   -1
>         Nominal TOPN   18
>        Default Delay   2
> Random passwd access   yes
>           Table Size   47
>                Owner   root
>          Group Owner   kmem
>                 Mode   2755
>        bin directory   $(PREFIX)/bin
>        man directory   $(PREFIX)/man/man1
>        man extension   1
>        man style       man
> 
> Building Makefile...
> Building top.local.h...
> Building top.1...
> Doing a "make clean".
> rm -f *.o top core core.* sigdesc.h
> To create the executable, type "make".
> To install the executable, type "make install".
> ===>  Building for top-3.5beta5
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c top.c
> awk -f sigconv.awk /usr/include/sys/signal.h >sigdesc.h
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c commands.c
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c display.c
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c screen.c
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c username.c
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c utils.c
> utils.c: In function `errmsg':
> utils.c:348: warning: return discards `const' from pointer target type
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c version.c
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c getopt.c
> cc "-DOSREV=12G" -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O -c machine.c
> rm -f top
> cc -o top top.o commands.o display.o screen.o username.o  utils.o version.o getopt.o machine.o -ltermcap -lm -lkvm
> root@pumpy:/u/pkgsrc/sysutils/top(1343)# make install
> >> Checksum OK for top-3.5beta5.tar.gz.
> ===>  Installing for top-3.5beta5
> /usr/bin/install -o root -m 2755 -g kmem top /usr/pkg/bin
> /usr/bin/install top.1 /usr/pkg/man/man1/top.1
> strip /usr/pkg/bin/top
> ===>  Registering installation for top-3.5beta5
> root@pumpy:/u/pkgsrc/sysutils/top(1344)# 


 A.2 topのパッケージング
 =======================

> root@pumpy:/u/pkgsrc/sysutils/top(1344)# make package
 > >> Checksum OK for top-3.5beta5.tar.gz.
> ===>  Building package for top-3.5beta5
> Creating package top-3.5beta5.tgz
> Registering depends:.
> Creating gzip'd tar ball in '/u/pkgsrc/sysutils/top/top-3.5beta5.tgz'
> root@pumpy:/u/pkgsrc/sysutils/top(1345)#


=================================================
付録B:FTPサーバのパッケージアーカイブのレイアウト
=================================================

ftp.netbsd.org上のコンパイル済みのバイナリー・パッケージのレイアウト

/pub/NetBSD/packages/
                README
                distfiles/
		pkgsrc -> /pub/NetBSD/NetBSD-current/pkgsrc
                1.3/
                        i386/
                                All/
                                archivers/
                                        foo -> ../All/foo
                                ...
                        m68k/
                                All/
                                archivers/
                                        foo -> ../All/foo
                                ...
                        amiga -> m68k
                        atari -> m68k
                        ...


作成:
 - cd /usr/pkgsrc ; make install ; make package
 - /usr/pkgsrc/packages を ftp://ftp.netbsd.org/pub/NetBSD/packages/`uname -r`/`sysctl -n hw.machine_arch`へアップロードする。
 - 必要ならln -s `sysctl -n hw.machine` `sysctl -n hw.machine_arch`

必要なディスクスペース: 不明


###########################################################################
# Local Variables:
# mode:				Text
# fill-column:			75
# sentence-end-double-space:	nil
# End:
