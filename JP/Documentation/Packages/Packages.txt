# $NetBSD: Packages.txt,v 1.7 2000/03/21 14:58:25 sakamoto Exp $
# $Id: Packages.txt,v 1.7 2000/03/21 14:58:25 sakamoto Exp $
###########################################################################

			==========================
			 NetBSDパッケージシステム
			   ドキュメンテーション
			==========================

		      Hubert Feyrer, Alistair Crooks


目次:
==================

 grep -B1 '^.====' Packages.txt | egrep -v '^.[-=]'


 0 イントロダクション
 ====================

UNIXベースのシステムには、自由に利用できるソフトウェアが数多く存在しま
す。これらは普通、またはいくつかの変更でNetBSDで実行できます。NetBSDパ
ッケージコレクションは一つのコマンドで、そのソフトウェアにNetBSDで実行
するのに必要ないくらかの変更を施して、ソフトウェアパッケージのインスト
ール(および再インストール)を簡単にします。

NetBSDパッケージシステムは、自由に利用できるサードパーティのソフトウェ
アを、NetBSDホストで容易に構築することを可能にします。一旦ソフトウェア
が構築されたら、それらは pkg_* ツールにより操作できるので、そのパッケ
ージのインストール、デインストール、全てのインストールされたパッケージ
の目録の表示、一行コメント、あるいはより詳細な説明の情報検索は、全く簡
単です。

NetBSDパッケージコレクションおよびNetBSDパッケージシステムは、FreeBSD
に由来しています。


 0.1 概要
 ========

このドキュメントは二部に別れています。第一部は「ユーザーガイド」で、パ
ッケージコレクションの一つのパッケージを使う方法を、コンパイル済みのバ
イナリーパッケージのインストールと、自分自身でコピーしたNetBSDパッケー
ジシステムから構築する方法の両方で説明します。第二部の「パッケージ構築
者ガイド」は、パッケージ構築の詳細について知らない他のNetBSDユーザーが、
簡単にそのパッケージを構築できるようにする方法を説明します。


 0.2 専門用語
 ============

ここまで、「ポート(ports)」、「パッケージ(packages)」などについて多く
話されています。ここで、このドキュメント中に使われている用語を説明します: 

 * パッケージ(Package):
   ファイルのセットで、NetBSDパッケージシステムを使用したソフトウェアを
   構築するのに必要なことが記述された構築手順書です。パッケージは、伝統
   的に/usr/pkgsrcの下に置かれます。

 * NetBSDパッケージシステム:
   これは、NetBSDオペレーティングシステムの一部分で、パッケージの構築(コ
   ンパイル)、インストールおよびリムーブを扱います。

 * Distfile:
   この用語は、自由に利用できるソフトウェアの作者が、彼の仕事を配布するた
   めに提供しているファイルまたは複数のファイルのことを指しています。NetBSD
   で構築するのに必要な全ての変更は、対応するパッケージに反映されます。
   通常distfileは、圧縮されたtarアーカイブ形式ですが、他の形式でも使用
   できます。Distfilesは/usr/pkgsrc/distfilesの下に保存されます。

 * ポート(Port):
   これはFreeBSDの人たちが、私たちがパッケージ(package)と呼んでいるものを
   表すために使われている用語です。NetBSDでは「ポート(port)」は、
   異なるアーキテクチャーを参照する用語となります。

 * コンパイル済み(バイナリー)パッケージ:
   NetBSDパッケージシステムを使ってdistfileより作成されたバイナリーの
   セットで、ひとつの .tgz ファイルに集められています。これはリコンパイル
   なしに同じマシンアーキテクチャーのマシンにインストールすることができます。
   パッケージはNetBSDパッケージシステムにより、/usr/pkgsrc/packagesで
   生成され、それはftp.netbsd.orgにもアーカイブされています。

   時々、これは、特にコンパイル済みのパッケージの文脈で、
   単に「パッケージ」と表されることもあります。

 *プログラム:
   対応するパッケージが、Distfileにあるファイルから作成した、
   インストールされるべきソフトウェアのひとまとまりです。

 * RCS IDs:
   パッケージに含まれるいくつかのファイルは、そのファイルのバージョンに
   対応したRCS IDが含まれています(cvsにより自動的に挿入されます)。
   これらのIDは、このドキュメントの中のいくつかの例で使用されていますが、
   このドキュメント自体がCVSによって管理されていますので、生のRCS IDを
   列挙することができません。かわりに、$は<$>のように記していますので、
   <$>NetBSD<$> や <$>Id<$> となります。


**************************************************************第一部は翻訳作業中
======================
第一部: ユーザーガイド
======================

 1 コンパイル済みのバイナリーパッケージのインストール
 ====================================================

このセクションは、あなたのマシンタイプ用にすでに準備されたコンパイル済
みのバイナリーパッケージを見つけ、取得してインストールする方法について
説明します。


 1.1 どこから得るか
 ==================

プリコンパイルされたパッケージは、ほどなくFTPアクセスのためにディレク
トリー/pub/NetBSD/packagesでftp.netbsd.orgおよびそのミラーで保存されま
す。どうぞ" sysctl hwによって指示されたようにそこで(に)正しいサブディ
レクトリーを選んで下さい。マシン_ "にアーチを作って下さい。実際のバイ
ナリーを含むサブディレクトリー「すべて」を加えてそのディレクトリーで、
それぞれのカテゴリーのためのサブディレクトリーがあります。tgz -ファイ
ル。カテゴリー・サブディレクトリーは、象徴的なそれらのファイルへのリン
クを使います。(今が/usr/pkgsrc/packagesでのように同じディレクトリー・
レイアウトです)。

この同じディレクトリー・レイアウトは、CDROMディストリビューションに申
し込みます、単に、そのディレクトリーは、たぶんどこかに/cdromの下に、ど
こかほかのところ鼻で地面を掘られるかもしれません。どうぞ正確な場所のた
めのあなたのCDROMのドキュメンテーションを調べて下さい! 


 1.2 やりかた
 ============ 

(最初に鼻で地面を掘る(べき) suに確かな)もしCDROMの書類を保管するかある
いはあなたのハードディスクに彼(それ)らをダウンロードしたら、あなたは、
以下のコマンドで彼(それ)らをインストールすることができます: 

 pkg _が加えます/path/to/package.tgz 

もしあなたはFTPアクセスがあります、そして、あなたがインストールの前にFTP
経由でパッケージをダウンロードしたくなければ、あなたが_が加えるpkgを与
えることによって自動的に今をすることができますftp - URL : 

 ftp://ftp.netbsd.org/pub/packages/`sysctl - nの_が加えるpkg hw。マシ
ン_アーチ` /すべて/ package.tgz 

sysctlが自動的にバイナリ・ファイルの正しいセットを決めるためにここで(
に)使われることに注意してください。彼(それ)らがあなたがインストールす
るプレゼントであることを仮定してまた問題のパッケージを走らせるのに必要
ないくらかの(どんな)パッケージがまた、インストールされるだろうと述べて
下さい。

パッケージをインストールした後に、確かにあなたの$ PATHの/usr/pkgがあっ
て下さい、したがってあなたは、実際には、ちょうどインストールされたプロ
グラムを開始することができます。


 1.3 警告
 ========

どうぞあなたが作り出さなかったとても警告への注目がインストールする生ま
れつきの危機についてその人力のページで表したということに気をつけるバイ
ナリー・パッケージ自身、およびこのようなファイルの無差別な加えることに
よってあなたのシステムへ紹介することができるセキュリティ・ホールを払っ
て下さい。


 2 構築よりインストールする
 ========================== 

今は、パッケージがNetBSDパッケージ・システムがすでに一部分はあると仮定
します。それはそうではありません、それから、あなたがこのドキュメント、
「建設者のガイドを包装して下さい」。の第II章を読むように勧められるか


 2.1 どこからpkgsrcを得るか
 ==========================

パッケージ情報源を動き出させるために、あなたは、ftp://ftp.netbsd.org/pub/NetBSD
-current/tar_files/pkgsrc.tar.gzからpkgsrc.tar.gzファイルを受け取って/usr/pkgsr
cへそれをアンパックする必要があります。

代案として、あなたは、ソフトウェア更新プロトコル、一すすり経由でpkgsrc
を得ることができます。そうするために、あなたのsupfileがライン言動にそ
れで「= pkgsrcをリリースして」、/usr/share/examples/supfilesで例を見さ
せる、およびディレクトリー/usr/pkgsrcがもちろん(あえて)存在することを
確かめて下さい。それから、「一すすり- v /path/to/your/supfile」を開始
するだけで良いのです。


 2.2 distfilesの取得
 =================== 

1つのgotchaがあります:ディストリビューション・ファイル(すなわち変更さ
れていない情報源)は、それを構築することができる(べき)パッケージ・シス
テムのためのあなたのシステムで存続しなくてはいけません。もしそれはでは
ありません、それから、ftp ( 1 )を使って自動的にディストリビューション
・ファイルをフェッチすれば。

あなたは、あなた自身のものに近いサイトに合う(べき)いくらかの主要なディ
ストリビューション・サイトをオーバーライトすることができます。/usr/pkgsrc/mk/mk
.conf.exampleをちょっと見ていくつかの例を見つけて下さい。今は、いくら
かのあなたのbandwith、および時間を保存するかもしれません。

もしあなたが永久的なインターネット、コネクションおよびあなたにどちらの
ファイルをダウンロードするかを知らせたくなければ、"作りますフェッチし
て下さい-リスト"あなたに，何を(に)あなたが必要とするだろうかを話すでし
ょう。/usr/pkgsrc/distfilesへこれらのdistfilesを置いて下さい。


 2.3 構築してインストールする方法
 ================================ 

それが(今まで)終わったことを仮定して、ルートになって適切なディレクトリ
ーに変わって下さい。それから、あなたはタイプすることができます

 作って下さい

パッケージのいろいろなコンポーネントを構築するのが迅速なシェルで、およ
び

 インストールをして下さい

シェルで入力を促してあなたのシステムで正しい場所へいろいろなコンポーネ
ントをインストールして下さい。

例としてトップのシステム・ユーティリティを取って、我々は、A.1で示され
るとして建物によって我々のシステムでそれをインストールすることができま
す。

プログラムは、パッケージ・ツリーのデフォルト根の下にインストールされま
す- /usr/pkg。あなたのパッケージ・ツリーの根として評価する(単にあなた
の環境の変数、およびそれが使うだろうLOCALBASEをセットされた)あなたの趣
味に相似でないので、今がすべきですか。したがって、/usr/localを使うため
に、セットしました

 LOCALBASE =/usr/local 

あなたの環境で。今への1つの例外が、もちろん、あります- X11パッケージは、
伝説的にX11ツリーに取り付けられています。X11パッケージを治める環境変数
の場所は、X11BASEです。したがって、/usr/local/X11R6、セットへX11パッケ
ージをインストールすること

 X11BASE =/usr/local/X11R6 

あなたの環境で。

しかし、ライブラリ、およびヘッダ・ファイルが他のソフトウェアによって見
つけられないかもしれないのでもしあなたがX11ツリーの外でX11パッケージを
インストールすれば、下手物が起こるかもしれないことに気をつけて下さい、
そうすればアプリケーション・デフォルトは、見つけられないかもしれません。
その理由で、あなたは、X11ツリーでX11パッケージを残すように勧められます。
我々は、今を変える方法を見ています。

いくつかのパッケージは、造り時間でいくつかの構成オプションを変えるため
に、/etc/mk.confをのぞいて見ます。/usr/pkgsrc/mk/mk.conf.exampleをちょ
っと見てそこで(に)あなたがセットすることができるものの概要を得て下さい。


 3 コンパイル済みのパッケージを作る
 ==================================

一旦あなたが述べられたとしてパッケージを構築してインストールしたら上で
す、あなたは、pkgsrcツリーでそれを--CPU時間を無駄に使うのではなくあな
たのバイナリー・パッケージを使うために他者のためにもう一つのNetBSDシス
テム、あるいはシンプルな方法を提供することでちょうど構築したバイナリー
を使うことができるように、今をしたいでしょう--今が適当なディレクトリー
に変わることによって終わった「バイナリー・パッケージ」に組み込むことが
できます、そしてコマンドをタイプします

 メイク・パッケージ

シェル・プロンプトで。今は、あなたのパッケージ(すでにされるとはいえな
くても)を構築してインストールするでしょう、そして、あなたが今を操作す
るためにpkg _ *ツールを使うことができるように結果のうちでその時バイナ
リー・パッケージを構成して下さい。バイナリー・パッケージは、/usr/pkgsrc/package
sの下に保存されます、それは、現在の時間のgzippedのファイルの形でありま
す。上記のトップの例の継続に関して付録A.2を参照して下さい。

どうぞそのようなバイナリーのパッケージを提出する方法でこのドキュメント
で後で「提出している」セクションを見て下さい。
**************************************************************第一部は翻訳作業中


==============================
第二部: パッケージ構築者ガイド
==============================

 4 パッケージコンポーネント - ファイル、ディレクトリー、およびコンテンツ
 ======================================================================= 

FreeBSD Portsコレクションからパッケージを用意しても、ゼロからパッケー
ジを用意する場合でも、いつも以下のセクションで述べられている多くのファ
イルが存在します。特に、それぞれのファイルがどうFreeBSD Portsと違うの
かも説明していきます。


 4.1 Makefile
 ============ 

構築、インストールおよびバイナリーパッケージの作成は、すべてパッケージ
のMakefileによりコントロールされます。

それぞれのパッケージのためのMakefileがあります。このファイルは、パッケ
ージのコンパイルとインストールのために必要なすべての定義とアクションが
セットされた標準のbsd.pkg.mkファイル("../../mk/bsd.pkg.mk")をインクル
ードします。必須となるフィールドは、インターネットのサイトからダウンロ
ードされる配布ファイルのベース名を指定するDISTNAME と、そのサイトを指
定する MASTER_SITES、パッケージが置かれるカテゴリーを意味するCATEGORIES、
パッケージの名前である PKGNAMEとメインテイナー名である MAINTAINERです。
これは、そのパッケージを維持する人による(いつも完全に正しい)決定にへり
くつを言う誰かが、活発に苦情を言うことができるようにするためです。

MASTER_SITES は、定義済みのサイトの一つをセットすることもできます。

	${MASTER_SITE_XCONTRIB}
	${MASTER_SITE_GNU}
	${MASTER_SITE_PERL_CPAN}
	${MASTER_SITE_TEX_CTAN}
	${MASTER_SITE_SUNSITE}

もしこれらの予め定義されたサイトの1つを選んだ場合、そのサイトのサブデ
ィレクトリーを指定する方法が必要となるかもしれません。これらのマクロは
一つ以上の実際のサイトに展開されるかもしれませんので、サブディレクトリ
ーを指定する場合は、以下の表記を使わなければなりません: 

	${MASTER_SITE_GNU:=subdirectory/name/}

(サブディレクトリー名あとのスラッシュ / に注意してください)廃止された
MASTER_SITE_SUBDIR を使用しても動作しません。

現在 CATEGORIES 値として以下の値が使用できます。もし一つ以上にまたがる
場合、それらの値はスペースで分けられる必要があります: 

	archivers   corba      games     meta-pkgs  security
	audio       cross      graphics  misc       shells
	benchmarks  databases  lang      net        sysutils
	cad         devel      mail      news       textproc
	comms       editors    math      plan9      www
	converters  emulators  mbone     print      x11

全ての利用できるオプション、および変数の記述に関しては、NetBSD packages(7)
マニュアルページを参照してください。

以下の事柄に気を配ってください。FreeBSD Portsコレクションからパッケージを
持ってきた場合は特に気を付けてください:

 - パッケージのMakefileから、すべての MANx と CATx の定義を削除して
   ください。- NetBSDではマニュアルページを自動的に取扱います。
   これらの定義は現在使用されていません。
 - もしパッケージにより(すでにそこにないとしても)マニュアルページが
   圧縮された形式でインストールされる場合、MANCOMPRESSED を追加してください。
   bsd.pkg.mkのコメントを参照。
 - すべてのファイルの /usr/local を ${PREFIX} に変更してください。
   (後述のパッチを参照)
 - どんな ldconfig コマンドも削除してください - もしNetBSDプラットフォームが
   ldconfigをサポートしていれば自動的に実行されますし、ldconfigをサポート
   しないプラットフォーム(例 NetBSD/Alpha)では他の処置がとられるでしょう。
 - もしFreeBSD Portsコレクションからパッケージを持ってきて変更するならば、
   それらの RCS ID を保持してください: FreeBSDのRCS Id中の '$' を削除し、
   なければ 'FreeBSD' を挿入してください。そして、<$>NetBSD<$> を追加して
   ください(<>は必要ありません。「専門用語」セクションを参照のこと)。
   すなわち:

   修正前:
	# <$>Id: Makefile,v 1.17 1997/06/16 06:39:51 max Exp <$>

   修正後:
	# <$>NetBSD<$>
	# FreeBSD Id: Makefile,v 1.17 1997/06/16 06:39:51 max Exp

 - もし、パッケージが info ファイルをインストールするのであれば、
   メインのinfo ディレクトリーファイルにこの事実を反映するために
   更新する必要があります。NetBSDではこれを行うための INFO_FILES 
   定義を持っています。例えば、indent.info をインストールしたことを
   info ディレクトリーファイルに反映するには、単に

	INFO_FILES=	indent.info

   とパッケージのMakefileに定義してください。もしパッケージにこれを
   追加するならば、必需品であるGNU texinfo パッケージがあなたのシステムに
   インストールされているかどうかを確認するために、USE_GTEXINFO も
   パッケージのMakefileに指定してください。
 - もしあなたが将来の更新のために、そのパッケージをメンテナンスするつもりで
   あれば、MAINTAINER にあなたのメールアドレスをセットしてください。
   標準では MAINTAINER は packages@netbsd.org にセットします。
   FreeBSDの人々は NetBSDのパッケージついて関心がないと思われます。
 - もし問題のソフトウェアにホームページが存在するのであれば、
   MAINTAINER の後ろに HOMEPAGE を追加してください。
   HOMEPAGEの値はホームページのURLにしてください。

 4.2 files/*
 =========== 

最も重要なことは、このディレクトリーには、パッケージのコンパイルに必要
なすべてのdistfileのmd5 チェックサム(必須) が含まれているということで
す。このファイル - files/md5 - は、インターネットから取得したdistfile
が悪意によりセキュリティホールを入れられたファイルに変更されていたり、
転送中にファイルが壊れたりすることを確認するために、配布ファイルのmd5 
チェックサムを含んでいます。このファイルは、NetBSDパッケージを作成する
ために使われたオリジナル配布ファイルやパッチなどのmd5 チェックサムを含
んでいます。これはmd5(1)コマンドを使うか、"make makesum"により生成する
ことができます。

filesディレクトリーにはまた、そのパッケージのpatches/ ディレクトリー(
セクション 4.3 参照)に入っている、公式なすべてのパッチのチェックサムフ
ァイルも入っています。このチェックサムファイルは patch-sum といい、パ
ッチ中のNetBSD RCS Idを除いたすべての行のMD5 チェックサムが含まれてい
ます。このファイルは "make makepatchsum" コマンドにより生成することが
できます。

また、もしあなたがコンフィグレーションまたは構築するより前に、パッケー
ジ中に何かファイルを置きたいならば、それらのファイルを files ディレク
トリーに置くことができますし、pre-configure ターゲットで、cp コマンド
によりコピーすることができます。あるいは、/dev/null に対するそのファイ
ルの単純なdiffをとり、パッチメカニズムを使用して、そのファイルを生成す
ることもできます。


 4.3 patches/*
 ============= 

このディレクトリーは、patch(1) コマンドを使用して作られたファイルを含
んでいます。このファイルは、配布ファイルのソースをNetBSD上で完全にコン
パイルして実行できるように変更するためのものです。これらのファイルは、
アルファベット順(シェルによる "patches/patch-*" 展開順)で適用されます。
つまり patch-aa は patch-ab より前に適用されます。

patch-?? ファイルは diff -u フォーマットであるべきです。これは、FreeBSD
Portsのtsarがcontext diffよりもこの形式の方が読みやすいことを見つけた
からです。ですから、もしあなたが同じ流儀でdiffを作れば、あなたのNetBSD
パッケージは、FreeBSD Portsシステムの一部として受け入れられるチャンス
が多くなります。

なお、将来の変更が難しくなってしまうので、一つのパッチファイルに、複数
のファイルへの変更を入れるのは止めてください。

一つ重要なこととして、NetBSD CVS ツリーにチェックインした後に問題を引
き起こすので、パッチファイルにRCS IDを含ませないように注意してください。
これを避けるためには、diffを "-U 2" または "-U 1" オプションで使ってく
ださい。

FreeBSD PortsからNetBSDパッケージシステムに持ってくる場合、NetBSD上で
もたいていFreeBSD Portsが使用できるでしょう。しかしながら、FreeBSDにソ
フトウェアを移植した人が、当てにならない __FreeBSD__ cpp defineを使っ
ていないかどうかチェックしてください。これをする簡単な方法は、パッケー
ジディレクトリーで

	grep -i freebsd patches/patch-??

としてください。

また、オリジナルパッケージ中の Makefile の /usr/local を ${PREFIX}に変
更するパッチを提供するなど、他のFreeBSDイズムにも気をつけてください。

パッケージを作り終えたとき、忘れずに "make makepatchsum" コマンドでパ
ッチファイルのチェックサムを生成するようにしてください。セクション 4.2
を参照してください。


************************************************************これ以降も翻訳作業中
 4.4 pkg / *  ========= 

このディレクトリーは、バイナリー・パッケージの創造を管理するのが慣れて
いるいくつかのファイルを含みます。このディレクトリーからのファイルは、
それ自身でバイナリー・パッケージで使われて、このように、他のマシンでイ
ンストールされるでしょう、したがって、あなたは、あなたのコメント、およ
び気のきいた言葉のためにあなたが思うだろうよりも、より広い聴衆がいるこ
とを知っているべきです。

 4.4.1必須ファイル ===================== 

 * pkg /コメント: ソフトウェアの断片のA 1 -ラインの記述。小包の名前を
述べるいかなる必要もありません-彼(それ)らが呼びかけられるときに、今は、
自動的に、pkg _ *ツールによって加えられるでしょう。

 * pkg / DESCR : ソフトウェアの断片のマルチ・ラインの記述。今は、彼(そ
れ)らが満期であるいくらかの(どんな)信用を含むべきです。どうぞ心で他者
があなたのユーモアのセンス(あるいは綴り字idiosyncracies )を共有しない、
および他者がここで(に)あなたが書くすべてを読むだろうことを支えて下さい。

 * pkg / PLIST : このファイルは、あなたのシステムでインストールされる
ファイルを治めます:すべてのバイナリー、マニュアルページ、etc。ディレク
トリーの創造、および削除、および差し込まれたファイルの場所をコントロー
ルするために、このファイルに入力されるかもしれない他の指令があります。

もしあなたがNetBSDのために働くためにFreeBSDパッケージを更新していれば、
どうぞpkg / PLISTでその以下の物への細心の注意を払って下さい: 

 -もしいくらかの(どんな)「@エグゼクティブldconfig ...」ステートメント、
あるいはいくらかの(どんな)「@ unexec ldconfig ...」があれば、彼(それ)
らを削除して下さい。電話ldconfigに、いくつかのNetBSD以来、アーキテクチ
ャーがldconfigを持たないのにかかわらず、NetBSDは自動的にうまくいきます。
-どんなミスしている@ dirrmステートメントを加えて下さい-小包Makefileの
いくらかの(どんな) MAN定義

あなたは、またport2pkgパッケージを調査することができました( pkgsrc/pkgtools/por
t2pkg) (あなたのための多くのロバ仕事をする)。


 4.4.2オプション・ファイル ==================== 

 * pkg /インストール: シェル・スクリプトは、_が加えるpkgの間に2度呼び
かけました。インストールする(べき)ファイルがその場に動かされる後に小包
抽出、およびファイルがその場に動かされる以前2回目の後で初めて時間を決
めて下さい。今は、PLISTで@エグゼクティブ・コマンドで可能な(のでは)ない
いくらかの(どんな)カスタム・プロシージャをするために、使うことができま
す。pkg _が( 1 )加えるのを見て下さい、そして、pkg _ ( 1 )さらに詳しい
情報については作り出して下さい。

 * pkg / DEINSTALL : このスクリプトは、前におよびいくらかの(どんな)フ
ァイルがリムーブされる以後実行されます。pkg _が削除するすべてがファイ
ルを削除する方法はオリジナルのディストリビューションで作り出されるかを
知っているので小包の施設のあたりにいくらかの(どんな)追加の乱雑な詳細を
きれいにすることは、このスクリプトの責任です。pkg _が( 1 )削除するのを
見て下さい、そして、pkg _ ( 1 )さらに詳しい情報については作り出して下
さい。

 * pkg / REQ : 要求して下さい-スクリプトそれは利用できるあるアカウント、
使い方方針と同意するユーザー/ sysadmin、といった物を確実にするのが施設
の前に呼びかけられた、およびde -施設のetcです。

 * pkg /メッセージ・ディスプレイ小包の施設の後のこのファイル。ほとんど
自由なソフトウェア、etcの法律の通知といった物に役に立ちます。


 4.5は/ *の台本を書きます ============= 

このディレクトリーは、あなたのソフトウェア、etcの構成に必要ないくらか
の(どんな)ファイルを含みます。もし以下の名前のどれ(か)をもつスクリプト
が現存すれば、それは、造りプロセスの間に適当な時期で実行されるでしょう:

 事前(に)フェッチします造りの前です造り後が後インストールの小包の前で
す小包後をプリインストールするパッチ後が事前(に)構成するパッチ前が後(
で)構成する抜粋後が構成する抜粋前を後(で)フェッチして下さい

造りプロセスの記述に関してセクション7を参照して下さい。


 4.6は/ *を働かせます ========== 

あなたが「作る」とタイプするときに、ディストリビューション・ファイルは、
このディレクトリーへアンパックされます。それは、タイピングによってリム
ーブすることができます

 きれいに作って下さい

シェル・プロンプトで。また、このディレクトリーを使っていろいろなタイム
・スタンプ・ファイルをつけます。


 CVへ小包を輸入する4.7  ================================== 

新しく開発された小包は、「TNF」のベンダー札および「pkgsrc -ベースだ」、
e .g::のリリース札で輸入されるべきです

 pkgsrc -ベースのcvs輸入pkgsrc/<category>/frobnitz TNF 

FreeBSDポートから生じている小包は、普通のCV運営によってそれから必要な
変更をして、(ポートのスナップ写真が撮られた日付であるYYYY - MMの- DDが
FreeBSDツリーを形づくります)「FREEBSD」のベンダー札および「FreeBSD -流
れ- YYYY - MMの- DD」のリリース札で輸入されるかもしれません。E.g: 

 cvs輸入pkgsrc/<category>/mumbler FREEBSD FreeBSD -現在の- 1998-04-01 
cvs rm patches/patch-a cvsが加えますパッチ/パッチ- aa cvs ci 

すべてがupdates/additionsを包装することに注意してくださいドック/ pkg -
変化!それのこのファイルuptodateを保つのがとても重要な、それがそうだろ
う原因は、www.netbsd.orgで自動的にいくつかのページを更新するために、ス
クリプトから使いました。
**************************************************************ここまで翻訳作業中


 5 PLIST* 問題 
 =============

このセクションでは、PLIST ファイル(複数の場合もあります、以下を参照
してください)を扱う場合に注意が必要な、いくつかの特別な問題について
述べます。


 5.1 雑多な事
 ============

 * RCS Id : 
   あなたが書いたすべての PLIST ファイルの先頭行に RCS ID が追加されて
   いることを確認してください。

	@comment <$>NetBSD<$>

 * ranlib: 
   ranlib コマンドを PLIST ファイルに記述しないでください。パッケージ
   が削除される時にトラブルをひきおこすかもしれません。構築時にだけ 
   ranlib が実行されること(通常、実行します)を確認してください。そう
   すれば特に気にする必要はありません。これは FreeBSD ポートを流用
   する時にいつも問題となります。

 * ldconfig:
   ldconfig コマンドを PLIST ファイルに記述しないでください。このコマ
   ンドは問題をひきおこす可能性があります。NetBSD では、共有オブジェ
   クトのキャッシングは自動的におこなわれます(あなたが、
   「"Automatic shared object handling」メッセージの出力を見た時にお
   こなわれています)。したがって、これに関しては気にする必要はありま
   せん。もしパッケージの中に共有オブジェクトが見つかれば、自動的に
   処理されます。必要であれば ldconfig を実行し、そうでなければ実行し
   ません。これは FreeBSD ポートを流用する時にいつも問題となります。

 * ${MACHINE_ARCH}、${MACHINE_GNU_ARCH}:
   emacs、および perl のようないくつかのパッケージは、それらが構築
   されたアーキテクチャーに関する情報を、インストールするファイルの
   パス名に埋め込みます。このようなケースに対応するため、実際に使わ
   れる前に、PLIST に前処理がおこなわれます。そして、シンボル
   「${MACHINE_ARCH}」は、「sysctl -n hw.machine_arch」の出力でおき
   かえられます。${MACHINE_GNU_ARCH} が PLIST のどこかにうめこまれて
   いる場合も同様の事がおこなわれます。これは、GNU autoconfigure を
   使用しているパッケージで使われます。

   昔の話:「<$ARCH>」シンボルは「uname -m」の出力によって置きかえられ
   ていました。しかし、もはやサポートされていませんし、削除されています。

 * ${OPSYS}、${OS_VERSION}: 
   いくつかのパッケージでは、OS 名とバージョンをいくつかのパス名に埋め
   込みます。このような場合、PLIST で二つの変数を使用してください。
   ${OPSYS} は「uname - s」の出力で置きかえられます。${OS_VERSION}には
   「uname - r」出力が設定されます。

 * マニュアルページの圧縮: 
   もし、(bsd.own.mk に)MANZ が設定されていれば、マニュアルページは圧縮
   形式でインストールされます。そうでなければ展開された形式でインストー
   ルされます。PLIST ファイルでこれをサポートするために、MANX と 
   MANCOMPRESSED の設定の有無に従い、「.gz」サフィックスがマニュアルペー
   ジに自動的に追加、削除されます。この PLIST ファイルに対する変更は、
   pkg/PLIST 自身にたいしてでなく、それがコピーされる時におこなわれます。 


 5.2 MD/MI 対 汎用の PLIST  
 =========================

pkg/PLIST のパッケージング・リストは、プラットフォーム間で時々異なり
ます。例えば、あるプラットフォームが共有ライブラリーをサポートして、
それ以外ではサポートしていない場合です。これに対応するために、パッケー
ジの Makefile 中で条件に従い自由に PLIST ファイルを定義できるフックが、
NetBSD パッケージシステムへ導入されました。


 5.2.1 $PLIST_SRC  
 ================ 

ひとつ以上のファイルを、バイナリー・パッケージを構築するために PLIST の
ソースとして使用する時は、それらのファイル名を変数 PLIST_SRC に設定して
ください。これらのファイルは、後で cat(1) によって連結されます。連結の
順番は重要な問題なので、以下を参照してください。


 5.2.2 PLIST-mi、PLIST-md.shared、PLIST-md.static
 ================================================

もし、PLIST_SRC が設定されていない(通常の場合)、あるいは、pkg/PLIST
が存在しない場合、パッケージシステムは、各プラットフォーム間の共有ライ
ブラリーのサポートの有無を吸収するために、pkg/PLIST-mi、pkg/PLIST-md.shared、
pkg/PLIST-md.static を検索します。PLIST-mi は機種独立なファイルを含み
ます。PLIST-md* は機種依存のファイルを含んでいます。これは動的ライブラ
リーと共有ローディングをサポートしていないアーキテクチャー間で異なりま
す。現在、これは perl のパッケージでのみ使用されています。alpha 上の 
perl5 は、まだ perl/TK のような拡張された動的ローディングをサポート
していません。PLIST-mi.static も又、(pmax、powerpc 以外では) alpha 
で使用されています。perl の動的ローディングが修正されたら、alpha では
使われなくなるでしょう。

(この MI/MD PLIST ファイルの扱いは、PLIST_SRC に「PLIST-mi PLIST-md.static」
が設定されているか、あるいは「PLIST-mi PLIST-md.shared」が設定されている
かによって異なります。/usr/pkgsrc/mk/bsd.pkg.mkを見て下さい)。


 5.2.3 PLIST* ファイルの順番
 ===========================

@dirrm ステートメントの順番については間違いやすいので注意する必要があり
ます。MD @dirrm ディレクティブの後に実行される MI @dirrm ディレクティブ
は、PLIST.md-* に記述しなければなりません。これは PLIST-mi と 
PLIST.md-{shared/static} が、この順番で連結されるためです。もし MI ディ
レクトリーが PLIST-mi にリストされれば、それは、MDディレクトリーの前に
削除され、うまく動作しないでしょう。

例えば、以下のディレクトリが存在する場合、

        foo/mi
        foo/mi/md

PLIST-mi は以下のものを含みます。
        <nothing>

そして、PLIST-md.* は以下のものを含みます。
        @dirrm foo/mi/md
        @dirrm foo/mi

これは、いくつかの @dirrm ステートメントの重複をまねくでしょう。しかし、
すべてが適切に削除されることを保証する唯一んぼ方法です。PLIST_SRC がパッ
ケージ固有の設定のために使用される場合にも、同じ注意が必要です。


 6 パッケージの修正に関する 6 つの注意
 =====================================

 6.1 CPP 定義
 ============

アプリケーションを NetBSD に移植するためには、コンパイラーがコンパイル
しているシステムを判断する必要があります。したがって、C のプリプロセッサー
がシステムを判断できるように、CPP の定義を使います。

非常に簡単に言うと、多くのFreeBSDポート(NetBSD ではパッケージとよばれる)
が CPPの定義 __FreeBSD__ に依存しています。この定義は FreeBSD 固有の仕様
のためにだけ使用すべきですが、残念ながら今はそうなっていません。また多く
の FreeBSD ポートは、CPU がインテルベースのリトルエンディアンという事実
に依存しています。

4.4 BSD から派生したシステム上で作業しているかどうかをテストするためには、
BSD 定義を使用するべきです。これは <sys/param.h> で定義されています。

        #include <sys/param.h>

また、BSD に固有の部分を、以下の条件でかこむこともできます。

	#if (defined(BSD) && BSD >= 199306)
	...
	#endif

どうか注意して __NetBSD__ 定義を使って下さい。4.4-lite から派生した他のBSD
にない NetBSD 固有の特徴にのみ適用してください。

美的な観点からすると、__FreeBSD__=1 を定義して、単純に FreeBSDポートを使う
ことは避けるべきです。


 6.2 共有ライブラリ- libtool  
 ===========================

NetBSD はさまざまな種類のマシンをサポートします。それらは a.out と 
ELF のような異なるオブジェクトフォーマットを使い、共有ライブラリ、
ダイナミックローディングの有無すらも異なります。これに対応するため
にコマンドそのもの、およびオプションがコンパイラー、リンカなどに渡
される必要があります。すべてのマシンで正しく動作させることは非常に
むずかしく、テストのためにすべてのマシンを持っていない場合は特にそ
うでしょう。「libtool」パッケージはこれを助けます。「libtool」は
ソースファイルから、静的、動的なライブラリー両方を構築する方法を
知っています。したがって、プラットフォーム独立です。

「libtool」を使うためには、まず libtool-pkg への構築依存性を追加して
ください。それからライブラリー構築時に libtool を使用するように、パッ
ケージのソースを変更してください。最後に変更の結果をパッチとして、
パッケージの patches ディレクトリにおいてください。

以下に、libtool をパッケージで使用するための 7 つの手順を記述します。

1. USE_LIBTOOL=yes をパッケージの Makefile へ追加します。

2. ライブラリーオブジェクトのために、 ${LIBTOOL} --mode=compile ${CC}
   を ${CC} に設定します。ライブラリが、提供された Makefile だけを使用
   して構築されるのであれば、CCの定義にこれを追加するだけです。このコマ
   ンドひとつだけで、PIC と 非 PIC のライブラリーオブジェクトを作成しま
   す。したがって、共有ライブラリとそうでないライブラリーの構築規則を別
   々に記述する必要はありません。

3. ライブラリーのリンクのために、「ar」、「ranlib」、「ld -Bshareble」
   コマンドを削除してください。そしてその代わりに以下のコマンドを使用
   してください。

	${LIBTOOL} --mode=link cc -o ${.TARGET:.a=.la} ${OBJS:.o=.lo} -rpath ${PREFIX}/lib -version-info major:minor

   ライブラリーは.la 拡張のために変更され、オブジェクトは .lo 拡張のために
   変更されることに注意してください。OBJS を必要に応じて変更してください。
   このコマンドは、必要なものすべて、.a、.so.major.minor、そして ELF の
   symlink(必要なら)を自動的にカレントディレクトリに作成します。

4. インストールする前のライブラリーに依存するプログラムをリンクする時に、
   cc か ld の前に「${LIBTOOL} --mode=link」を書いてください。このコマン
   ドは、正しいライブラリー(静的、または共有)を見つけます。ただし、libtool
   を使う時には -L オプションで相対パスを指定すること(-L../somelib のよ
   うに)ができない事に注意してください。引数として .la ファイルを使うよ
   うに修正しなければなりません。例えば、

	${LIBTOOL} --mode=link ${CC} -o someprog -L../somelib -lsomelib

   は正常に動作しないので、以下のように変更する必要があります。

	${LIBTOOL} --mode=link ${CC} -o someprog ../somelib/somelib.la

   これで、ライブラリーを正しく扱う事ができます。もし、-L で相対パスを
   使用しなければならず、インストールする前にこのプログラムを実行しない
   場合は、リンクおよびインストールの時に libtool を使用しなくてもかまい
   ません。この場合、-L でサブディレクトリー「.libs」を追加してください。

	${CC} -o someprog -L../somelib/.libs -lsomelib

5. ライブラリをインストールするときに、install あるいは cp コマンドの
   前に「${LIBTOOL} --mode=install」を書いて下さい。そしてライブラリの
   名前を .la に変えてください。例えば、以下のように書く必要があります。

	${LIBTOOL} --mode=install ${BSD_INSTALL_DATA} ${SOMELIB:.a=.la} ${PREFIX}/lib

   これは、静的リンクのための .a、共用ライブラリ、必要な symlink を
   インストールし、「ldconfig」を実行します。

6. PLIST の中に、.a、.la、そして so.major.minor ファイルを追加してください。
   ただし、ELF の symlink は追加しないでください。これは自動的に作成されます。

すでに libtool をサポートしている GNU パッケージのための注意
USE_LIBTOOL=yes をパッケージの Makefile に追加してください。パッケージ
に含まれている libtool をチェックしない、または構成しないように、configure
スクリプトを修正する必要があるでしょう。パッケージの libtool を回避する簡単
な例は、libwww パッケージ、patch-ab を参考にしてください。


 6.3 FreeBSDポートに関する注意
 =============================

Makefile の問題(MANx、CATx、MANCOMPRESSED、ldconfig、RCS IDs)については
4.1 を参照してください。FreeBSD のポートからパッチを流用した場合におこなう
べき作業については 4.3 を参照してください。

FreeBSDポートの最も大きい問題の1つが、多くのポートが ${PREFIX} の設定
を無視し /usr/local にインストールされると仮定されている事です。これを
修正するために、パッケージの Makefile に以下のような行を追加してください。

pre-configure:
        for f in `find ${WRKDIR} -type f -print|xargs grep -l '/usr/local'`; do
\
                ${SED} -e 's:/usr/local:'${PREFIX}':g' < $$f > $$f.pdone && ${MV} $
$f.pdone $$f; \
        done

これは sysutils/rtty パッケージで使用している方法です。これがあなたの
パッケージでも正しく動作することを確認してください。例えば、/usr/local
で何かを探すことは、実際には意味があるかもしれません。したがって、
無条件に /usr/local を置き換えてはいけません。

FreeBSD は、パッケージの Makefile にマニュアルページを列挙し、PLIST に
対応するエントリーを作らないことを決めました。MAN[1-8ln] の定義を削除
する前に、これらを PLIST に追加する必要があるでしょう。 MLINKS と 
CAT[1-8ln] エントリーも同様です。

PLIST のマニュアルページについての注意
.gz サフィックスについては特に注意をはらう必要はありません。多くの 
FreeBSD ポートは、実際には圧縮せずにマニュアルページをインストール
する場合も、PLIST に .gz ページをもっていますが、気にしなくてもかま
いません。我々は、MANZ に従い.gz サフィックスを追加します。つまり、
PLIST のマニュアルページの名前が .gz サフィックスを持っているかどうか
は重要ではありません。もし、それが必要であれば自動的に追加されるし、
不必要な .gz サフィックスがあれば自動的に削除されるでしょう。

いくつかのパッケージは、構築時に bsd スタイルの .mk ファイルを使用します。
したがって MANZ が設定されていれば、インストールされるマニュアルページは 
gzip で圧縮されます。もし、MANZ が設定されていなければ圧縮しません。もし
パッケージが bsd スタイルの .mkファイルを使う場合は、Makefile の中で変数 
MANCOMPRESSED_IF_MANZに yes を設定してください。


 6.4 作者へのフィードバック
 ========================== 

もしパッケージの不具合を発見し動作するように修正した場合、NetBSD 上で動作
させるために特別な手順が必要だった場合、あるいはさまざまなソフトウェアの
拡張をおこなった場合、これらの修正をプログラムのオリジナルの作者へ報告
してください。このようなサポートによってのみ、プログラムの次のリリース
にそれらの修正を反映することができます。そして、NetBSD パッケージシステム
を使用していない人々も、あなたの努力でのおかげで幸せになれます。

フリー・ソフトウェアの理念をサポートして下さい。


 7 構築の手順
 ============

プログラムを構築するための基本的な手順は常に同じです。最初に、プログラム
のソースファイル(distfile) をローカル・システムへ持ってきて展開します。
NetBSD 上でコンパイルするためのいくつかのパッチを適用した後に、ソフトウェア
を設定し、構築(通常、コンパイルすることによって)します。最後に作成された
バイナリー等を、システムにインストールします。これはまさに NetBSD パッ
ケージ・システムによって実行される手順です。この手順は、中心となる Makefile、
/usr/pkgsrc/mk/bsd.pkg.mk の中で一連のターゲットとして実装されています


 7.1 プログラムの場所 
 ==================== 

次のセクションで NetBSD パッケージ・システムによって実行される手順の概略
を述べる前に、プログラムがインストールされる場所、その場所に影響をおよぼ
す変数について簡単に記述します。

自動変数 PREFIX は、最終的にプログラムのすべてのファイルがインストール
される場所をしめします。通常、$LOCALBASE (/usr/pkg)、または「クロス」
カテゴリーのパッケージのための $CROSSBASE と同じ場所になっています。
もし USE_IMAKE、USE_MOTIF、あるいは USE_X11BASE が定義されていれば、
その値は $X11BASE と同じになります。${PREFIX}の値は、プログラムの
ソース中でこれらのファイルが符号化されるさまざまな場所に使用されるべき
です。詳細に関しては、セクション 4.3 および 6.2 を参照して下さい。

これらの変数のどれかを選択し使用する場合には、以下のルールに従ってください。

 * ${PREFIX} は常に 現在のパッケージがインストールされる場所を指します。
   パッケージ自身のインストール先のパスを参照する時に、${PREFIX} を使用
   してください。

 * ${LOCALBASE} は、すべての非 X11 パッケージがインストールされる場所
   です。他の非 X11 パッケージによってインストールされたインクルード
   ファイルやライブラリの場所をさがすためのコンパイラの -I や -L オプ
   ションを指定する場合に、${LOCALBASE} を使用してください。

 * ${X11BASE} は、実際に X11 ディストリビューションがインストールされる
   場所です。通常の X11 のインクルードファイル(パッケージとしてインストール
   されていない)をさがす場合、${X11BASE} を使用してください。

 * X11 ベースのパッケージは特別です。/etc/mk.conf の設定によっては、
   X11BASE、または LOCALBASE に依存するかもしれません。もし、USE_IMAKE
   や USE_MOTIF、USE_X11BASE を Makefile で定義した pkg としてインストール
   されたインクルードファイルやライブラリーをさがす場合、${X11BASE} と 
   ${LOCALBASE} の両方を使用する必要があります。


 7.2 主なターゲット
 ================ 

bsd.pkg.mk で定義された、構築手順で使用される主なターゲットについて述べます。

 * fetch:
   これは、変数 DISTFILES と PATCHFILES (パッケージの Makefile で定義
   された)で指定されたファイルが、ローカルシステムの /usr/pkgsrc/distfiles
   に存在するかどうかをチェックします。もし、存在しなければ、変数 PATCH_SITE
   で指定されたサイトから、ftp(1) を使用し取得します。PATCH_SITE は
   URL の形式で、ftp://-、および http://- が使用できます。これは、ftp(1)
   が両方の形式を解釈できるからです。

 * checksum:
   distfile を取得した後に、MD5 チェックサムを生成し、files/md5 ファイル
   に保存されたチェックサムと比較します。もし、チェックサムが一致しなけれ
   ば、構築は中断されます。これはパッケージ作成時と同じ distfile が、構築
   に使用されていること、つまり、悪意やネットワークの損失によって distfile
   が変更されていないことを保証するためです。

 * extract: 
   distfile がローカルシステム上に存在している場合、通常、それらは圧縮
   アーカイブフォーマットで保存されているので、展開する必要があります。
   もっとも一般なフォーマットは .tar.gz です。もし、すべての distfile
   を伸張する必要がないのであれば、伸張するファイルを EXTRACE_ONLY に
   設定してください。もしdistfile が .tar.gz フォーマットでなければ、
   EXTRACT_CMD、EXTRACT_CMD、 EXTRACT_BEFORE_ARGS、そして EXTRACT_AFTER_ARGS
   を設定することにより、それらを展開することができます。

 * patch: 
   展開の後で、PATCHFILES で指定されたパッチとパッケージのパッチサブ
   ディレクトリに存在するパッチ、すべてが適用されます。.Z、あるいは
   .gz で終る名前のパッチファイルは、適用する前に伸張されます。.orig、
   .rej で終るものは無視されます。patch(1) のためのいくつかのオプション
   は、PATCH_DIST_ARGS で指定する事ができます。詳細に関してはセクション
   4.3 を参照して下さい。

 * configure: 
   ほとんどのソフトウェアは、NetBSD で利用できるヘッダーファイル、システム
   コール、およびライブラリルーチンについての情報を必要とします。これは
   コンフィギュレーションとして知られているプロセスであり、通常、自動化
   されています。大抵の場合、スクリプトがソースと一緒に提供され、それを
   実行することによりヘッダーファイルや Makefile 等が生成されます。

   プログラムがコンフィギュレーションのためのスクリプトを提供していない
   場合、パッケージのスクリプトディレクトリに configure という名前の
   スクリプトを置くことができます。そして、それは sh(1) によって実行
   されます。

   もし、プログラムの distfile が 専用の configure スクリプトを含んで
   いる場合、HAS_CONFIGURE を設定することにより、実行することができます。
   もし、そのスクリプトが GNU の autoconf スクリプトである場合は、かわり
   に、GNU_CONFIGURE を指定してください。どちらの場合も、configure スクリ
   プトの引数は、変数 CONFIGURE_ARGS で指定されます。もし設定スクリプトの
   名前がデフォルトの configure でない場合は、その名前を CONFIGURE_SCRIPT 
   に設定してください。

   もし、プログラムがコンフィギュレーションのために Imakefile を使用する
   のであれば、USE_IMAKE を YES に設定することにより、適切な手順が実行され
   ます。(もし、$X11BASE にインストールされるパッケージが欲しいだけで、
   xmkmf を実行したくない場合、かわりに USE_X11BASE を使用してください!)

 * build: 
   コンフィギュレーションが終ったら、$MAKEFILE の中で、構築のターゲット
   として $ALL_TARGET を指定し $MAKE_PROGRAM を起動することにより、
   NetBSD 上にソフトウェアを構築することができます。もし、USE_GMAKE が
   設定されていれば、デフォルトの MAKE_PROGRAM は「gmake」です。そうで
   なければ、makeが使用されます。MAKEFILE にはデフォルトで Makefile が
   設定されます。そして、ALL_TARGET のデフォルトは all です。デフォルト
   の構築手順を変更するために、これらの変数を設定することができます。

 * install: 
   構築の段階が完了すると、ユーザーのためにソフトウェアをパブリックな
   ディレクトリにインストールする必要があります。。build ターゲットと
   同様に、$MAKE_PROGRAM が $MAKEFILE 中で起動されます。ただし、
   $INSTALL_TARGETが指定されます。この変数のデフォルトは「install」
   です。(もし USE_IMAKE が設定されていれば、「install.man」も追加されます)。

   もし、ターゲットが指定されなければ、デフォルトは「build」です。手順
   の途中のターゲットが指定された場合、それ以前のすべての手順が実行され
   ます。例えば「make build」は、以下と同等のことを実行します。

	make fetch
        make checksum
	make extract
	make patch
	make configure
	make build


 7.3 他の役に立つターゲット
 =========================

 * pre/post-*
   前のセクションで述べた主ターゲットのために、二つの補助ターゲット
   が存在します。これは主ターゲットに「pre-」や「post-」というプレ
   フィックスをつけたものです。これらのターゲットは、特別な設定やイ
   ンストール手順のために、主ターゲットが実行される前や後に実行され
   ます。例えば、プログラムのコンフィギュレーションスクリプトやイン
   ストールターゲットが省略された場合に有用です。これらのターゲット
   のために、同名のスクリプトをパッケージのスクリプト用のサブディレ
   クトリに置くことができます。セクション4.5を見て下さい。

 * do-*:
   主なターゲットがおかしな動作をし、それを修正するための変数が存在
   しない場合、do-* ターゲットを使用することにより、それらを再定義す
   ることができます(do-* ターゲットのかわりに、ターゲット自体を再定義
   してはいけません。pre-* や post-* ターゲットが実行されなくなってし
   まいます)。通常、再定義する必要はありません。

 *reinstall:
  もし、「make install」実行後に、いくつかのファイルがきちんとインストール
  されなかった事に気がついた場合、このターゲットを使い、再びインストール
  する事ができます。この場合、「インストール済み」フラグは無視されます。

 * deinstall: 
   このターゲットは、パッケージを削除するためにカレントディレクトリで 
   pkg_delete(1) を実行します。動作を制御するために、以下の変数をコマンド
  ライン、または /etc/mk.conf で使用することができます。

  - PKG_VERBOSE:
    pkg_delete(1) コマンドに「-v」オプションを渡します。

  - DEINSTALLDEPENDS: 
    指定されたパッケージに必要な(依存する)すべてのパッケージを削除します。
    このターゲットは、指定されたパッケージによってインストールされた
    パッケージを削除するために使用されます。例えば、DEINSTALLDEPENDS=1
    が x11/kde で指定されている場合、KDE 全体 を削除します。pkg_delete
    のコマンドラインに -R を指定すると設定されます。

 *update:
   このターゲットは、現在のパッケージを最新のものに更新します。最初に
   パッケージと、それに依存するすべてのパッケージを削除します。それか
   ら最新のバージョンのパッケージをコンパイル、インストールします。
   これは、現在どのパッケージがインストールされているかを調べ、
   「make deinstall」、「make clean」、「make install」を続けて実行す
   るのと同じです。

   以前に実行した「make uddate」がさまざまな理由で中断された場合、
   パッケージの更新のために、このターゲットを使用することができます。
   ただし、「make clean」を実行していない事、あるいは ${WRKDIR} の
   依存パッケージのリストを削除していない事を確認してください。そう
   でなければ、インストール済みの依存パッケージを使用し、現在のパッ
   ケージを自動更新することができません。

  「make update」の動作を変更するために、以下の変数をコマンドライン、
  または/etc/mk.conf で使うことができます。

    - DEPENDS_TARGET:
      更新されたパッケージや依存パッケージのために使用されるインストール
      ターゲット。デフォルトは「install」です。例えば、
     「make update DEPENDS_TARGET=package」のように使用します。

    - NOCLEAN:
      更新した後、きれいに掃除をしません。調査やその他の目的のために、
      更新されたパッケージの作業用ソース等をそのままにしておきたい場合
      に役に立ちます。最終的にはソースツリーを掃除してください(以下の
     「clean-update」ターゲットを見てください)。そうしなければ、次回の
     「make」や「make update」の時に古いソースコードが残っていることで
      トラブルがおこるかもしれません。

    - REINSTALL:
      すべてのパッケージを更新する場合は、${DEPEND_TARGET} でなく
      「reinstall」を使用してください。この変数を使用する時には、
      「reinstall」ターゲットが使用される事を覚えておいてください。

 *clean-update: 
  カレントディレクトリで「make update」が実行された時に更新される
  すべてのパッケージのソースツリーを掃除します。カレントパッケージ
  (あるいは、依存パッケージ)がすでに削除されている(例えば make update 
  を実行した後)場合には、このターゲットを使ってはいけません。もし使用
  すると、更新するつもりのパッケージのいくつかを失う可能性があります。
  経験的には、初めて「make update」を実行する前、あるいは汚れたパッケージ
  ツリーがある場合(例えば NOCLEAN を使用した場合)にのみ使用すべきです。
  「make clean-update」の動作を変更するために、以下の変数をコマンドライン、
   または /etc/mk.conf で使うことができます。

  - CLEAR_DIRLIST: 
    「make clean」の後で、パッケージのためのディレクトリーのリストを
    再構築しません。「make update」で、更新したいすべてのパッケージが
    インストールされた場合にのみ使用してください。通常、これは
    「make update」で自動的に実行されます。ただし、NOCLEAN 変数の設定
    によって実行されない事もあります(上を参照してください)。

 * readme:
   このターゲットは、README.htmlファイルを作成します。このファイルは
   netscape (pkgsrc/www/mozilla) や lynx (pkgsrc/www/lynx) のような
   ブラウザで閲覧することができます。作成されたファイルは、ローカルホスト
   の ${PACKAGES} ディレクトリにあるパッケージへの参照を含んでいます。
   また、FTP_PKG_URL_HOST と FTP_PKG_URL_DIR を元にした URL を参照させる
   こともできます。(例えば、ローカルマシン上の /usr/packages ディレクトリ
   のバイナリーパッケージを参照する README.htmlファイルを作成したい場合、
   FTP_PKG_URL_HOST=file://localhost と FTP_PKG_URL_DIR=/usr/packages 
   をセットしてください。${PACKAGES} ディレクトリと、そのサブディレクトリ
   はすべてのバイナリパッケージで検索されます。

 * readme-all:
   このターゲットを使い、README-all.html を作成することができます。この
   ファイルは NetBSD パッケージコレクションの中の、現在利用可能なすべて
   のパッケージのリスト、また、それらが属するカテゴリーと簡単な説明を含
   んでいます。このファイルは pkgsrc/*/README.html から作りだされます。
   したがって、「make readme」の後に、このターゲットを実行してください。

 * cdrom-readme:
   これは readme ターゲット(上を見てください)とほとんど同じですが、
   CD-ROM に焼かれる pkgsrc ツリーを作る時に使われます。また、
   このターゲットは README.html ファイルを作成し、CDROM_PKG_URL_HOST と 
   CDROM_PKG_URL_DIR に基づくURLへの参照を作ります。

 * show-distfiles:
    このターゲットは、パッケージを構築するために、どの distfile や
    パッチファイルが必要かを表示します。

 * show-downlevel:
   このターゲットは、パッケージがインストールされていない場合は何も表示
   しません。もし、あるバージョンのパッケージがインストールされているが、
   現在の pkgsrc のバージョンでインストールさらたものでない場合、警告
   メッセージを表示します。このターゲットは、インストール済みのパッケージ
   が古いバージョンであり、そのバージョンが削除可能で、最新の物が追加され
   ることを表示するために使用されます。



 8 デバッグ
 ==========

FreeBSD のポートからパッケージを作成する時に落ちいりやすい間違いを
チェックし、パッケージを動作させるための手順があります。これは基本的
には前のセクションで説明したことと同じですが、デバッグを助けるための
方法を追加しています。

 - FreeBSD コレクションからポートをさがしてください。
 - パッケージの Makefile 中の RCS-ID を修正してください。
   セクション 4.1 を参考にしてください。
 - 未変更の FreeBSD のソースをインポートしてください(cvs アクセスが
   可能な場合だけおこなってください。そうでない場合は必要ありません。)。
   (cd .../pkgsrc/category/pkgname ; cvs import pkgsrc/category/pkgname \
	FREEBSD FreeBSD-current-yyyy-mm-dd)
 - CVS にインポートしたら、以下の修正が必要かどうか調べて下さい
   (CVS にアクセスできなければ必要ありません)。
 - 必要なら Makefile を修正してください。セクション 4.1 を参考にしてください。
 - パッチが適切かどうか確認してください。
 - すべての pkg/PLIST の先頭行「@comment <$>NetBSD<$>」という行を追加して
   ください(セクション5 を参考にしてください)。
 - make
 - もし何かがうまくいかなければ、修正してください。パッチを作成するために、
   ファイルの修正後に diff を再生成してください。
   「diff -bu foo.orig foo >../../patch-xx」
   (作業する前に、mv patch-xx patch-xx.orig しておいてください)
   もし、前のパッチで foo.orig が作成されない場合でも、必ず、どこかに
   そのファイルの古いバージョンを持っていて下さい。この作業を繰り返して
   ください。:)
 - ビルドがすべて OK なら touch /tmp/bla して下さい。
 - make install
 - find /usr/pkg/ /usr/X11R6/ -newer /tmp/bla >/tmp/x
   (又は、LOCALBASE や X11BASE を設定したすべてのディレクトリを対象として)
 - pkg_delete blub
 - find /usr/pkg/ /usr/X11R6/ -newer /tmp/bla
   もし、なにかファイルが見つかれば、それらは pkg/PLIST* に不足している
   ので、追加してください。
 - pkg/PLIST* と /tmp/x を比較し、前者を修正してください。
   ( sort /tmp/x >/tmp/x2 ; sort pkg/PLIST >/tmp/P ; sdiff /tmp/x2 /tmp/P )
 - make reinstall && make package
 - pkg_delete blub  
 - 「find /usr/pkg/ /usr/X11R6/ -type f -newew /tmp/bla」を実行し、
   何も見つからないことを確認してください。
 - pkg_add .../blub.tgz  
 - 遊んでみてください。:)
 - pkg_delete - 今までと同様に、いかなるファイルも残っていてはいけません。
  (もう一度、上記のfind を実行してください)。
 - 提出してください(もし cvs アクセス可能であればコミットしてください)。
   セクション 10 が参考になります。


 9 FAQ とパッケージシステムの特徴
 ================================

 9.1 GNU autoconfig を利用するパッケージ
 =======================================

もしパッケージが GNU autoconf を使うのであれば、パッケージの Makefile
に以下の設定を追加してください。

> GNU_CONFIGURE= yes

この設定が CONFIGURE_ARGS に --prefix=${PREFIX} を追加することに注意
してください。したがって、あなた自身でこれを追加する必要はありません。
そして、これはあなたの望む設定とは異なるかもしれません。


 9.2 tar.gz 以外の配布方法
 =========================

パッケージが tar.gz 以外の方法で配布されている場合、plan9/sam パッ
ケージを参考にしてください。これは gzip されたシェルアーカイブ 
(shar)を使っています。いちおう簡単に説明すると、DISTNAME フィールド
の後で EXTRACT_SUFX に名前を設定し、パッケージの Makefile に以下の
設定を追加してください。

> EXTRACT_SUFX=   .msg.gz
> EXTRACT_CMD=            zcat
> EXTRACT_BEFORE_ARGS=
> EXTRACT_AFTER_ARGS=     |sh


 9.3 それ自身のサブディレクトリーを作り出さないパッケージ
 ========================================================

パッケージがサブディレクトリーを作らずに(例えば、GNU ソフトウェアのよ
うに)、カレントディレクトリーに展開される場合、もう一度 plan9/sam を
見てください。簡単にいうと以下の設定が必要です。

> NO_WRKSUBDIR=   yes


 9.4 カスタムコンフィギュレーションプロセス 
 ================================ 

パッケージが、かわった Configure スクリプトを使用している場合、top 
のパッケージを参照してください。簡単にいえば、以下の設定をおこなって
ください。

> HAS_CONFIGURE=          yes
> CONFIGURE_SCRIPT=       Configure
> CONFIGURE_ARGS+=        netbsd13


 9.5 DISTNAME ディレクトリーで作成されないパッケージ
 ===================================================

パッケージが、DISTNAME をベースにしないディレクトリーで構築される場合、
tcl、および tk パッケージを参考にしてください。

> WRKSRC=         ${WRKDIR}/${DISTNAME}/unix

 9.6 一度にすべての distfiles を取得する方法
 ===========================================

「make fecth」を実行できない職場や大学において、一回のバッチ処理で、
すべての distfiles をダウンロードしたいと思うことがあるかもしれません。
しかしながら、ftp.netbsd.org には distfiles のアーカイブはありません。
そして ftp.freebsd.org 上にあるアーカイブは、移植されていない多くの 
distfiles を含んでいます。

現時点では、「make fetch-list」を /usr/pkgsrc で実行し、その結果の
リストを使用してくださいとしかいえません、


 9.7 ファイアウォールの内側からファイルを取得する方法
 ====================================================

もし、あなたがファイヤーウォールの内側にいる場合、ファイヤーウォールの
内側にないインターネット上の他のマシンとの通信をおこなうために、適切な
プロキシーホストを指定する必要があります。これは URL 形式の環境変数で
指定します。例えば、Amdahl ドメインにおいては、orpheus.amdahl.com と
いうマシンはファイヤーウォールのひとつで、プロキシーポート番号として、
80 番のポートを使用します。この場合、proxy 環境変数は以下のようになり
ます。

	ftp_proxy=ftp://orpheus.amdahl.com:80/
	http_proxy=http://orpheus.amdahl.com:80/


 9.8 パッチが RCS IDを含む場合
 ============================

 パッチから RCS ID を削除する方法については、セクション 4.3 を参照して
 ください。


 9.9 /etc/mk.conf から変数を捕まえる方法 
 ============================================== 

MAKECONF や /etc/mk.conf で上書き可能な、パッケージで定義された変数に
は問題があります。それは、変数は make(1) がそれを使う時に展開されるが、
プリプロセッサー風の文(.if、.ifdef そして .ifndef)は読み込み時に評価
される事です。したがって、.if* 文内で変数(/etc/mk.confでセットされる
可能性のある)を使う時は、その .if* ステートメントの前に /etc/mk.conf
をインクルードしておかなくていけません。

/etc/mk.conf や MAKECONF が存在したら、それらをインクルードするという
ad-hoc な方法をとらずに、すべてのプリプロセッサ風の .if、.ifdef、また
は .ifndef 文の前で、pkgsrc/mk/bsd.prefs.mk をインクルードしてください。

	.include "../../mk/bsd.prefs.mk"

	.if defined(USE_MENUS)
	...
	.endif


 9.10 pkg について話しあうためのメーリングリストはありますか?
 ============================================================

はい。パッケージに関する問題を議論するために tech-pkg@netbsd.org が
存在します。購読するためには以下のようにして下さい。

    echo subscribe tech-pkg | mail majordomo@netbsd.org


 9.11 どうすれば 「make fetch」で passive FTP を使用することができますか?
 ========================================================================

/etc/make.conf に以下の設定を追加してください。PASSIVE_FETCH=1


 9.12 他のパッケージへの依存
 ===========================

パッケージは他のパッケージに依存するかもしれません。そして、この依存性
を定義するためのいろいろな方法があります。NetBSD は BUILD_DEPENDS、
RUN_DEPENDS、DEPENDS 定義をサポートしています(注意: DEPENDS 定義は 
FreeBSD のものと同じではありません。NetBSD は FreeBSD の LIB_DEPENDS
定義をもはや使用していません。ELF 化された NetBSD のプラットフォーム上
で問題が発生することがわかりました。)。

[以下の例において、BUILD_DEPENDS および RUN_DEPENDS には、決められた
フォーマットがあります。:<ファイル> :<作成するパッケージのディレクトリー>
[:<段階>]。もし、<段階>が指定されていなければ、「install」がデフォルト
となります。ファイルが 「/」を含む場合、それは通常ファイルとして解釈
されます。そうでない場合は、実行可能ファイルとしてあつかわれ、<ファイル>
をさがすために PATH が調べられます。もし、通常ファイルが見つからない、
あるいは実行可能ファイルがパス内に存在しなければ、必要なパッケージが 
<作成するパッケージのディレクトリー> 内のソースから作成されます。DEPENDS
定義はパッケージ名(バージョン番号を含む)と、そのバージョンのパッケージ
がインストールされていない場合のために、作成するパッケージのディレクトリー
を指定します。]

(a) パッケージを作成するために他のパッケージのファイルを必要とするなら、
print/ghostscript5 パッケージを参考にしてください。(作成中に jpeg の
ソースが存在することを前提としています)

BUILD_DEPENDS=  ../../graphics/jpeg/${WRKDIR:T}/jpeg-6a:../../graphics/jpeg:extract

(b) パッケージを構築するために他のパッケージが必要なら、BUILD_DEPENDS 
定義を使ってください。ただし、上の説明とは異なり、「:extract」を指定
してはいけません。print/lyx がよい例です。このパッケージは構築中に 
latex のバイナリーを使用します。

BUILD_DEPENDS=  latex:../../print/teTeX

(c) もし、パッケージがリンクのためのライブラリを必要とするなら、DEPENDS
定義を使ってください。たとえば、print/lyx パッケージは、作成のために 
xpm ライブラリーの バージョン 3.4j を使用します。

DEPENDS + = xpm - 3.4j :../../graphics/xpm 

また、パッケージ依存関係にはワイルドカードを使うことができます。

DEPENDS+=	xpm-*:../../graphics/xpm

ワイルドカードは、バイナリーパッケージを作る時に展開されることに注意
してください。したがって、バイナリーパッケージは、作成時にインストール
されていたライブラリーのバージョンに依存します。

(d) もし、パッケージを実行するために、いくつかの実行可能ファイルが必要
なら、RUN_DEPENDS 定義を使ってください。print/lyx パッケージを実行する
時には、latex と ispell のバイナリが実行可能でなければなりません。これ
は、以下のように指定します。

RUN_DEPENDS=    latex:../../print/teTeX \
                ispell:../../textproc/ispell


 9.13 他のパッケージとの衝突 
 ===========================

パッケージは、すでにインストール済みの別のパッケージと衝突する可能性が
あります。例えば、パッケージが、pkgsrc の中の別のパッケージと同じファイ
ルをインストールするような場合です。

この場合、衝突するパッケージ(バージョン文字列を含む)のリストをスペース
で区切って CONFLICTS にセットすることができます。

例えば、pkgsrc/x11/Xaw3d および pkgsrc/x11/Xaw-Xpm は同じ共有ライブラリ
をインストールします。したがって、pkgsrc/x11/Xaw3d/Makefile に以下のよう
な設定をおこなってください。

CONFLICTS=      Xaw-Xpm-*

そして、pkgsrc/x11/Xaw-Xpm/Makefile には以下の設定が必要です。

CONFLICTS=      Xaw3d-*

パッケージは、名前のプレフィックスが同じで、異なるバージョン文字列をもつ
別のパッケージと自動的に衝突します。例えば「Xaw3d-1.5」は、古いバージョン
の「Xaw3d-1.3」と衝突するでしょう。

 9.14 WWW ホームページがあるソフトウェア 
 ======================================= 

NetBSDパッケージシステムは、HOMEPAGE 変数をサポートしています。もし、
パッケージ化されたソフトウェアのホームページが存在するのであれば、その
ページの URL を Makefile の HOMEPAGE 変数に設定するべきです。この変数は
MAINTAINER 変数のすぐ後に定義してください。


 10 提出
 =======

 *コンパイル済みのバイナリーパッケージ:
  我々は、トロイの木馬等を含まないことを保証するために、NetBSD 開発者
  からしかバイナリーをうけとりません。これは、誰かを糞ったれ扱いするもの
  ではなく、むしろユーザーを保護するための方針です。しかしながら、あなた
  の作ったバイナリーパッケージをどこかに置き、配布することは自由におこな
  ってもかまいません。

 *パッケージ:
  最初にパッケージが完全かどうか、コンパイル、実行できるかどうかを確認
  してください。このドキュメントのセクション 8、その他を参考になるで
  しょう。次に、パッケージに必要なすべてのファイルの gzip された tar 
  ファイルを作成してください。これは、すべてのファイルをひとつのディレ
  クトリーにおきたいためです。次に、その tar ファイルを、パッケージの
  メンテナーが FTP か HTTP (WWW)を使用して取得できる場所においてくださ
  い。最後に、パッケージの名前とバージョンを含む概要、簡単な説明
  (pkg/COMMENT の内容でも OK です)、そして tar ファイルの URL を書き、
 「pkg」カテゴリーで障害レポートをおこなってください。

  障害レポートが処理されたら、あなたに連絡がいきます。そうすれば、tar 
  ファイルを削除してもかまいません。


 11 パッケージの簡単な例: bison
 ==============================

私は、FreeBSD のポート(ports)にないソフトウェアをさがし、GNU bison
を選びました。バークレーの yacc がすでにソースツリーに存在するので、
bison を使いたい人はいないでしょう。しかし、練習という意味では役に
たちます。


 11.1 ファイル 
 =============

このセクションのファイルの内容は、実際には 「> 」というプレフィックス
なしで使用してください。


 11.1.1 Makefile
 =============== 

> # <$>NetBSD<$>
>  
> DISTNAME=       bison-1.25
> CATEGORIES=     devel
> MASTER_SITES=   ${MASTER_SITE_GNU}
>
> MAINTAINER=     thorpej@netbsd.org
> HOMEPAGE=       http://www.gnu.org/software/bison/bison.html
>  
> GNU_CONFIGURE=  yes
> INFO_FILES=     bison.info
>  
> .include "../../mk/bsd.pkg.mk"


 11.1.2 pkg/COMMENT
 ================== 

> GNU yacc clone.


 11.1.3 pkg/DESCR
 ================ 

> GNU version of yacc.  Can make re-entrant parsers, and numerous other
> improvements.  Why you would want this when Berkeley yacc(1) is part
> of the NetBSD source tree is beyond me.


 11.1.4 pkg/PLIST
 ================ 

> @comment <$>NetBSD<$>
> bin/bison
> man/man1/bison.1.gz
> @unexec install-info --delete %D/info/bison.info %D/info/dir
> info/bison.info
> info/bison.info-1
> info/bison.info-2
> info/bison.info-3
> info/bison.info-4
> info/bison.info-5
> @exec install-info %D/info/bison.info %D/info/dir
> share/bison.simple
> share/bison.hairy


 11.1.5 パッケージをチェックする 「pkglint」
 ==========================================

NetBSD パッケージシステムは、「pkglint」(pkgsrc/pkgtools/pkglint
ディレクトリーにあります)とよばれるツールを含んでいます。このツールは
これらのファイルの内容をチェックするのを助けてくれます。一度インス
トールしてしまえば、このツールは非常に簡単に使うことができます。検査
したいパッケージのディレクトリーに移動し、「pkglint」を実行するだけです。

> tron@lyssa:/usr/pkgsrc/devel/bison>pkglint
> OK: checking pkg/COMMENT.
> OK: checking pkg/DESCR.
> OK: checking Makefile.
> OK: checking files/md5.
> OK: checking patches/patch-aa.
> looks fine.

指定されたコマンド行の引き数(「man pkglint」を見てください)によっては、
よりきびしいチェックがおこなわれます。例えば「pkglint -a -v」は、大変
詳細かつ冗長なチェックをおこないます。


 11.2 構築、インストール、パッケージングの手順
 =============================================

パッケージのためのディレクトリーと、いくつかの追加のディレクトリーを
作成します。

> root@pumpy:/u/pkgsrc/lang(1765)# cd /usr/pkgsrc/lang
> root@pumpy:/u/pkgsrc/lang(1765)# mkdir bison
> root@pumpy:/u/pkgsrc/lang(1766)# cd bison
> root@pumpy:/u/pkgsrc/lang/bison(1768)# mkdir files patches pkg

セクション 11.1 のように Makefile、pkg/COMMENT、pkg/DESCR、および
pkg/PLISTを作り、distfile を取得します。

> root@pumpy:/u/pkgsrc/lang/bison(1769)# make fetch
> >> bison-1.25.tar.gz doesn't seem to exist on this system.
> >> Attempting to fetch from ftp://prep.ai.mit.edu/pub/gnu//.
> Requesting ftp://prep.ai.mit.edu/pub/gnu//bison-1.25.tar.gz (via ftp://orpheus.amdahl.com:80/)
> ftp: Error retrieving file: 500 Internal error
>  
> >> Attempting to fetch from ftp://wuarchive.wustl.edu/systems/gnu//.
> Requesting ftp://wuarchive.wustl.edu/systems/gnu//bison-1.25.tar.gz (via ftp://orpheus.amdahl.com:80/)
> ftp: Error retrieving file: 500 Internal error
>  
> >> Attempting to fetch from ftp://ftp.freebsd.org/pub/FreeBSD/distfiles//.
> Requesting ftp://ftp.freebsd.org/pub/FreeBSD/distfiles//bison-1.25.tar.gz (via ftp://orpheus.amdahl.com:80/)
> Successfully retrieved file.

distfile のチェックサムを files/md5 へ作成します。

> root@pumpy:/u/pkgsrc/lang/bison(1770)# make makesum

コンパイルします。

> root@pumpy:/u/pkgsrc/lang/bison(1777)# make
> >> Checksum OK for bison-1.25.tar.gz.
> ===>  Extracting for bison-1.25
> ===>  Patching for bison-1.25
> ===>   Ignoring empty patch directory
> ===>  Configuring for bison-1.25
> creating cache ./config.cache
> checking for gcc... cc
> checking whether we are using GNU C... yes
> checking for a BSD compatible install... /usr/bin/install -c -o bin -g bin
> checking how to run the C preprocessor... cc -E
> checking for minix/config.h... no
> checking for POSIXized ISC... no
> checking whether cross-compiling... no
> checking for ANSI C header files... yes
> checking for string.h... yes
> checking for stdlib.h... yes
> checking for memory.h... yes
> checking for working const... yes
> checking for working alloca.h... no
> checking for alloca... yes
> checking for strerror... yes
> updating cache ./config.cache
> creating ./config.status
> creating Makefile
> ===>  Building for bison-1.25
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g LR0.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g allocate.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g closure.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g conflicts.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g derives.c
> cc -c -DXPFILE=\"/usr/pkg/share/bison.simple\"  -DXPFILE1=\"/usr/pkg/share/bison.hairy\" -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1  -g  ./files.c 
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g getargs.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g gram.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g lalr.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g lex.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g main.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g nullable.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g output.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g print.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g reader.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g reduce.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g symtab.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g warshall.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g version.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g getopt.c
> cc -c -DSTDC_HEADERS=1 -DHAVE_STRING_H=1 -DHAVE_STDLIB_H=1 -DHAVE_MEMORY_H=1 -DHAVE_ALLOCA=1 -DHAVE_STRERROR=1 -I./../include  -g getopt1.c
> cc  -g -o bison LR0.o allocate.o closure.o conflicts.o derives.o files.o         getargs.o gram.o lalr.o lex.o                                   main.o nullable.o output.o print.o reader.o reduce.o symtab.o   warshall.o version.o                        
                    getopt.o getopt1.o  
> ./files.c:240: warning: mktemp() possibly used unsafely, consider using mkstemp()
> rm -f bison.s1
> sed -e "/^#line/ s|bison|/usr/pkg/share/bison|" < ./bison.simple > bison.s1

すべて OK のようなので、ファイルをインストールします。

> root@pumpy:/u/pkgsrc/lang/bison(1785)# make install
> >> Checksum OK for bison-1.25.tar.gz.
> ===>  Installing for bison-1.25
> sh ./mkinstalldirs /usr/pkg/bin /usr/pkg/share  /usr/pkg/info /usr/pkg/man/man1
> rm -f /usr/pkg/bin/bison
> cd /usr/pkg/share; rm -f bison.simple bison.hairy
> rm -f /usr/pkg/man/man1/bison.1 /usr/pkg/info/bison.info*
> install -c  -o bin -g bin -m 555 bison /usr/pkg/bin/bison
> /usr/bin/install -c -o bin -g bin -m 644 bison.s1 /usr/pkg/share/bison.simple
> /usr/bin/install -c -o bin -g bin -m 644 ./bison.hairy /usr/pkg/share/bison.hairy
> cd .; for f in bison.info*;  do /usr/bin/install -c -o bin -g bin -m 644 $f /usr/pkg/info/$f; done
> /usr/bin/install -c -o bin -g bin -m 644 ./bison.1 /usr/pkg/man/man1/bison.1
> ===>  Registering installation for bison-1.25

これで bison を使用することができます。そして、「pkg_delete bison-1.25」
を実行することで bison を削除することもできます。もし、バイナリーパッケージ
が欲しければ、以下のようにしてください。

> root@pumpy:/u/pkgsrc/lang/bison(1786)# make package
> >> Checksum OK for bison-1.25.tar.gz.
> ===>  Building package for bison-1.25
> Creating package bison-1.25.tgz
> Registering depends:.
> Creating gzip'd tar ball in '/u/pkgsrc/lang/bison/bison-1.25.tgz'

もし、ソースやオブジェクトファイルが必要ないのであれば、掃除してください。

> root@pumpy:/u/pkgsrc/lang/bison(1787)# make clean
> ===>  Cleaning for bison-1.25


=================
付録A: 構築のログ
=================

 A.1 top の構築
 ==============

> Script started on Fri Oct  3 13:22:31 1997
> root@pumpy:/u/pkgsrc/sysutils/top(1342)# make
> >> top-3.5beta5.tar.gz doesn't seem to exist on this system.
> >> Attempting to fetch from ftp://ftp.groupsys.com/pub/top/.
> Requesting ftp://ftp.groupsys.com/pub/top/top-3.5beta5.tar.gz (via ftp://orpheus.amdahl.com:80/)
> Successfully retrieved file.
> >> Checksum OK for top-3.5beta5.tar.gz.
> ===>  Extracting for top-3.5beta5
> ===>  Patching for top-3.5beta5
> ===>  Applying NetBSD patches for top-3.5beta5
> ===>  Configuring for top-3.5beta5
> /bin/cp /u/pkgsrc/sysutils/top/files/defaults /u/pkgsrc/sysutils/top/work/top-3.5beta5/.defaults
> chmod a-x /u/pkgsrc/sysutils/top/work/top-3.5beta5/install
> 
> Reading configuration from last time...
> 
> Using these settings:
>         Bourne Shell   /bin/sh
>           C compiler   cc
>     Compiler options   -DHAVE_GETOPT -O
>          Awk command   awk
>      Install command   /usr/bin/install
> 
>               Module   netbsd13
>              LoadMax   5.0
>         Default TOPN   -1
>         Nominal TOPN   18
>        Default Delay   2
> Random passwd access   yes
>           Table Size   47
>                Owner   root
>          Group Owner   kmem
>                 Mode   2755
>        bin directory   $(PREFIX)/bin
>        man directory   $(PREFIX)/man/man1
>        man extension   1
>        man style       man
> 
> Building Makefile...
> Building top.local.h...
> Building top.1...
> Doing a "make clean".
> rm -f *.o top core core.* sigdesc.h
> To create the executable, type "make".
> To install the executable, type "make install".
> ===>  Building for top-3.5beta5
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c top.c
> awk -f sigconv.awk /usr/include/sys/signal.h >sigdesc.h
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c commands.c
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c display.c
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c screen.c
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c username.c
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c utils.c
> utils.c: In function `errmsg':
> utils.c:348: warning: return discards `const' from pointer target type
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c version.c
> cc -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O  -c getopt.c
> cc "-DOSREV=12G" -DHAVE_GETOPT -DORDER -DHAVE_GETOPT -O -c machine.c
> rm -f top
> cc -o top top.o commands.o display.o screen.o username.o  utils.o version.o getopt.o machine.o -ltermcap -lm -lkvm
> root@pumpy:/u/pkgsrc/sysutils/top(1343)# make install
> >> Checksum OK for top-3.5beta5.tar.gz.
> ===>  Installing for top-3.5beta5
> /usr/bin/install -o root -m 2755 -g kmem top /usr/pkg/bin
> /usr/bin/install top.1 /usr/pkg/man/man1/top.1
> strip /usr/pkg/bin/top
> ===>  Registering installation for top-3.5beta5
> root@pumpy:/u/pkgsrc/sysutils/top(1344)# 


 A.2 top のパッケージング
 ========================

> root@pumpy:/u/pkgsrc/sysutils/top(1344)# make package
 > >> Checksum OK for top-3.5beta5.tar.gz.
> ===>  Building package for top-3.5beta5
> Creating package top-3.5beta5.tgz
> Registering depends:.
> Creating gzip'd tar ball in '/u/pkgsrc/sysutils/top/top-3.5beta5.tgz'
> root@pumpy:/u/pkgsrc/sysutils/top(1345)#


=================================================
付録B:FTPサーバのパッケージアーカイブのレイアウト
=================================================

ftp.netbsd.org 上のコンパイル済みのバイナリーパッケージのレイアウト

/pub/NetBSD/packages/
                README
                distfiles/
		pkgsrc -> /pub/NetBSD/NetBSD-current/pkgsrc
                1.3/
                        i386/
                                All/
                                archivers/
                                        foo -> ../All/foo
                                ...
                        m68k/
                                All/
                                archivers/
                                        foo -> ../All/foo
                                ...
                        amiga -> m68k
                        atari -> m68k
                        ...


作成:
 - cd /usr/pkgsrc ; make install ; make package
 - /usr/pkgsrc/packages を ftp://ftp.netbsd.org/pub/NetBSD/packages/`uname -r`/`sysctl -n hw.machine_arch` へアップロードする。
 - 必要なら ln -s `sysctl -n hw.machine` `sysctl -n hw.machine_arch`

必要なディスクスペース: 不明


###########################################################################
# Local Variables:
# mode:				Text
# fill-column:			75
# sentence-end-double-space:	nil
# End:
