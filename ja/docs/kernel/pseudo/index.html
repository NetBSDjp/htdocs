<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="Website XSL Stylesheet V2.6.0">
<link rel="home" href="../../../../." title="Welcome to The NetBSD Project: Of course it runs NetBSD.">
<link rel="up" href="../../../../ja/docs/kernel/." title="NetBSD ドキュメンテーション: カーネル">
<link rel="previous" href="../../../../ja/docs/kernel/profiling/." title="NetBSD ドキュメンテーション: カーネルプロファイリング HOWTO">
<link rel="next" href="../../../../ja/docs/kernel/programming.html" title="NetBSD ドキュメンテーション: カーネルプログラミング FAQ">
<link rel="first" href="../../../../ja/docs/kernel/lazyfpu.html" title="NetBSD ドキュメンテーション: どのように lazy FPU コンテキストスイッチは動作するのか">
<link rel="last" href="../../../../ja/docs/kernel/elf-notes.html" title="NetBSD ドキュメンテーション: ベンダー特有の ELF 記号要素(Note Elements)">
<link rel="stylesheet" href="../../../../global.css" type="text/css">

  

    <title>NetBSD ドキュメンテーション: 擬似デバイスの書き方</title>
  </head>
<body class="website"><div class="webpage">
<a name="ja-docs-kernel-pseudo-index"></a><div id="top"><a href="#mainContent" class="doNotDisplay doNotPrint">本文へ飛ぶ。</a></div>
<div id="header">
<div class="topNavigation">
<span>» </span><a href="../../../../docs/guide/en/">
	  ガイド</a> |
	<a href="http://man.NetBSD.org/">マニュアルページ</a> |
	<a href="../../../../ja/mailinglists/">
	  メーリングリスト</a>と
	<a href="http://mail-index.NetBSD.org/">記事</a> |
	<a href="http://cvsweb.NetBSD.org/">CVS リポジトリー</a> |
	バグの<a href="http://www.NetBSD.org/cgi-bin/sendpr.cgi?gndb=netbsd">報告</a>
	と
	<a href="../../../../ja/support/query-pr.html">
	 照会</a> |
	<a href="../../../../ja/docs/software/packages.html">
	  ソフトウェアパッケージ
	</a>
</div>
<div class="centralHeader">
<a href="../../../../ja/"><img alt='NetBSD プロジェクト "Of course it runs NetBSD"' width="506" height="90" src="../../../../images/NetBSD-headerlogo.png"></a><div class="headerTools"><div id="headerSearch"><form method="get" action="http://www.google.com/custom">
<input class="whiteOnBlack" type="text" name="q" onfocus="if(this.value==this.defaultValue ) this.value='';" size="12" maxlength="255" value="Search"><input type="hidden" name="cof" value="L:http://www.NetBSD.org/images/NetBSD-smaller.png;LH:200;LW:200;AH:center;AWFID:4f6b0499f0f58d2c;"><input type="hidden" name="domains" value="NetBSD.org"><input type="hidden" name="sitesearch" value="www.NetBSD.org"><input type="submit" value="検索">
</form></div></div>
</div>
<div class="navBar">
<span class="doNotDisplay">
	  案内:
	</span><a href="../../../../ja/">
	  ホーム</a> | 
	<a href="../../../../ja/about/">
	  概要</a> | 
	<a href="../../../../ja/gallery/">
	  展示室</a> | 
	<a href="../../../../ja/releases/">
	  ダウンロード</a> | 
	<a href="../../../../ja/docs/">
	  ドキュメンテーション</a> | 
	<a href="../../../../ja/support/">
	  サポート</a> | 
	<a href="../../../../ja/community/">
	  コミュニティー</a> | 
	<a href="../../../../ja/ports/">
	  機種</a>
</div>
</div>
<div id="content"><div class="fullWidth"><div class="rowOfBoxes">
<h1>NetBSD ドキュメンテーション: 擬似デバイスの書き方</h1>
<h3 class="title"><a name="pseudo">擬似デバイスの書き方</a></h3>
<ul>
<li><a href="#intro">序説</a></li>
<li><a href="#your_code">あなたのコード</a></li>
<li><a href="#functions">関数</a></li>
<li><a href="#newdevice">カーネルに新しいデバイスを知らせる</a></li>
<li><a href="#config">config(1) に新しいデバイスを知らせる</a></li>
<li><a href="#kernelconfig">カーネルコンフィグファイルに新しいデバイスを追加する</a></li>
<li><a href="#userlevel">ユーザーレベルプログラムが新しいデバイスにアクセスすることを許す</a></li>
</ul>
<hr>
<h3 class="title">擬似デバイスの書き方</h3>
        <h4 class="title">
<a name="intro"></a>序説 (<a href="#pseudo">top</a>)
  </h4>
	
	<p>このドキュメントはカーネルドライバーを書いてみようという方へのガイドです。
	  ここではシンプルな擬似デバイスドライバーの書き方を扱います。
	  カーネルの構築、makefile 関連や新しいカーネルのインストールに関する他の奥義
	  はこれらはこのドキュメントには含まれてなく(別に)必要です。
	  また、カーネルプログラミングそれ自体も含まれていなく
	   - これは、ユーザーレベルプログラミングとは多くの面でとても違います。
	  という断り書きをした上で、この文章を読めば、あなたのコードを
	  カーネルに加えて動作させることができるようになります。</p>
      
        <h4 class="title">
<a name="your_code"></a>あなたのコード (<a href="#pseudo">top</a>)
  </h4>

	<p><a class="ulink" href="../../../../docs/kernel/pseudo/pseudo_dev_skel.c" target="_top">pseudo_dev_skel.c</a> ファイルが
	  擬似デバイスとファイルの骨格となります。
	  <a class="ulink" href="../../../../docs/kernel/pseudo/pseudo_dev_skel.h" target="_top">pseudo_dev_skel.h</a> では 
	  kernel 関数プロトタイプと ioctl データ構造 と加えて ioctl 番号自体を定義します。
	  注として、普通のデバイスドライバーと違って、
	  擬似デバイスドライバーには、プローブルーチンは必要ないので持っていません。
	  このため、autoconfig フレームワークを扱う必要がなく、話が簡単になります。
	  この skeleton ファイルは擬似デバイスの open, close, ioctl calls をサポートします。
	  これは、実際の擬似デバイスにおいて最低限実用的なコールのセットです。
	  read, write, mmap や ほかの デバイス 関数 をサポートするためのほかのコールもありますが、
	  詳細を除けば全て open, close, ioctl のパターンと同様に扱えます。</p>

	<p>   たぶん、最初の重要な決定は、新しいデバイスをなんと呼ぶかを決めることです。
	  関数コール名の前にデバイス名をくっつけた kernel 構造体をつくるのに
	  便利なマクロがたくさんあることが知られていて、これは
	  作りたいカーネルコンフィグファイルエントリーの助けになるでしょう。
	  config ファイルエントリーはヘッダーファイル名と合わせる必要はありません。
	  この skeleton ドライバー では、 <span class="quote">“<span class="quote">skeleton</span>”</span> 擬似デバイスと呼ぶ事にしたので
	  skeleton というエントリーを コンフィグファイルに作る事になります。
	  つまり、 attach, open, close, ioctl 関数 呼び出しcall の名前を、それぞれ
	  skeletonattach, skeletonopen, skeletonclose, skeletonioctl とすると言う事です。
	  もう1つの重要なのはデバイスの種類を決めることで -
	  あなたのコードが、カーネルと、もちろん、あなたのコード自体と、どう相互作用するかで
	  キャラクター型 か ブロック デバイス のどちらかにします。
	  ブロック型対キャラクター型のデバイスの決定は、
	  ドライバーが会話する根底の ハードウェアにかなり依存し、
	  もしドライバーがデータの読書きを一定の塊で行なうデバイスなら
	  ブロックデバイスが良い選択で、そのようなデバイスの例として、
	  ハードディスクはたいてい 512 byte セクターをブロックとして読み書きします。
	  ハードウェアが一度に読み書きするのが 1 byte のデータなら、
	  普通、キャラクター型デバイスが最もよい選択で、
	  例えば、シリアルラインドライバーがそうです。
	  注として、いくつかのドライバーはデバイスのアクセスに
	  ブロックモードとキャラクターモードの両方をサポートしていて、
	  この場合、キャラクターモードはしばしば "raw" デバイスと呼ばれます。
	  それは、アクセス時に
	  データブロック抽出操作(the data blocking abstractions operating) なしに
	  ハードウェアのアクセスができるからです。
	  擬似デバイスでは、考慮するべき根底のハードウェアがないので、より柔軟に選べます。
	  擬似デバイスを使ってする内容により選択し、ブロック型デバイスは 
	  ハードディスクやそのようなもののエミュレートには便利でしょう。
	  skeleton ドライバーは キャラクター型デバイスです。</p>

	<p>それを決定したら、コードを編集することができますが、
	  その前にファイルをどこに置くか決めることが必要です。
	  複数のアーキテクチャーで使われる擬似デバイスを書くなら、
	  そのドライバーのコードの置き場は <code class="filename">/usr/src/sys/dev</code> です。
	  もし擬似デバイスが個別のアーキテクチャーに特有の物なら、
	  ドライバーのコードは個別のディレクトリーの下に置き、
	  i386 の例では、 <code class="filename">/usr/src/sys/arch/i386/i386</code> です。
	  インクルードファイルについては、
	  アーキテクチャー非依存のデバイスは <code class="filename">/usr/src/sys/sys</code> に、
	  アーキテクチャー特有のデバイスでは、
	  アーキテクチャー個別のディレクトリーの下の <code class="filename">include</code> ディレクトリー、
	  例えば i386 アーキテクチャーでは
	  <code class="filename">/usr/src/sys/arch/i386/include</code> に置くべきです。
	  どちらの場合でも、適切な <code class="filename">Makefile</code> を更新してください。
	  それで、インクルードファイルがインストールされます。
	  <a class="ulink" href="../../../../docs/kernel/pseudo/pseudo_dev_skel.c" target="_top">pseudo_dev_skel.c</a> の先頭に
	  <code class="code">struct
	  skeleton_softc</code> を書いてください。
	  デバイス名に "_softc" が書き添えられた名前で softc 構造体の宣言が必要で、
	  この構造体の最初の要素は <code class="code">struct device</code> 型である必要があり、
	  エントリー名は重要ではありませんが、最初にある必要があり、
	  autoconfig システムが softc struct が宣言されていることをあてにしているから
	  で、その最初の要素は struct device です。
	  デバイスハンドル minor 番号 ごとに softc struct が必要です。
	  softc 構造体は minor デバイスがそれを維持する状態の情報を、必要に応じて
	  ただの struct device より多くの要素を持つことができます。</p>

      
        <h4 class="title">
<a name="functions"></a>関数 (<a href="#pseudo">top</a>)
  </h4>

	<p>ユーザーレベルプログラムによるアクセスには
	  カーネルインターフェースはデバイスに対しては関数のコールを通して行ないます。
	  デバイスは後に示すように全ての関数をサポートする必要はありませんが、
	  実用的なデバイスは最低限オープンとクローズをサポートする必要はあります。
	  関数名はデバイス名を前につけることを思い出してください。
	  この関数は:</p>

	<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
	    <p><code class="function">attach()</code></p>
	    <p>この関数はカーネルが初期化するときに一度呼び出されます。
	      これは、あらゆる変数の設定に使われ、
	      後のコールや、バッファーが必要とするカーネルメモリー割り当て
	      で参照されます。
	      attach 関数には引数が一つ渡されます。これはこのドライバーが扱う
	      デバイスの数です。</p>
	  </li>
<li class="listitem">
	    <p><code class="function">open()</code></p>
	    <p>その名が示すように、ユーザーレベルプログラムが
	      デバイスに対して <a href="http://netbsd.gw.com/cgi-bin/man-cgi?open+2+NetBSD-5.1+i386">open(2)</a> コールをした時に呼び出されます。
	      一番簡単な場合、 open 関数は単に success で戻るだけです。
	      より一般に open call は
	      バッファーの要求と可能なら allocate することや
	      他ドライバー関数のコールをサポートするため
	      他のドライバーの状態を初期化することを有効にします。
	      open call は下記のパラメーターが使え:</p>
	    <div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
	        <p><em class="parameter"><code>dev</code></em></p>
		<p>open しようとするデバイスのマイナー番号。</p>
              </li>
<li class="listitem">
	        <p><em class="parameter"><code>flags</code></em></p>
		<p>open call に渡されるフラグ</p> 
	      </li>
<li class="listitem">
	        <p><em class="parameter"><code>mode</code></em></p>
		<p>open のモード</p> 
	      </li>
<li class="listitem">
	        <p><em class="parameter"><code>proc</code></em></p>
		<p>オープン要求をしているプロセスの proc 構造体のポインター
                  これは、そのプロセスが
                  信頼できるものである(資格証明を有効にしてよい)ことを示します。</p>
	      </li>
</ul></div>
	  </li>
<li class="listitem">
	    <p><code class="function">close()</code></p>
	    <p>open されていたデバイスを close します。
	      ドライバーによって、これはただ単純に success で戻るだけのものだったり、
	      あるいは、割り当てられていたメモリーの解放や
	      ドライバーの状態変数を、もはや open されてはいないと示すように変更する
	      必要があったりします。
	      close 関数呼び出しのパラメーターは、 open で記述したのと同じです。</p>
	  </li>
<li class="listitem">
	    <p><code class="function">read()</code></p>
	    <p>デバイスからデータを読み出します。
	      この関数のパラメーターは:</p>
	    <div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
	        <p><em class="parameter"><code>dev</code></em></p>
		<p>デバイスのマイナー番号。</p>
	      </li>
<li class="listitem">
	        <p><em class="parameter"><code>uio</code></em></p>
		<p> uio 構造体へのポインターです。
		  read 関数は uio 構造体 にユーザーが欲しいデータを満たして戻ります。</p>
	      </li>
<li class="listitem">
	        <p><em class="parameter"><code>flags</code></em></p>
		<p>flags</p> 
	      </li>
</ul></div>
	  </li>
<li class="listitem">
	    <p><code class="function">write()</code></p>
	    <p>デバイスにデータを書きこみます。
	      write 関数 のパラメーターは、 read 関数のものと同じで - ただ、違うのは
	      uio 構造体はデバイスに書きこまれるデータを含んでいることです。</p>
	  </li>
<li class="listitem">
	    <p><code class="function">ioctl()</code></p>
	    <p>デバイスに ioctl をします。
	      ioctl call のパラメーターは:</p>
	    <div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
	        <p><em class="parameter"><code>dev</code></em></p>
		<p>デバイスのマイナー番号。</p>
	      </li>
<li class="listitem">
	        <p><em class="parameter"><code>cmd</code></em></p>
		<p>実行される ioctl コマンドです。
                  このコマンドはヘッダーファイル内で定義され
                  カーネルコードおよびユーザーレベルコードが参照します。
                  例は<a class="ulink" href="../../../../docs/kernel/pseudo/pseudo_dev_skel.c" target="_top">サンプルのヘッダー</a>を見てください。</p>
	      </li>
<li class="listitem">
	        <p><em class="parameter"><code>data</code></em></p>
		<p>ユーザーレベルコードで使えるパラメーターのポインターです。
                  このパラメーターは ioctl の実装と、実際に発行されたコマンドに依存します。</p>
	      </li>
<li class="listitem">
	        <p><em class="parameter"><code>flags</code></em></p>
		<p>flags</p> 
	      </li>
<li class="listitem">
	        <p><em class="parameter"><code>proc</code></em></p>
		<p>ioctl 要求を出したユーザーレベルプロセスに関連する
                  proc 構造体 です。</p>
	      </li>
</ul></div>
	  </li>
<li class="listitem">
	    <p><code class="function">stop()</code></p>
	    <p>tty 様式デバイスで出力を停止します。</p>
	    <div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
	        <p><em class="parameter"><code>tty</code></em></p>
		<p>デバイスに結び付けられた tty</p>
	      </li>
<li class="listitem">
	        <p><em class="parameter"><code>flags</code></em></p>
		<p>flags</p> 
	      </li>
</ul></div>
	  </li>
<li class="listitem">
	    <p><code class="function">poll()</code></p>
	    <p>デバイスからデータが読めるかチェックします。
	      パラメーターは:</p>
	    <div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
	        <p><em class="parameter"><code>dev</code></em></p>
		<p>デバイスが使っているマイナー番号。</p>
	      </li>
<li class="listitem">
	        <p><em class="parameter"><code>events</code></em></p>
		<p>ユーザーレベルコールがポーリングするイベント。</p>
	      </li>
<li class="listitem">
	        <p>proc</p>
		<p>ioctl 要求を出したユーザーレベルプロセスに関連する
		  proc 構造体 です。</p>
	      </li>
</ul></div>
	  </li>
<li class="listitem">
	    <p><code class="function">mmap()</code></p>
	    <p>ドライバーのバッファーをユーザーレベルプログラムのメモリー空間に mmap する
	      権限をサポートします。パラメーターは:</p>
	    <div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
	        <p><em class="parameter"><code>dev</code></em></p>
		<p>デバイスが使っているマイナーデバイス番号。</p>
	      </li>
<li class="listitem">
	        <p><em class="parameter"><code>offset</code></em></p>
		<p>mmap 開始時のバッファーの先頭からのオフセット。</p>
	      </li>
<li class="listitem">
	        <p><em class="parameter"><code>prot</code></em></p>
		<p>mmap の挙動のタイプで、
                  読みこみ専用、書きこみ専用、読み書き可能かのいずれかです。
                  デバイスドライバーは全てをサポートする必要はありません。</p>
	      </li>
</ul></div>
	  </li>
</ol></div>

	<p>このデバイスドライバーがサポートする関数を、
	  キャラクター型デバイス用の <code class="code">struct cdevsw</code> と
	  <code class="code">struct bdevsw</code> のいずれかまたは両方に含める必要があります。
	  この構造体の名前は、モジュール名の後に <code class="code">_cdevsw</code> または <code class="code">_bdevsw</code>
	  を付けたものです。
	  ここで例示する疑似デバイスは、キャラクター型デバイスとしてのみふるまうので、
	  構造体の名前は <code class="code">skeleton_cdevsw</code> とします。
	  なお、この構造体には、すべてのデバイスインターフェース関数のエントリーがありますが、
	  デバイス側で実装するのは、この関数の一部分だけでかまいません。
	  使われないスタブ関数をすべてのデバイスに実装させるのではなく、
	  頭に <code class="code">no</code> がついた (たとえば <code class="code">noread</code>,
	  <code class="code">nowrite</code> など)、
	  あらかじめ宣言されたスタブが用意されており、これらは呼ばれた時に <code class="code">ENODEV</code>
	  または、何の操作もせずに成功を返す <code class="code">null</code>
	  (たとえば <code class="code">nullread</code>, <code class="code">nullwrite</code>
	  など) を返します。
	  cdevsw や bdevsw にある関数でドライバーがサポートしていないものに対しては、
	  あらかじめ宣言されたスタブのものを使うだけです。</p>

      
        <h4 class="title">
<a name="newdevice"></a>カーネルに新しいデバイスを知らせる (<a href="#pseudo">top</a>)
  </h4>

	<p>擬似デバイスのコーディングをしたら、
	  アクセスできるよう、カーネルに組み込みます。
	  注として、カーネルが擬似デバイスを組みこむ方法は
	  通常のデバイスの場合と、いろいろ違います。
	  擬似デバイスは、通常のデバイス検出と auto-configuration を飛ばし、
	  実行時の代わりにソースレベルでカーネル構造体の中にエントリーを作ったり
	  そうではなかったりするからです。
	  カーネルがあなたのコードを使うようにするには、
	  これらのファイルを変更する必要があって:</p>

        <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
	    <p><code class="filename">/usr/src/sys/conf/majors</code> or
	      <code class="filename">/usr/src/sys/&lt;arch&gt;/conf/majors.&lt;arch&gt;</code></p>

	    <p>この各ファイルには、
	      NetBSD におけるデバイスメジャー番号のリストが含まれます。
	      <code class="filename">/usr/src/sys/conf/majors</code> にあるのは、機種独立なデバイス、すなわち
	      NetBSD が対応しているすべてのアーキテクチャーで利用可能なデバイスのメジャー番号です。
	      デバイスが特定のアーキテクチャーにのみ関連するものである場合は、
	      <code class="filename">/usr/src/sys/&lt;arch&gt;/conf/majors.&lt;arch&gt;</code>
	      (&lt;arch&gt; は、関連するアーキテクチャーに置き換えます)
	      ファイルを使う必要があります。
	      この各ファイルに含まれるエントリーは、以下の形式をとります。</p>

	    <pre class="programlisting">
device-major    prefix		type      number	condition</pre>
	    <p>この行の正確な文法は、
	      <a href="http://netbsd.gw.com/cgi-bin/man-cgi?config+5+NetBSD-5.1+i386">config(5)</a> マニュアルページで説明されていますが、
	      ここで例示するドライバーのためにその内容を説明しておきます。</p>

	    <div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
	        <p>device-major</p>
		<p>このエントリーが、
		  デバイスメジャー番号のエントリーであることを示すキーワードです。</p>
	      </li>
<li class="listitem">
	        <p>prefix</p>
		<p>すべてのドライバーの関数に対して、
		  関数名が自動生成される時に与えられる接頭辞です。
		  ここでの例においては、
		  <code class="code">skeleton</code> とします。</p>
	      </li>
<li class="listitem">
	        <p>type</p>
		<p>メジャーデバイスの型で、
		  <code class="code">char</code> または <code class="code">block</code> のいずれかです。
		  char と block それぞれの type と number の組を繰り返し書くことで、
		  両方の型のデバイスを指定することができます。</p>
	      </li>
<li class="listitem">
	        <p>number</p>
		<p>デバイスのメジャー番号です。次の空いている番号を選びます。
		  なお、<code class="filename">/dev</code> にデバイスノードを作る必要があるので、
		  選んだ番号を控えておきます。</p>
	      </li>
<li class="listitem">
	        <p>condition</p>
		<p>このデバイスがカーネルに含まれる条件です。
		  これは、conf ファイル (後述)
		  に含めた疑似デバイスのエントリーと一致させるようにします。</p>
	      </li>
</ul></div>

	    <p>ここで例示する skeleton 疑似デバイスは、キャラクター型デバイスとし、
	      ドライバーは i386 アーキテクチャーに依存するものとします。
	      このような仮定をしたので、
	      <code class="filename">/usr/src/sys/arch/i386/conf/majors.i386</code>
	      ファイルを編集すればよいことになります。すると、
	      メジャー番号 140 が使えることがわかるので、以下のような行を追加します。</p>
	    <pre class="programlisting">
device-major	skeleton	char	140	skeleton</pre>
	  </li></ol></div>
      
        <h4 class="title">
<a name="config"></a><a href="http://netbsd.gw.com/cgi-bin/man-cgi?config+1+NetBSD-5.1+i386">config(1)</a> に新しいデバイスを知らせる (<a href="#pseudo">top</a>)
  </h4>

	<p><a href="http://netbsd.gw.com/cgi-bin/man-cgi?config+1+NetBSD-5.1+i386">config(1)</a> に新しい擬似デバイスを知らせるには、
	  <code class="filename">/usr/src/sys/conf/files</code> (アーキテクチャー独立なデバイスの場合) または
	  <code class="filename">/usr/src/sys/arch/&lt;arch&gt;/conf/files.&lt;arch&gt;</code>
	  (&lt;arch&gt; は関連するアーキテクチャー) のいずれかのファイルを編集します。
	  このファイルは  有効な デバイスの名前 と
	  これらのデバイスと関連するファイルを config に教えます。
	  最初に擬似デバイスを定義するセクションを捜します。
	  この セクションは <code class="code">defpseudo</code> で始まる行を持っています。
	  ここでは、ドライバーはアーキテクチャー依存であることを仮定しているので、
	  <code class="filename">/usr/src/sys/arch/i386/conf/files.i386</code>
	  を編集します。
	  正しいセクションを見つけると、こういう行を加えることができ:</p>

	<pre class="programlisting">
defpseudo skeleton</pre>

        <p><a href="http://netbsd.gw.com/cgi-bin/man-cgi?config+1+NetBSD-5.1+i386">config(1)</a>に skeleton という擬似デバイスがあることを教えます。
	  つぎに、 <a href="http://netbsd.gw.com/cgi-bin/man-cgi?config+1+NetBSD-5.1+i386">config(1)</a> に skeleton 擬似デバイスに関連するファイルを教えてあげる必要があります。
	  この場合はひとつのファイル
	  があるだけですが、より複雑な擬似デバイスでは より多くのファイルがあるかもしれず、
	  同じ方法で必要とされるファイルごとに行を単純に追加していきます。
	  例では、このような1行が必要なだけで:</p>

	<pre class="programlisting">
file dev/skeleton.c	   skeleton	needs-flag</pre>

        <p>行中の <code class="code">file</code> はデバイスとファイルの関係の定義 
	  を書くためのキーワードです。
	  2番目のフィールドは、ファイルの
	  カーネルソースツリールートからの相対位置 (通常、
	  <code class="filename">/usr/src/sys</code>) です。
	  3番目のフィールドはドライバー名でこのファイルが関連しているもので、
	  この場合 skeleton - サンプル擬似デバイスです。
	  4番目 で 最後の フィールド は <a href="http://netbsd.gw.com/cgi-bin/man-cgi?config+1+NetBSD-5.1+i386">config(1)</a> に
	  <code class="filename">skeleton.h</code> インクルードファイルを書かせるための制御フラグです。
	  ここでファイル名が <code class="filename">skeleton.c</code> になっていますが、例示したファイルを使った場合、
	  ファイル <code class="filename">pseudo_dev_skel.c</code> を
	  <code class="filename">skeleton.c</code> にリネームするか、このエントリーを
	  (<code class="filename">pseudo_dev_skel.c</code> に) 変更するかする必要がありますので注意してください。
	  上述のとおり、私たちはこれを skeleton と呼んでいるので、ここは
	  <code class="filename">skeleton.c</code>
	  としたほうがおそらく素直でしょう。</p>

	
	  <h4 class="title">
<a name="kernelconfig"></a>カーネルコンフィグファイルに新しいデバイスを追加する (<a href="#pseudo">top</a>)
  </h4>

	  <p><a href="http://netbsd.gw.com/cgi-bin/man-cgi?config+1+NetBSD-5.1+i386">config(1)</a> にデバイスのことを教えてやったあと、
	    そのデバイスをカーネルコンフィグファイルに追加することは簡単です。
	    skeleton デバイスを追加するには、このような行を加え:</p>

	  <pre class="programlisting">
pseudo-device  skeleton</pre>

          <p>カーネルコンフィグファイルには、
	    前節での <code class="code">defpseudo</code> 行で与えられた名に揃えた
	    擬似デバイス名を書きます。
	    
	    新しい定義は
	    <code class="code">options</code> カーネルコンフィグファイル キーワードをつかうことで、
	    カーネル makefile に追加することができ、
	    config は <span class="command"><strong>cc</strong></span> コマンドに対し
	    <code class="option">-D</code> コマンドラインオプションを指定した
	    makefile を作ります。</p>
	    
	
	  <h4 class="title">
<a name="userlevel"></a>ユーザーレベルプログラムが新しいデバイスにアクセスすることを許す (<a href="#pseudo">top</a>)
  </h4>

	  <p>新しいカーネルを構築しインストールした後、
	    最後にすることとして、新しい擬似デバイスにアクセスできるように
	    デバイスノードを作る必要があります。
	    そのデバイスノードはアクセスすることができる
	    どんなファイルシステム上に作ることもできますが、
	    慣習によって、 デバイスノードは
	    <code class="filename">/dev</code> に作られます。
	    デバイスノード をつくるために <a href="http://netbsd.gw.com/cgi-bin/man-cgi?mknod+8+NetBSD-5.1+i386">mknod(8)</a>を使う必要があり、
	    4.i 節で書きとめた major 番号で デバイスノード を作ります。
	    この場合、 <a href="http://netbsd.gw.com/cgi-bin/man-cgi?mknod+8+NetBSD-5.1+i386">mknod(8)</a> コマンドでこのようにでき:</p>

	  <pre class="programlisting"><code class="prompt">#</code> <strong class="userinput"><code>mknod /dev/skel c 140 0</code></strong></pre>

	  <p>これで、新しいデバイスをオープンして試すことができます。
	    <a class="ulink" href="../../../../docs/kernel/pseudo/sample.c" target="_top">sample.c</a> ファイルは
	    skeleton 擬似デバイスが元気であることを示します。
	    このファイルは、ここにある指示に従っていて
	    <code class="filename">/dev/skel</code> が作られていると仮定していて、
	    このデバイスはオープンされ、パラメーター構造体は
	    ioctl call でデバイスドライバーに移されます。
	    サンプルコードをコンパイルするには、コマンドラインで:</p>
	    
	  <pre class="programlisting"><code class="prompt">$</code> <strong class="userinput"><code>cc -o sample sample.c</code></strong></pre>

	  <p>これで、 sample というバイナリーができるでしょう。
	    <span class="emphasis"><em>注意:</em></span> ヘッダーファイル置き場で、
	    <code class="filename">pseudo_dev_skel.h</code> を入れた
	    システムインクルードファイルのディレクトリーで
	    <span class="command"><strong>make includes</strong></span> をする必要があります。
	    さもなければ、コンパイラーはインクルードファイルが見つからないと訴えるでしょう。
	    プログラムをコンパイルして実行すると、
	    カーネルメッセージがコンソールと
	    <code class="filename">/var/log/messages</code> の両方に現われ、
	    それはこのようなもので:</p>

	  <pre class="programlisting">
May 17 20:32:57 siren /netbsd: Got number of 42 and string of Hello World</pre>

          <p>SKELTEST ioctl 要求を受けた時に skeleton ioctl ハンドラーが表示する
	    メッセージです; この番号と文字列は <code class="filename">sample.c</code> の <code class="code">param</code>
	    構造体の中に入れてあったものです。</p>

	<hr>
<em><a href="../">NetBSD ドキュメンテーション: カーネル</a></em> に戻る</div></div></div>
<div class="navfoot"></div>
<div id="footer"><center>
<span class="footfeed"><a href="http://www.NetBSD.org/cgi-bin/feedback.cgi">
	  連絡</a> |
      </span><span class="footcopy"><a href="../../../../ja/about/disclaimer.html">
      免責事項</a> |

      <span class="copyright">Copyright © 1994-2011 The NetBSD Foundation, Inc. </span>ALL RIGHTS RESERVED.<br>NetBSD<sup>®</sup> は The NetBSD
	Foundation, Inc. の登録商標です。</span>
</center></div>
</div></body>
</html>
