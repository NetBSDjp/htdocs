<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="Website XSL Stylesheet V2.6.0">
<link rel="home" href="../../../." title="Welcome to The NetBSD Project: Of course it runs NetBSD.">
<link rel="up" href="../../../ja/docs/." title="NetBSD ドキュメンテーション">
<link rel="previous" href="../../../ja/docs/mirror.html" title="NetBSD ミラー FAQ">
<link rel="next" href="../../../ja/docs/misc/smbprint/." title="NetBSD ドキュメンテーション: NetBSD からリモート SMB プリンターへの印刷">
<link rel="first" href="../../../ja/docs/Hardware/." title="ハードウェアドキュメンテーション">
<link rel="last" href="../../../ja/docs/x/." title="NetBSD ドキュメンテーション: X Window System">
<link rel="stylesheet" href="../../../global.css" type="text/css">

<title>NetBSD ドキュメンテーション: 他の FAQ と HOWTO</title>
</head>
<body class="website"><div class="webpage">
<a name="ja-docs-misc-index"></a><div id="top"><a href="#mainContent" class="doNotDisplay doNotPrint">本文へ飛ぶ。</a></div>
<div id="header">
<div class="topNavigation">
<span>» </span><a href="../../../docs/guide/en/">
	  ガイド</a> |
	<a href="http://man.NetBSD.org/">マニュアルページ</a> |
	<a href="../../../ja/mailinglists/">
	  メーリングリスト</a>と
	<a href="http://mail-index.NetBSD.org/">記事</a> |
	<a href="http://cvsweb.NetBSD.org/">CVS リポジトリー</a> |
	バグの<a href="http://www.NetBSD.org/cgi-bin/sendpr.cgi?gndb=netbsd">報告</a>
	と
	<a href="../../../ja/support/query-pr.html">
	 照会</a> |
	<a href="../../../ja/docs/software/packages.html">
	  ソフトウェアパッケージ
	</a>
</div>
<div class="centralHeader">
<a href="../../../ja/"><img alt='NetBSD プロジェクト "Of course it runs NetBSD"' width="506" height="90" src="../../../images/NetBSD-headerlogo.png"></a><div class="headerTools"><div id="headerSearch">
<div id="header-cse-search-form" style="width: 24%;">Google custom search</div>
<script src="http://www.google.com/jsapi" type="text/javascript"></script><script type="text/javascript"> 
                  google.load('search', '1', {language : 'en'});
                  google.setOnLoadCallback(function() {
                    var header_customSearchControl = new google.search.CustomSearchControl('006277936787196004968:mbdhrauy1wm');
                    header_customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET);
                    var header_options = new google.search.DrawOptions();
                    header_options.enableSearchboxOnly("http://google.com/cse?cx=006277936787196004968:mbdhrauy1wm");    
                    header_customSearchControl.draw('header-cse-search-form', header_options);
                  }, true);
                </script><link rel="stylesheet" href="http://www.google.com/cse/style/look/default.css" type="text/css">
</div></div>
</div>
<div class="navBar">
<span class="doNotDisplay">
	  案内:
	</span><a href="../../../ja/">
	  ホーム</a> | 
	<a href="../../../ja/about/">
	  概要</a> | 
	<a href="../../../ja/gallery/">
	  展示室</a> | 
	<a href="../../../ja/releases/">
	  ダウンロード</a> | 
	<a href="../../../ja/docs/">
	  ドキュメンテーション</a> | 
	<a href="../../../ja/support/">
	  サポート</a> | 
	<a href="../../../ja/community/">
	  コミュニティー</a> | 
	<a href="../../../ja/ports/">
	  機種</a>
</div>
</div>
<div id="content"><div class="fullWidth"><div class="rowOfBoxes">
<h1>NetBSD ドキュメンテーション: 他の FAQ と HOWTO</h1>
<div class="sect1">
<div class="titlepage"></div>
</div>
<h3 class="title"><a name="general">NetBSD に関する一般的な疑問</a></h3>
<ul>
<li><a href="#release-changes">NetBSD リリース間で何が変わったの?</a></li>
<li><a href="#64-bit">NetBSD は 64 bit オペレーティングシステム?</a></li>
<li><a href="#exportability">NetBSD は米国から輸出できる?</a></li>
<li><a href="#netbsd-uses">何のために NetBSD を使うの?</a></li>
</ul>
<h3 class="title"><a name="user-configuration">ユーザー設定</a></h3>
<ul>
<li><a href="#adding-a-user">ユーザーの追加</a></li>
<li><a href="#gecos-field">finger によって表示される情報の変更は?</a></li>
<li><a href="#problems-with-root">root としてログインあるいは 'su' する時の問題</a></li>
<li><a href="#adding-to-path"> あなたのパスに何かを加える</a></li>
<li><a href="#setting-something-for-all-users">全ユーザーのためになにか設定する</a></li>
<li><a href="#shells">シェルでのカーソルキー編集またはファイルネーム補完</a></li>
<li><a href="#languages">メッセージ言語の指定</a></li>
</ul>
<h3 class="title"><a name="printing-scanning">印刷とスキャン</a></h3>
<ul>
<li><a href="#postscript-manpages">PostScript でマニュアルページを印刷する</a></li>
<li><a href="#smbprint">NetBSD からリモート SMB プリンターへの印刷</a></li>
<li><a href="#jetdirect">DHCP 経由の HP JetDirect Card 設定</a></li>
<li><a href="#burstpage">なぜ sh は、 HP JetDirect の「バースト」ページを抑制しないのですか?</a></li>
<li><a href="#scanning">NetBSD でスキャナーを使う</a></li>
</ul>
<h3 class="title"><a name="disks-filesystems">ディスクおよびファイルシステム</a></h3>
<ul>
<li><a href="#adding-a-disk">存在しているシステムにディスクを追加する</a></li>
<li><a href="#softdeps">soft updates (softdeps) はどうやって使うの?</a></li>
<li><a href="#softdep-impact">softdep による改善はどう判断してるの?</a></li>
<li><a href="#ffs-integ">Fast File System (FFS)、 softdeps を使った FFS および NetBSD の ext2fs の実装の、不適切なシャットダウンに対する回復性はどうですか?</a></li>
<li><a href="#moving-usr"> /usr をルートからほかのパーティションに移す</a></li>
<li><a href="#read-only-to-read-write">どうやって'リードオンリー'ファイルシステムを読み書きできるようにマウントするの?</a></li>
<li><a href="#using-fsck">いつ fsck を使うのが安全なの?</a></li>
<li><a href="#kernfs"> /kern は何に使われているの?</a></li>
<li><a href="#procfs"> /proc は何に使われているの?</a></li>
<li><a href="#cgd-swap">cgd(4) を使ったスワップの暗号化</a></li>
</ul>
<h3 class="title"><a name="boot-related">ブート関連の質問</a></h3>
<ul>
<li><a href="#why-single-user">シングルユーザーモードってなに? 必要な理由と使い方は?</a></li>
<li><a href="#single-user-to-multi-user">どうやって、シングルユーザーからマルチユーザーに移行するの</a></li>
<li><a href="#boot-messages">ブートメッセージはどうやって読むの?</a></li>
<li><a href="#shutting-down">どうやって機械をシャットダウンするの?</a></li>
<li><a href="#rebooting">どうやって、機械をリブートするの?</a></li>
<li><a href="#cron-reboot">起動時にプログラムを開始する</a></li>
</ul>
<h3 class="title"><a name="memory-swap">メモリー/スワップの構成</a></h3>
<ul>
<li><a href="#swap">スワップスペース(空間)はどのくらい</a></li>
<li><a href="#adding-swap">動作中のシステムにスワップを追加する</a></li>
<li><a href="#tuning-vm">メモリーが少ないシステムでの性能改善のための仮想メモリーの調整</a></li>
</ul>
<h3 class="title"><a name="common-problems">一般の(それと一般ではない)問題</a></h3>
<ul>
<li><a href="#nroff-missing">'man' を実行すると /usr/bin/nroff: not found となります</a></li>
<li><a href="#var-mail-permissions">メールを読んでいる時 'Unable to lock mailbox: Permission denied'が出ます</a></li>
<li><a href="#kernel-not-netbsd">'netstat -r' を実行すると netstat: kvm_read kvm_read: Bad address となります</a></li>
<li><a href="#libkvm-mismatch">'netstat -r' をしてみると、限りないクエスチョンマークの列が帰ってきます。 何が悪いの?</a></li>
<li><a href="#kernel-upgrade">新しいカーネルにアップデートしたあと、 w, ps, と netstat が働きません</a></li>
<li><a href="#proc-size-mismatch">カーネル変更後 'ps' が "proc size mismatch" と言います</a></li>
<li><a href="#hash-map-alias0">'hash map "Alias0":unsafe map file
    /etc/aliases: No such file or directory' が表示されます</a></li>
<li><a href="#portmap-messup">どうやったら、 root でログインした時のシェルが出す portmap メッセージ を抑制できますか</a></li>
<li><a href="#locales">どうやったらウムラウトその他の地域的な文字を表示できますか?</a></li>
</ul>
<h3 class="title"><a name="other-questions">その他の疑問</a></h3>
<ul>
<li><a href="#bluetooth">NetBSD で Bluetooth を使えるようにする方法は?</a></li>
<li><a href="#editing-files"> NetBSD でのファイル編集</a></li>
<li><a href="#rebuilding-dev">/dev の再構築</a></li>
<li><a href="#connecting-a-ups">NetBSD システムに UPS をつなぐ</a></li>
<li><a href="#changing-motd">/etc/motd を何らかの変更をしてももとの内容に戻ってしまいます</a></li>
<li><a href="#selling-hardware">どこへ NetBSD 関連のハードウェアを売ればいいの?</a></li>
<li><a href="#setup-ccd">ストライプ (ccd) ドライブを設定する</a></li>
<li><a href="#edit-fonts">コンソールのビットマップフォントの作成や編集用のユーティリティーは?</a></li>
</ul>
<h3 class="title"><a name="other-links">他のリンク</a></h3>
<ul>
<li><a href="#mreriksson">Ola Eriksson の NetBSD FAQ</a></li>
<li><a href="#japanese-language-support">NetBSD の日本語サポート</a></li>
</ul>
<hr>
<h3 class="title">NetBSD に関する一般的な疑問</h3>
<h4 class="title">
<a name="release-changes"></a>NetBSD リリース間で何が変わったの? (<a href="#general">top</a>)
  </h4>
<p>
全ての変更の最新の一覧 ( NetBSD-current での物も含まれています)
が<a class="ulink" href="../../changes/" target="_top">あります</a>。
</p>
<p>これは、各リリースの最上位ディレクトリーの
<code class="code">CHANGES</code> ファイルにもあり、また、
<a class="ulink" href="http://cvsweb.NetBSD.org/bsdweb.cgi/~checkout~/src/doc/CHANGES.prev?content-type=text/plain" target="_top">前回</a>
および
<a class="ulink" href="http://cvsweb.NetBSD.org/bsdweb.cgi/~checkout~/src/doc/CHANGES?content-type=text/plain" target="_top">次回</a>
のリリースのものがオンラインで保守されています。

</p>

<h4 class="title">
<a name="64-bit"></a>NetBSD は 64 bit オペレーティングシステム? (<a href="#general">top</a>)
  </h4>
<p>

NetBSD は 32 bit と 64 bit CPU のどちらでも動いています。
<a class="ulink" href="../../ports/alpha/" target="_top">alpha</a> CPU では、
カーネルとユーザーランドは LP64 として知られているモードで走り、
それは、 <span class="bold"><strong>int</strong></span> が 32 bit で <span class="bold"><strong>long</strong></span> と
ポインター (とアドレス空間) が 64 bit です。
<a class="ulink" href="../../ports/amd64/" target="_top">amd64</a> および
<a class="ulink" href="../../ports/sparc64/" target="_top">sparc64</a> ポートは 32 ビットと 64 ビット
いずれの設定でも動作します。 64 ビットカーネル (LP64) は、 64 ビットモード
において 32 ビットのアプリケーションをサポートします。
32 ビットカーネルは整数、ポインター、 long 整数すべてに 32 ビットを使い、
64 ビットプログラムは動作しません。
</p>
<p>

R4000 とそれ以降の MIPS といった、ほかの 64bit capable CPU (<a class="ulink" href="../../ports/#in-tree-ports" target="_top">いくつかのポートで使われています</a>)
では、 NetBSD は 32 bit モードで走りますが、 64 bit に変更中です。
</p>
<p>

全ての NetBSD ポートは
カーネルとユーザーランドプログラムで 64 bit 演算に対応しています。
カーネル内では、それはさまざまなカウンターと、
FFS 、64 bit 'Fast File System' に使われています。
</p>

<h4 class="title">
<a name="exportability"></a>NetBSD は米国から輸出できる? (<a href="#general">top</a>)
  </h4>
<p>
NetBSD 1.4.x まで(とそれを含む)では、
security 配布物 (すなわち secr.tgz) 以外の全ては
米国から輸出できます。
secr.tgz 配布物ファイルには、暗号のためのライブラリーが含まれています。
NetBSD 1.5 からは、 暗号化コードは
NetBSD の base 配布物に含まれています。
<a class="ulink" href="../../about/crypto-export.html" target="_top">
輸出制限されたコードとバイナリーに関する NetBSD ドキュメントを参照してください </a>。
</p>

<h4 class="title">
<a name="netbsd-uses"></a>何のために NetBSD を使うの? (<a href="#general">top</a>)
  </h4>
<p>
Chris G. Demetriou (cgd@NetBSD.org) の言葉では:
</p>
<div class="blockquote"><blockquote class="blockquote"><span class="quote">“<span class="quote">
NetBSD は、一般的に、  "安定した研究プラットフォーム" を意味します  -- 
それは、商用、家庭、研究作業……に使えるシステムであり、
何に使うかは、あなた次第です。一般的に、 私たちが NetBSD でしている仕事は、
私たちに可能なあらゆる方法による、システムを改善する試みです -- 
より多くのハードウェアのサポート、より高い安定性、より良い性能、より多くの文書化……
</span>”</span></blockquote></div>
<p>

我々の
<a class="ulink" href="../../about/features.html" target="_top">特色のページ</a> を
NetBSD があなたに与える機会(能力)のアイデアとして見てください!
</p>
<hr>
<h3 class="title">ユーザー設定</h3>
<h4 class="title">
<a name="adding-a-user"></a>ユーザーの追加 (<a href="#user-configuration">top</a>)
  </h4>
<p>
<a href="http://netbsd.gw.com/cgi-bin/man-cgi?useradd+8+NetBSD-5.1+i386">useradd(8)</a> コマンドを使ってユーザーを追加できます。
<code class="code">/etc/passwd</code>
を編集してもユーザーは追加できません。パスワードデータベースを編集したい場合は
<a href="http://netbsd.gw.com/cgi-bin/man-cgi?vipw+8+NetBSD-5.1+i386">vipw(8)</a> を使ってください。さらなる情報は、 <a href="http://netbsd.gw.com/cgi-bin/man-cgi?pwd_mkdb+8+NetBSD-5.1+i386">pwd_mkdb(8)</a> を参照してください。
</p>

<h4 class="title">
<a name="gecos-field"></a><code class="code">finger</code> によって表示される情報の変更は? (<a href="#user-configuration">top</a>)
  </h4>
<p>
<a href="http://netbsd.gw.com/cgi-bin/man-cgi?chfn+1+NetBSD-5.1+i386">chfn(1)</a> および <a href="http://netbsd.gw.com/cgi-bin/man-cgi?chsh+1+NetBSD-5.1+i386">chsh(1)</a> コマンドを使うか、または、
vipw(8) を使って <code class="code">/etc/master.passwd</code> を編集してください。
</p>

<h4 class="title">
<a name="problems-with-root"></a>root としてログインあるいは 'su' する時の問題 (<a href="#user-configuration">top</a>)
  </h4>
<p>
以下のような、いくつもの場合がありえます:
</p>
<p>
</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
<span class="bold"><strong>root として直接ログインできません</strong></span><br>
	NetBSD は <code class="code">/etc/ttys</code> 中に 'secure' が書かれている端末からのみ、
	root として直接ログインすることを許します ( <a href="http://netbsd.gw.com/cgi-bin/man-cgi?ttys+5+NetBSD-5.1+i386">ttys(5)</a> を見よ)。
	ネットワークをまたいで直接ログインできるようにする( 推奨され <span class="bold"><strong>ない</strong></span> )には、
	'<code class="code">secure</code>' を各ネットワーク端末行の最後に加える必要があります。
	こうするためには、 root になって
	以下のようにすればよく、各行をいちいち編集する必要はありません。
	<pre class="programlisting">
		cd /etc
		cp ttys ttys.orig
		cat ttys.orig | sed 's/network$/network secure/' &gt; ttys</pre>
    </li>
<li class="listitem">
<span class="bold"><strong>root に 'su' できません</strong></span><br>
	NetBSD は誰かが root に <a href="http://netbsd.gw.com/cgi-bin/man-cgi?su+1+NetBSD-5.1+i386">su(1)</a> しようとすると、
	<code class="code">/etc/group</code> の 'wheel' グループに誰が入っているかチェックします。
	もしこのグループが空 (wheel:*:0:) なら誰もが正しいパスワードで root に su できます。
	グループが空でない場合は、root になることが許可されたアカウントを、
        コンマで区切って (スペースを入れてはいけません) 並べておきます。</li>
<li class="listitem">
<span class="bold"><strong>誰にも 'su' できません</strong></span>
        <p>"<span class="bold"><strong><code class="code">ls -l /usr/bin/su</code></strong></span>" と入力してください。
	出力の最初の 'word' は '-r-sr-xr-x' であるべきです。
        もし、それがなにか違う ('-r-xr-xr-x' みたいに) なら
	(root になって)  "<span class="bold"><strong><code class="code">chmod 4555 /usr/bin/su</code></strong></span>"
	と入力してください。
	その位置の 's' は 'setuid' バイナリーを示していて、この場合、
	'su' が root 特権で走ることを認めています。
	</p>
	<p>
	この問題は、配布物を展開した時に tar に '-p' (パーミッション保護) フラグが
	与えられていなかったことによるものです。この場合、
	ほかのさまざまなユーティリティーもまた壊れているでしょうから、
	全ての tar ファイル ( etc.tar.gz 以外)を再展開してください。
        </p>
    </li>
</ul></div>
<p>
</p>

<h4 class="title">
<a name="adding-to-path"></a> あなたのパスに何かを加える (<a href="#user-configuration">top</a>)
  </h4>
<p>
例えば、あなたのパスに /usr/X11R6/bin を加えるなら、
ホームディレクトリーの <span class="emphasis"><em>.login</em></span> ファイルを編集し
次のように加えます:
</p>
<pre class="programlisting">set path = ( /usr/X11R6/bin $path )</pre>
<p>
</p>
<p>
これは C-shell <a href="http://netbsd.gw.com/cgi-bin/man-cgi?csh+1+NetBSD-5.1+i386">csh(1)</a> と、その派生物の
<span class="emphasis"><em><a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/shells/tcsh/README.html" target="_top"><code class="filename">shells/tcsh</code></a></em></span> のようなものでのみ、働きます。
<a href="http://netbsd.gw.com/cgi-bin/man-cgi?sh+1+NetBSD-5.1+i386">sh(1)</a> と派生物 (<a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/shells/bash2/README.html" target="_top"><code class="filename">shells/bash2</code></a> のような) では
正しい文法は:
</p>
<pre class="programlisting">
PATH=/usr/X11R6/bin:$PATH
export PATH</pre>
<p>
</p>

<h4 class="title">
<a name="setting-something-for-all-users"></a>全ユーザーのためになにか設定する (<a href="#user-configuration">top</a>)
  </h4>
<p>
次に示すファイルのいずれか一つに書き加えると、<a href="http://netbsd.gw.com/cgi-bin/man-cgi?csh+1+NetBSD-5.1+i386">csh(1)</a> や <a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/shells/tcsh/README.html" target="_top"><code class="filename">shells/tcsh</code></a>
を走らせている全ユーザー向けの設定をすることができます。
</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
<span class="bold"><strong><code class="code">/etc/csh.cshrc</code></strong></span><br>
    これは、新しいシェルが開かれるごとに、
    ユーザーのホームディレクトリーにある、いかなる <span class="bold"><strong><code class="code">.cshrc</code></strong></span> よりも先に実行されます。</li>
<li class="listitem">
<span class="bold"><strong><code class="code">/etc/csh.login</code></strong></span><br>
    これは、ユーザーがログインする時、
    <span class="bold"><strong><code class="code">/etc/csh.cshrc</code></strong></span> よりも後だけど、ユーザーのホームディレクトリーにあるいかなる <span class="bold"><strong><code class="code">.login</code></strong></span>
    よりも先に実行されます。</li>
<li class="listitem">
<span class="bold"><strong><code class="code">/etc/csh.logout</code></strong></span><br>
    これは、ユーザーがログアウトする時、ユーザーのホームディレクトリーにあるいかなる <span class="bold"><strong><code class="code">.logout</code></strong></span>
    よりも先に実行されます。</li>
</ul></div>
<p>
</p>

<h4 class="title">
<a name="shells"></a>シェルでのカーソルキー編集またはファイルネーム補完 (<a href="#user-configuration">top</a>)
  </h4>
<p>
これは、使っているシェルの種類によります。
</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
<a href="http://netbsd.gw.com/cgi-bin/man-cgi?sh+1+NetBSD-5.1+i386">sh(1)</a> (Bourne シェル)<br>
	これは、シングルユーザーモードで使われるシェルであり、また、
	NetBSD 4.0 以降では標準のユーザーシェルになっています。
	'<code class="code">set -E</code>' または '<code class="code">set
	-o emacs</code>' コマンドで、コマンドライン編集を有効にできます。
	TAB によるファイル名の補完は、'<code class="code">set -o tabcomplete</code>'
	で有効にできます。これらはいずれも、標準状態で有効になるように
	(<code class="filename">~/.shrc</code> から読み込まれる
	<code class="filename">/etc/shrc</code> で) 設定されています。
	シングルユーザーモードでいつもコマンドライン編集ができるように、
	<code class="code">/.profile</code> にこれを加えることができます。
</li>
<li class="listitem">
<a href="http://netbsd.gw.com/cgi-bin/man-cgi?csh+1+NetBSD-5.1+i386">csh(1)</a> ('C' シェル)<br>
	これは NetBSD 4.0 より前までは標準のユーザーシェルだったもので、
	ファイルネーム補完をサポートしています ('<span class="bold"><strong>set
	filec</strong></span>' してから、 ESCAPE キーを使って) が、
	コマンドライン編集はサポートしていません。</li>
<li class="listitem">
<a href="http://netbsd.gw.com/cgi-bin/man-cgi?ksh+1+NetBSD-5.1+i386">ksh(1)</a> (Korn Shell)<br>
	これはパブリックドメイン版の Korn Shell 、別名 pdksh です。
	Emacs モードまたは Vi モードのコマンドライン編集に対応しています
	('set -o {emacs,vi}' で設定します) 。 Emacs モードでは、標準で、
	TAB キーを使ってファイル名やコマンドを補完することができます。
	Vi モードで TAB や ESC でのファイル名補完をするには、それぞれ、
	'set -o vi-tabcomplete' や 'set -o vi-esccomplete' を使います。<br>
	このパブリックドメイン版 korn shell は NetBSD のベースシステムに含まれていますが、
	他のオペレーティングシステム用として
	<a class="ulink" href="../software/packages.html" target="_top">NetBSD パッケージコレクション</a>の
	<a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/shells/pdksh/README.html" target="_top"><code class="filename">shells/pdksh</code></a> からも利用可能です。また、 KSH-93 も
	<a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/shells/ast-ksh/README.html" target="_top"><code class="filename">shells/ast-ksh</code></a> から利用可能です。</li>
<li class="listitem">
<span class="bold"><strong>bash (GNU Bourne Again Shell)</strong></span><br>
	'bash' はもうひとつの、コマンドライン編集拡張されているシェルで、
	これは 'sh' が基になっています。
	<a class="ulink" href="../software/packages.html" target="_top">NetBSD パッケージコレクション</a>
	中の <a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/shells/bash2/README.html" target="_top"><code class="filename">shells/bash2</code></a> からインストールすることができます。</li>
<li class="listitem">
<span class="bold"><strong>tcsh (拡張された 'C' シェルの一つ)</strong></span><br>
	'tcsh' はほぼ完璧な csh のスーパーセット(拡張物)で
	ファイルネーム補完(TAB を使います)と
	コマンドライン編集を含む沢山の便利な特別な機能があります。
	 <a class="ulink" href="../software/packages.html" target="_top">NetBSD パッケージコレクション</a> 
	中の <a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/shells/tcsh/README.html" target="_top"><code class="filename">shells/tcsh</code></a> からインストールすることができます。</li>
<li class="listitem">
<span class="bold"><strong>ほかの shell たち</strong></span><br>
	<a class="ulink" href="../software/packages.html" target="_top">NetBSD パッケージコレクション</a> 
	の <a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/shells/README.html" target="_top"><code class="filename">shells</code></a> カテゴリーの下には、
	さまざまな他のコマンドラインシェルが含まれています。</li>
</ul></div>
<p>
</p>

<h4 class="title">
<a name="languages"></a>メッセージ言語の指定 (<a href="#user-configuration">top</a>)
  </h4>
<p>
NetBSD は、エラーメッセージやそのようなものに用いる言語を
決めるのに
'<code class="code">LANG</code>' 環境変数を使います。
csh や tcsh では
'<code class="code">setenv LANG <span class="bold"><strong>XX</strong></span></code>' コマンドで設定でき、
ここで、 XX は2文字の国コードです。
サポートされているコードタイプの一覧は
'<code class="code"> /usr/share/nls</code>' にあります。
</p>
<p>
<span class="bold"><strong>どうか注意</strong></span>:確実に翻訳されているものだけにしてください。
確認するには、 <code class="code">LANG</code> 変数をセットし、
</p>
<pre class="programlisting">
  cd /a_directory_that_does_not_exist</pre>
<p>
と打ってください。
</p>
<hr>
<h3 class="title">印刷とスキャン</h3>
<h4 class="title">
<a name="postscript-manpages"></a>PostScript でマニュアルページを印刷する (<a href="#printing-scanning">top</a>)
  </h4>
<p>
   マニュアルページは、
    <a href="http://netbsd.gw.com/cgi-bin/man-cgi?nroff+1+NetBSD-5.1+i386">nroff(1)</a> ソースとして /usr/share/man/man<span class="emphasis"><em>X</em></span>/<span class="emphasis"><em>manpage</em></span>.<span class="emphasis"><em>X</em></span> 
    にあります。ここで <span class="emphasis"><em>X</em></span> はセクション番号です (例: nroff の場合は 1 )。
    それを PostScript に変換するにはこれが使えて:
    </p>
<pre class="programlisting">groff -Tps -mandoc /usr/share/man/man<span class="emphasis"><em>X</em></span>/<span class="emphasis"><em>manpage</em></span>.<span class="emphasis"><em>X</em></span></pre>
<p>
    たとえば、 <a href="http://netbsd.gw.com/cgi-bin/man-cgi?ls+1+NetBSD-5.1+i386">ls(1)</a> マニュアルページ を PostScript に変換し、
    <a href="http://netbsd.gw.com/cgi-bin/man-cgi?lpr+1+NetBSD-5.1+i386">lpr(1)</a> を通して直接デフォルトのプリンターに送るには、以下のコマンドを使うことができます。
    </p>
<pre class="programlisting">groff -Tps -mandoc /usr/share/man/man1/ls.1 |lpr</pre>
<p>
    ほかのタイプのプリンターで印刷したいなら、
    pkgsrc の
    <a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/print/ghostscript/README.html" target="_top"><code class="filename">print/ghostscript</code></a> パッケージを使うとよいでしょう。
</p>

  <h4 class="title">
<a name="smbprint"></a>NetBSD からリモート SMB プリンターへの印刷 (<a href="#printing-scanning">top</a>)
  </h4>
<p>
詳細は<a class="ulink" href="smbprint/" target="_top">このページ</a>をご覧ください。
</p>

<h4 class="title">
<a name="jetdirect"></a>DHCP 経由の HP JetDirect Card 設定 (<a href="#printing-scanning">top</a>)
  </h4>
<p>
JetDirect EX Plus のような、 JetDirect プリントサーバーを持っていれば、
プリントサーバーを設定するために、 NetBSD のもとで dhcpd(8) を使うことができます。 このステップは:

JetDirect サーバーのために <code class="code">/etc/dhcpd.conf</code> にエントリーを作ります。
</p>
<pre class="programlisting">
options jd-tftp-cfg		code 144 = string;
options jd-tftp-server		code 150 = string;

allow				bootp;

# [...]

host hp690c {
	fixed-address		hp690c;			# set to the DNS name or address of the JetDirect
	hardware ethernet	00:60:b0:00:11:22;	# set to the MAC address of the JetDirect
	option	log-servers	servername;		# set to the DNS name or address of log server
	option	jd-tftp-server	servername;		# set to the DNS name or address of tftp server
	option	jd-tftp-cfg	"hpnp/hp690c.cfg";	# name of the JetDirect config file
}</pre>
<p>
このファイルの書き方について、より詳しい情報は <a href="http://netbsd.gw.com/cgi-bin/man-cgi?dhcpd.conf+5+NetBSD-5.1+i386">dhcpd.conf(5)</a> を見てください。
</p>
<p>
<code class="code">/etc/inetd.conf</code> 内で、 <code class="code">tftpd</code> が有効になっていることを確かめてください。
注意として、
 "-s" 引数を <code class="code">/etc/inetd.conf</code> の <code class="code">tftp</code> の行につけるようにしてください。
この引数は、 <a href="http://netbsd.gw.com/cgi-bin/man-cgi?tftpd+8+NetBSD-5.1+i386">tftpd(8)</a> のルートディレクトリーを設定するものです。
以下、この例においては、
<a href="http://netbsd.gw.com/cgi-bin/man-cgi?tftpd+8+NetBSD-5.1+i386">tftpd(8)</a> のルートディレクトリーを <code class="code">/tftpboot</code> に設定していると仮定します。
</p>
<p>
<code class="code">/etc/rc.conf</code> 内で、 <code class="code">dhcpd</code> が有効になっていることを確かめてください。
</p>
<p>

次に Network Printer Interface (NPI) 設定ファイルをつくります。
この例では、ファイルは <code class="code">/tftpboot/hpnp/hp690c.cfg</code> で、
このファイルは次のようになっているべきです:
</p>
<pre class="programlisting">
name: printer name
location: Location of the Printer 
contact: Contact Person 
idle-timeout: 1800
banner: 0</pre>
<p>

<code class="code">/etc/inetd.conf</code> に変更を加えた場合は、
かならず <code class="code">kill -HUP `cat /var/run/inetd.pid`</code> して、
<a href="http://netbsd.gw.com/cgi-bin/man-cgi?inetd+8+NetBSD-5.1+i386">inetd(8)</a> に <a href="http://netbsd.gw.com/cgi-bin/man-cgi?inetd.conf+5+NetBSD-5.1+i386">inetd.conf(5)</a> を再読込みさせてください。
JetDirect プリントサーバー (または HP JetDirect カードのついたプリンター)
をリブートすると、サーバーは DHCP で設定を読みこみます。
いくつかのプリンターでは、フロントパネル(の操作)で BOOTP/DHCP の設定を
明示的に有効にする必要があるかもしれません。
</p>

<h4 class="title">
<a name="burstpage"></a>なぜ <span class="emphasis"><em>sh</em></span> は、 HP JetDirect の「バースト」ページを抑制しないのですか? (<a href="#printing-scanning">top</a>)
  </h4>
<p>
この「バースト」ページは、プリンターとローカル接続されているホスト、特にこのケースでは
<a href="http://netbsd.gw.com/cgi-bin/man-cgi?lpd+8+NetBSD-5.1+i386">lpd(8)</a> をエミュレートする専用ハードウェアの機能です。 NetBSD がリモートスプーラーとして
<span class="emphasis"><em>rm</em></span> とともに使われる場合は、バーストページを追加することはありません。
この JetDirect の「バースト」ページは、専用デバイスの非標準な機能です。
<a class="ulink" href="http://h20015.www2.hp.com/en/document.jhtml?lc=en&amp;docName=bpj02755&amp;prodId=jd2337a" target="_top">HP (TM)
ではこのページを実際には "trailer" と呼んでいます</a>。
この機能は、 <code class="code">banner: 0</code> を設定するか、または、デバイスの 23 番ポートに単純に
telnet して <code class="code">banner 0</code> コマンドを実行してから <code class="code">quit</code> することで、
止めることができます。
</p>
<p>
JetDirect の個体によっては、この <code class="code">banner</code> コマンドを追加するために、
ファームウェアをアップグレードする必要があるかもしれません。
ファームウェアをアップグレードするには、 HP による JetDirect
ネットワーク管理ツールを適切に使う必要があります
このアップグレードを行うために、 SNMP read and write community strings
を、既知の価に設定する必要があるかもしれません。
この設定をするには、以下の内容を NPI 設定に使います。
</p>
<pre class="programlisting">
get-community-name: read-password
set-community-name: write-password</pre>
<p>
(DHCP を使った JetDirect カードの設定については、前の項目を参照してください。)
なお、 (TFTP 経由で) 公開される設定ファイルにこれらの項目を置くことによる
セキュリティー上の影響を認識するようにしてください。

</p>

<h4 class="title">
<a name="scanning"></a>NetBSD でスキャナーを使う (<a href="#printing-scanning">top</a>)
  </h4>
<p>
NetBSD は、 <a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/graphics/sane-backends/README.html" target="_top"><code class="filename">graphics/sane-backends</code></a>スキャニングパッケージを用いて、
さまざまな SCSI スキャナーをサポートしています。
この API にアクセスするためのフロントエンドは
<a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/graphics/sane-frontends/README.html" target="_top"><code class="filename">graphics/sane-frontends</code></a> パッケージで提供されており、
また、<a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/graphics/gimp/README.html" target="_top"><code class="filename">graphics/gimp</code></a>
のようなグラフィックツールから直接呼び出すことができます。
</p>
<p>
注意: 
1.4.2 より前のバージョンの NetBSD では、
カーネル内の <a href="http://netbsd.gw.com/cgi-bin/man-cgi?ss+4+NetBSD-5.1+i386">ss(4)</a> スキャナードライバーは <a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/graphics/sane-backends/README.html" target="_top"><code class="filename">graphics/sane-backends</code></a>
といくつかのスキャナーで問題を起こすかもしれません。
 - その解決法は、カーネルを <a href="http://netbsd.gw.com/cgi-bin/man-cgi?ss+4+NetBSD-5.1+i386">ss(4)</a> デバイスを使わずに <a href="http://netbsd.gw.com/cgi-bin/man-cgi?uk+4+NetBSD-5.1+i386">uk(4)</a> を使うように再コンパイルするか、
 1.4.2 以降にアップグレードすることのどちらかです。
</p>
<hr>
<h3 class="title">ディスクおよびファイルシステム</h3>
<h4 class="title">
<a name="adding-a-disk"></a>存在しているシステムにディスクを追加する (<a href="#disks-filesystems">top</a>)
  </h4>
<p>
</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">システムを Halt(停止) します</li>
<li class="listitem">新しいドライブをつなぎます</li>
<li class="listitem">マシンが PROM か BIOS を持っていて、ドライブ一覧が出せるなら、
    そのドライブが認識されているかチェックします:
    <div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
<span class="bold"><strong>最近の sparc</strong></span>: 起動開始以前に
	<code class="code"><span class="bold"><strong>[STOP][A]</strong></span></code> を押し、そして "<code class="code">ok</code>" プロンプトの所で <code class="code"><span class="bold"><strong>probe-scsi</strong></span></code>。</li>
<li class="listitem">
<span class="bold"><strong>adaptec BIOS の入っている i386 </strong></span>:起動開始以前に、
	<code class="code"><span class="bold"><strong>[CTRL][A]</strong></span></code> を押し、BIOS にはいります。</li>
<li class="listitem">
<span class="bold"><strong>他のもの</strong></span>: もっと詳しいこと(を寄せられること)を歓迎します :)</li>
</ul></div>
</li>
<li class="listitem">boot します。</li>
<li class="listitem">ドライブが認識されていることを、<a href="http://netbsd.gw.com/cgi-bin/man-cgi?dmesg+8+NetBSD-5.1+i386">dmesg(8)</a> 出力で確かめます</li>
<li class="listitem">
<a href="http://netbsd.gw.com/cgi-bin/man-cgi?disklabel+8+NetBSD-5.1+i386">disklabel(8)</a> を用いてパーティションに <a href="http://netbsd.gw.com/cgi-bin/man-cgi?disklabel+5+NetBSD-5.1+i386">disklabel(5)</a> を書きこみます<br>
        (もし、ディスクにディスクラベルがまだなければ、
         たぶん以下のようにすることになるでしょう:<pre class="programlisting"> disklabel -i -I sd1 # "sd1: no disk label" という警告はすべて無視します</pre>
    パーティション 'c' は、ディスクのうち NetBSD 部分全体として予約されており、
    一部のポート (特に i386) では同様に 'd' がディスク全体として予約されています。
    以下はセッションの例で、ディスク全体をひとつのパーティション 'e'
    として設定しています:
<pre class="programlisting">
	partition&gt; <span class="bold"><strong>e</strong></span>
	Filesystem type [?] [unused]: <span class="bold"><strong>4.2BSD</strong></span>
	Start offset [0c, 0s, 0M]: 
	Partition size ('$' for all remaining) [0c, 0s, 0M]: <span class="bold"><strong>$</strong></span>
 	e: 234375000         0     4.2BSD      0     0     0   # (Cyl.    0 - 232514*)
	partition&gt; <span class="bold"><strong>W</strong></span>
	Label disk [n]? <span class="bold"><strong>y</strong></span>
	partition&gt; <span class="bold"><strong>Q</strong></span></pre>
    <code class="code">disklabel -i</code> の実行中は、さらなるヘルプを '?' で参照できます。
</li>
<li class="listitem">追加されたファイルシステムごとに、
    <code class="code"><span class="bold"><strong>newfs &lt;filesystem&gt;</strong></span></code>
    (ここで <span class="emphasis"><em>&lt;filesystem&gt;</em></span> は生(raw)デバイスのパーティションです。
      /dev/rsd1e, /dev/rwd1f, ... のような)
</li>
<li class="listitem">ファイルシステムを <code class="code">/etc/fstab</code> に書きこみます。</li>
<li class="listitem">それを <a href="http://netbsd.gw.com/cgi-bin/man-cgi?fsck+8+NetBSD-5.1+i386">fsck(8)</a> します: <pre class="programlisting">fsck -f &lt;filesystem&gt;</pre>
</li>
<li class="listitem">それを <a href="http://netbsd.gw.com/cgi-bin/man-cgi?mount+8+NetBSD-5.1+i386">mount(8)</a> します: <pre class="programlisting">mount -va</pre>
</li>
</ol></div>
<p>
</p>

<h4 class="title">
<a name="softdeps"></a>soft updates (softdeps) はどうやって使うの? (<a href="#disks-filesystems">top</a>)
  </h4>
<p>
    Frank van der Linden
    (<a class="ulink" href="mailto:frank@wins.uva.nl" target="_top">frank@wins.uva.nl</a>)
    はメインツリーに
     Kirk McKusick の 精巧な sync + FFS soft update コードを
    持ってきました。
</p>
    <p>
    使うには、次のようにします:

    </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">カーネルコンフィグファイルに "<code class="code">options SOFTDEP</code>" をつけて
        新しいカーネルをコンパイルします。
        このオプションは GENERIC カーネルでは有効になっています。</li>
<li class="listitem">新しいカーネルを走らせます。</li>
<li class="listitem"> <code class="code">/etc/fstab</code> の中で、 softdeps を使いたい全てのファイルシステムに
        "<code class="code">softdep</code>" マウントオプションを追加します。
        たとえば、このような行は
<pre class="programlisting">
/dev/wd0e    /usr    ffs     rw                      1 2</pre>
このように変更します:
<pre class="programlisting">
/dev/wd0e    /usr    ffs     rw<span class="bold"><strong>,softdep</strong></span>              1 2</pre>
</li>
<li class="listitem">リブートします。</li>
<li class="listitem">遊ぼう!</li>
</ol></div>
<p>

</p>

<h4 class="title">
<a name="softdep-impact"></a>softdep による改善はどう判断してるの? (<a href="#disks-filesystems">top</a>)
  </h4>
<p>

変化したデータが直ちにディスクに書き込まれない事実から、
システムがもっと速くなったと思われます。
現時点では、これを表わす数字はありません。
</p>
<p>

Paul Vixie は、softdep が
ありとなし
の両方のシステムで、一つのディレクトリーに (ランダム順に) 75.000 ファイル を蓄え検索する
ベンチマークを走らせました。
この結果は、大きなディレクトリーにおいて、生成および配置の両方のファイルアクセス時間が、
一般的に、soft dependencies なシステムのほうが良い結果であることを
示しています。(この場合の softdep システムは FreeBSD 4.2で、
非-softdep システムは BSD/OS 3.1 です。
 NetBSD システムでも softdep の有る無しで見られる挙動は似たものであるはずです)。
</p>
<p>
</p>

<h4 class="title">
<a name="ffs-integ"></a>Fast File System (FFS)、 softdeps を使った FFS および NetBSD の ext2fs の実装の、不適切なシャットダウンに対する回復性はどうですか? (<a href="#disks-filesystems">top</a>)
  </h4>
<p>

FFS では、ファイルシステムがクラッシュ後に修復可能であることを保証すべく、
メタデータ操作をそれが参照するデータの実体の操作より先に行うことと、
さらに、あらゆるメタデータ操作は適切な順序で行なうことに注意を払っています。
最後の N 秒 (N は同期間隔) ぶんの<span class="emphasis"><em>ファイルデータ</em></span>は、修復不可能に
なるかもしれませんが、それでもファイルシステムメタデータは修復可能です。
この N は通常は 30 です。
</p>
<p>    
softdeps を使うと、通常の FFS と<span class="emphasis"><em>ほとんど</em></span>同じだけの信頼性が得られます。
softdeps では、クラッシュ前のある時点における、
矛盾のないファイルシステムのスナップショットを得られることが保証されます。
このため、たとえば、ロックファイルのリネームといった不可分な操作を行なった場合、
softdeps を使わない場合と同じく、ロックファイルが本当にあることはわかりません;
しかし、そのファイルのあったディレクトリーが消されないことと、
この不可分な操作と将来の不可分な操作の間の依存関係の順序が保持されることはわかります。
このため、制御が不可分な操作に依存している場合、
たとえば、ある種のデータベース的なプロセス (大量のメールスプールファイルの
書き込み、取引システムからのデータ集計などなど) では、
それが終わったように見えた時点で、安全にバックアップを取ることができます。
</p>
<p>
NetBSD の ext2fs の実装は、メタデータに関して、 (Linux の実装とは違って)
旧来の FFS 並の保証をしていますので、 Linux でネイティブの ext2fs
を使う場合よりも多くの信頼を持って実際に使うことができます。
若干遅くなるという欠点はあります。しかしこれは、
システムクラッシュ時に適切な扱いをして、
潜在的なファイルシステム破壊の可能性を避けるようにしたためなのです。
</p>

<h4 class="title">
<a name="moving-usr"></a> /usr をルートからほかのパーティションに移す (<a href="#disks-filesystems">top</a>)
  </h4>
<p>
    </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">希望する新しい位置(例えば <code class="code">/dev/sd0e</code>)が
	   存在する他のどのパーティションとも重ならないことを確かめます。
	   <a href="http://netbsd.gw.com/cgi-bin/man-cgi?disklabel+8+NetBSD-5.1+i386">disklabel(8)</a> の出力をチェックします。</li>
<li class="listitem">移動先にまだファイルシステムがなければ、以下を実行します。
	<pre class="programlisting"># <span class="bold"><strong>newfs /dev/sd0e</strong></span></pre>
        </li>
<li class="listitem">それをマウントし、データを向こうへコピーします:
	<pre class="programlisting"># <span class="bold"><strong>mount /dev/sd0e /mnt</strong></span></pre>
        </li>
<li class="listitem"><pre class="programlisting"># <span class="bold"><strong>cd /usr</strong></span></pre></li>
<li class="listitem"><pre class="programlisting"># <span class="bold"><strong>pax -rw -pe . /mnt</strong></span></pre></li>
<li class="listitem"><pre class="programlisting"># <span class="bold"><strong>umount /mnt</strong></span></pre></li>
<li class="listitem">
<code class="code">/etc/fstab</code> を編集し、
	   '<code class="code">/dev/sd0e /usr ffs rw 1 2</code>' を加えます。
	   ( <code class="code">/dev/sd0e</code> はあなたの状況に応じて変えて下さい)。
        </li>
<li class="listitem">シングルユーザーモードに shutdown し、
	    新しいマウントポイントをつくります:
	<pre class="programlisting"># <span class="bold"><strong>shutdown now</strong></span></pre>
</li>
<li class="listitem"><pre class="programlisting"># <span class="bold"><strong>mv /usr /usr.old</strong></span></pre></li>
<li class="listitem"><pre class="programlisting"># <span class="bold"><strong>mkdir /usr</strong></span></pre></li>
<li class="listitem">システムを起動し、テストし、まったく良好なら、
	   '<code class="code">rm -rf /usr.old</code>' します。</li>
</ol></div>
<p>
</p>

<h4 class="title">
<a name="read-only-to-read-write"></a>どうやって'リードオンリー'ファイルシステムを読み書きできるようにマウントするの? (<a href="#disks-filesystems">top</a>)
  </h4>
<p>
<a href="http://netbsd.gw.com/cgi-bin/man-cgi?mount+8+NetBSD-5.1+i386">mount(8)</a> の <code class="code">-u</code> (update) スイッチを使ってください:
'<span class="bold"><strong><code class="code">mount -u /</code></strong></span>'。
あなたはおそらくシングルユーザーで起動したのでしょうが、この場合、
ルートファイルシステムは、標準でリードオンリーでマウントされます。
これは、マルチユーザーでシステムが起動する前に、
手動で fsck を走らせる機会を与えてくれます。
読み書きできるように、
<code class="code">/etc/fstab</code> の全てのファイルシステムをマウントするもうひとつの方法は
'<span class="bold"><strong><code class="code">mount -a</code></strong></span>' をつかうことです。
</p>
<p>
しかしながら、これをする一番良い方法は、シングルユーザーシェルを抜けて
マルチユーザーモードに入ることです。
これで、 <code class="code">/etc/fstab</code> に載せられているモードで
その全てのファイルシステムをマウントします。
</p>

<h4 class="title">
<a name="using-fsck"></a>いつ fsck を使うのが安全なの? (<a href="#disks-filesystems">top</a>)
  </h4>
<p>
<a href="http://netbsd.gw.com/cgi-bin/man-cgi?fsck+8+NetBSD-5.1+i386">fsck(8)</a> は、アンマウントされているか、
リードオンリーのファイルシステムにだけ
使うようにしてください。
読み書きできるファイルシステムに
fsck(8) をかけることは危険で、ファイルシステムをより悪くしてしまうかもしれません。
シングルユーザーモードでシステムを起動すれば、リードオンリーでマウントされます。
そこで '<span class="bold"><strong><code class="code">fsck -p</code></strong></span>' とすることで、
システムがマルチユーザーモードで起動する前に、
全てのファイルシステムをチェックすることができます。
もし、ファイルシステムに既に "clean," とマークされているけど、
それでもまだチェックしたいなら、
<a href="http://netbsd.gw.com/cgi-bin/man-cgi?fsck+8+NetBSD-5.1+i386">fsck(8)</a> に <code class="code">-f</code> フラグ を使うことができます。
</p>
<p>
fsck を使って、ファイルシステムになにかの変更がされたら
たぶん、ディスクを同期せずに機械をすぐリブートするために
 '<span class="bold"><strong><code class="code">reboot -n</code></strong></span>'
と打つのが、一番良いことでしょう。
</p>

<h4 class="title">
<a name="kernfs"></a> <code class="code">/kern</code> は何に使われているの? (<a href="#disks-filesystems">top</a>)
  </h4>
<p>
それは、 kernfs ファイルシステムのマウントに使われています。
<a href="http://netbsd.gw.com/cgi-bin/man-cgi?mount_kernfs+8+NetBSD-5.1+i386">mount_kernfs(8)</a> マニュアルページを見てください。
</p>

<h4 class="title">
<a name="procfs"></a> <code class="code">/proc</code> は何に使われているの? (<a href="#disks-filesystems">top</a>)
  </h4>
<p>
それは、 procfs ファイルシステムのマウントに使われています。
<span class="emphasis"><em>The Design and Implementation of the 4.3BSD UNIX Operating System</em></span>
by Leffler, McKusick, et al., p. 104-5, 436 を調べてください。
<a href="http://netbsd.gw.com/cgi-bin/man-cgi?mount_procfs+8+NetBSD-5.1+i386">mount_procfs(8)</a> マニュアルページも見てください。
</p>
<p>

これは、普通 root で '/proc' ディレクトリーを作って、
/etc/fstab ( <a href="http://netbsd.gw.com/cgi-bin/man-cgi?fstab+5+NetBSD-5.1+i386">fstab(5)</a> を見よ) に次のように加えることで使われています:<br>
<code class="code">/proc /proc procfs rw 0 0</code>
</p>
<p>

NetBSD では <code class="code">/proc</code> はプロセス関連のデータ専用になっているため、
それ以外の linux で使われているような項目は提供されません。しかし、
以下のようにファイルシステムフラグに "<code class="code">linux</code>" オプションを加えることで、
変えることができます。<br>
<code class="code">/proc /proc procfs rw<span class="bold"><strong>,-olinux</strong></span> 0 0</code>
</p>
<p>
</p>

<h4 class="title">
<a name="cgd-swap"></a><a href="http://netbsd.gw.com/cgi-bin/man-cgi?cgd+4+NetBSD-5.1+i386">cgd(4)</a> を使ったスワップの暗号化 (<a href="#disks-filesystems">top</a>)
  </h4>
<p>
スワップの暗号化については時々話題にのぼるため、ここで示す情報は
スワップスペースの暗号化に関心がある人にとっては有用かもしれませんが、
必須のものではありません。
</p>
<p>
現在、制約がひとつあります。 cgd デバイスは、 4.2BSD
と記されているスライスただひとつを含んだディスクラベルから作られますが、
これはスワップに使うには不適切です。
これが、 cgd ドライブをスワップデバイスとして使うことが面倒な理由です。
Roland Dowdeswell がこのことを調べており、近い将来解決されるはずです。
</p>
<p>

実際の例を示します:

  スワップデバイス wd0b を、 256 ビット aes-cbc 鍵を使って cgd1
  として設定します。手順の説明は以下のとおりです。

</p>
<pre class="programlisting">
  1) cgd デバイス用のパラメーターファイルを作ります。デフォルトでは /etc/cgd/wd0b
     になりますが、ここでは説明しやすくするため /etc/cgd/swap を使います。

     # cgdconfig -g -V none -k randomkey aes-cbc &gt; /etc/cgd/swap

  2) wd0b 上の cgd デバイスを設定します (この時点では wd0b
     がスワップデバイスとして使われていないことを確認してください)。

     # cgdconfig cgd1 /dev/wd0b /etc/cgd/swap

  3) cgd1 用にディスクラベルを編集します。妥当なスワップスライスを作る必要があるからです。
     編集したディスクラベルをファイルに保存します。

     # disklabel -e -I cgd1

     # /dev/rcgd1d:
     type: cgd
     disk: cgd
     label: default label
     flags:
     bytes/sector: 512
     sectors/track: 2048
     tracks/cylinder: 1
     sectors/cylinder: 2048
     cylinders: 128
     total sectors: 263655
     rpm: 3600
     interleave: 1
     trackskew: 0
     cylinderskew: 0
     headswitch: 0           # microseconds
     track-to-track seek: 0  # microseconds
     drivedata: 0

     4 partitions:
     #        size    offset     fstype  [fsize bsize cpg/sgs]
      d:    263655         0     4.2BSD      0     0     0   # (Cyl.    0 - 128*)

     スワップスライスを作り、ラベルを変更します (これは本当に必要なわけではなく、
     単に自分用の情報としてのものです)。

     # /dev/rcgd1d:
     type: cgd
     disk: cgd
     label: swap
     flags:
     bytes/sector: 512
     sectors/track: 2048
     tracks/cylinder: 1
     sectors/cylinder: 2048
     cylinders: 128
     total sectors: 263655
     rpm: 3600
     interleave: 1
     trackskew: 0
     cylinderskew: 0
     headswitch: 0           # microseconds
     track-to-track seek: 0  # microseconds
     drivedata: 0

     4 partitions:
     #        size    offset     fstype  [fsize bsize cpg/sgs]
      a:    263655         0       swap                      # (Cyl.    0 - 128*)

    そして、ファイルに保存します。

     # disklabel cgd1 &gt; /etc/cgd/swap.disklabel

  4) cgd デバイスを、ブート時に自動的に設定されるようにします。
     /etc/cgd/cgd.conf に以下の行を追加します。

     cgd1 /dev/wd0b /etc/cgd/swap

  5) ここで、ブート時に新たに作られた cgd デバイスにディスクラベルを書き戻す必要があります。
     以下のような単純な関数が書かれた /etc/rc.conf.d/cgd を作ります。

     swap_device="cgd1"
     swap_disklabel="/etc/cgd/swap.disklabel"
     start_postcmd="cgd_swap"

     cgd_swap()
     {
             if [ -f $swap_disklabel ]; then
                     disklabel -R -r $swap_device $swap_disklabel
             fi
     }

  6) cgd デバイスを、スワップデバイスとして /etc/fstab に追加します。

     /dev/cgd1a none swap sw 0 0</pre>
<p>

以上ですべてです。これで、 'swapctl -a /dev/cgd1a' または単にリブートすることで、
スワップパーティションを有効化できます。
</p>
<p>

以上でお見せした設定は、筆者のラップトップの設定です。
</p>
<pre class="programlisting">
   Device      1K-blocks     Used    Avail Capacity  Priority
   /dev/cgd1a     131827     8828   122999     7%    0</pre>
<p>
</p>
<hr>
<h3 class="title">ブート関連の質問</h3>
<h4 class="title">
<a name="why-single-user"></a>シングルユーザーモードってなに? 必要な理由と使い方は? (<a href="#boot-related">top</a>)
  </h4>
<p>
'single-user' モードはカーネルがブートした時の状態で、
コンソール上で1つのシェルが動いています。
シングルユーザーで起動すると、ルートファイルシステムだけが
リードオンリーでマウントされます。
多くのユーザーにとって、シングルユーザーモードは:
</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">傷んでる疑いのためにファイルシステムに <code class="code">fsck</code> をかける。</li>
<li class="listitem"> <code class="code">/etc</code> にある傷んだシステム設定ファイルを編集する。</li>
<li class="listitem">ダウンロードあるいは自分でコンパイルした新しいバイナリーセットをインストールする。</li>
<li class="listitem">ユーザープロセスからの干渉を気にせずにファイルシステムのバックアップをとる</li>
</ul></div>
<p>
動作中のシステムから、 root 権限で 
 '<code class="code"><span class="bold"><strong>shutdown now</strong></span></code>' を実行することで、
シングルユーザーモードに入れます。
または、システムの起動中に、
 '-s' フラグを使う(この方法はポートごとによってさまざまです)
ことでもできます。
</p>
<p>
シングルユーザーで起動した場合には、次のようないくつかのコマンドが便利かもしれません:
</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
<code class="code"><span class="bold"><strong>fsck -p ; mount -va</strong></span></code><br>
    <a href="http://netbsd.gw.com/cgi-bin/man-cgi?fsck+8+NetBSD-5.1+i386">fsck(8)</a> でファイルシステムをチェックし、それを <a href="http://netbsd.gw.com/cgi-bin/man-cgi?mount+8+NetBSD-5.1+i386">mount(8)</a> で使える状態にします。
</li>
<li class="listitem">
<code class="code"><span class="bold"><strong>set -E</strong></span></code><br>
    コマンドライン編集を有効にします。
</li>
<li class="listitem">
<code class="code"><span class="bold"><strong>TERM=vt220 ; export TERM</strong></span></code><br>
    <a href="http://netbsd.gw.com/cgi-bin/man-cgi?vi+1+NetBSD-5.1+i386">vi(1)</a> のようなエディターが動作できるように、
    TERM 変数を設定し、 export します。
    注意: コンソールタイプによって 'vt220' を別のターミナルタイプにする必要があります。
</li>
<li class="listitem">
<code class="code"><span class="bold"><strong>sh /etc/rc.d/network start</strong></span></code><br>
    ネットワークを起動します。
    nfs マウントされたファイルシステムがあるなら、
    fsck と mount の前に実行する必要があるでしょう。
    NetBSD 1.5 より前のシステムの場合は、このコマンドは
    <code class="code"><span class="bold"><strong>sh /etc/netstart</strong></span></code> にします。
</li>
</ul></div>
<p>
</p>

<h4 class="title">
<a name="single-user-to-multi-user"></a>どうやって、シングルユーザーからマルチユーザーに移行するの (<a href="#boot-related">top</a>)
  </h4>
<p>
シングルユーザーシェルを "exit" か ctrl-D で抜けてください。
</p>
<p>

これで、システムはマルチユーザーモードで起動し、各種サービス等が開始されます。
シングルユーザーからマルチユーザーへの移行の際にはディスクが検査されないことに
注意してください。
</p>

<h4 class="title">
<a name="boot-messages"></a>ブートメッセージはどうやって読むの? (<a href="#boot-related">top</a>)
  </h4>
<p>
システムメッセージバッファーは <a href="http://netbsd.gw.com/cgi-bin/man-cgi?dmesg+8+NetBSD-5.1+i386">dmesg(8)</a> で表示できます。
これは(1.4 以降では)いつも起動後ごとにすぐに
 /var/run/dmesg.boot に自動的に貯められます。
カーネルインストールで kernfs ( <a href="http://netbsd.gw.com/cgi-bin/man-cgi?mount_kernfs+8+NetBSD-5.1+i386">mount_kernfs(8)</a> を見よ) 
が有効になっているなら、
 <code class="code"><span class="bold"><strong>more /kern/msgbuf</strong></span></code> もしてください。
</p>

<h4 class="title">
<a name="shutting-down"></a>どうやって機械をシャットダウンするの? (<a href="#boot-related">top</a>)
  </h4>
<p>
シングルユーザーモードに落ちるなら、
 '<span class="bold"><strong><code class="code">shutdown now</code></strong></span>' を使ってください。
機械を停止するのなら
 '<span class="bold"><strong><code class="code">shutdown -h now</code></strong></span>' を使ってください。
いくつかのポートでは、実際に電源を落とすなら
 '<span class="bold"><strong><code class="code">shutdown -p now</code></strong></span>' を使う必要があります。
完全な詳しいことは <a href="http://netbsd.gw.com/cgi-bin/man-cgi?shutdown+8+NetBSD-5.1+i386">shutdown(8)</a> マニュアルページを見てください。
</p>

<h4 class="title">
<a name="rebooting"></a>どうやって、機械をリブートするの? (<a href="#boot-related">top</a>)
  </h4>
<p>
'<span class="bold"><strong><code class="code">shutdown -r now</code></strong></span>' か '<span class="bold"><strong><code class="code">reboot</code></strong></span>' を使ってください。
  より細かいことは <a href="http://netbsd.gw.com/cgi-bin/man-cgi?shutdown+8+NetBSD-5.1+i386">shutdown(8)</a> や <a href="http://netbsd.gw.com/cgi-bin/man-cgi?reboot+8+NetBSD-5.1+i386">reboot(8)</a> マニュアルページを見てください。
</p>

<h4 class="title">
<a name="cron-reboot"></a>起動時にプログラムを開始する (<a href="#boot-related">top</a>)
  </h4>
<p>
システムのブート時にプログラムを起動するために、 <code class="code">/etc/rc.local</code>
にあらゆるコマンドを追加することができます。これは、ブート過程の
一番最後に実行されます。
</p>
<p>

root 以外の大多数のユーザー向けの代替策として、
( NetBSD で使っている) Vixie <a href="http://netbsd.gw.com/cgi-bin/man-cgi?cron+8+NetBSD-5.1+i386">cron(8)</a> の特別な時間指定 <span class="bold"><strong>@reboot</strong></span>
は、与えられたプログラムを <a href="http://netbsd.gw.com/cgi-bin/man-cgi?cron+8+NetBSD-5.1+i386">cron(8)</a> 起動時に開始することが可能です。
それはたいてい、システム起動時と一致します。これは root 特権の無いユーザーに、
起動時にコマンドを自動的に実行させることを許しているということです。
</p>
<hr>
<h3 class="title">メモリー/スワップの構成</h3>
<h4 class="title">
<a name="swap"></a>スワップスペース(空間)はどのくらい (<a href="#memory-swap">top</a>)
  </h4>
<p>
    古い unix システムでは、RAM の倍ほどの大きさのスワップスペースが推奨されています。
    これはなぜなら RAM のアクティブページは swap 上に配置されていなければならず、
    事実上、 仮想メモリーの合計は、 スワップ空間の大きさによって制限されていたからです。
     NetBSD では、これはもはや正しくなく、仮想メモリー合計は、スワップ + RAM が近似値です。
</p>
    <p>
    NetBSD の下では、スワップ空間は3つの基本的な利用目的があって:
</p>
    <div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<span class="bold"><strong>仮想メモリーの追加</strong></span><br>
	変更されたデータを含むアクティブページが少なくなると、
	物理メモリーより大きく準備された仮想メモリーとして
	データがスワップ空間へ移動することができます。
    </li>
<li class="listitem">
<span class="bold"><strong>カーネルのコアダンプのための場所</strong></span><br>
	これは起動時、 <a href="http://netbsd.gw.com/cgi-bin/man-cgi?savecore+8+NetBSD-5.1+i386">savecore(8)</a> に読まれます。
	これが機能するためには、プライマリースワップパーティションは
	全 RAM 容量よりわずかでも大きい必要があります。
    </li>
<li class="listitem">
<span class="bold"><strong> <a href="http://netbsd.gw.com/cgi-bin/man-cgi?mfs+8+NetBSD-5.1+i386">mfs(8)</a> ファイルシステムのため</strong></span><br>
	/tmp を使うあらゆるプログラムの高速化のために、
	古典的に /tmp をマウントすることで、
	<a href="http://netbsd.gw.com/cgi-bin/man-cgi?fstab+5+NetBSD-5.1+i386">fstab(5)</a> ファイルに次のように加えることによって:
	<pre class="programlisting">	swap  /tmp  mfs  rw,-s=<span class="emphasis"><em>SIZE</em></span> 0 0</pre>
	ここで <span class="emphasis"><em>SIZE</em></span> は 512byte ブロックのものです。
	この要求されたスペースは、スワップ空間から
	ファイルシステムとして使うために持ってこられます。
    </li>
</ol></div>
    <p>
    スワップの'正しい'値と言うのは、システムの利用法に依存しますが、
    いくつか一般的なルールがあって:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">基本容量として良いのは、 RAM容量か 32MB の大きい方に
	<a href="http://netbsd.gw.com/cgi-bin/man-cgi?mfs+8+NetBSD-5.1+i386">mfs(8)</a> ファイルシステムの全容量を足した量です。
    </li>
<li class="listitem">
<a href="http://netbsd.gw.com/cgi-bin/man-cgi?X+7+NetBSD-5.1+i386">X(7)</a> を実行するつもりなら、 RAM 容量の 1/2 か 16MBの大きい方を加えます。
    </li>
<li class="listitem">いつもスワップ帯域が増加するように、
	可能な限り沢山のディスクをまたがるようスワップを分割してみます。
    </li>
<li class="listitem">少ないよりは多いほうがと思います。- スワップを使い果たすと、
	システムは実行しているプロセスを kill させることができます。
    </li>
</ul></div>
<p>
</p>

<h4 class="title">
<a name="adding-swap"></a>動作中のシステムにスワップを追加する (<a href="#memory-swap">top</a>)
  </h4>
<p>
    システムは、
    <a class="ulink" href="#swap" target="_top">スワップスペースはどのくらい</a>のとおりの
    充分なスワップ空間が設定されているべきです。
</p>
    <p>
    設定されているシステムにスワップを追加するには3通りの方法があります:
</p>
    <p>
    </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<span class="bold"><strong>システムディスクを再構築し、大きなスワップパーティションを使います。
	</strong></span><br>
	この方法はおそらく最も美しい解決法ですが、
	明らかに重大な困難を伴います。
    </li>
<li class="listitem">
<span class="bold"><strong>スワップパーティションを追加します。</strong></span><br>
	ディスク追加時に、 小さい 'b' パーティションをスワップの追加のために
	含めるのは、大抵良いアイデアで、
	 <code class="code">/etc/fstab</code> ファイルに 起動時に自動的に有効になるように
	次の形式のエントリーを追加します
	<pre class="programlisting">	/dev/<span class="emphasis"><em>DISK</em></span>b       none    swap sw 0 0</pre>
	(ここで、 <code class="code"><span class="emphasis"><em>DISK</em></span></code> は 'sd1' や 'wd2' のような ディスクの名前です).
    </li>
<li class="listitem">
<p><span class="bold"><strong>スワップファイルを作ります。</strong></span></p>
<p>
	もっとも早く、簡単な選択は、
	存在するファイルシステムにファイルをつくり、
	追加スワップ空間として使うことです。
	これをアクセスすることは、
	専用のスワップパーティションをアクセスするよりわずかながら
	遅いでしょうが、
	 (フラグメンテーションやファイルシステムオーバーヘッドによる)
	スワップの不足を解決する一時的なものとしてはよいでしょう。
	</p>
	<p>
	10 MByte のスワップ空間を追加することは、
	充分な空き空間のあるファイルシステムを選ぶだけの簡単なことで:
	</p>
<pre class="programlisting">	# <span class="bold"><strong>dd if=/dev/zero bs=1m count=10 of=/somefilesystem/swap</strong></span>
	# <span class="bold"><strong>chmod 600 /somefilesystem/swap</strong></span>
	# <span class="bold"><strong>swapctl -a -p 1 /somefilesystem/swap</strong></span></pre>
<p>
	<a href="http://netbsd.gw.com/cgi-bin/man-cgi?dd+1+NetBSD-5.1+i386">dd(1)</a> コマンド が 10 MByte の
	`<code class="code">/somefilesystem/swap</code>' ファイルをつくります。
	このスワップファイルは、特権のないユーザーが
	その内容を読めないように、 <a href="http://netbsd.gw.com/cgi-bin/man-cgi?chmod+1+NetBSD-5.1+i386">chmod(1)</a> 600 をする必要があります
	(<a href="http://netbsd.gw.com/cgi-bin/man-cgi?swapctl+8+NetBSD-5.1+i386">swapctl(8)</a> は誰でも読めるファイルは拒否します) 。
	そして、 <a href="http://netbsd.gw.com/cgi-bin/man-cgi?swapctl+8+NetBSD-5.1+i386">swapctl(8)</a> コマンドは 
	<code class="code">/somefilesystem/swap</code> を
	優先度 1 のシステムスワップ領域として加えます。
	優先度 0 が (デフォルトの) 最も高い優先度です。
	優先度 1 にする理由は、ファイルへのスワップはわずかに遅いので、
	これを使うのは従来型のスワップを使い切ったときだけにしたいからです。
	</p>
	<p>
	このファイルをずっとスワップとして使うようにし、
	リブートの都度有効にするため、 /etc/fstab
	に以下のように書いておきます:
	</p>
	<pre class="programlisting">/somefilesystem/swap none swap sw,priority=1 0 0</pre>
    </li>
</ol></div>
<p>
</p>

<h4 class="title">
<a name="tuning-vm"></a>メモリーが少ないシステムでの性能改善のための仮想メモリーの調整 (<a href="#memory-swap">top</a>)
  </h4>
<p>
tech-kern メーリングリストの <a class="ulink" href="http://mail-index.NetBSD.org/tech-kern/2002/11/27/0005.html" target="_top">
Simon Burge の記事</a>によれば、仮想メモリーの設定に手を加えることで、
メモリーの少ないマシンの性能を大幅に改善することができます。
この記事をすべて読んだうえで、どう設定すべきか決めることが最善ではありますが、
要点は、 <code class="code">sysctl -w vm.anonmax=95</code> を実行するとよいということです。 <a href="http://netbsd.gw.com/cgi-bin/man-cgi?sysctl+3+NetBSD-5.1+i386">sysctl(3)</a>
マニュアルページによれば、これは「匿名アプリケーションデータを保持するために、
他のメモリーの用途から取り戻される物理メモリーのパーセンテージ」を変更します。
</p>
<hr>
<h3 class="title">一般の(それと一般ではない)問題</h3>
<h4 class="title">
<a name="nroff-missing"></a>'man' を実行すると <span class="bold"><strong>/usr/bin/nroff: not found</strong></span> となります (<a href="#common-problems">top</a>)
  </h4>
<p>
'text' セット (text.tgz) をインストールする必要があります。インストールノートを見てください。
</p>

<h4 class="title">
<a name="var-mail-permissions"></a>メールを読んでいる時 '<span class="bold"><strong>Unable to lock mailbox: Permission denied</strong></span>'が出ます (<a href="#common-problems">top</a>)
  </h4>
<p>
<code class="code">/var/mail</code> ディレクトリーのパーミッションをチェックしてください。
それは '<code class="code">drwxrwxrwt</code>'となっているべきで:
</p>
<pre class="programlisting">
% <span class="bold"><strong>ls -ld /var/mail</strong></span>
drwxrwxrwt  2 root  wheel  512 Nov  6 08:21 /var/mail</pre>
<p>
そうでなければ、 root になって '<code class="code"><span class="bold"><strong>chmod 1777 /var/mail</strong></span></code>' を実行します。
</p>

<h4 class="title">
<a name="kernel-not-netbsd"></a>'<code class="code">netstat -r</code>' を実行すると <span class="bold"><strong>netstat: kvm_read kvm_read: Bad address</strong></span> となります (<a href="#common-problems">top</a>)
  </h4>
<p>
これはなにも心配はいりません。
基本的に、 <code class="code">/netbsd</code> というファイルは
あなたの現在のカーネルではありません。
たくさんのプログラム( <code class="code">ps</code>, <code class="code">who</code>, <code class="code">systat</code> 等のような)
や libkvm <a href="http://netbsd.gw.com/cgi-bin/man-cgi?kvm+3+NetBSD-5.1+i386">kvm(3)</a> は
カーネル内がどうなっているかを知るために <code class="code">/netbsd</code> をアクセスします。
それで、この手のエラーを回避する為に、
あなたの現在のカーネルを <code class="code">/netbsd</code> に単純にリネームすることができます。
これをしている時に動作中のカーネルを上書きしていないか確かめてください。
それが、あなたがしようとしていることではないかぎり。
</p>

<h4 class="title">
<a name="libkvm-mismatch"></a>'<code class="code">netstat -r</code>' をしてみると、限りないクエスチョンマークの列が帰ってきます。 何が悪いの? (<a href="#common-problems">top</a>)
  </h4>
<p>
それは、 <code class="code">libkvm/netstat</code> と <code class="code">/netbsd</code> の間で不適合になっているからです。
または、 <code class="code">/netbsd</code> という名前ではないカーネルを走らせているからです。
この問題のほかの兆候は、
 <code class="code">who</code>, <code class="code">ps</code>, <code class="code">ifconfig</code> や <code class="code">systat</code> 
のようなものも良く動かないことでしょう。
もし、カーネルとバイナリーを同時にアップデートすれば、解決するでしょう。
</p>

<h4 class="title">
<a name="kernel-upgrade"></a>新しいカーネルにアップデートしたあと、 <code class="code">w</code>, <code class="code">ps</code>, と <code class="code">netstat</code> が働きません (<a href="#common-problems">top</a>)
  </h4>
<p>
2つのうちの1つです。
 現在起動しているカーネルが <code class="code">/netbsd</code> と名づけられていないか、
使っているカーネルとバイナリーの間で不適合があるかのどちらかです。
 最初の場合、単純に現在起動されているカーネルを
 <code class="code">/netbsd</code> にリンクをつくることで、問題は解決します。
</p>
<p>
2番目の場合、ダイナミックリンクされたバイナリーは、
 libkvm を新しいカーネルに適合するようにアップグレードすることで、
直せます。
スタティックリンクされたバイナリーは
より新しいバージョンの物に置きかえる必要があります。
それらはスタティックリンクされているので、
それらを再コンパイルしようとするなら、
問題のプログラムの再構築をする <span class="bold"><strong>前に</strong></span> <code class="code">libkvm.a</code> を再構築する必要が
あります。
</p>
<p>
John Wittkowski (jpw@netscape.com) に感謝、
これは彼による ( <code class="code">/bin/ps</code> のほかに)
libkvm に依存するプログラムのほとんどの一覧です
(これらの全ては <code class="code">/usr/bin</code> にあります): 
</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><code class="code">fstat</code></li>
<li class="listitem"><code class="code">gdb</code></li>
<li class="listitem"><code class="code">ipcs</code></li>
<li class="listitem"><code class="code">netstat</code></li>
<li class="listitem"><code class="code">nfsstat</code></li>
<li class="listitem"><code class="code">systat</code></li>
<li class="listitem"><code class="code">uptime</code></li>
<li class="listitem"><code class="code">vmstat</code></li>
<li class="listitem"><code class="code">w</code></li>
</ul></div>
<p>
</p>

<h4 class="title">
<a name="proc-size-mismatch"></a>カーネル変更後 'ps' が <span class="bold"><strong>"proc size mismatch"</strong></span> と言います (<a href="#common-problems">top</a>)
  </h4>
<p>
この前にある3つの疑問のように、
その答えは、たいてい、
libkvm がカーネルやバイナリーと同期がとれていないからです。
この問題を解決するには、
カーネルに適合したバイナリー配布物を手に入れるか、
下に示した方法で構築するかのどちらかの方法がとれます:

</p>
<pre class="programlisting">
"proc size mismatch" エラーが出て、 lib のアップデートが必要だと決意した場合、
次のようにします:

1. 全ソースコードを手に入れます。
   もし、あなたがこれをしたり、再コンパイルをすることを望まなくても、
   誰かがこの作業をしたか探すよりは、
   いちいち手作業をしてインストールに挑戦しましょう。

2. インクルードファイルが 更新されているか確認します。
   このようにし:
      cd /usr/src
      make includes
   これは、ちょっと時間がかかるでしょう。
   いくつかの Makefile に INSTALL 変数が定義されていなかったため、
   私は何度かトラブルに遭いました。
   "make includes" が失敗するごとに、
   表示されている、最後のディレクトリーに行って、
   Makefile にこの行を加えました:
      INSTALL=/usr/bin/install
   これを何度か行なうことで、エラーなしに終わることができました。

   (まず、 /usr/bin/make と /usr/share/mk 内の全てのファイルが
   更新されていることを確かめれば、 上の問題点を避けることができるでしょう。)

3. libkvm を再構築し、インストールします:
      cd /usr/src/lib/libkvm
      make
      make install
   注意として、 libkvm を得る目的で
   私のシステムでコンパイルをするのに、
   次のようなリンクを加える必要がありました:
      cd /usr/include/machine
      ln -s ../m68k/kcore.h kcore.h
   これはたぶん私のシステムの癖なので、
   最初にこれをせずにコンパイルを試してください。

4. そして、 libkvm にスタティックリンクされたバイナリーを再構築します。
   私が気がついているスタティックリンクされたプログラムは
   "/bin/ps" だけで、  ps の再構築には、単純に:
      cd /usr/src/bin/ps
      make
      make install

5.  libkvm にダイナミックリンクされたバイナリーは、
   再構築が必要かもしれませんし、必要ないかもしれません。
   これは、なぜかと言うと(私が考えるに)、
   古いバイナリーに対し、 lib の メジャーバージョン番号 が変わるなら、
   古いバージョン番号を求めていて、新しいバージョンの lib では動かないでしょう。
   たとえば、 私の古い libkvm は libkvm.so.4.0 で、
   その新しいものは libkvm.so.5.0 です。
   ダイナミックリンクされたバイナリー を再コンパイルしなければ、
   "proc size mismatch" ( 4.0 lib がまだそこにあれば)か、
   some lib missing error ( /usr/lib から 4.0 lib が取り除かれていれば)
   と不平を言うでしょう。
   マイナーバージョンナンバーの変更 (たとえば 4.0 から 4.1) なら
    warning を出しながらも動き、
   これらの全てを再コンパイルする必要はないでしょう。

   私が気がついている ダイナミックリンクされたバイナリーは
    "proc size mismatch" エラー ( 4.0 lib がまだそこにあれば) か
    some lib missing エラー ( /usr/lib から 4.0 lib が取り除かれていれば) 
   を出すでしょう。
   マイナーバージョンナンバーの変更 (たとえば 4.0 から 4.1) なら
    warning を出しながらも動き、
   これらの全てを再コンパイルする必要はないでしょう。

   私が気がついているダイナミックリンクされたバイナリーは:
      /usr/bin/fstat
      /usr/bin/gdb
      /usr/bin/ipcs
      /usr/bin/netstat
      /usr/bin/nfsstat
      /usr/bin/systat
      /usr/bin/uptime (linked to /usr/bin/w)
      /usr/bin/vmstat
      /usr/bin/w
   注意 /usr/bin/uptime は /usr/bin/w にリンクされていて、
   w に対して "make install" をすることで、セットアップされるでしょう。

   これらを再コンパイルするには、次のようにし:
      cd /usr/src/usr.bin/&lt;cmd&gt;
      make 
      make install
   たとえば、 /usr/bin/vmstat を再コンパイルするには:
      cd /usr/src/usr.bin/vmstat
      make
      make install</pre>
<p>

これに関する具体的な答えをくれた John Wittkowski (jpw@netscape.com) に感謝

</p>
<p>
小さな背景: 
これらのシステムユーティリティーに、上にあげたすべての問題も含め、
カーネルメモリー情報を手に入れさせ続ける必要がある理由は、
この手段がカーネルクラッシュダンプに対しても働き、
カーネルデバッグ作業に便利な特徴になることが出来るからです。
</p>

<h4 class="title">
<a name="hash-map-alias0"></a>'<span class="bold"><strong>hash map "Alias0":unsafe map file
    <code class="code">/etc/aliases</code>: No such file or directory</strong></span>' が表示されます (<a href="#common-problems">top</a>)
  </h4>
<p>
root 権限で '<span class="bold"><strong><code class="code">newaliases</code></strong></span>' と打つことで直せます。<br>
sendmail は <a href="http://netbsd.gw.com/cgi-bin/man-cgi?aliases+5+NetBSD-5.1+i386">aliases(5)</a> ファイルが存在しないとこれを報告します。

注 sendmail(8) は実際には
   <code class="code">/etc/aliases.db</code> ( <code class="code">/etc/aliases</code> からつくられる高速参照
   hash(3) マップ) を使い、それで、このエラーメッセージは小さな誤解をおこすのです。

これは、 NetBSD 1.3 から 1.4 だけで、注意すべきで、
ほかのバージョンでは、
必要に応じて <code class="code">/etc/sendmail.cf</code> を自動的に再構築する
異なる <code class="code">/etc/sendmail.cf</code> を持っています。

もし、古くても NetBSD 1.4.1 を走らせていなければ、
新しい <a class="ulink" href="../../releases/formal.html" target="_top">公式リリース</a> 
にアップグレードするべきです。
</p>

<h4 class="title">
<a name="portmap-messup"></a>どうやったら、 root でログインした時のシェルが出す <code class="code">portmap</code> メッセージ を抑制できますか (<a href="#common-problems">top</a>)
  </h4>
<p>
<a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/security/sudo/README.html" target="_top"><code class="filename">security/sudo</code></a> をつかって、そして、決して root でログインしないでください。
</p>
<p>
root でログインする必要があるなら、
<code class="code">/etc/syslog.conf</code> ファイルを編集することで、
うるさいメッセージを抑制するために
重要な 装備 を外すことができます。

たいていの場合、それは、次の行の
<code class="code">auth.debug</code> を無効化することで充分で:
</p>
<pre class="programlisting">*.notice;auth.debug                                     root</pre>
<p>
これで、それらのうるさい 
<code class="code">portmap&nbsp;[pid]:&nbsp;connect&nbsp;from&nbsp;some.other.host&nbsp;...</code> 
メッセージが消えるでしょう。

必ず
 <code class="code">kill&nbsp;-HUP</code> <code class="code">syslogd</code> の pid 
をしてください。
</p>
<p>
<code class="code">xconsole</code> を使うために、
<a class="ulink" href="../x/#xconsole" target="_top">FAQ 項目</a>も見るのもいいかもしれません。
</p>

<h4 class="title">
<a name="locales"></a>どうやったらウムラウトその他の地域的な文字を表示できますか? (<a href="#common-problems">top</a>)
  </h4>
<p>

NetBSD 1.6 には、デフォルトで数々のロケールがインストールされています。これらのロケールは
<code class="code">/usr/share/locales</code> にあります。あなたの居住地にもっとも合ったロケールを選んで、
環境変数 LC_ALL を適切に設定してください。なお、 LC_ALL をたとえば ``de_DE''
に設定するのでは不十分なことに注意してください。 ``de_DE.ISO8859-15'' のような
<span class="emphasis"><em>完全な</em></span>ロケールを使う必要があります
</p>
<p>
古いバージョンの NetBSD 向けに、<a class="ulink" href="http://mail-index.NetBSD.org/netbsd-users/2000/11/09/0019.html" target="_top">メール アーカイブ</a>
からの情報を以下に示します:
</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"> <a class="ulink" href="ftp://ftp.NetBSD.org/pub/NetBSD/arch/i386/french-1.4/locale.tgz" target="_top">locale.tgz</a> を
取得してください。</li>
<li class="listitem"> / にそれを展開し: <code class="code">tar plzvxCf / locale.tgz</code>
</li>
<li class="listitem"> シェルで、 set LC_ALL=iso_8859_1 してください。
(常時設定にするには、 .cshrc 、 .profile 、 ...において)</li>
<li class="listitem"> シェルを再起動するか、ログインしなおしてください。</li>
<li class="listitem"> シェルを見ると、 vi その他 キーボードからのこれらウムラウトのすべてを
受け付けます: öäüÄÖÜ...
(訳者注:環境によっては化けているかもしれません)</li>
</ol></div>
<p>
</p>
<hr>
<h3 class="title">その他の疑問</h3>
  <h4 class="title">
<a name="bluetooth"></a>NetBSD で Bluetooth を使えるようにする方法は? (<a href="#other-questions">top</a>)
  </h4>
  <p>
    Bluetooth に対応した最初の公式 NetBSD バージョンは、
    NetBSD 4.0 になります。準備と設定の方法を記した
    <a class="ulink" href="http://wiki.netbsd.se/index.php/Bluetooth" target="_top">howto</a>
    が用意されています。
    
  </p>

<h4 class="title">
<a name="editing-files"></a> NetBSD でのファイル編集 (<a href="#other-questions">top</a>)
  </h4>
<p>
基本システムには2通りの明らかな選択肢があって:
</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
<a href="http://netbsd.gw.com/cgi-bin/man-cgi?ed+1+NetBSD-5.1+i386">ed(1)</a> (Line 指向 のテキストエディター)<br>
    <code class="code">ed</code> は非常に単純なテキストエディターです。
    これには、コマンドモード(起動時に選択されている)と
    入力(インプット)モードがあります。

    その一番の利点は、 '/' ファイルシステムだけがマウントされた
    シングルユーザーモードでも存在していて、
    正しいターミナルタイプに設定されていなくても動作することです。

     <a href="http://netbsd.gw.com/cgi-bin/man-cgi?ed+1+NetBSD-5.1+i386">ed(1)</a> の基本的な理解をすることは、価値のあることで、
    - 非常時に、 <a href="http://netbsd.gw.com/cgi-bin/man-cgi?fstab+5+NetBSD-5.1+i386">fstab(5)</a> と <a href="http://netbsd.gw.com/cgi-bin/man-cgi?rc.conf+5+NetBSD-5.1+i386">rc.conf(5)</a> ファイルを直すのに充分です。</li>
<li class="listitem">
<a href="http://netbsd.gw.com/cgi-bin/man-cgi?vi+1+NetBSD-5.1+i386">vi(1)</a> (Screen 指向のテキストエディター)<br>
    <code class="code">vi</code> は <a href="http://netbsd.gw.com/cgi-bin/man-cgi?ex+1+NetBSD-5.1+i386">ex(1)</a> のコマンドモードとインプットモードを持ち、
    だが、フルスクリーンビジュアルインターフェースが加えられています。

    vi は基本インストールで存在する唯一のスクリーンエディターで、
    実行には、妥当なターミナルタイプが要求されます。<br>
    たくさんのオンラインの vi チュートリアル(個人指導)があって:
    <div class="itemizedlist"><ul class="itemizedlist" type="circle">
<li class="listitem">
<a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/editors/vilearn/README.html" target="_top"><code class="filename">editors/vilearn</code></a> - pkgsrc にあって、高く推奨します。</li>
<li class="listitem">
<a class="ulink" href="http://www.thomer.com/vi/vi.html" target="_top">
	VI 愛好者ホームページ(英文)</a>.</li>
<li class="listitem">
<a class="ulink" href="https://engineering.purdue.edu/ECN/Resources/KnowledgeBase/Categories/editors/vi/" target="_top">Purdue
	University Engineering Computer Network</a>.</li>
<li class="listitem">
<a class="ulink" href="http://engr.smu.edu/co/help/vi-tutorial.html" target="_top">
	Southern Methodist University のいくつかの参考文献</a>.
    </li>
</ul></div>
    <a href="http://netbsd.gw.com/cgi-bin/man-cgi?rc.conf+5+NetBSD-5.1+i386">rc.conf(5)</a> の設定に vi を使うことを試みるなら、
    <a class="ulink" href="#why-single-user" target="_top">シングルユーザーモード</a> の
    項目を読むべきです。
    </li>
</ul></div>
<p>
</p>
<p>
pkgsrc の
<a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/editors/README.html" target="_top"><code class="filename">editors</code></a>
カテゴリーには、沢山の数のエディターがあって:
</p>
<p>
</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
<span class="bold"><strong><a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/editors/joe/README.html" target="_top"><code class="filename">editors/joe</code></a></strong></span><br>
    WordStar と emacs のキー割り当て (<span class="emphasis"><em>jstar</em></span>, <span class="emphasis"><em>jmacs</em></span>) を
    エミュレートできる小さくて高速なエディター
    <a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/editors/joe/README.html" target="_top"><code class="filename">editors/joe</code></a> は
    Borland IDE を使う人達に知られているでしょう。
    </li>
<li class="listitem">
<span class="bold"><strong><a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/editors/pico/README.html" target="_top"><code class="filename">editors/pico</code></a></strong></span><br>
    非常にシンプルに使えるテキストエディターで、
    <a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/mail/pine/README.html" target="_top"><code class="filename">mail/pine</code></a>
    メールパッケージで使われています。
    </li>
<li class="listitem">
<span class="bold"><strong><a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/editors/nedit/README.html" target="_top"><code class="filename">editors/nedit</code></a></strong></span><br>
    シンプルだけど便利な、融通の利く X ベースの GUI エディター。
    </li>
<li class="listitem">
<span class="bold"><strong><a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/editors/emacs/README.html" target="_top"><code class="filename">editors/emacs</code></a></strong></span><br>
    ことわざにある 'なんでもかんでも (everything and the kitchen sink)'
    なエディターで、完全な lisp インタープリターを含みます。
    小さな機械には推奨されません。
    </li>
</ul></div>
<p>

</p>

<h4 class="title">
<a name="rebuilding-dev"></a><code class="filename">/dev</code> の再構築 (<a href="#other-questions">top</a>)
  </h4>
<p>
<code class="filename">/dev</code> ディレクトリーには、
ハードウェアと 擬似デバイスをアクセスするために必要な
デバイスファイルが含まれています。
もしそれが、ダメージを受けていれば、

もっと不思議なことが結果として起こるでしょう。
<code class="filename">/dev</code> ディレクトリーを再構築するには、
まずシングルユーザーで起動するべきです
 (マルチユーザーででもできるかもしれないが、推奨しません)。そして:
</p>
<pre class="programlisting">
mkdir /newdev
cd /newdev
cp /dev/M* .
sh MAKEDEV all
cd /
mv dev olddev; mv newdev dev
rm -r olddev</pre>
<p>
</p>

<h4 class="title">
<a name="connecting-a-ups"></a>NetBSD システムに UPS をつなぐ (<a href="#other-questions">top</a>)
  </h4>
<p>
UPS をつなぐのは単純なことだけど、
監視して、電源が落ちたときに、
きちんと NetBSD をシャットダウンするには、ちょっとした事が必要で:<br>
Simon J. Gerraty は
<a class="ulink" href="http://www.crufty.net/sjg/apcmon.html" target="_top">APC Smart-UPS</a> を使うための
ページを開設しています。
UPS と通信するソフトウェアを書くには、 tcsetattr() 経由で
 softcar フラグを設定する必要があるでしょう。
Wolfgang Rupprecht は、簡単なフィールド調査をしました:
</p>
<p>
</p>
<div class="blockquote"><blockquote class="blockquote">
UPS インターフェースは異なる2種類の型があって、
ときどき、同じ UPS に両方存在しています。
UPS についている 9ピンのコネクターには、決して、普通の PC-style RS-232 として配線しないでください。
最善のものは、 3芯で、それを保つようにピンを再配置した RS-232 インターフェースです。
最悪なのは、内部信号端子(??)が RS-232 の 信号電圧 ですらなく、
変わったケーブルを使う必要のあるもので、
そのケーブルは電圧レベル変換装置がついていて、
それによってRS-232 ポートから見えるようになっているものです。
後者の型のインターフェースからの信号は、
1bit(通常/電源断)の信号を送出するだけです。
それは DCD のような モデム制御信号 で処理されるべきで、
プログラム経由でモデム制御信号の状態をチェックして検出するべきです。
注意しないと、 UPS に付いてきた、モデム制御信号だけのケーブルと
本物の RS-232 ケーブルがごっちゃになってしまいます。
<br><br>
 APC web page を捜しまわったり、
 altavista でいくつか当たった有望なものによると、
 3 つの基本的なインターフェースがあることがわかりました。

  低価格帯の UPS ("back UPS") は
 モデムコントロールライン タイプのインターフェースだけを持っています。

高価格帯の2つ ("Back UPS Pro", "Smart UPS") は
モデムコントロールラインと 3芯 RS-232 信号の両方の組み合わせを持っています。
どちらかのケースでは、
2つのうちのどらちかの種類の特殊ケーブルを使う必要があります。

モデムコントロールラインインターフェースのケーブルには、
レベルシフトのためにトランジスターとダイオードが入っています。
(電源はほかの線のどれかからとってきます)。

それは UGLY という単語がぴったりだと思えるほど
本当にぶざまな解決法で、正しく変更するべきです。(???)

2番目のタイプのケーブルは、 UPS とシリアルで会話できるでしょうが、
いくつかの 3-rd party のドキュメントには、 UPS は
ストップビットを2ビットで送信する時だけ喋ると示されています。	

プロトコルに関する公式ドキュメントは無いようで、
また、 back-UPS pro と smart UPS は異なるシリアルラインプロトコルを
喋るようです。

 back-UPS pro ラインだけが いくつかの サードパーティー のサポートがあるようで、
プロトコルの詳細の多くが推測だけのようです。
<br><br>
競合品のどれもが、 (modem コントロール信号 だけ、および、
特殊ケーブルで(知的財産)権利のある シリアル信号プロトコル)を真似しているようです。
  私は、標準規格についての公開された文書を見つけることができませんでした。
</blockquote></div>
<p>
</p>

<h4 class="title">
<a name="changing-motd"></a><code class="code">/etc/motd</code> を何らかの変更をしてももとの内容に戻ってしまいます (<a href="#other-questions">top</a>)
  </h4>
<p>
<code class="code">/etc/motd</code> のヘッダーを消すと、
起動時にスタートアッププロセスがあなたのした変更を上書きします。
これは、 <code class="code">/etc/rc.conf</code> 内で <code class="code">update_motd=NO</code> と
設定することで無効にすることができ、
これで、<code class="code">/etc/motd</code> にはまったく手が加わらなくなり、
あなたが、変更することができるようになります。

</p>

<h4 class="title">
<a name="selling-hardware"></a>どこへ NetBSD 関連のハードウェアを売ればいいの? (<a href="#other-questions">top</a>)
  </h4>
<p>
補助アイテムのために、一般的に、
その port の <a class="ulink" href="../../mailinglists/" target="_top">メーリングリスト</a> と、
 <a class="ulink" href="mailto:netbsd-forsale@mono.org" target="_top">netbsd-forsale@mono.org</a> 
に投稿することができます。
NetBSD の開発を支援するために何らかのハードウェアを寄付したいのなら、
 <a class="ulink" href="../../contrib/hardware.html" target="_top">ハードウェア寄付ページ</a> をチェックするか、
 <a class="ulink" href="mailto:finance-exec@NetBSD.org" target="_top">finance-exec@NetBSD.org</a> に連絡してください。
</p>

<h4 class="title">
<a name="setup-ccd"></a>ストライプ (ccd) ドライブを設定する (<a href="#other-questions">top</a>)
  </h4>
<p>

ディスクストライピングは、 NetBSD では RAIDframe または <a href="http://netbsd.gw.com/cgi-bin/man-cgi?ccd+4+NetBSD-5.1+i386">ccd(4)</a> を使っておこなうことができます。
ここでは <a href="http://netbsd.gw.com/cgi-bin/man-cgi?ccd+4+NetBSD-5.1+i386">ccd(4)</a> の使い方を説明します。

</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">全てのディスクに disklabel をつけます:<br>
結合したいパーティションをつくり、
開始オフセットを 確かめます
( 16 セクターでまったく充分 - 確信しているわけじゃないけど)。

この種の問題が起こっても、私にはわかりません。
"普通の" 4.2BSD パーティション を使っているので。
</li>
<li class="listitem">ccd を設定します。<br>
性能チューニングで、
最も良いインターリーブを見つけるために少し試してみる必要があるでしょう。
私の場合、2つのディスクで 48 が良く動作します。

私が知る限り、16 かいくつかのほかの数字では、
全ての inode が同じディスク上に存在してしまうので、
パフォーマンス向上にはならないでしょう。
私の記憶が確かなら、
コンポーネントのセクター数をインターリーブの倍数にしないと、
いくつかの問題がありました。
</li>
<li class="listitem">普通のハードディスクと同様に ccd に disklabel を書きます。</li>
<li class="listitem">ccd を newfs します。</li>
<li class="listitem">それをマウントします。</li>
</ol></div>
<p>
</p>
<p>
より詳しい情報は <a href="http://netbsd.gw.com/cgi-bin/man-cgi?ccd+4+NetBSD-5.1+i386">ccd(4)</a> と <a href="http://netbsd.gw.com/cgi-bin/man-cgi?ccdconfig+8+NetBSD-5.1+i386">ccdconfig(8)</a> のマニュアルページを見てください。
</p>

<h4 class="title">
<a name="edit-fonts"></a>コンソールのビットマップフォントの作成や編集用のユーティリティーは? (<a href="#other-questions">top</a>)
  </h4>
<p>
<a href="ftp://ftp.NetBSD.org/pub/pkgsrc/current/pkgsrc/sysutils/pcvt-utils/README.html" target="_top"><code class="filename">sysutils/pcvt-utils</code></a> パッケージをインストールしてください。
このパッケージには、fed と fontedit
という二つのフォントエディターが含まれており、
これらは <code class="filename">/usr/share/wscons/fonts</code> のフォント用としても使うことができます。
</p>
<hr>
<h3 class="title">他のリンク</h3>
<h4 class="title">
<a name="mreriksson"></a><a class="ulink" href="http://www.mreriksson.net/faqs/netbsd/" target="_top">Ola Eriksson の NetBSD FAQ</a> (<a href="#other-links">top</a>)
  </h4>

<h4 class="title">
<a name="japanese-language-support"></a><a class="ulink" href="http://ezine.daemonnews.org/200202/japanese-netbsd.html" target="_top">NetBSD の日本語サポート</a> (<a href="#other-links">top</a>)
  </h4>
</div></div></div>
<div class="navfoot"></div>
<div id="footer"><center>
<span class="footfeed"><a href="http://www.NetBSD.org/cgi-bin/feedback.cgi">
	  連絡</a> |
      </span><span class="footcopy"><a href="../../../ja/about/disclaimer.html">
      免責事項</a> |

      <span class="copyright">Copyright © 1994-2012 The NetBSD Foundation, Inc. </span>ALL RIGHTS RESERVED.<br>NetBSD<sup>®</sup> は The NetBSD
	Foundation, Inc. の登録商標です。</span>
</center></div>
</div></body>
</html>
