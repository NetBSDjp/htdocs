<html>
<head>

<!-- DO NOT EDIT THIS FILE. EDIT 'kernel-profiling.list' AND RUN 'make' -->

<!-- Copyright (c) 1999 The NetBSD Foundation, Inc.
     ALL RIGHTS RESERVED. -->
<link rev="made" href="mailto:kenh@NetBSD.ORG">
<title>NetBSD 開発者ドキュメント: カーネルプロファイリング HOWTO</title>
</head>
<body bgcolor="#FFFFFF" text="#000000">

<h2><a name="top">NetBSD 開発者ドキュメント: カーネルプロファイリング HOWTO</a></h2>
<font><ul>
<li><a href="#how-does-it-work">どのように動作するのか</a></li>
<li><a href="#call-graph-recording">呼び出しグラフの記録</a></li>
<li><a href="#statistical-profiling">統計的なプロファイリング</a></li>
<li><a href="#how-to-use-it">使い方</a></li>
</ul></font>


この文章にはどのようにカーネルプロファイリングが動作し、
どう使うのかが書かれています。このドキュメントはMatthias Drochner
<a href="mailto:drochner@zel459.zel.kfa-juelich.de">&lt;drochner@zel459.zel.kfa-juelich.de&gt;</a>の筆によります。

<hr>
<h2>NetBSD 開発者ドキュメント: カーネルプロファイリング HOWTO</h2><hr>
<p><dl><dt>
<font><h3><a name="how-does-it-work">どのように動作するのか</a>
<font size="-1">(<a href="#top">top</a>)</font></h3></font>
</dt><dd>
<p>
プロファイル済みのコードの振る舞いに関する、
2種類のデータが個別に記録されます:
全関数の呼び出し頻度 (呼び出しグラフプロファイリング)
と各関数の処理にかかった時間です。
これらは、適当にサンプルされた時に関数内にあるプログラムカウンターの
確率によって概算され、その確率は、調べている関数が実行中に起こる、
プロファイリングタイマーの割り込み率によって逆に概算されます。
<b><a href="http://www.flame.org/cgi-bin/uncgi/hman?page=gprof&amp;sect=1">gprof(1)</a></b> というユーティリティーを使って、データを解釈します。
しかし、二つのデータの相関性がないため、いくつか制限が出てきます。
これは、manページのBUGSの章に書かれています。
<p>
カーネルのプロファイリングとユーザープログラムのプロファイリングは、
よく似ています;
プロファイリングデータを処理する方法と、コントロールする方法が
若干違う程度です。
<p>
カーネルプロファイリングに関係するデータは、グローバル構造体の
<b><kbd>_gmonparam</kbd></b> 内にあります。
この構造体は、(<b><kbd>kern/subr_prof.c</kbd></b> 中の)
<b><kbd>kmstartup()</kbd></b> により、システムが初期化する際に
初期化されます。
ユーザーレベルのコントロールプログラムである<b><a href="http://www.flame.org/cgi-bin/uncgi/hman?page=kgmon&amp;sect=8">kgmon(8)</a></b> は、
コントロールとデータアクセスのために<b><a href="http://www.flame.org/cgi-bin/uncgi/hman?page=sysctl&amp;sect=3">sysctl(3)</a></b>を呼び出し、
一部<b><a href="http://www.flame.org/cgi-bin/uncgi/hman?page=kvm&amp;sect=3">kvm(3)</a></b> アクセスを呼び出しています
(動作しているカーネルがプロファイルされる標準的な場合もです!) 。

</dd></dl></p>
<p><dl><dt>
<font><h3><a name="call-graph-recording">呼び出しグラフの記録</a>
<font size="-1">(<a href="#top">top</a>)</font></h3></font>
</dt><dd>

プロファイリングのフラグ (<b><kbd>-pg</kbd></b>) により、
コンパイラーは関数のエントリーごとに<b><kbd>mcount()</kbd></b>を
呼び出します。
これは、マシン独自の橋渡しによって、
<b><kbd>_mcount(frompc, selfpc)</kbd></b>へ送られます。
<b><kbd>_mcount(frompc, selfpc)</kbd></b>は
<b><kbd>sys/lib/libkern/mcount.c</kbd></b>で実装されます。
<b><kbd>frompc</kbd></b>は関数を呼び出すアドレスで、
<b><kbd>selfpc</kbd></b>は呼ばれる関数自体のアドレスです。
<p>
プロファイル中に遭遇する全ての
(<b><kbd>frompc</kbd></b>, <b><kbd>selfpc</kbd></b>) 用に、
<b><kbd>struct tostruct</kbd></b>は
<b><kbd>_gmonparam.tos</kbd></b> が示す配列から割り当てられます。
エントリーは最初に使用する順番で、始めから終わりまで単純に割り当てられます。
<b><kbd>kmstartup()</kbd></b>内のあるマジックによって、
カーネルのテキストサイズから配列のサイズが決められます--
一種の"経験則" のようです。
<p>
<b><kbd>struct tostruct</kbd></b> のエントリーは、ヒストグラムカウンターと
一緒に、呼ばれた関数 (<b><kbd>selfpc</kbd></b>) のアドレスを持っています。
同じ呼び出しアドレスにあるエントリーは、リンクした一覧を形成します。
一覧のヘッド (つまり、特定の呼び出しアドレスに属する
<b><kbd>_gmonparam.tos</kbd></b> 配列内の最初のエントリーの見出し)
は、<b><kbd>_gmonparam.froms</kbd></b>という二つ目のデータ配列に
あります。この<b><kbd>_gmonparam.froms</kbd></b> は、
ある値によって分割された呼び出しアドレス (<b><kbd>frompc</kbd></b>)
により、見出しを付けられます (ある値は、コード内の二つの呼び出しの最短距離
より長くなることはありません - <b><kbd>sys/sys/gmon.h</kbd></b>
にあるコメントを見てください) 。
<p>
標準的な関数呼び出しには、それぞれの<b><kbd>frompc</kbd></b>
に対して<b><kbd>selfpc</kbd></b>がひとつしかないことに注意してください。
その結果、典型的な一覧が一つのメンバーのみで構成されるようになります。

</dd></dl></p>
<p><dl><dt>
<font><h3><a name="statistical-profiling">統計的なプロファイリング</a>
<font size="-1">(<a href="#top">top</a>)</font></h3></font>
</dt><dd>

プロファイリングが始まると、プロファイリングタイマーの割り込みが
セットされ、<b><kbd>statclock()</kbd></b> を呼び出します
(<b><kbd>sys/kern/kern_clock.c</kbd></b> を参照してください) 。
プロファイリングタイマーは、関数への干渉がシステムのクロックと
同期して動かなくならないように、通常のシステムクロックから独立した
タイマーであるべきです。
<b><kbd>statclock()</kbd></b> はユーザープログラムでも、
カーネルプロファイリングでも使われます。
<p>
ある値で再分割されていれば、割り込み時にプログラムカウンターは
見出しとして使われて、ヒストグラムの<b><kbd>_gmonparam.kcount</kbd></b>
に記録され、該当するセルの値が増えます。

</dd></dl></p>
<p><dl><dt>
<font><h3><a name="how-to-use-it">使い方</a>
<font size="-1">(<a href="#top">top</a>)</font></h3></font>
</dt><dd>

<ul>
<li> プロファイリングカーネルを構築し、ブートします。
  これには、<b><kbd>-p</kbd></b>フラグを用いて<b><a href="http://www.flame.org/cgi-bin/uncgi/hman?page=config&amp;sect=8">config(8)</a></b>します。
  用いなければ、特別なことはありません。プロファイリングカーネルは
  以下のようなメッセージを自動設定後、ルートファイルシステムが
  マウントされる前に出力します。
  <pre>
  Profiling kernel, textsize=1611256 [f0100000..f02895f8]</pre>
  after autoconfiguration, before the root filesystem
  is mounted.
<li> <b><kbd>/netbsd</kbd></b>が現在動作しているカーネルであるか
  確認してください。もし違えば、下の<b><a href="http://www.flame.org/cgi-bin/uncgi/hman?page=kgmon&amp;sect=8">kgmon(8)</a></b>の呼び出しで、
  <b><kbd>-N</kbd></b> オプションを使ってください。
<li> <b><kbd>kgmon -b</kbd></b>でプロファイリングを開始します。
<li> いくつかアプリケーションを起動して、システムの中でも調べたい部分に
  負担をかけます。
<li> <b><kbd>kgmon -h</kbd></b>でプロファイリングを止めます。
<li> <b><kbd>kgmon -p</kbd></b> を起動して、収集したデータを
  <b><kbd>gmon.out</kbd></b>というファイルに書き込みます。
<li> 他のものを計測する前に、<b><kbd>kgmon -r</kbd></b>でカーネル内の
  プロファイリングデータのバッファーをリセットします。
<li> <b><kbd>gmon.out</kbd></b> から人間が判読できる解釈を入手するため、
  以下のコマンドを実行します。<pre>
  % gprof /netbsd &gt; gprof.out</pre>
<li> データの解釈をします。
</ul>

</dd></dl></p>
<hr>

<a href=""><em>メインの開発者ページ</em>へ戻る</a>
<hr>


<table width="100%"><tr>
<td>
  <table><tr>
  <td>
    <a href="../">
    <img src="/images/NetBSD-banner.gif" border=0 alt=""></a>
  </td><td>
    <font>
    <a href="../">
    <img src="/images/empty.gif" border=0
     alt="NetBSD ">ホームページ</a>
    </font>
  </td>
  </tr></table>
</td><td>
  <table><tr>
  <td>
    <a href="../developers">
    <img src="/images/NetBSD-banner.gif" border=0 alt=""></a>
  </td><td>
    <font>
    <a href="../developers">
    <img src="/images/empty.gif" border=0
     alt="NetBSD ">開発者ドキュメント</a>
    </font>
  </td>
  </tr></table>
</td>
</table>


<address>
  kenh@NetBSD.ORG<br>
  $NetBSD: kernel-profiling.list,v 1.3 2000/01/19 01:13:25 abs Exp $<br>
  <a href="../Misc/disclaimer.html">Copyright &copy; 1998, 1999
    The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED.</a>
</address>
</body>
</html>
