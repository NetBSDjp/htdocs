#!/usr/bin/env perl

#	$NetBSD: data2html.pl,v 1.3 2000/09/21 11:19:12 dent Exp $
#
# Copyright (c) 1997 The NetBSD Foundation, Inc.
# All rights reserved.
#
# This code is derived from software contributed to The NetBSD Foundation
# by David Brownlee / absolute <abs@mono.org>
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. All advertising materials mentioning features or use of this software
#    must display the following acknowledgement:
#        This product includes software developed by the NetBSD
#        Foundation, Inc. and its contributors.
# 4. Neither the name of The NetBSD Foundation nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

# Generate split & all in one information files from 'vax-data'.
# Could be adapted to other data quite easily.
# Documentation would help...		<abs>
# Dynamically determining links from the text is going to get _really_ slow
# with large amounts of data, but just too convenient for now...
#
# Add Japanese support. I stole the basic idea from sakamoto's work
# in htdocs/ja/list2html.pl. <yyamano>
#

# use strict;
my(%opt);
use Getopt::Std;
&getopts('vq',\%opt);

$^W=1;
my($maxcol,$datafile,$start,%title2name,%title2section);
my($head,$tail,$intro,@fhs,@sections,%section2title,%name2title,%data);
$|=1;
$maxcol=80;
if( ! @ARGV )
    {
    print "Need data file\n";
    exit 3 ;
    }
$datafile=$ARGV[0];

$start=time;
&verbose("Read data\n");
$head=&read_file('head.txt') .
"\n<!-- Automatically generated by data2html.pl. DO NOT EDIT DIRECTLY -->\n\n";
$tail=&read_file('tail.txt');
$intro=&read_file('intro.txt');
&read_datafile($datafile);

&verbose("Output header and index to all files\n");
&output_all;
exit(0);

sub fail
    {
    print STDERR "\a",@_,"\n";
    exit(3);
    }

sub key2title
    {
    my($key)=@_;

    $key =~ s/-/ /g;
    $key =~ s/(.)/\U$1/;
    $key =~ s/ /&nbsp;/g;
    $key;
    }

sub output_all
    {
    my($section,$loop,$elapsed);

    open(OUT_FULL,'| nkf -j >full.html') || &fail("Cannot write full.html: $!");
    open(OUT_INDEX,'| nkf -j >sections.html')||&fail("Cannot write sections.html: $!");
    open(OUT_INTRO,'| nkf -j >index.html')||&fail("Cannot write index.html: $!");
    @fhs=('OUT_FULL','OUT_INDEX','OUT_INTRO',@sections);
    foreach $section ( @sections )
	{
	if( ! open($section,">$section.html") )
	    { &fail("Unable to write $section.html: $!"); }
	}

    $_=$head;
    $_ =~ s/\$title/オール・イン・ワン・ページ/g;
    print OUT_FULL $_;

    $_=$head;
    $_ =~ s/\$title/セクション・インデックス/g;
    print OUT_INDEX $_;

    $_=$head;
    $_ =~ s/\$title/イントロダクション/g;
    print OUT_INTRO $_;

    print OUT_INTRO <<END
<h2>この情報は三つのフォーマットで提供されています</h2>
<ul>
  <li><a href="sections.html">インデックス・ページ、セクション毎にわかれた
							    ページ</a><br>
      特定の情報だけが必要で、すべての情報をダウンロードしたくない場合に
      便利です。
  <li><a href="full.html">オール・イン・ワン・ページ</a><br>
      各セクションへ移動するためのインライン・リンクを使いたい場合に便利です。
  <li><a href="$datafile">プレイン・テキストのテーブル</a><br>
      上記の二つのフォーマットを生成するために使われるテキストデータベース
</ul>
END
;
    print OUT_INTRO $intro;

    foreach $section ( @sections )
	{
	$_=$head;
	$_ =~ s/\$title/$section2title{$section}/g;
	print $section $_;
	}

    &output_main_index;

    &verbose("Output entries\n");
    for( $loop=0 ; $loop<@sections ; ++$loop )
	{
	$section=$sections[$loop];
	&output_section_index($section,$loop?$sections[$loop-1]:undef,
					    $sections[$loop+1]);
	&output_section_entries($section);
	print $section $tail;
	}
    print OUT_FULL "$tail\n";
    print OUT_INDEX "$tail\n";

    foreach( @fhs )
	{ close($_); }
    if( $opt{'v'} )
	{
	$elapsed=time-$start;
	print "Elapsed: ",int($elapsed/60)," min, ",$elapsed%60," sec.\n";
	}
    }

sub output_main_index
    {
    my($section);
    my($fh,$ref);

    foreach $fh ( @fhs )
	{
	if( $fh eq 'OUT_INTRO' )
	    { next; }
	if( $fh eq 'OUT_FULL' || $fh eq 'OUT_INDEX' )
	    { print $fh "<font size=\"+3\"><a name=\"main_index\">メイン・",
	      "インデックス</a></font>\n"; }
	else
	    { print $fh "<font size=\"+3\"><a name=\"main_index\">インデックス</a>",
	      "</font>\n"; }
	print $fh "<ul>\n",
		  "  <li><a href=\".\">イントロダクション・ページ</a>\n";
	foreach $section ( @sections )
	    {
	    if( $fh eq 'OUT_FULL' )
		{ $ref="#section:$section"; }
	    else
		{ $ref="$section.html#section:$section"; }
	    print $fh "  <li><a href=\"$ref\">$section2title{$section}</a>\n";
	    }
	print $fh "</ul>\n\n";
	}
    }

sub output_section_entries
    {
    my($section,$fh)=@_;
    my($name,$entry,$text,$all,$right,$double,@double);

    &verbose("$section2title{$section}\n");
    foreach $name ( eval '@section_'.$section )
	{
	&verbose("    $name2title{$name}\n");
	$all="\n\n<p><b><big><a name=\"$section:$name\">\n".
	     "$name2title{$name}</a></big></b>\n<small>".
	     "<a href=\"#section:$section\">".
	     "($section2title{$section} インデックス)</a></small>\n<table border=1>\n";
	print OUT_FULL $all;
	print $section $all;
	$all='';
	$right=0;
	foreach $entry ( eval '@entry_'.$name )
	    {
	    $_=$data{$name}{$entry};
	    s/<[^>]*>//g;
	    $double=length($_)>$maxcol;
	    push(@double,$double);
	    if( $double )
		{
		if( $right )
		    {
		    $double[$#double-1]=1;
		    $right=0;
		    }
		}
	    else
		{ $right^=1; }
	    }
	if( $right )
	    {
	    $double[$#double]=1;
	    $right=0;
	    }
	foreach $entry ( eval '@entry_'.$name )
	    {
	    $text=$data{$name}{$entry};
	    $double=shift(@double);
	    if( ! $opt{'q'} )
		{
		foreach( keys %title2name )
		    {
		    if( $title2name{$_} ne $name )
			{
			$text =~ s+\b($_(|s|es))([,\.\?\)\s\n]|$)+<a href="#$title2section{$_}:$title2name{$_}">$1</a>$3+g;
			}
		    }
		}
	    if( ! $right || $double )
		{ $all.='<tr>'; }
	    $all.='<th width="1%" align=right>'.&key2title($entry).":</th>\n";
	    if( $double )
		{ $all.='<td colspan=3>'; }
	    else
		{ $all.='<td>'; }
	    $all.="$text</td>";
	    if( $right || $double)
		{ $all.='</tr>'; }
	    if( $double )
		{ $right=0; }
	    else
		{ $right^=1; }
	    $all.="\n";
	    }
	$all .="</table>";
	print OUT_FULL $all;
	$all =~ s/(#)([^:]+)/$2.html#$2/g;
	$all =~ s/section\.html#section:([^"]+)/$1.html#section:$1/g;
	print $section $all;
	}
    print OUT_FULL "\n\n";
    print $section "\n\n";
    }

sub output_section_index
    {
    my($section,$prev_section,$next_section)=@_;
    my($entry,$fh,$ref,$name);

    foreach $fh ( @fhs )
	{
	if( $fh eq 'OUT_FULL' )
	    { $ref="#$section"; }
	elsif( $fh eq $section || $fh eq 'OUT_INDEX' )
	    { $ref="$section.html#$section"; }
	else
	    { next; }
	print $fh "<hr><table width=\"100%\">\n",
		"  <tr>\n",
		"    <td><font size=\"+3\"><a name=\"section:$section\">",
			$section2title{$section},"</a></font></td>",
		"<td align=right valign=top>\n\n",
		"    <table border=0><tr>\n";
	if( $prev_section )
	    {
	    print $fh "    <td valign=top><small><a href=\"",
		    &section_url($prev_section,$fh),
		    "\">(前 - $section2title{$prev_section})</a>",
		    "</small></td>\n";
	    }
	if( $next_section )
	    {
	    print $fh "    <td valign=top><small><a href=\"",
		    &section_url($next_section,$fh),
		    "\">(次 - $section2title{$next_section})</a>",
		    "</small></td>\n";
	    }
	print $fh "    <td valign=top><small>",
		    "<a href=\"#main_index\">(メイン・インデックス)",
		    "</a></small></td>\n";
	if( $fh ne 'OUT_FULL' && $fh ne 'OUT_INDEX' )
	    {
	    print $fh
		"    <td valign=top><small>",
		"<a href=\"sections.html#main_index\">",
			"(すべてのインデックス)</a></small></td>\n";
	    }
	print $fh "    </tr></table>\n\n",
		"  </td></tr>\n",
		"</table>\n\n<ul>\n";
	foreach $name ( eval '@section_'.$section )
	    {
	    print $fh "  <li><a href=\"$ref:$name\">",
	    $name2title{$name},"</a>\n";
	    }
	print $fh "</ul>\n\n";
	}
    }

sub read_datafile
    {
    my($file)=@_;
    my($key,$value,$name,$last_key);
    my(%sectioncount);

    open(DATA, "nkf -e $file|") || &fail("Unable to open '$file': $!");
    while( <DATA> )
	{
	s/#.*//;
	if( ( ($key,$value) = /^([\S]+):\s*(\S.*)/ ) == 2 )
	    {
	    if( $key eq 'title' )
		{
		if( $value =~ /^(\S+)\s+(.*)$/ )
		    {
		    push(@sections,$1);
		    $section2title{$1}=$2;
		    $title2section{$2}='section';
		    $title2name{$2}=$1;
		    $sectioncount{$1}=0;
		    }
		else
		    { &fail("Cannot parse 'title:' at line $.\n"); }
		}
	    elsif( $key eq 'name' )
		{
		$name=&safename($value);
		if( defined( $name2title{$name} ) )
		    { &fail("Duplicate name '$name' at line $.\n"); }
		$name2title{$name}=$value;
		$title2name{$value}=$name;
		}
	    elsif( defined($name) )
		{
		if( $key eq 'section' )
		    {
		    ++$sectioncount{$value};
		    if( !defined($section2title{$value}) )
			{ &fail("Unknown section '$value' at line $.\n"); }
		    eval 'push(@section_'.$value.',$name)';
		    $title2section{$name2title{$name}}=$value;
		    }
		else
		    { eval 'push(@entry_'.$name.',$key)'; }
		$last_key=$key;
		$data{$name}{$key}=$value;
		}
	    else
		{ &fail("'name:' must be first data at line $.\n"); }
	    }
	elsif( /^\s+(\S.*)/ )
	    { $data{$name}{$last_key}.=" $1"; }
	}
    if( $opt{'v'} )
	{
	foreach( @sections )
	    { print "    $_ : $sectioncount{$_} entries\n"; }
	}
    close(DATA);
    }

sub read_file
    {
    my($file)=@_;
    my($data);

    $data='';
    open(FILE,"nkf -e $file|") || &fail("Unable to read '$file': $!");
    read(FILE,$data,-s $file);
    close(FILE);
    $data =~ s/\$NetBSD[^\$]+\$/\$NetBSD\$/g;
    $data;
    }

sub safename
    {
    my($name)=@_;

    $name =~ y/A-Z/a-z/;
    $name =~ s/[^_a-z0-9]/_/g;
    $name;
    }

sub section_url
    {
    my($section,$fh)=@_;
    my($ref);

    if( $fh eq 'OUT_FULL' )
	{ $ref="#section:$section"; }
    else
	{ $ref="$section.html#section:$section"; }
    $ref;
    }

sub verbose
    {
    $opt{'v'} && print @_;
    }
