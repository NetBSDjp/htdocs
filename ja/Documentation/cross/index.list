<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<!-- Copyright (c) 2001
	The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED. -->
    <title>Cross-building NetBSD</title>
  </head>

<body bgcolor="#FFFFFF" text="#000000">

<HEADING> NetBSD のクロス構築

<LIST>

<h2>他の情報源</h2>
<ul>
<li><a href="../current/">NetBSD-currentの追跡</a>
<li><a href="../../Documentation/">総合的な NetBSD ドキュメンテーション</a>
    - クロス構築だけに限らない疑問について。
</ul>

<SECTION>繰り返される質問

<ENTRY>terminology  用語
<ul>
<li>ホストシステム: クロス構築で、作業そのものを行おうとするシステム。
<li>ターゲットシステム: クロス構築の作業結果を動かそうとするシステム。
<li>クロス構築: ターゲットシステムとホストシステムが異なる場合に行うのがクロス構築。
<li>セルフ構築: ターゲットシステムとホストシステムが同じ場合、セルフ構築。
</ul>

 NetBSD/i386 上で、 NetBSD/sh3 のバイナリーを構築するなら、
 クロス構築 をします。
NetBSD/i386 が "ホストシステム" で、 NetBSD/sh3 が "ターゲットシステム" です。

<ENTRY>why  どうしてクロス構築?  クロス構築が必要なのはいつ?

 クロス構築の2つの理由は:
<ul>
<li>NetBSD <A HREF="../../Ports/">非常に多くのアーキテクチャー</A> を
サポートします。
それらのいくつかは、他の現代的アーキテクチャーに比べ性能は低いです。
古いアーキテクチャー向けに何度も構築作業を行うなら、
クロス構築は良い解決法です。

<li>もし、 ターゲットシステムが(携帯電話のような)組み込みシステム製品で、
それに、 NetBSD を移植しようとするなら、
 ターゲットシステム上で セルフ構築 をできないかもしれません。

<li>もし何らかの理由で、 NetBSD ではないホストシステム でNetBSD バイナリーを
構築する必要があるなら、 クロス構築する必要があります。

<li> NetBSD を新しいアーキテクチャーに移植しようとするなら、
クロスコンパイルだけが、唯一の選択肢です。
</ul>

<ENTRY>caveats  警告?
 クロス構築には、コンパイラーの設定を巧妙にします。
 クロス構築設定において、コンパイラー バグ は、よりしばしば現れる傾向があります。

また、セルフ構築と異なるバージョンのコンパイラーを使う必要があることもあり、
それで、コンパイラーの互換性問題( GCC のバージョンが違うとか、他のベンダーのコンパイラー
であるとか)が頭痛の種となることがあります。
<p>

<tt>pkgsrc/cross</tt> では、a.out PIC へのクロス構築はサポートされていません。
<p>

正しい cpp を使ってください。さもないと
 <tt>__NO_LEADING_UNDERSCORES__</tt> や <tt>__LITTLE_ENDIAN__</tt> のような、
あらかじめ定義されたシンボルで困ることになります。
<p>

もちろん、クロス構築をもっと安定させる必要はあります。

<SECTION>道のり

<ENTRY>host-system  ホストシステムの選択
特別な理由がなければ、ホストシステムには、
 NetBSD(多分 最新のリリース または netbsd-current)  を使うことを勧めます。
ホストシステムに NetBSD を使えば、
 /usr/bin/make や /usr/share/mk/*, 等が同じ物を使えるので、
より簡単です。

<ENTRY>cross-compiler クロスコンパイラーを用意する。
 NetBSD ホストシステム上で NetBSD ターゲットシステムを構築するなら、
NetBSD パッケージシステムの "cross" ディレクトリーの下に
 クロスコンパイラー設定があります。
例えば、 target system が NetBSD/sh3 なら、
<PKGSRC>cross/sh-netbsdcoff (ビッグエンディアン 用) あるいは
<PKGSRC>cross/shel-netbsdcoff (リトルエンディアン用) があります。
<p>

もし、ホストシステムに、 NetBSD ではないシステムを使うなら、
クロス構築するのに、 GNU gcc と GNU binutils の設定をする必要があります。

また、 NetBSD の make(1), config(8) や、そのシステムにある
他の構築ツールを make する必要があります。

<ENTRY>build-tree  build tree を用意する
まず第一に、NetBSD ソースコード ツリー 全体を入手する必要があります。
詳しくは <a href="../current/">"NetBSD-currentの追跡"</a> を見てください。

次の記述において、ツリーは $TOP/src の下にあると仮定します。.
<p>
クロス構築するために、 /etc/mk.conf を正確に設定してください。
詳しくは options(4) と mk.conf(5) を見てください。
<ul>
<li>殖民用のコンパイル生成物を置くディレクトリーを用意します。
 /etc/mk.conf の <tt>DESTDIR</tt> で指定します。

<li> <tt>OBJMACHINE</tt> を使えば、複数のアーキテクチャーで同じソースコードツリーが使えます。
</ul>

<ENTRY>build-script  構築 script を用意する
ホストシステムの通常のコンパイラーの代わりに、
適切なコンパイラーを使うには、以下のようなスクリプトを用意します。

この script は、 <PKGSRC>cross/sh-netbsdcoff バイナリーで NetBSD/evbsh3 を作るためのものです。
すくなくても MACHINE , MACHINE_ARCH , TARGET の設定は、いじる必要があります。
<p>

いくつかのほかの構築スクリプトがあり:
<A HREF="../../Ports/hpcmips/hpcmips-make">hpcmips-make</A>
<p>

<pre>
#! /bin/sh

# just helping for cross compilation.

MACHINE=evbsh3
MACHINE_ARCH=sh3eb
# just in case you forgot to specify this when you built gcc...
CFLAGS="-D__NetBSD__"
export MACHINE MACHINE_ARCH CFLAGS
TARGET=/usr/pkg/cross/bin/sh-netbsdcoff
CPP=`$TARGET-gcc -print-prog-name=cpp`

make AR=$TARGET-ar AS=$TARGET-as CC=$TARGET-gcc LD=$TARGET-ld NM=$TARGET-nm \ 
	RANLIB=$TARGET-ranlib SIZE=$TARGET-size \ 
	STRIP=$TARGET-strip OBJCOPY=$TARGET-objcopy \ 
	CXX=$TARGET-c++ CPP=$CPP $*
</pre>

<ENTRY>compile-kernel クロスコンパイルの実際 - カーネル
カーネルの構築には、構築スクリプトを使います。
NetBSD の config(8) は、アーキテクチャーに依存しないので、
ホストシステムの物を使うことができます。
<pre>
% cd $TOP/src/sys/arch/MYARCH/conf
% cp GENERIC MYCONF
% vi MYCONF
% config MYCONF
% cd ../compile/MYCONF
% sh build-script depend
% sh build-script
</pre>

<ENTRY>include-lib インクルードファイルとライブラリーファイルの作成
ユーザーランドでクロス構築を実行するには、
ターゲットシステムで動作するライブラリーおよびインクルードファイルを
手に入れる必要があります。
<p>

最初に、 DESTDIR 上にディレクトリー構造を配置する必要があります。
<pre>
# (cd $TOP/src; sh build-script beforeinstall)
</pre>
<p>

全インクルードツリーを得るには、 構築スクリプトを用いて、
 "make includes" を実行する必要があります。
<pre>
# (cd $TOP/src; sh build-script includes)
</pre>
これで、インクルードファイルが <tt>$DESTDIR/usr/include</tt> の下に用意できたはずです。
それをクロスコンパイラーが利用するディレクトリーに
コピー(かシンボリックリンク)してください。
<p>
全ライブラリーファイルを得るには、次の構築スクリプトを使って実行してください。
<pre>
# (cd $TOP/src/lib/csu; sh build-script dependall install)
# (cd $TOP/src/lib; sh build-script dependall install)
</pre>
これで、 <tt>$DESTDIR/usr/lib</tt> にライブラリーのバイナリーができてるはずです。
それをクロスコンパイラーが利用するディレクトリーに
コピー(かシンボリックリンク)してください。

<ENTRY>compile-userland クロスコンパイルの実際 - ユーザーランド
ツリー全体の構築には構築スクリプトを用い、
<a href="../current/">"NetBSD-currentの追跡"</a> に書かれているように
します。

<pre>
# (cd $TOP/src; sh build-script obj build)
</pre>

<SECTION>一般的な問題

<ENTRY>make  "make" 中におかしくなります


構築 Makefile のうちのいくつかにおいて、 sub-make を呼び出すときに、
次のように、(誤った)使い方がされていることがあって:
<pre>
foo:
	(cd subdir; make)
</pre>
この問題は、"make" の呼び出しにおいて与えられたコマンドライン引数を失うというもので、
これはまた、開始時に使われた make と異なるものを使ってしまいまうというものです。
<p>

解決法: "make" を "${MAKE}" で置き換えます。
また、是非、
<a href="../../Misc/send-pr.html#submitting">開発者へレポートする</a>
をして、再び起こらないようにしてください。
<pre>
foo:
	(cd subdir; ${MAKE})
</pre>

<ENTRY>compiler-issue  コンパイラーが内部エラーか同じような何らかの原因でお亡くなりになります。
はい、それは問題です。
クロスコンパイルにおいて、コンパイラーの内部エラーは、しばしば現れます。

また、セルフ構築で使われるのと異なるバージョンのコンパイラーや
コンパイラー自体が違うものを使うと、その時々によって面白い結果になります。

 pkgsrc/cross ツリーに関してでさえも、
 NetBSD セルフ構築 (egcs 1.1.2) と異なるバージョンの GCC (egcs 1.1.1) を使います。

また、 pkgsrc/cross は NetBSD ツリーで egcs に加えられた変更のいくつかが含まれていないかもしれません。

<p>

これに対しては魔法の杖はありません:
<ul>
<li>コンパイルスクリプトの中身を検討します。
	もし、(クロス構築中に /usr/bin/as を使うなどのように)
	異なるターゲット向けのコンパイラーが混ざると、問題を起こします。
<li>次善策として、実行時にコンパイラーの設定を変え、
最適化レベルを下げて試してみます( -O2 から -O のように)
<li>クロスコンパイラー生成時のコンパイラーの設定を検討します。
<li>もし、それを再現する方法を知っていて、 gcc を使っているなら、
	<a href="http://www.gnu.org/software/gcc/bugs.html">
	gcc の人たちにバグレポートを申し出ましょう</a>.
</ul>

</LIST>

<DOCLINK>

<hr>
<address>
  <small>
  <a href="../../Misc/feedback.html">(Contact us)</a>
  $NetBSD: index.list,v 1.14 2001/02/02 14:01:23 itojun Exp $<br>
  <a href="../../Misc/disclaimer.html">Copyright &copy;
    2001
    The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED.</a>
  </small>
</address>

</body>
</html>
