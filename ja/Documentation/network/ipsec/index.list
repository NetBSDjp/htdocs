<html>
<head>
<!-- Copyright (c) 1998, 1999, 2000
        The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED. -->
<link rev="made" href="mailto:www@NetBSD.ORG">
<title>IP security FAQ</title>
</head>
<body bgcolor="#FFFFFF" text="#000000">

<HEADING>NetBSD IP security

This page is developing, and we welcome any
<a href="../../../Misc/feedback.html">comments or suggestions</a>.

<LIST>
<h2>Other links</h2>
<ul>
  <li><a href="http://www.kame.net/">KAME project</a>,
        where the IPv6 implementation come from
  <li><CURRENTSRC>/sys/netinet6/IMPLEMENTATION:
        detailed information on the implementation
</ul>

<SECTION>IP security FAQ

<ENTRY>getting_started Getting Started
IP security (IPsec for short) code was merged into the NetBSD distributions in
June 1999.
It will be included in official releases from NetBSD 1.5.
IPsec provides per-packet authenticity/confidentiality guarantees between
peers communicate using IPsec.
IPsec is available for both IPv6 and IPv4.
<p>

Note that, however, kernel re-configuration is necessary to use IPsec.
It is not turned on for default GENERIC kernel.
<p>

If you have pre-1.5 systems, your situation is as follows:
<ul>
  <li>If you are using NetBSD 1.4.x, you may want to visit
      <a href="http://www.kame.net/">KAME project</a> webpage
      for IPsec support patches.
      KAME project supplies IPv6/IPsec patches in single tar.gz file.
      IPsec portion is usable for both IPv4 and IPv6.
  <li>If you are using NetBSD-current before late November 1999,
      use of special kernel configuration file
      (<tt>GENERIC.v6</tt>) is required to use IPsec.
  <li>If you are using NetBSD-current after November 21 1999,
      <tt>GENERIC</tt> kernel configuration file includes
      IPsec support by default, commented out.
</ul>

<p>

Userland code includes IPsec support where possible, by default,
so no rebuild of userland is necessary even if you switch between kernel
with IPsec, and without IPsec.
<p>

<ENTRY>ipsec_breakdown  IPsec = AH + ESP + IPcomp + IKE
IPsec consists of a couple of separate protocols, listed below:
<ul>
  <li>Authentication Header (AH): provides authenticity guarantee for packets,
        by attaching strong crypto checksum to packets.
        If you receive a packet with AH and the checksum operation was
        successful, you can be sure about two things <em>if you and the
        peer share a secret key, and no other party knows the key</em>:
    <ul>
      <li>The packet was originated by the expected peer.
        The packet was not generated by impersonator.
      <li>The packet was not modified in transit.
    </ul>
        Unlike other protocols, AH covers the whole packet, from the IP header
        to the end of the packet.

  <li>Encapsulating Security Payload (ESP): provides confidentiality guarantee
        for packets, by encryptiong packets with encryption algorithms.
        If you receive a packet with ESP and successfully decrypted it,
        you can be sure that the packet was not wiretapped in the middle,
        <em>if you and the peer share a secret key, and no other party
        knows the key</em>.

  <li>IP payload compression (IPcomp): ESP provides encryption service to the
        packets.
        However, encryption tend to give negative impact to compression on
        the wire (such as ppp compression).
        IPcomp provides a way to compress packet before encryption by ESP
        (Of course, you can use IPcomp alone if you wish to).

  <li>Internet Key Exchange (IKE): As noted above, AH and ESP needs shared
        secret key between peers.
        For commuincation between distant location, we need to provide ways
        to negotiate keys in secrecy.
        IKE will make it possible.
</ul>

AH, ESP and IPcomp are implemented in the kernel code.
IKE is implemented as daemon process in the userland.
Kernel part and userland part will cooperate by using key management table
inbetween.
<p>

IKE is actually optional, you can configure secret keys manually for AH/ESP.
However, please understand it: you cannot use the same secret key forever.
If you use the same secret key for a long period of time,
your traffic become more and more likely to get compromised.
<p>

NOTE: <strong>security of IPsec protocols depend on the secrecy of secret keys.
</strong>
If secret keys are compromised, IPsec protocols can no longer be secure.
Take caution about permission mode of configuration files,
key database files, or whatever thay may lead to information leakage.

<pre>

        userland programs               IKE daemon
          ^ | AF_INET{,6} socket          ^ | PF_KEY socket
========= | | =========================== | | ======== Kernel/user boundary
          | v                             | v
        transport layer, TCP/UDP        key management table
          ^ |                             ^ | key information
          | |                             | |
          | v                             | v
        IP input/output logic <-------> AH/ESP/IPcomp logic
          ^ |
          | v
        Network drivers (ethernet)
</pre>

<ENTRY>trans_tunnel  Transport mode and tunnel mode
AH, ESP and IPcomp have two modes of operation: transport mode and tunnel mode.
Transport mode encrypts normal communication between peers.
Tunnel mode will encapsulate packet into new IPv4/v6 header.
Tunnel mode is designed to be used by VPN gateways.
<pre>
[[transport mode]]
my host ======== peer's host
        transport
        mode

packets: [IP: me->peer] ESP payload
                        &lt;---------&gt; encrypted


[[tunnel mode]]
        (a)                  (b)                        (c)
my host ---- my VPN gateway ======== peer's VPN gateway ---- peer's host
                            tunnel mode

packets on (a): [IP: me->peer] payload
packets on (b): [IP: mygw->peergw] ESP [IP: me->peer] payload
                                   &lt;------------------------&gt; encrypted
packets on (c): [IP: me->peer] payload
</pre>

<ENTRY>policy  IPsec "policy" management
Though the kernel knows how to secure packets, it does not know
<em>which packet</em> requires security.
We need to tell kernel about which packet needs to be secured.
IPsec "policy" configuration allows us to specify it.
<p>

IPsec policy can be configured in per-packet, or per-socket manner:
<ul>
  <li>Per-packet: configured into the kernel just like packet filters.
        You can specify like "encrypt outgoing packets if I'm sending
        to 10.1.1.0/24".
        This works well when you are running an IPsec router.
  <li>Per-socket: configured via setsockopt(2) for a certain socket.
        You can specify like "encrypt outgoing packets from this socket".
        This works well when you would like to run IPsec-aware server program.
</ul>

IPsec policy decides which IPsec protocols (AH, ESP or IPcomp) to be used
against a packet. 
You can configure kernel to use any combination of
AH, ESP and IPcomp against a packet.
You can even apply same protocol multiple times, like multiple ESP operation
against single packet.
It is questionable if multiple ESP operation has any benefit, but certainly
interesting for test/debug use.

<ENTRY>export_issues  Export issues
Due to US export regularions against cryptography technology,
NetBSD project has two source code repository for crypto-oriented code:
<tt>crypt-intl</tt> (everywhere in the world except the US)
and <tt>crypto-us</tt> (for US domestic use only).
ESP and IKE are subject to export restrictions.
You will need to grab source code from appropriate location for you.
<p>

The regulation is being updated recently (early 2000),
NetBSD project will be updating repository structure soon.

<ENTRY>config_kernel  Configuring IPsec kernel
<strong>(pre-1.5)</strong>
At the time of writing, we are not sure about how we will redistribute
crypto-ready binaries for NetBSD 1.5.
The following documents how you can build a crypto-ready binaries
from source code tree.
Refer to <A HREF="/Documentation/current/"><em>tracking NetBSD-current</em></a>
for more details of the build process.
<ol>
  <li>Get <A HREF="#export_issues">export-regulated source code tree</A>
        from appropriate location for you.
        here we assume that we've placed the tree like below:
<pre>
NetBSD -+- src ---------+- bin  
        |               +- sbin
        |               +- usr.bin
        |               +- usr.sbin
        +- cryptosrc-intl -- crypto-intl -+- dist
                                          +- usr.sbin
</pre>
  <li>Make a symbolic link from <tt>src/crypto-intl</tt> to
        <tt>../cryptosrc-intl/crypto-intl</tt>.
        Now the tree will look like this:
<pre>
NetBSD -+- src ---------+- bin  
        |               +- sbin
        |               +- usr.bin
        |               +- usr.sbin
        |               +- crypto-intl
        |                    | symbolic link
        |                    v
        +- cryptosrc-intl -- crypto-intl -+- dist
                                          +- usr.sbin
</pre>
  <li>In your kernel configuration file, enable the following portion
and build a new kernel.
<pre>
prefix ../crypto-intl/sys
cinclude "conf/files.crypto-intl"
prefix
options IPSEC
options IPSEC_ESP
</pre>
  <li>perform <tt>make build</tt> as usual.
        When the build finishes, you will get additional userland tools,
        including racoon(8) IKE daemon, kerberos5-ready telnet(1)/telnetd(8),
        and more.
  <li>replace the kernel and reboot.
</ol>

<ENTRY>sample_esp  Configuration examples: host-to-host encryption
If you would like to run host-to-host (transport mode) encryption with
manually configured secret keys, the following configuration should be enough.
We use setkey(8) to configure manual keys.
<pre>
#! /bin/sh
#
# packet will look like this: IPv4 ESP payload
# the node is on 10.1.1.1, peer is on 20.1.1.1
setkey -c &lt;&lt;EOF
add 10.1.1.1 20.1.1.1 esp 9876 -E des-cbc "hogehoge";
add 20.1.1.1 10.1.1.1 esp 10000 -E des-cbc "mogamoga";
spdadd 10.1.1.1 20.1.1.1 any -P out ipsec esp/transport//use;
EOF
</pre>
<p>

First two lines configure secret keys to be used by ESP.
The decimal numbers appar as the fourth word are called SPI
(security parameter index).
The value will be attached to ESP packet, and it lets receiving side to
lookup secret key from the packet.
The number needs to be unique on a node.
<ul>
  <li>From 10.1.1.1 to 20.1.1.1, we'd use DES-CBC algorithm,
        with secret key <tt>"hogehoge"</tt>.
        The traffic will be identified by SPI 9876.
  <li>From 20.1.1.1 to 10.1.1.1, we'd use DES-CBC algorithm,
        with secret key <tt>"mogamoga"</tt>.
        The traffic will be identified by SPI 10000.
</ul>
<p>

The last line configures per-packet IPsec policy for the node.
With the configuration, the node (10.1.1.1) to transmit packets to the peer
(20.1.1.1) encrypted, whenever secret key is configured into the kernel.
The configuration does not prohibit unencrypted packets from 20.1.1.1 to
reach 10.1.1.1.
If you would like to reject unencrypted packet, add the following line:
<pre>
spdadd 10.1.1.1 20.1.1.1 any -P in ipsec esp/transport//require;
</pre>
<p>

The syntax for policy configuration is documented in ipsec_set_policy(3).
<p>

Try running tcpdump(8) to see the encrypted packets on the wire -
they are encrypted, it is no longer possible to wiretap those packets.
<p>

The above exampe uses human-readable secret keys.
However, use of human-readable secret key is discouraged by the specification
(since it will have more chance to be compromised, than binary keys).
You'd better use binary keys for real operation.
<p>

Key length is determined by algorithms.
For des-cbc, the secret key MUST be 64 bits (= 8 bytes).
If you specify shorter/longer key, you will get error from setkey(8).

<ENTRY>sample_ah  Configuration examples: host-to-host authentication
Just like ESP, you can configure AH.
<pre>
#! /bin/sh
#
# packet will look like this: IPv4 AH payload
# the node is on 10.1.1.1, peer is on 20.1.1.1
setkey -c &lt;&lt;EOF
add 10.1.1.1 20.1.1.1 ah 9877 -A hmac-md5 "hogehogehogehoge";
add 20.1.1.1 10.1.1.1 ah 10001 -A hmac-md5 "mogamogamogamoga";
spdadd 10.1.1.1 20.1.1.1 any -P out ipsec ah/transport//use;
EOF
</pre>
<p>

<ENTRY>sample_both  Configuration examples: host-to-host encryption+authentication
If you configure secret keys for both AH and ESP, you can use both of them.
IPsec document suggests to apply AH after ESP.
<pre>
#! /bin/sh
#
# packet will look like this: IPv4 AH ESP payload
# the node is on 10.1.1.1, peer is on 20.1.1.1
setkey -c &lt;&lt;EOF
add 10.1.1.1 20.1.1.1 esp 9876 -E des-cbc "hogehoge";
add 20.1.1.1 10.1.1.1 esp 10000 -E des-cbc "mogamoga";
add 10.1.1.1 20.1.1.1 ah 9877 -A hmac-md5 "hogehogehogehoge";
add 20.1.1.1 10.1.1.1 ah 10001 -A hmac-md5 "mogamogamogamoga";
spdadd 10.1.1.1 20.1.1.1 any -P out ipsec esp/transport//use ah/transport//use;
EOF
</pre>

<ENTRY>sample_vpn  Configuration examples: VPN
(to be written)

<ENTRY>config_ike  Configuring AH/ESP keys by using IKE
(to be written)

<ENTRY>conformance  Conformance to standard, interoperability
KAME IPsec implementation (which is included in NetBSD tree)
conforms to latest set of IPsec standards.
<CURRENTSRC>/sys/netinet6/IMPLEMENTATION
has comprehensive list of standard documents to which the implementation
conforms.
<p>

Interoperability with other implementation has been confirmed in various
occasions.
<CURRENTSRC>/sys/netinet6/IMPLEMENTATION
includes list of implementations which we have confirmed interoperability
in the past.
Note that, however, it is possible for both sides to change the code
after interoperability tests, and it is possible that they no longer
interoperate.
It is also possible that NetBSD device and peer's device interoperate in
certain configuration only.
<p>

If you try to configure NetBSD device with other implementation,
please note that IPsec specifications/implementations
have too many knobs to play with.
You need to configure your NetBSD device with peer's device
<strong>exactly the same</strong> to make them interoperate.

<ENTRY>compatibility  API compatibility with other IPsec stacks
If you write userland code that is aware of IPsec,
you may become curious about API compatibility across IPsec platforms.
<p>

We have RFC2367 PF_KEY API for manipulating secret key database in the kernel.
Basic portion of this API is available on other UNIX-based IPsec stacks as well,
and may be compatible to certain degree
(for example, OpenBSD implements PF_KEY API as well).
KAME IPsec stack extends this in certain way, just like other parties do.
Extended portion is not compatible with other (non-KAME) IPsec stacks.
<p>

There is no document that specifies IPsec policy management API.
Therefore, we can expect no compatibility with (non-KAME) IPsec stacks
in IPsec policy management API.
<p>

There is no standard for configuration file syntax.
You will need to convert them if you would like to copy configuration from/to
non-NetBSD IPsec devices.
<p>

Since NetBSD and FreeBSD share IPsec codebase from the same origin (KAME),
there is a good chance for API compatibility.
Note that, however, there are differences in NetBSD IPsec code
and FreeBSD IPsec code, since they merged in KAME code of different date.
As of writing, normal userland applications do not need to worry about the
difference:
<ul>
  <li>NetBSD-current incorporates KAME IPsec stack of late December 1999.
  <li>FreeBSD-current incorporates KAME IPsec stack of early November 1999.
  <li>There is no difference in manual ipsec key configuration,
        kernel behavior on AH/ESP operation, or ipsec_set_policy(3) API.
  <li>There are differences in behavior of PF_KEY socket, libipsec
        API for PF_KEY wrapper functions and several other locations.
        The difference may bite you if you want to implement application
        that manipulates PF_KEY socket directly (i.e. IKE daemon like racoon(8)
        or key config program like setkey(8)).
</ul>

</LIST>

<a href="../">Up to <em>NetBSD Documentation: Network</em></a>
<hr>

<DOCLINK>

<hr>
<address>
  <a href="../../../Misc/feedback.html">(Contact us)</a>
  $NetBSD: index.list,v 1.7 2000/02/26 06:29:54 itojun Exp $<br>
  <a href="../../../Misc/disclaimer.html">Copyright &copy;
    1998, 1999, 2000
    The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED.</a>
</address>

</body>
</html>
