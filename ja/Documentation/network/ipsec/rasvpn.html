<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="ja">
<head>

<!-- DO NOT EDIT THIS FILE. EDIT 'rasvpn.list' AND RUN 'make' -->

<!-- Copyright (c) 2005 Emmanuel Dreyfus.  ALL RIGHTS RESERVED. -->
<link rev="made" href="mailto:www@jp.NetBSD.org">
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
<title>How to build a remote user access VPN</title>
</head>
<body bgcolor="#FFFFFF" text="#000000">

<table><tr><td>
    <a href="../../../Misc/disclaimer.html#bsd-daemon"><img
     align="middle" src="../../../../images/BSD-daemon.jpg" origlink="../../../images/BSD-daemon.jpg" border="0"
     width=146 height=129 alt="BSD daemon"></a>
  </td><td align=center>
    <h1>NetBSD ドキュメンテーション:</h1>
    <h1>リモートユーザーアクセス VPN の構築方法</h1>
</td></tr></table>
<p>

<h2><a name="top">ソフトウェアリリース</a></h2>
<ul>
</ul>
<h2>リモートユーザーアクセス VPN</h2>
<ul>
<li>
<a href="#context">背景となる状況</a></li>
<li>
<a href="#security">セキュリティー上の問題</a></li>
<li>
<a href="#solutions">解決策</a></li>
</ul>
<h2>IPsec を使ったユーザーリモートアクセス</h2>
<ul>
<li>
<a href="#ph1auth">IPsec フェーズ 1 認証</a></li>
<li>
<a href="#xauth">Xauth</a></li>
<li>
<a href="#hybrid">Hybrid auth</a></li>
<li>
<a href="#mode_cfg">ISAKMP モード設定</a></li>
<li>
<a href="#nat_t">NAT Traversal</a></li>
<li>
<a href="#ike_frag">IKE フラグメンテーションおよび ESP フラグメンテーション</a></li>
<li>
<a href="#dpd">Dead Peer Detection</a></li>
</ul>
<h2>VPN ゲートウェイの設定</h2>
<ul>
<li>
<a href="#kernel">カーネルコンフィギュレーション</a></li>
<li>
<a href="#forw">パケットフォワーディング</a></li>
<li>
<a href="#cert">証明書の作成</a></li>
<li>
<a href="#config">racoon(8) の設定</a></li>
<li>
<a href="#more_frag">さらなるフラグメンテーション問題</a></li>
<li>
<a href="#firewall">ファイアウォールとの関係</a></li>
<li>
<a href="#radius">VPN ゲートウェイと RADIUS</a></li>
</ul>
<h2>VPN クライアント</h2>
<ul>
<li>
<a href="#client">Cisco VPN Client</a></li>
<li>
<a href="#client_conf">クライアントとしての racoon(8) : 設定例</a></li>
<li>
<a href="#connection">VPN との接続と切断</a></li>
<li>
<a href="#save_pwd">Xauth パスワードの保存</a></li>
</ul>


<hr>
<h2>ソフトウェアリリース</h2><hr>この文書の情報は、以下の NetBSD カーネルを対象としています。
<ul>
<li>2005 年 5 月以降の NetBSD-current
<li>2005 年 5 月以降の NetBSD-3.0_BETA
</ul>
<p>

また、対象としているユーザーランド (<a href="http://man.NetBSD.org/man/setkey+8+NetBSD-current">setkey(8)</a>, <a href="http://man.NetBSD.org/man/racoon+8+NetBSD-current">racoon(8)</a>, <a href="http://man.NetBSD.org/man/racoonctl+8+NetBSD-current">racoonctl(8)</a> および libipsec) は以下のものです。
<ul>
<li>2005 年 5 月以降の NetBSD-current
<li>2005 年 5 月以降の NetBSD-3.0_BETA
<li>これより前の NetBSD リリースに、NetBSD の pkgsrc を使って
ipsec-tools 0.6.beta2 以上のパッケージを追加したもの
</ul>

<hr>
<h2>リモートユーザーアクセス VPN</h2><hr>
<p><h3>
<a name="context">背景となる状況</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
多くの組織では、リモートアクセスサーバー (Remote Access Server, RAS)
を持っており、ユーザーが旧来の公衆電話回線 (Plain Old Telephone System, POTS)
とモデム接続を使ってリモートアクセスできるようにしています。
<p>

デジタル加入者回線 (Digital Subscriber Line, DSL) やケーブル回線といった
高帯域接続の普及に伴い、POTS を使ったリモートアクセスは時代遅れとなり、
ユーザーは高帯域のリモートアクセスを求めるようになっています。
仮想プライベートネットワーク (Virtual Private Network, VPN) を使うことは、
この問題に対する解決策のひとつです。
<p>

VPN アクセス用のユーザー認証としては、いくつかの方法があります。
<ul>
<li>グループパスワード (ユーザー全員が同じパスワードを使う)
<li>ログイン名とパスワード
<li>x509 証明書
</ul>
<p>

グループパスワードは劣った手法であり、使うべきではありません。
ユーザーを本当に認証しているわけではないからです。
x509 証明書は最高のセキュリティーをもたらしますが、ユーザー証明書の管理が面倒かもしれません。
それでも構わなければ、必要な情報は <a href="index.html">IPsec FAQ</a>
にすべてあります。ログイン名とパスワードは、並のセキュリティーレベルです。
パスワードは推測されたり、別のプロトコルで公開されたり (例: SSL を使わない POP3)
するので、安全性は高くはありません。しかし、強いパスワードを使うようにし、
また、傍受されないようなプロトコルの使い方をしていれば、
経済的に安全を実現できます。
<p>

この HOW-TO では、リモートユーザー VPN アクセス用に
ログイン名とパスワードが使われている状況を対象とします。
<p>

</dd></dl>
<p><h3>
<a name="security">セキュリティー上の問題</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
安全な VPN を確立するために、リモートユーザーは VPN ゲートウェイを認証しなければならず、
また、VPN ゲートウェイはリモートユーザーを認証しなければなりません。
お互いの認証がおこなわれないと、中間者攻撃 (Man in the Middle (MiM) attack)
の抜け穴が開き、攻撃者が VPN ゲートウェイになりすまして
ユーザーパスワードを収集できてしまいます。
<p>

リモートユーザーがログイン名とパスワードで認証すると説明しましたが、
VPN ゲートウェイはどうやって認証するのでしょうか? 事前共有鍵を使う場合、
その鍵を知っている人なら誰でも VPN ゲートウェイになりすますことができますし、
正当なユーザーは事前共有鍵を知っておかねばならなくなります。これは非常に弱いセキュリティーです。
代替策は、VPN ゲートウェイで x509 証明書を使うことです。これはサーバー証明書であり、
ユーザー証明書より管理しやすいものです。ここでは、
VPN ゲートウェイの認証に証明書を使うものとします。
<p>

</dd></dl>
<p><h3>
<a name="solutions">解決策</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
ここでは、ユーザーの認証にはログイン名とパスワードを使い、
VPN ゲートウェイの認証には証明書を使うことが必要です。これを実現できる手法はあまりありません。
<a href="http://www.openvpn.org">OpenVPN</a> は、これが実現可能な、
Secure Socket Layer (SSL) を使った解決策です。別の解決策として、 IPsec を使う方法もあり、
この HOW-TO ではこちらの方法を取り扱います。

</dd></dl>
<hr>
<h2>IPsec を使ったユーザーリモートアクセス</h2><hr>
<p><h3>
<a name="ph1auth">IPsec フェーズ 1 認証</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
IPsec フェーズ 1 は、NetBSD では <a href="http://man.NetBSD.org/man/racoon+8+NetBSD-current">racoon(8)</a> としても知られる IKE デーモンによって行なわれる、
IPsec 鍵交換 (IPsec Key Exchange, IKE) 操作の一部です。IPsec フェーズ 1 の目的は、
通信相手を認証したうえで、 IPsec フェーズ 2 を安全に行なうためのマスター鍵の設定をすることです。
フェーズ 2 の目的は、IPsec トラフィック交換に使われる鍵を得ることです。
IPsec トラフィック交換がおこなわれている間、フェーズ 2 の鍵は定期的に再生成されます。
<p>

IPsec フェーズ 1 は、二つの認証方法を提供します。事前共有鍵と、証明書です。
以下の理由により、IPsec フェーズ 1 はわれわれが求めているものではありません。
<ul>
<li>事前共有鍵は、ログイン名に縛られません。グループパスワードとした場合だけは管理可能ですが、
それを除けば、事前共有鍵を適切に扱うための管理ツールがありません。
<li>IPsec フェーズ 1 認証は、対称的であることが前提です。
つまり、両端ともに事前共有鍵認証を、または両端ともに証明書認証を使う、というものです。
これは、われわれが探しているものではありません。
</ul>

</dd></dl>
<p><h3>
<a name="xauth">Xauth</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
Xauth は、フェーズ 1 の後に使われ、ログイン名/パスワード認証を追加する IKE 拡張です。
これは、認証にまつわる問題の半分を解決します。Xauth はフェーズ 1 の直後に使われるので、
フェーズ 1 認証により安全なものとなります。問題の半分は解決しましたが、まだ
フェーズ 1 では事前共有鍵か証明書が必要です。事前共有鍵の使用は安全ではありませんし、
証明書を使うことは、ユーザー証明書を使うことを意味します。
ユーザー証明書の使用はわれわれが避けたかったことです。

</dd></dl>
<p><h3>
<a name="hybrid">Hybrid auth</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
Hybrid auth はもうひとつの IKE 拡張で、フェーズ 1 を非対称にするものです。
フェーズ 1 の行なわれている間、VPN ゲートウェイは、リモートユーザーが認証をする必要がなくても、
証明書を使うことができます。フェーズ 1 が行なわれた後の状況は、以下のとおりです。
<ul>
<li>リモートユーザーは、通信相手が VPN ゲートウェイであることがわかっています
<li>リモートユーザーと VPN ゲートウェイとの間のやりとりは安全です
<li>VPN ゲートウェイは、話している相手が誰かわかっていません
</ul>
<p>

このフェーズ 1 の後、リモートユーザーのセキュリティー認証のために Xauth 交換をすることができます。
その後、フェーズ 2 がおこなわれます。
<p>

IPsec + Xauth + Hybrid auth のセキュリティーの度合は、
パスワード認証を使った SSH とだいたい同じぐらいです。

</dd></dl>
<p><h3>
<a name="mode_cfg">ISAKMP モード設定</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
以上のとおり、認証の問題は IPsec + Xauth + Hybrid auth を使うことで解決されました。
リモートアクセスをユーザーフレンドリーなものにするために、
リモートユーザーのマシン設定を自動化する必要があります。ISAKMP モード設定は、
VPN ゲートウェイがリモートユーザーのマシンにネットワーク設定 (内部 IP アドレス、
DNS アドレス、ドメイン名など) を提供できるようにする IKE 拡張です。
<p>

</dd></dl>
<p><h3>
<a name="nat_t">NAT Traversal</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
リモートユーザーは、IPsec 暗号化ストリームを使った場合には機能しない、
ネットワークアドレス変換器 (Network Address Translator, NAT) の向こうにいるかもしれません。
トラフィックを暗号化する必要があるときは、IPsec は、暗号ペイロード (Encapsulated Security Payload, ESP)
というレイヤー 4 のプロトコルを使用します。TCP や UDP とは異なり、ESP
はポート番号を持たず、 NAT デバイスが簡単に扱うことはできません。
<p>

RFC 3947 および 3948 では、ESP を UDP でカプセル化する方法と、
IPsec ストリームの両端の間にある NAT を管理するための IKE 拡張について解説しています。
このカプセル化の方法と IKE 拡張の組み合わせは、NAT Traversal (NAT-T)
として知られています。
<p>

NAT-T は、合衆国特許の<a href="https://datatracker.ietf.org/public/ipr_detail_show.cgi?&ipr_id=78">制約を受けることになるかもしれません</a>。

</dd></dl>
<p><h3>
<a name="ike_frag">IKE フラグメンテーションおよび ESP フラグメンテーション</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
リモートユーザーが DSL モデムルーター機器を介して接続してくるのは、よくあることでしょう。
これらのデバイスのほとんどは、大きな UDP パケットの扱いに関して、まったく用をなしません。
UDP が DNS リクエストでしか使われないという想定で作られており、それより大きな
UDP パケットやフラグメントされた UDP パケットはこぼしてしまいます。
IKE トランザクションや ESP オーバー UDP は大きくなりがちなので、
ブロックされてしまいます。
<p>

この問題を処理するため、IKE パケットを小さな断片に分割 IKE 拡張である、
IKE フラグメンテーションを使います。
ESP フラグメンテーションは、大きな ESP オーバー UDP パケットの問題を、
ESP のカプセル化の前に IP フラグメンテーションをすることによって、処理します。
すなわち、ネットワークに frag(IP/UDP/ESP/IP) を送るのではなく IP/UDP/ESP/frag(IP) を送るのです。
このため、IPsec 両端点の間にはさまれたデバイスは、
いかなるフラグメントされたパケットも認識しません。

</dd></dl>
<p><h3>
<a name="dpd">Dead Peer Detection</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
最後の問題です。リモートユーザーのインターネット接続が不安定で、
あたかも接続が切れたかのようになることがあります。これに対して、
IPsec に内蔵されている仕組みは、しばらく後に IKE phase 2 鍵再生成を強制的に行なうことだけです。
その時に通信相手がオンラインでなかったら、これは失敗し、その結果 VPN トンネルは破棄されます。
<p>

この仕組みは、リモートユーザーがオフラインになったことを確認するため頻繁に鍵再生成を強制されるので、
あまり便利ではありません。Dead Peer Detection (DPD) は、リモートの IPsec 端点が生きていることを
定期的に確認するのに使われる IKE 拡張です。
DPD は、リモートホストが数秒間オフラインになったことを確認するのに使うことができます。

</dd></dl>
<hr>
<h2>VPN ゲートウェイの設定</h2><hr>以下に、IPsec + Xauth + Hybrid auth + ISAKMP モード設定 + NAT-T + DPD + IKE フラグメンテーション +
ESP フラグメンテーションを使った VPN ゲートウェイの設定例を示します。

<p><h3>
<a name="kernel">カーネルコンフィギュレーション</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
最初に、少なくとも以下のオプションを含めた<a href="../../kernel/#how_to_build_a_kernel">カーネルを
構築してインストール</a>する必要があります。
<pre> 
options INET
options GATEWAY
options PFIL_HOOKS
options IPSEC
options IPSEC_ESP
options IPSEC_NAT_T

pseudo-device   ipfilter
</pre>

</dd></dl>
<p><h3>
<a name="forw">パケットフォワーディング</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
以下のコマンドを使って、IPv4 パケットフォワーディングを有効化する必要があります。
<pre>
# sysctl -w net.inet.ip.forwarding=1
</pre>
<tt>/etc/sysctl.conf</tt> に以下の行を追加して、
リブート時に自動的に実行することができます。
<pre>
net.inet.ip.forwarding=1
</pre>

</dd></dl>
<p><h3>
<a name="cert">証明書の作成</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
OpenSSL の設定をまだ行なっていない場合は、設定ファイルのサンプルのインストールから始めてください。
<pre>
# cp /usr/share/examples/openssl/openssl.cnf /etc/openssl/
</pre>

設定ファイルの用意ができたら、秘密鍵を作り、その鍵を使って証明書署名要求 (Certificate Signing 
Request, CSR) を作ります。
<pre>
# cd /etc/openssl
# umask 077
# openssl genrsa > certs/vpngw.key
# umask 022
# openssl req -new -key certs/vpngw.key -out certs/vpngw.csr
</pre>

この CSR (<tt>vpngw.csr</tt>) を認証局へ送って、署名をしてもらいます。
これで x509 証明書が交付されます。この証明書を <tt>vpngw.crt</tt>
という名前にすることにします。
<p>

自分自身が認証局となりたい場合は、以下の手順で
CA 秘密鍵の生成と署名をおこないます。
<pre>
# cd /etc/openssl
# mkdir -p demoCA/newcerts
# touch demoCA/index.txt
# echo "00" > demoCA/serial
# umask 077
# openssl genrsa > certs/ca.key
# umask 022
# openssl req -days 3650 -x509 -key certs/ca.key -new > certs/ca.crt
# openssl ca -in certs/vpngw.csr -keyfile certs/ca.key -cert certs/ca.crt -out certs/vpngw.crt
</pre>
<p>

秘密鍵が漏れると、 VPN はもう安全ではなくなってしまうので、
秘密鍵は秘密にするようにしてください。CA 証明書 <tt>ca.crt</tt>
をリモートユーザーに渡して、次の手順に進んでください。

</dd></dl>
<p><h3>
<a name="config"><a href="http://man.NetBSD.org/man/racoon+8+NetBSD-current">racoon(8)</a> の設定</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
以下に <tt>/etc/racoon.conf</tt> ファイルの例を示します。
<pre>
path certificate "/etc/openssl/certs";

listen {
        adminsock disabled;
}

remote anonymous {
        exchange_mode aggressive;
        certificate_type x509 "vpngw.crt" "vpngw.key";
        my_identifier asn1dn;
        proposal_check claim;
        generate_policy on;		# IPsec ポリシーを自動生成する
	dpd_delay 20;			# 20 秒毎に、 DPD ポーリングする
        nat_traversal force;		# NAT-T を常に使う
        ike_frag on;			# IKE フラグメンテーションを使う
        esp_frag 552;			# ESP フラグメンテーションを使う
        proposal {
                encryption_algorithm aes;
                hash_algorithm sha1;
                authentication_method hybrid_rsa_server;
                dh_group 2;
        }
}
mode_cfg {
        network4 10.99.99.1;		# VPN 用 IPv4 アドレス在庫の先頭のアドレス
        pool_size 253;			# VPN 用 IP アドレス在庫のサイズ: 253 アドレス
        auth_source system;		# /etc/passwd をもとにログインを検証する
        dns4 10.0.12.1;			# IPv4 DNS サーバー
        wins4 10.0.12.1;		# IPv4 WINS サーバー
        banner "/etc/racoon/motd";	# クライアントに対するバナーメッセージ
	pfs_group 2;
}

sainfo anonymous {
	pfs_group 2;
        lifetime time 1 hour;
        encryption_algorithm aes;
        authentication_algorithm hmac_sha1;
        compression_algorithm deflate;
}
</pre>
<p>

<tt>mode_cfg</tt> セクションで、ISAKMP モード設定を使って
VPN ゲートウェイからクライアントへ送られる設定を定義しています。
現在のところ、IPv4 の設定だけに対応しています。
このセクションで、払い出す VPN アドレスの在庫を、先頭のアドレス (<tt>network4</tt>)
と在庫のサイズ (<tt>pool_size</tt>) により定義しています。<tt>auth_source</tt>
は、ログイン名とパスワードをどうやって検証するかを表します。ここで指定できる値は、
システムユーザーデータベースをもとに検証する <tt>system</tt>、Pluggable Authentication Module (PAM)
システム (<tt>/etc/pam.d/racoon</tt> が使われます) を使う <tt>pam</tt>、
RADIUS をもとにログインを検証する <tt>radius</tt> です。
<p>

<tt>/etc/racoon.conf</tt> ファイルの準備ができれば、
<a href="http://man.NetBSD.org/man/racoon+8+NetBSD-current">racoon(8)</a> を実行することができます。
<pre>
# racoon
</pre>
<p>
ブート時に <a href="http://man.NetBSD.org/man/racoon+8+NetBSD-current">racoon(8)</a> を起動するためには、
<tt>/etc/rc.conf</tt> に以下のように書きます。
<pre>
racoon=YES
</pre>

</dd></dl>
<p><h3>
<a name="more_frag">さらなるフラグメンテーション問題</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
この設定例では、ESP フラグメンテーションを使って、送出するパケットが
552 バイトより大きくならないような <tt>esp_frag</tt> の指定をしています。
552 バイトは非常に小さいですが、これなら最もひどい DSL モデムルーター機器でも使えるはずです。
<tt>esp_frag</tt> を大きくすれば、性能が向上します。
<p>
ESP フラグメンテーションを使えば、どんなサイズの IP パケットでもトンネル経由で交換可能です。
しかし、TCP には特別な場合があり、Path Maximum Transmission Unit (PMTU)
探索にまつわる問題が起きるかもしれません。これに対する解決策は、
最大セグメント長 (Maximum Segment Size, MSS)
の調節を使うことです。払い出し用の VPN 内部アドレスの範囲が 10.99.99.0/24 であるとすると、
<tt>/etc/ipnat.conf</tt> に以下のように書けばよいです。
<pre>
map ex0 10.99.99.0/24 -> 0/0 mssclamp 552
</pre>
この設定を有効にするために、以下のようにタイプします。
<pre>
# ipf -E; ipnat -f /etc/ipnat.conf
</pre>
起動時にこのコマンドを実行するには、
<tt>/etc/rc.conf</tt> に以下のように書きます。
<pre>
ipfilter=YES
ipnat=YES
</pre>
注意: <tt>/etc/ipf.conf</tt> ファイルがない場合は、<tt>ipfilter=YES</tt>
とするとシステムが起動しません。 IP フィルタリングが一切必要ない場合は、
空のファイルを作っておけばよいです。

</dd></dl>
<p><h3>
<a name="firewall">ファイアウォールとの関係</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
この VPN の手法では、クライアントは VPN ゲートウェイの 500 番ポートと 4500 番ポートへ
UDP パケットを送る必要があります。最初のパケットは 500 番ポートで交換され、
それから NAT-T 交渉で 4500 番ポートにトランザクションが移ります。
<p>
VPN ゲートウェイの前に立つファイアウォールは、
VPN ゲートウェイ宛の udp/500 と udp/4500 を通すように設定する必要があります。


</dd></dl>
<p><h3>
<a name="radius">VPN ゲートウェイと RADIUS</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
RADIUS は、ログインの検証、IP アドレスの割り当てと、
アカウンティングに使うことができます。以下に示すのは、
<tt>/etc/racoon.conf</tt> ファイルの <tt>mode_cfg</tt> セクションで、
RADIUS を使うようにするための例です。
<pre>
mode_cfg {
	pool_size 253;			# IPv4 アドレス在庫のサイズ
	auth_source radius;		# RADIUS をもとにログインを検証する
	conf_source radius;		# RADIUS で IPv4 アドレスを割り当てる
	accounting radius;		# RADIUS アカウンティング
        dns4 10.0.12.1;			# IPv4 DNS サーバー
        wins4 10.0.12.1;		# IPv4 WINS サーバー
        banner "/etc/racoon/motd";	# クライアントに対するバナーメッセージ
	pfs_group 2;
}
</pre>
<p>

この設定のほか、RADIUS サーバーのアドレスと RADIUS サーバーとの共有鍵を含んだ
<tt>/etc/radius.conf</tt> ファイルを作る必要があります。
このファイルは、共有鍵を安全に保つために、
root の所有としてパーミッションを 0600 にしなければなりません。
以下に例を示します。詳細は <a href="http://man.NetBSD.org/man/radius.conf+5+NetBSD-current">radius.conf(5)</a> をご覧ください。
<pre>
auth radius.example.net MyDirtySecret
acct radius.example.net MyDirtySecret
</pre>
<p>

</dd></dl>
<hr>
<h2>VPN クライアント</h2><hr><p><h3>
<a name="client">Cisco VPN Client</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
前章で説明したような設定をした VPN ゲートウェイは、相互グループ認証 (mutual group authentication;
Hybrid authentication と同義) の設定をした Cisco VPN Client と相互運用することができます。
Cisco VPN クライアントが要求するグループおよびグループパスワードを、
<a href="http://man.NetBSD.org/man/racoon+8+NetBSD-current">racoon(8)</a> は無視しますが、これによってユーザー認証が安全でなくなることはありません。
<p>

NAT-T が有効になるよう、クライアントに
IPsec オーバー UDP トランスポートの設定をすることを忘れないでください。
<p>

</dd></dl>
<p><h3>
<a name="client_conf">クライアントとしての <a href="http://man.NetBSD.org/man/racoon+8+NetBSD-current">racoon(8)</a> : 設定例</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
<a href="http://man.NetBSD.org/man/racoon+8+NetBSD-current">racoon(8)</a> はクライアントとして使うことができます。
CA 証明書を <tt>/etc/openssl/certs/ca.crt</tt> にインストールし、
<tt>/etc/racoon.conf</tt> を以下のように設定する必要があります。
<pre>
path certificate "/etc/openssl/certs";
path pre_shared_key "/etc/racoon/psk.txt";

listen {
	# racoon と racoonctl との間で使うソケット
        adminsock "/var/racoon/racoon.sock" "root" "operator" 0660;
}

# Here is the address of the VPN gateway
remote 192.0.2.50 {
        exchange_mode aggressive;
        ca_type x509 "ca.crt";
        proposal_check obey;
        mode_cfg on;		# ISAKMP モード設定による設定を受け入れる
	dpd_delay 20;
        nat_traversal force;
        ike_frag on;
        esp_frag 552;
        script "/etc/racoon/phase1-up.sh" phase1_up;
        script "/etc/racoon/phase1-down.sh" phase1_down;
        passive off;
        proposal {
                encryption_algorithm aes;
                hash_algorithm sha1;
                authentication_method hybrid_rsa_client;
                dh_group 2;
       }
}


sainfo anonymous {
        lifetime time 1 hour;
        encryption_algorithm aes;
        authentication_algorithm hmac_sha1;
        compression_algorithm deflate ;
}
</pre>
<p>
二つのスクリプト <tt>phase1-up.sh</tt> と <tt>phase1-down.sh</tt> は、
それぞれ IKE phase 1 の確立時と終了時、つまり VPN 接続時と切断時に呼ばれます。
このスクリプトは IPsec Security Policies (SP), VPN IP アドレス、
ルーティングエントリーの設定と消去を受け持っています。
サンプルスクリプトのままでも必要なことはできるはずですが、
各自の必要に応じてカスタマイズすることもできます。
<pre>
# cp /usr/share/examples/ipsec-tools/roadwarrior/client/*.sh /etc/racoon/
</pre>
<p>

この準備ができれば、 <a href="http://man.NetBSD.org/man/racoon+8+NetBSD-current">racoon(8)</a> を起動できます。
<pre>
# racoon
</pre>
ブート時に <a href="http://man.NetBSD.org/man/racoon+8+NetBSD-current">racoon(8)</a> を起動するには、<tt>/etc/rc.conf</tt> に
<tt>racoon=YES</tt> を書き加えます。

</dd></dl>
<p><h3>
<a name="connection">VPN との接続と切断</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
<a href="http://man.NetBSD.org/man/racoonctl+8+NetBSD-current">racoonctl(8)</a> は、VPN への接続や VPN からの切断に使うことができます。
ログイン名を <tt>-u</tt> オプションで指定します。
パスワードは端末上で入力を促されます。
<pre>
$ racoonctl vc -u username 192.0.2.50
Pasword: password
Bound to address 10.99.99.3
==========================================================
                     Flying pigs LTD

 Welcome to our internal network, remote user.
==========================================================
$ racoonctl vd 192.0.2.50
VPN connection terminated
</pre>
この例では IP アドレスを使っていますが、DNS アドレスを使うこともできます。
注意: 何らかの理由で、ルーティングエントリーかセキュリティーポリシーデータベース
(Security Policy Database, SPD) にねじれが起きると、
VPN の切断時に DNS 名前解決ができなくなります。
この場合は、root で以下のコマンドを使って復旧できます。
<pre>
# setkey -F
# setkey -FP
# route flush
# route add default your_default_gateway
</pre>
<p>

<a href="http://man.NetBSD.org/man/racoon+8+NetBSD-current">racoon(8)</a> ソケット <tt>/var/racoon/racoon.sock</tt> への読み書き権限がある人なら、
誰でも VPN の起動や停止をすることができます。
このソケットの所有者とアクセス権限は、<tt>/etc/racoon.conf</tt> の
<tt>listen</tt> セクションで、<tt>adminsock</tt> ステートメントを使って設定できます。

</dd></dl>
<p><h3>
<a name="save_pwd">Xauth パスワードの保存</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
Xauth パスワードの入力を省略したい場合、このパスワードを racoon の事前共有鍵 (PSK)
ファイルに保持することができます。<tt>/etc/racoon.conf</tt> の
<tt>remote</tt> セクションに、以下の記述を追加します。
<pre>
	xauth_login "username";
</pre>
<p>

そして、 <tt>/etc/racoon/psk.txt</tt> に、
ログイン名とパスワードを一行で書き足します。
<pre>
username	password
</pre>
<p>

以上の設定をしておけば、以下のコマンドは、パスワードの入力を求めることなく、
<tt>toto</tt> ログイン<!-- XXX -->を使って VPN 接続を確立します。
<pre>
$ racoonctl vc 192.0.2.50
</pre>

</dd></dl>
<hr>

<a href="../"><em>NetBSD ドキュメンテーション: ネットワーク</em>へ戻る</a>
<hr>

<table width="100%"><tr><td>
<table border="0" summary="Footer navigation"><tr>
<td class="foothome"><span class="foothome"><a href="../../../"><img src="../../../../images/NetBSD-flag.png" origlink="../../../images/NetBSD-flag.png" alt="" border="0" width="90" height="90"></a></span></td>
<td class="foothome">
<span class="foothome"><a href="../../../">ホームページ</a></span><br>
</td>
</tr></table>
</td><td>
<table border="0" summary="Footer navigation"><tr>
<td class="foothome"><span class="foothome"><a href="../../../Documentation/"><img src="../../../../images/NetBSD-flag.png" origlink="../../../images/NetBSD-flag.png" alt="" border="0" width="90" height="90"></a></span></td>
<td class="foothome">
<span class="foothome"><a href="../../../Documentation/">Documentation top level</a></span><br>
</td>
</tr></table>

</td></tr></table>

<hr>
<address>
  <small>
  (連絡先 - <a href="http://www.NetBSD.org/cgi-bin/feedback.cgi">英語</a>,
       <a href="mailto:www@jp.NetBSD.org">日本語:
       www@jp.NetBSD.org</a>)<br>
  $NetBSD: rasvpn.html,v 1.1 2005/05/22 09:29:54 kano Exp $<br>
  <!-- based on english translation: -->
  <!-- NetBSD: rasvpn.list,v 1.3 2005/05/10 12:45:55 manu Exp   -->
  <a href="../../../Misc/disclaimer.html">Copyright &copy; 2005
    Emmanuel Dreyfus,  ALL RIGHTS RESERVED.</a>
  </small>
</address>

</body>
</html>
