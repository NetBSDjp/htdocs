<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>

<!-- DO NOT EDIT THIS FILE. EDIT 'index.list' AND RUN 'make' -->

<!-- Copyright (c) 1996, 1998, 1999, 2000
	The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED. -->
<link rev="made" href="mailto:www@JP.NetBSD.ORG">
<title>NetBSD Documentation: Other FAQs and HOWTOs </title>
</head>
<body bgcolor="#FFFFFF" text="#000000">

<table><tr><td>
    <a href="/Misc/daemon-copy.html"><img
     align="middle" src="/images/BSD-daemon.jpg" border="0"
     width=146 height=129 alt="BSD daemon"></a>
  </td><td align=center>
    <h1>NetBSD ドキュメンテーション:</h1>
    <h1>他の FAQ と HOWTO</h1>
</td></tr></table>
<p>

<h2><a name="top">ユーザー設定</a></h2>
<ul>
<li>
<a href="#adding-a-user">ユーザーの追加</a></li>
<li>
<a href="#problems-with-root">root としてログインあるいは 'su' する時の問題</a></li>
<li>
<a href="#adding-to-path">あなたのパスに何かを加える</a></li>
<li>
<a href="#setting-something-for-all-users">全ユーザーのためになにか設定する</a></li>
<li>
<a href="#shells">シェルでのカーソルキー編集またはファイルネーム補完</a></li>
<li>
<a href="#languages">メッセージ言語の指定</a></li>
<li>
<a href="#gecos-field"><tt>finger</tt> によって表示される情報の変更は?</a></li>
</ul>
<h2>印刷とスキャン</h2>
<ul>
<li>
<a href="#postscript-manpages">PostScript でマニュアルページを印刷する</a></li>
<li>
<a href="smbprint/">NetBSD からリモート SMB プリンターへの印刷</a></li>
<li>
<a href="#jetdirect">BOOTP 経由の HP JetDirect Card 設定</a></li>
<li>
<a href="#scanning">NetBSD でスキャナを使う</a></li>
</ul>
<h2>リムーバブルメディアを使う</h2>
<ul>
<li>
<a href="#using-floppies">フロッピーディスクを初期化して使用する</a></li>
<li>
<a href="#using-zips">ZIP ディスクの使い方</a></li>
<li>
<a href="#cdrom">NetBSD で CD を読む</a></li>
<li>
<a href="#cdrom-video">NetBSD で ビデオCD を使う</a></li>
<li>
<a href="#cdrom-audio">NetBSD で音楽 CD を使う</a></li>
<li>
<a href="#cdr">CD-R ライターを使う</a></li>
<li>
<a href="#cdrw">CD-RW リライタブルを使う</a></li>
<li>
<a href="#dvd">DVD サポート</a></li>
</ul>
<h2>NetBSD に関する一般的な疑問</h2>
<ul>
<li>
<a href="#release-changes">NetBSD リリース間で何が変わったの?</a></li>
<li>
<a href="#64-bit">NetBSD は 64 bit オペレーティングシステム?</a></li>
<li>
<a href="#exportability">NetBSD は輸出できる?</a></li>
<li>
<a href="#netbsd-uses">何のために NetBSD を使うの?</a></li>
</ul>
<h2>一般の(それと一般ではない)問題</h2>
<ul>
<li>
<a href="#nroff-missing">'man' 実行時 <b>/usr/bin/nroff: not found</b></a></li>
<li>
<a href="#var-mail-permissions">メールを読んでいる時 '<b>Unable to lock mailbox: Permission denied</b>'が出ます</a></li>
<li>
<a href="#kernel-not-netbsd">'<tt>netstat -r</tt>' を実行すると <b>netstat: kvm_read kvm_read: Bad address</b> となります</a></li>
<li>
<a href="#libkvm-mismatch">'<tt>netstat -r</tt>' をしてみると、限りないクエスチョンマークの列が帰ってきます。 何が悪いの?</a></li>
<li>
<a href="#kernel-upgrade">新しいカーネルにアップデートしたあと、 <tt>w</tt>, <tt>ps</tt>, と <tt>netstat</tt> が働きません</a></li>
<li>
<a href="#proc-size-mismatch">カーネル変更後 'ps' が <b>"proc size mismatch"</b> と言います</a></li>
<li>
<a href="#hash-map-alias0">'<b>hash map "Alias0":unsafe map file     <tt>/etc/aliases</tt>: No such file or directory</b>' が表示されます</a></li>
<li>
<a href="#portmap-messup">どうやったら、 root でログインした時のシェルが出す <tt>portmap</tt> メッセージ を抑制できますか</a></li>
<li>
<a href="#locales">どうやったらウムラウト記号を表示できますか:</a></li>
</ul>
<h2>ほかの疑問</h2>
<ul>
<li>
<a href="#editing-files">NetBSD でのファイル編集</a></li>
<li>
<a href="#adding-a-disk">存在しているシステムにディスクを追加する</a></li>
<li>
<a href="#softdeps">soft updates (softdeps) はどうやって使うの?</a></li>
<li>
<a href="#softdep-impact">softdep による改善はどう判断してるの?</a></li>
<li>
<a href="#swap">スワップスペース(空間)はどのくらい</a></li>
<li>
<a href="#adding-swap">動作中のシステムにスワップを追加する</a></li>
<li>
<a href="#moving-usr">/usr をルートからほかのパーティションに移す</a></li>
<li>
<a href="#rebuilding-dev">/dev の再構築</a></li>
<li>
<a href="#connecting-a-ups">NetBSD システムに UPS をつなぐ</a></li>
<li>
<a href="#non-export-useability">インストールで secr.tgz 配布物を入れずに NetBSD を実行することができますか?</a></li>
<li>
<a href="#why-single-user">シングルユーザーモードってなに、どうして、なんのため?</a></li>
<li>
<a href="#single-user-to-multi-user">どうやって、シングルユーザーからマルチユーザーに移行するの</a></li>
<li>
<a href="#read-only-to-read-write">どうやって'リードオンリー'ファイルシステムを読み書きできるようにマウントするの?</a></li>
<li>
<a href="#using-fsck">いつ fsck を使うのが安全なの?</a></li>
<li>
<a href="#boot-messages">ブートメッセージはどうやって読むの?</a></li>
<li>
<a href="#shutting-down">どうやって機械をシャットダウンするの?</a></li>
<li>
<a href="#rebooting">どうやって、機械をリブートするの?</a></li>
<li>
<a href="#kernfs"><tt>/kern</tt> は何に使われているの?</a></li>
<li>
<a href="#procfs"><tt>/proc</tt> は何に使われているの?</a></li>
<li>
<a href="#changing-motd"><tt>/etc/motd</tt> を何らかの変更をしてももとの内容に戻ってしまいます</a></li>
<li>
<a href="#selling-hardware">どこへ NetBSD 関連のハードウエアを売ればいいの?</a></li>
<li>
<a href="#create-mpeg3">オーディオ CD からMP3 (MPEG layer 3) ファイルを作る</a></li>
<li>
<a href="#cron-reboot">起動時にプログラムを開始する</a></li>
<li>
<a href="#setup-ccd">ccd ドライブを設定する</a></li>
</ul>


<h2>他のリンク</h2>
<ul>
  <li><a href="http://cynjut.neonramp.com/">*BSD FAQ site</a>
      (もはやあまり手入れがされていません)
</ul>

<hr>
<h2>ユーザー設定</h2><hr>
<p><h3>
<a name="adding-a-user">ユーザーの追加</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=adduser&amp;sect=8">adduser(8)</a> マニュアルページの手続きに従う方法と
 <a href="../software/packages.html">NetBSD パッケージコレクション</a> の
 <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/sysutils/user/README.html">user</a> パッケージを使う方法のどちらでも行なうことができます。

 <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/sysutils/user/README.html">user</a> management suite(ユーザー管理セット) は
 NetBSD 1.4.2 から統合されています。

</dd></dl>
<p><h3>
<a name="problems-with-root">root としてログインあるいは 'su' する時の問題</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

これは数多くの起こりうる問題をカバーし:
<p>
<ul>
    <li><strong> root として直接ログインできません</strong><br>

	NetBSD は <tt>/etc/ttys</tt> 中に 'secure' が書かれている端末からのみ、
	 root として直接ログインすることを許します ( <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=ttys&amp;sect=5">ttys(5)</a> を見よ)。


	ネットワークをまたいで直接ログインできるようにする( 推奨され <b>ない</b> )には、
	 '<tt>secure</tt>' を各ネットワーク端末行の最後に加える必要があります。
	これらをするのに、各行を編集する必要はなく root になって
	 打ちます:

	<dl>
	<dd><tt><b>cd /etc</b></tt></dd>
	<dd><tt><b>cp ttys ttys.orig</b></tt></dd>
	<dd><tt><b>cat ttys.orig | sed 's/network$/network secure/'
	   &gt; ttys</b></tt></dd>
	</dl>

    <p><li><strong> root に 'su' できません</strong><br>

	NetBSD は誰かが root に <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=su&amp;sect=1">su(1)</a> しようとすることに対して、
	 <tt>/etc/group</tt> の 'wheel' グループに入っているかチェックします。

	もしそこが空 (wheel:*:0:) なら誰もが正しいパスワードで root に su できます。

	さもなければ、
	(スペースじゃなく!)
	コンマで区切られた許可されたアカウントのリストがあるべきです。


    <p><li><strong>誰も 'su' できません</strong><br>
        "<b><tt>ls -l /usr/bin/su</tt></b>" と入力してください。
	出力の最初の 'word' は '-r-sr-xr-x' であるべきです。
	もし、それがなにか違う( '-r-xr-xr-x' みたいに)なら
	(root になって) "<b><tt>chmod 4555 /usr/bin/su</tt></b>"と入力してください。

	その位置の 's' は 'setuid' バイナリーを示していて、この場合、
	 'su' が root 特権 で走ることを認めています。

	<p>
	この問題は、配布物を展開した時に tar に '-p'(パーミッション保護) フラグが
	与えられていなかったことによるものです。

	この場合、
	ほかのさまざまなユーティリティもまた壊れているでしょうから、
	全ての tar ファイル ( etc.tar.gz 以外)を再展開してください。

</ul>

</dd></dl>
<p><h3>
<a name="adding-to-path">あなたのパスに何かを加える</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

例えば、あなたのパスに /usr/X11R6/bin を加えるなら、
ホームディレクトリーの <em>.login</em> ファイルを編集し
次のように加えます:

<dl>
<dd><tt><b>set path = ( /usr/X11R6/bin $path )</b></tt></dd>
</dl>
<p>

これは C-shell <em><a href="http://www.flame.org/cgi-bin/uncgi/hman?page=csh&amp;sect=1">csh(1)</a></em> と、その派生物の
 <em><a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/shells/tcsh/README.html">tcsh</a></em> のようなものでのみ、働きます。

 <em><a href="http://www.flame.org/cgi-bin/uncgi/hman?page=sh&amp;sect=1">sh(1)</a></em> と派生物( <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/shells/bash2/README.html">bash2</a> のような)では
正しい文法は:

<dl>
<dd><tt><b>PATH=/usr/X11R6/bin:$PATH</b></tt></dd>
<dd><tt><b>export PATH</b></tt></dd>
</dl>

</dd></dl>
<p><h3>
<a name="setting-something-for-all-users">全ユーザーのためになにか設定する</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=csh&amp;sect=1">csh(1)</a> や <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/shells/tcsh/README.html">tcsh</a> を走らせている全ユーザーのために、
次に示すファイルの一つに書き加えることで、
なにか設定することができます。
:

<ul>
<li><b><tt>/etc/csh.cshrc</tt></b><br>

    これは、新しいシェルが開かれるごとに、
    ユーザーのホームディレクトリにある、いかなる <b><tt>.cshrc</tt></b> に先立って実行されます。


<li><b><tt>/etc/csh.login</tt></b><br>

    これは、ユーザーがログインする時、
     <b><tt>/etc/csh.cshrc</tt></b> よりも後だけど、
    ユーザーのホームディレクトリにあるいかなる
     <b><tt>.login</tt></b> よりも先に実行されます。

<li><b><tt>/etc/csh.logout</tt></b><br>

    これは、ユーザーがログアウトする時、ユーザーのホームディレクトリにある
     いかなる <b><tt>.logout</tt></b> より先に実行されます。
</ul>

</dd></dl>
<p><h3>
<a name="shells">シェルでのカーソルキー編集またはファイルネーム補完</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

これは、使っているシェルの型により:
<ul>
<li><b><a href="http://www.flame.org/cgi-bin/uncgi/hman?page=sh&amp;sect=1">sh(1)</a> (Bourne シェル)</b><br>

	これは、シングルユーザーモードで使われるシェルで、

 '<tt>set -E</tt>' コマンドで、コマンドライン編集を有効にできます。

	シングルユーザーモードでいつもコマンドライン編集ができるように、
	 <tt>/.profile</tt> にこれを加えることができます。

<li><b><a href="http://www.flame.org/cgi-bin/uncgi/hman?page=csh&amp;sect=1">csh(1)</a> ('C' シェル)</b><br>

	これは標準のユーザーシェルで、ファイルネーム補完をサポートしています 
	('<b>set filec</b>' してから、 ESCAPE キーを使って) が、
	コマンドライン編集はサポートしていません。

	けれども、 <a href="../software/packages.html">NetBSD パッケージコレクション</a> 
	からファイルネーム補完とコマンドライン編集が標準で有効になっている
	 <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/shells/tcsh/README.html">tcsh</a> や <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/shells/bash2/README.html">bash2</a> をインストールすることができます。

<li><b>tcsh (拡張された 'C' シェルの一つ)</b><br>
	'tcsh' はほぼ完璧な csh のスーパーセット(拡張物)で
	ファイルネーム補完(TAB を使います)と
	コマンドライン編集を含む沢山の便利な特別な機能があります。
	 <a href="../software/packages.html">NetBSD パッケージコレクション</a> 
	中の shells/<a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/shells/tcsh/README.html">tcsh</a> からインストールすることができます。

<li><b>bash (GNU Bourne Again Shell)</b><br>
	 'bash' はもうひとつの、コマンドライン編集拡張されているシェルで、
	これは 'sh' が基になっています。

 <a href="../software/packages.html">NetBSD パッケージコレクション</a>
中の shells/<a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/shells/bash2/README.html">bash2</a> からインストールすることができます。
<li><b>ほかの shell たち</b><br>
	The <a href="../software/packages.html">NetBSD パッケージコレクション</a> 
	の <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/shells/README.html">shells</a> カテゴリーの下には、
	さまざまな他のコマンドラインシェルが含まれています。

</ul>

</dd></dl>
<p><h3>
<a name="languages">メッセージ言語の指定</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

NetBSD は、エラーメッセージやそのようなものに用いる言語を
決めるのに
 '<tt>LANG</tt>' 環境変数 を使います。

 csh や tcsh では
 '<tt>setenv LANG <b>XX</b></tt>' コマンドで設定でき、
ここで、 XX は2文字の国コードです。
サポートされているコードタイプの一覧は
 '<tt> /usr/share/nls</tt>' にあります。<br>
<p>
<b>どうか注意</b>:確実に翻訳されているものだけにしてください。

確認するには、 <tt>LANG</tt> 変数をセットし、
'<tt>cd&nbsp;/a_directory_that_does_not_exist</tt>'と打ってください。
  </p>

</dd></dl>
<p><h3>
<a name="gecos-field"><tt>finger</tt> によって表示される情報の変更は?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

 '<b><tt><a href="http://www.flame.org/cgi-bin/uncgi/hman?page=chfn&amp;sect=1">chfn(1)</a></tt></b>' コマンドを使ってください。
または
 <tt>/etc/master.passwd</tt> をエディットするために、
 '<b><tt><a href="http://www.flame.org/cgi-bin/uncgi/hman?page=vipw&amp;sect=8">vipw(8)</a></tt></b>' を使ってください。


</dd></dl>
<hr>
<h2>印刷とスキャン</h2><hr>
<p><h3>
<a name="postscript-manpages">PostScript でマニュアルページを印刷する</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

   マニュアルページは、
 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=nroff&amp;sect=1">nroff(1)</a> ソースとして /usr/share/man/man<em>X</em>/<em>manpage</em>.<em>X</em> 
にあります。ここで <em>X</em> はセクション番号です (例: nroff の場合は 1 )。

    それを PostScript に変換するにはこれが使えて:<br>

    <pre>	<b>groff -Tps -mandoc /usr/share/man/man<em>X</em>/<em>manpage</em>.<em>X</em></b></pre>

    たとえば、 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=ls&amp;sect=1">ls(1)</a> マニュアルページ を PostScript に変換し、
    <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=lpr&amp;sect=1">lpr(1)</a> を通して直接デフォルトのプリンタに送るにはこれを使うことができ、

    <pre>	<b>groff -Tps -mandoc /usr/share/man/man1/ls.1 |lpr</b></pre>

    ほかのタイプのプリンターで印刷したいなら、
     pkgsrc の <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/print/ghostscript/README.html">ghostscript</a> パッケージ を使いたくなるでしょう。

</dd></dl>
<p><h3>
<a href="smbprint/">NetBSD からリモート SMB プリンターへの印刷</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

</dd></dl>
<p><h3>
<a name="jetdirect">BOOTP 経由の HP JetDirect Card 設定</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

 JetDirect EX Plus のような、 JetDirect プリントサーバーを持っていれば、
プリントサーバーを設定するために、 NetBSD のもとで BOOTP を使うことができます。 このステップは:
 JetDirect サーバーのために <tt>/etc/bootptab</tt> にエントリーを作ります。
<pre>
hp690c:\ 
        :hn:\ 
        :ht=ether:\ 
        :ip=192.168.0.10:\            &lt;-- JetDirect が要求した IP アドレスに設定する
        :ha=00.60.b0.1d.04.d5:\       &lt;-- JetDirect の MAC アドレスを設定する
        :sm=255.255.255.0:\           &lt;-- JetDirect が要求した ネットマスクに設定する
        :sa=192.168.0.5:\             &lt;-- tftp サーバーのアドレスに設定する (TFTPD が走っているのと同じ機械)
        :gw=192.168.0.1:\             &lt;-- ゲートウェイアドレスを設定する
        :lg=192.168.0.5:\             &lt;-- ログをつけるサーバーlog server のアドレスを設定する
        :T144="hpnp/hp690c.cfg":\     &lt;-- JetDirect 設定ファイルの名前
        :vm=rfc1048:
</pre>
 より詳しい情報は <tt><a href="http://www.flame.org/cgi-bin/uncgi/hman?page=bootptab&amp;sect=5">bootptab(5)</a></tt> を見てください。

 <tt>/etc/inetd.conf</tt> 内で、 <tt>tftpd</tt> と <tt>bootp</tt> が
有効になっていることを確かめてください。

注意として、
 "-s" 引数を <tt>/etc/inetd.conf</tt> の <tt>tftp</tt> の行につけるようにしてください。
これは、 <tt><a href="http://www.flame.org/cgi-bin/uncgi/hman?page=tftpd&amp;sect=8">tftpd(8)</a></tt> のルートディレクトリーです。

この例についてはあとは、
 <tt><a href="http://www.flame.org/cgi-bin/uncgi/hman?page=tftpd&amp;sect=8">tftpd(8)</a></tt> のルートディレクトリーを <tt>/tftpboot</tt> に設定する
ことでしょう。

次に Network Printer Inferface (NPI) 設定ファイルをつくります。
この例では、ファイルは <tt>/tftpboot/hpnp/hp690c.cfg</tt> で、
  このファイルは次のようになっているべきで
:
<pre>
name: printer name
location: Location of the Printer 
contact: Contact Person 
idle-timeout: 1800
banner: 0
</pre>

もし、 <tt>/etc/inetd.conf</tt> に変更を加えたなら、
 <tt>kill -HUP `cat /var/run/inetd.pid`</tt> をすることで
 <tt><a href="http://www.flame.org/cgi-bin/uncgi/hman?page=inetd&amp;sect=8">inetd(8)</a></tt> が <tt><a href="http://www.flame.org/cgi-bin/uncgi/hman?page=inetd.conf&amp;sect=5">inetd.conf(5)</a></tt> を再読込みすることを確認してください。

 JetDirect プリントサーバー (または HP JetDirect カードのついたプリンター)
をリブートすると、サーバーは BOOTP の設定を読みこみます。


  いくつかのプリンターでは、フロントパネル(の操作)で BOOTP の設定を
明示的に有効にする必要があるかもしれません。

</dd></dl>
<p><h3>
<a name="scanning">NetBSD でスキャナを使う</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
    NetBSD は、 <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/graphics/sane-backends/README.html">sane-backends</a> スキャニングパッケージを用いて、
    さまざまな SCSI スキャナをサポートしています。この API にアクセスするための
    フロントエンドは <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/graphics/sane-frontends/README.html">sane-frontends</a> パッケージで提供されており、
    また、 <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/graphics/gimp/README.html">GIMP</a> のようなグラフィックツールから直接呼び出すことができます。
    <p>

    注意: 
 1.4.2 より前のバージョンの NetBSD では、
カーネル内の <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=ss&amp;sect=4">ss(4)</a> スキャナードライバーは
 <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/graphics/sane-backends/README.html">sane-backends</a> といくつかのスキャナーで
問題を起こすかもしれません。
 - その解決法は、カーネルを <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=ss&amp;sect=4">ss(4)</a> デバイスを使わずに <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=uk&amp;sect=4">uk(4)</a> を使うように再コンパイルするか、
 1.4.2 以降にアップグレードすることのどちらかです。

</dd></dl>
<hr>
<h2>リムーバブルメディアを使う</h2><hr>
<p><h3>
<a name="using-floppies">フロッピーディスクを初期化して使用する</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

PC-style フロッピーディスクは最初に low-level フォーマット(物理フォーマット)
をしなければならないことを除いて、大抵ハードディスクのような
他のディスクデバイスと同じように動作します。

<p>

1番目のフロッピードライブで 一般的な 1440 KB フロッピーとして使うには、
最初に(root になって)フォーマットし:
<pre>
fdformat -f /dev/rfd0a
</pre>

それから、 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=disklabel&amp;sect=8">disklabel(8)</a> を使ってディスクに1つのパーティションをつくります:

<pre>
disklabel -rw /dev/rfd0a floppy3
</pre>

空間に最適化された小さいファイルシステムを作ります:

<pre>
newfs -m 0 -o space -i 16384 -c 80 /dev/rfd0a
</pre>

これで、フロッピーディスクは他のディスクのようにマウントすることができます。
<br>

または、既に MS-DOS ファイルシステムになっているフロッピーディスクを
持っていて、単に NetBSD からアクセスしたいだけなら、単にこのようにするだけで:

<pre>
mount -t msdos /dev/fd0a /mnt
</pre>
<p>

しかしながら、フロッピーを標準(より大きい)ディスクとして使うのは、
ファイルシステム間をバイパスするのに便利だからで、
直接 raw device にファイルのアーカイブを置く( splat )なら、たとえば:
<pre>
tar cvfz /dev/rfd0a file1 file2 ...
</pre>

このバリエーションとして、
 <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/sysutils/mtools/README.html">mtools</a> パッケージを使って
 MS-DOS フロッピーを扱うことができ、
カーネルバッファーキャッシュを通さないという利益があって、
ファイルシステムがマウントされている最中に
フロッピーを取り出す危険にさらさずにすみます。

</dd></dl>
<p><h3>
<a name="using-zips">ZIP ディスクの使い方</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
<ol>
<li> システムが ZIP ドライブを持っているか見てみます:
<pre>
yui# dmesg | grep -i zip
sd0 at atapibus0 drive 1: &lt;IOMEGA  ZIP 100       ATAPI, , 14.A&gt; type 0 direct removable
</pre>

   一つあるのが見え、 単に他の SCSI ディスクと同じような sd0 として記録されています。

   The fact that the ZIP here is an ATAPI one doesn't matter
                - SCSI の ZIP もここに現われます。

  ZIP は "removable" と記されていて、
これは、 "<tt>eject sd0</tt>" で取り出すことができるという意味です。

   <p>

<li> ZIP ディスクを挿入します
   <p>

<li> ZIP 内のパーティションを眺めます:
<pre>
yui# disklabel sd0
# /dev/rsd0d:
type: ATAPI
 ...
8 partitions:
#        size   offset     fstype   [fsize bsize   cpg]
  d:   196608        0     unused        0     0         # (Cyl.    0 - 95)
  h:   196576       32      MSDOS                        # (Cyl.    0*- 95)
disklabel: boot block size 0
disklabel: super block size 0
</pre>
   <dl compact>
   <dt> "d" <dd> はディスク全体です。 i386 ではたいてい。
   <dt> "h" <dd> があなたの望んでいるもので、 msdos ファイルシステムとして見えます。
   </dl>
   それゆえ、 zip 上のパーティションをアクセスするには、 /dev/sd0h をつかいます。
   <p>

<li> それをマウントします:
<pre>
yui# mount -t msdos /dev/sd0h /mnt
yui# 
</pre>
   <p>

<li> ファイルにアクセスします:
<pre>
yui# ls -la /mnt
total 40809
drwxr-xr-x   1 root  wheel     16384 Dec 31  1979 .
drwxr-xr-x  28 root  wheel      1024 Aug  2 22:06 ..
-rwxr-xr-x   1 root  wheel   1474560 Feb 23  1999 boot1.fs
-rwxr-xr-x   1 root  wheel   1474560 Feb 23  1999 boot2.fs
-rwxr-xr-x   1 root  wheel    548864 Feb 23  1999 boot3.fs
-rwxr-xr-x   1 root  wheel  38271173 Feb 23  1999 netbsd19990223.tar.gz
</pre>
   <p>

<li> ZIP をアンマウントする:
<pre>
yui# umount /mnt
yui#
</pre>
    <p>
<li> ZIP を取り出す:
<pre>
yui# eject sd0
yui#
</pre>
</ol>

</dd></dl>
<p><h3>
<a name="cdrom">NetBSD で CD を読む</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

Data CD は、プログラム、音声ファイル (mp3, wav)、動画 (mp3, quicktime) から、
ソースコード、テキストファイル、その他にいたるまで、
あらゆる物を入れることができます。
これらのファイルにアクセスする前に、 CD はハードディスクみたいに、
ディレクトリーにマウントされる必要があります。

ハードディスクが異なるファイルシステム( ffs, lfs, ext2fs, ...)で使えるように、
CD に固有のファイルシステムがあって、 "cd9660" です。

NetBSD cd9660 ファイルシステムは、
Rockridge と Joliet 拡張として、あるいは拡張とせず に扱うことができます。

<p>
CD デバイスは SCSI and IDE (ATAPI) 共に /dev/cd0a と名づけられています。
<P>
この情報で、始めることができ:
<P>

<ol>
<li> システムが CD ドライブを持っているか見てみます:
     <pre>
     # dmesg | grep ^cd
     cd0 at atapibus0 drive 0: &lt;CD-R/RW RW8040A, , 1.12&gt; type 5 cdrom removable
     cd0: 32-bit data port
     cd0: drive supports PIO mode 4, DMA mode 0
     cd0(pciide0:1:0): using PIO mode 0, DMA mode 0 (using DMA data transfers)
     </pre>

     ここに一つのドライブがあり、 "cd0" です。
     それは IDE/ATAPI ドライブで  atapibus0 上に見つかっています

     もちろんそのドライブ (より正確にはそのメディア) はリムーバブルで、
     すなわち取り出すことができ、下記を見てください。
     <p>
<li>  CD を挿入します。
     <p>
<li> CD を手動でマウントします:
     <pre>
     # mount -t cd9660 /dev/cd0a /mnt
     # 
     </pre>

     このコマンドはなにも表示しません。
     それは、システムが CD を /dev/cd0a に見つけ、 "cd9660" ファイルシステムを使って
      /mnt にマウントしたという(暗黙の)知らせです。
     マウントポイント "/mnt" は存在するディレクトリでなければなりません。
     <p>
     
<li> CD の内容を確かめます:
     <pre>
     # ls /mnt
     INSTALL.html INSTALL.ps   TRANS.TBL    boot.catalog
     INSTALL.more INSTALL.txt  binary       installation
     # 
     </pre>
     全部良く見えています! これは NetBSD CD です、もちろん。 :)
     <p>
     
<li> CD をアンマウントします:
     <pre>
     # umount /mnt
     # 
     </pre>

     CD がアクセスされたまま(たとえば、どれか他のシェルがまだその中に "cd"したまま)
     たと、これは、働きません。
     もし、システムをシャットダウンされるなら、 CD は自動的に アンマウントされ、
     それに関してはなにも心配はいりません。
     <p>

<li>  /etc/fstab にエントリーを作ります:
     <p>
     もし、いちいち "mount"コマンドを完全に打ちたくなければ、
     /etc/fstab の行中にその値を置くことができ:
     <pre>
     # Device        mountpoint      filesystem  mount options 
     /dev/cd0a       /cdrom          cd9660      rw,noauto    
     </pre>

     例示したマウントポイント - "/cdrom" はあらかじめ存在しなければなりません:
     <p>
     <pre>
     # mkdir /cdrom
     # 
     </pre>

     これで、次のコマンドで CD をマウントすることができ:
     <pre>
     # mount /cdrom
     #
     </pre>

     前の通り、アクセスとアンマウントをします。
     <p>
     CD は "noauto" によって、起動時はマウントされません。
     - これは、多分、常時ドライブに CD を入れていないだろうから便利です。
     他のいくつかの便利なオプションは  <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=mount&amp;sect=8">mount(8)</a> と <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=mount_cd9660&amp;sect=8">mount_cd9660(8)</a> 
     を見てください。
     <p>
     
<li> CD を取り出します:
     <pre>
     # eject cd0
     # 
     </pre>

     CD がまだマウントされたままなら、もし可能ならアンマウントし、
     それでイジェクトします。
     <p>
</ol>

     
</dd></dl>
<p><h3>
<a name="cdrom-video">NetBSD で ビデオCD を使う</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
     多くの DVD プレイヤーのように、 NetBSD のもとで、
     MPEG ビデオストリームを再生するには、
     CD を普通の (データ) CD としてマウントし ( <a href="#cdrom">上</a> を見てください ) 、
     CD 上に蓄えられた mpeg ファイルを再生するために
     <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/graphics/mtv/README.html">mtv</a> パッケージを使ってください。
     <p>


</dd></dl>
<p><h3>
<a name="cdrom-audio">NetBSD で音楽 CD を使う</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

音楽 CD を扱うには2つの方法があって:
<p>
<ol>
<li> 
たいてい内部接続された
CDROM ドライブで
 ヘッドホン か サウンドカードのどちらで再生したいのか
教えてください。

 <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/audio/xmcd/README.html">xmcd</a> 、
 <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/audio/kdemultimedia/README.html">kdemultimedia</a> パッケージの "kscd" や、
 mixer プログラムとして
 <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/audio/xmix/README.html">xmix</a>, <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/audio/xmmix/README.html">xmmix</a>,
  Curses ベースの <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/audio/cam/README.html">cam</a> 
や <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/audio/kdemultimedia/README.html">kdemultimedia</a> に含まれる kmix 
のようなものを使ってください。

     <p>
     
     これは、SCSI と IDE (ATAPI) 両方の CDROM,CDRW,DVD ドライブで、
     大抵きちんと動きます。
     <p>
     
<li>
     オーディオトラックを デジタル -&gt; アナログ 変換 をしてもう一回戻すことなしに
     バイナリ形式で読み出す ("rip") には、 <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/audio/cdd/README.html">cdd</a>, <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/audio/tosha/README.html">tosha</a> と
     <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/audio/cdparanoia/README.html">cdparanoia</a> のようなプログラムが使えます。
     このデータは、後処理として、例えば
     それを MP3 ストリームにエンコードする ( <a href="#create-mpeg3">下</a> を見てください) 
     ことや、 <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/sysutils/cdrecord/README.html">cdrecord</a> を使って、CD-R に書き戻すことができます。
     <p>
     
     ドライブによって、ソフトウエアが対応していたり、いなかったりします。
      Cdparanoia は IDE (ATAPI) と SCSI ドライブ の多くの範囲で動作することが知られています。
     <p>
</ol>


</dd></dl>
<p><h3>
<a name="cdr">CD-R ライターを使う</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

CD に書きこむ過程には、2段階あって:
最初に、データの "イメージ" を作る必要があり、
第2段階で CD-R に書きこみます。

<p>

<ol>
<li> すでに有る ISO イメージを読み込む
     <pre>
     # dd if=/dev/rcd0a of=filename.iso bs=2k
     #
     </pre>
     代わりに、自分で新しい ISO イメージを作ることができ:
<li> ISO イメージをつくる
     <p>
     CD に入れたい全てのデータを1つのディレクトリに入れてください。
     つぎに、ディスクのような ISO イメージをつくる必要があります。

     イメージは、データを ISO 9660 フォーマットを使って
     後で CD に書きこむのと同じ形式でたくわえます。

     基本 ISO9660 フォーマットは 8+3 ファイル名だけ
     (最大で8文字のファイルネームと、加えて3文字までの拡張子)
     が使えます。

これは Unix のファイル名としては実用的ではなく、
それで "Rockridge Extension" と呼ばれるものを長いファイル名を使うために使う必要があります。


     (そのような拡張の 異なる set は Microsoft の世界でも存在し、
     それらのロングファイルネームを正しく get するためで、
     それは、 Joliet ファイルシステムとして知られています)。
     <p>
     ISO イメージは <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/sysutils/cdrecord/README.html">cdrecord</a> パッケージに入っている
      mkisofs コマンドを使ってつくります。

     <p>
     例: データが /usr/tmp/data にあって、 /usr/tmp/data.iso に ISO イメージをつくるなら、
     このようなコマンドで:
     <pre>
     $ <b>cd /usr/tmp</b>
     $ <b>mkisofs -o data.iso -r data</b>
     Using NETBS000.GZ;1 for  data/binary/kernel/netbsd.INSTALL.gz (netbsd.INSTALL_TINY.gz)
     Using NETBS001.GZ;1 for  data/binary/kernel/netbsd.GENERIC.gz (netbsd.GENERIC_TINY.gz)
       5.92% done, estimate finish Wed Sep 13 21:28:11 2000
      11.83% done, estimate finish Wed Sep 13 21:28:03 2000
      17.74% done, estimate finish Wed Sep 13 21:28:00 2000
      23.64% done, estimate finish Wed Sep 13 21:28:03 2000
      ...
      88.64% done, estimate finish Wed Sep 13 21:27:55 2000
      94.53% done, estimate finish Wed Sep 13 21:27:55 2000
     Total translation table size: 0
     Total rockridge attributes bytes: 5395
     Total directory bytes: 16384
     Path table size(bytes): 110
     Max brk space used 153c4
     84625 extents written (165 Mb)
     $
     </pre>

     出版者 (publisher) や作成者 (preparer) についての記述の指定など、
     他のオプションについては、 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=mkisofs&amp;sect=8">mkisofs(8)</a> マニュアルページを見てください。

      <a href="../bootcd.html">Bootable CD ROM How-To</a> が、
     ブータブル(起動可能) CD の作り方を説明してます。

     <p>
<li> CD-R に ISO イメージを書きこむ
     <p>
     ISO イメージファイルがあれば、単に CD に書くだけです。

     これは<a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/sysutils/cdrecord/README.html">cdrecord</a> パッケージの "cdrecord" コマンドで行ないます。

       ブランク CD-R を入れて、さあ、始めましょう:
     <p>
     <pre>
     # <b>cdrecord -v dev=/dev/rcd0d data.iso</b>
     ...
     #
     </pre>

     コマンドの実行が始まると、 'cdrecord' はドライブ、ディスク、
     書きこむイメージに関する沢山の情報を表示します。
     止めるためのラストチャンスとして10秒間カウントダウンし
     - 中止したければ ^C を押します。
     中止しなければ、 process は CD に全イメージを書き
     シェルプロンプトにもどります。
     <p>
     注釈 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=cdrecord&amp;sect=8">cdrecord(8)</a> は SCSI と IDE (ATAPI) ドライブ両方で動きます。
     <p>
<li> 試験
     <p>
     書き上がったばかりの CD をマウントし、 まったくの"標準"CD として試します。

<a href="#cdrom">上</a>を見てください。
     <p>
</ol>


</dd></dl>
<p><h3>
<a name="cdrw">CD-RW リライタブルを使う</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

NetBSD では CD-RW ドライブは <a href="#cdr">CD-R</a> ドライブのように扱うことができ、
 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=mkisofs&amp;sect=8">mkisofs(8)</a> でイメージをつくり、 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=cdrecord&amp;sect=8">cdrecord(8)</a> で CD-RW メディアに書きこむことができます。

<p>
ブランク CD-RW が欲しいなら、 cdrecord の "blank" オプションで作ることができ:
<p>
<pre>
# cdrecord dev=/dev/rcd0d blank=fast
</pre>
ブランク CD-RW を作る他のいくつかの方法があり、
"blank=help" をつけ <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=cdrecord&amp;sect=8">cdrecord(8)</a> を呼ぶとリストが得られます。
より多くの情報は <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=cdrecord&amp;sect=8">cdrecord(8)</a> マニュアルページを見てください。

</dd></dl>
<p><h3>
<a name="dvd">DVD サポート</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

現在、 NetBSD は CD-ROM でも使われている ISO9660 として だけども
DVD メディアをサポートしています。

DVD 上にある 新しい UDF ファイルシステムはサポートしていませんが、
ほとんど全ての DVD は ISO 9660 ファイルシステムを使っていて、良く使えます。
<p>

DVD 動画を見るには、若干のカーネルの対応 ( NetBSD-current で提供されています) と、
MPEG2 DVD プレイヤープログラムが必要です。

まだ、本当に有能(capable)なプレイヤーアプリケーションはありませんが、
非常に早期の、 完全にはサポートされない NetBSD バイナリーを含んだ
<a href="ftp://ftp.netbsd.org/pub/incoming/mycroft/dvd-19991031.tgz">プレイヤーがあります</a> 。

</dd></dl>
<hr>
<h2>NetBSD に関する一般的な疑問</h2><hr>
<p><h3>
<a name="release-changes">NetBSD リリース間で何が変わったの?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
<p>
全ての変更の日ごとの一覧 ( -current での物も含まれています)
が  <a href="/Changes/changes-1.5.html" origlink="../../Changes/changes-1.5.html">あります</a>。

<p>それは、各リリースの最上位ディレクトリーの
 <tt>CHANGES</tt> ファイルにもあります。

</dd></dl>
<p><h3>
<a name="64-bit">NetBSD は 64 bit オペレーティングシステム?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
NetBSD は 32 bit と 64 bit CPU のどちらでも動いています。

 <a href="../../Ports/alpha/">alpha</a> CPU では、

カーネルとユーザーランドは LP64 として知られているモードで走り、
それは、 <b>int</b> が 32 bit で <b>long</b> と
ポインター (とアドレス空間) が 64 bit です。

 UltraSparc (<a href="/Ports/sparc64/" origlink="../../Ports/sparc64/">sparc64</a>) や
 MIPS (<a href="/Ports/pmax/" origlink="../../Ports/pmax/">pmax</a>) のような
ほかの 64bit  capable CPU では、 NetBSD は 32 bit モードで走りますが、
プロセスは 64 bit で動くようになっています。


<p>
全ての NetBSD port は
カーネルとユーザーランドプログラムで 64 bit 算術 に対応しています。
カーネル内では、それはさまざまなカウンターと、
FFS 、64 bit 'Fast File System' に使われています。

</dd></dl>
<p><h3>
<a name="exportability">NetBSD は輸出できる?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
 NetBSD 1.4.x まで(とそれを含む)では、
 security 配布物 (すなわち secr.tgz) 以外の全ては
輸出できます。(訳注:原著者の国から、外国への輸出)
 secr.tgz 配布物ファイルには、暗号のためのライブラリーが含まれています。
 NetBSD 1.5 からは、 暗号化コードは
 NetBSD の base 配布物に含まれています。
<a href="../../Misc/crypto-export.html">
輸出制限されたコードとバイナリーに関する NetBSD ドキュメントを参照してください </a>。

</dd></dl>
<p><h3>
<a name="netbsd-uses">何のために NetBSD を使うの?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
 Chris G. Demetriou (cgd@netbsd.org) の言葉では:
<blockquote><pre>
NetBSD は、一般的に、  "安定した 研究 プラットフォーム" を意味し  -- それは、
商用、家庭、研究作業....、あなたに従って"あなた"がすること、に使えるシステムです。
  一般的に、 私たちが NetBSD でしている仕事は、システムを改善する試み、
それは私たちに可能なあらゆること -- 
より多くのハードウエア、より高い安定性、より良い性能、より多くの文書化...
</pre></blockquote>

我々の
 <a href="../../Misc/features.html">特色のページ</a> を
NetBSD があなたに与える機会(能力)のアイデアとして見てください!

</dd></dl>
<hr>
<h2>一般の(それと一般ではない)問題</h2><hr>
<p><h3>
<a name="nroff-missing">'man' 実行時 <b>/usr/bin/nroff: not found</b></a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

 'text' セットをインストールする必要があります。
 base install notes を見てください。

</dd></dl>
<p><h3>
<a name="var-mail-permissions">メールを読んでいる時 '<b>Unable to lock mailbox: Permission denied</b>'が出ます</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

 <tt>/var/mail</tt> ディレクトリのパーミッションをチェックしてください。
それは '<tt>drwxrwxrwt</tt>'となっているべきで:
<pre>
% <b>ls -ld /var/mail</b>
drwxrwxrwt  2 root  wheel  512 Nov  6 08:21 /var/mail
</pre>
そうでなければ、 root になって '<tt><b>chmod 1777 /var/mail</b></tt>' を実行します。

</dd></dl>
<p><h3>
<a name="kernel-not-netbsd">'<tt>netstat -r</tt>' を実行すると <b>netstat: kvm_read kvm_read: Bad address</b> となります</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

これはなにも心配はいりません。
 基本的に、 <tt>/netbsd</tt> というファイルは
あなたの現在のカーネルではありません。
たくさんのプログラム( <tt>ps</tt>, <tt>who</tt>, <tt>systat</tt> 等のような.)
や libkvm (<a href="http://www.flame.org/cgi-bin/uncgi/hman?page=kvm&amp;sect=3">kvm(3)</a>)は
カーネル内がどうなっているかを知るために <tt>/netbsd</tt> をアクセスします。

それで、この手のエラーを回避する為に、
あなたの現在のカーネルを <tt>/netbsd</tt> に単純にリネームすることができます。

これをしている時に動作中のカーネルを上書きしていないか確かめてください。
それが、あなたがしようとしていることではないかぎり。

</dd></dl>
<p><h3>
<a name="libkvm-mismatch">'<tt>netstat -r</tt>' をしてみると、限りないクエスチョンマークの列が帰ってきます。 何が悪いの?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
それは、 <tt>libkvm/netstat</tt> と <tt>/netbsd</tt> の間で不適合になっているからです。
または、 <tt>/netbsd</tt> という名前ではないカーネルを走らせているからです。
この問題のほかの兆候は、
 <tt>who</tt>,<tt>ps</tt>, <tt>ifconfig</tt> や <tt>systat</tt> 
のようなものも良く動かないことでしょう。
もし、カーネルとバイナリーを同時にアップデートすれば、解決するでしょう。

</dd></dl>
<p><h3>
<a name="kernel-upgrade">新しいカーネルにアップデートしたあと、 <tt>w</tt>, <tt>ps</tt>, と <tt>netstat</tt> が働きません</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

2つのうちの1つです。
 現在起動しているカーネルが <tt>/netbsd</tt> と名づけられていないか、
使っているカーネルとバイナリーの間で不適合があるかのどちらかです。

 最初の場合、単純に現在起動されているカーネルを
 <tt>/netbsd</tt> にリンクをつくることで、問題は解決します。
<p>

2番目の場合、ダイナミックリンクされたバイナリーは、
 libkvm を新しいカーネルに適合するようにアップグレードすることで、
直せます。

スタティックリンクされたバイナリーは
より新しいバージョンの物に置きかえる必要があります。

それらはスタティックリンクされているので、
それらを再コンパイルしようとするなら、
問題のプログラムの再構築をする <b>前に</b> <tt>libkvm.a</tt> を再構築する必要が
あります。
<p>
John Wittkowski (jpw@netscape.com) に感謝、
これは彼による ( <tt>/bin/ps</tt> のほかに)
libkvm に依存するプログラムのほとんどの一覧です
(これらの全ては <tt>/usr/bin</tt> にあります): 
<ul>
<li><tt>fstat</tt>
<li><tt>gdb</tt>
<li><tt>ipcs</tt>
<li><tt>netstat</tt>
<li><tt>nfsstat</tt>
<li><tt>systat</tt>
<li><tt>uptime</tt>
<li><tt>vmstat</tt>
<li><tt>w</tt>
</ul>

</dd></dl>
<p><h3>
<a name="proc-size-mismatch">カーネル変更後 'ps' が <b>"proc size mismatch"</b> と言います</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>


この前にある3つの疑問のように、
その答えは、たいてい、
libkvm がカーネルやバイナリーと同期がとれていないからです。

この問題を解決するには、
カーネルに適合したバイナリー配布物を手に入れるか、
下に示した方法で構築するかのどちらかの方法がとれます:

<blockquote><pre>

"proc size mismatch" エラーが出て、 lib のアップデートが必要だと決意した場合、
次のようにします:

1. 全ソースコードを手に入れます。
   もし、あなたがこれをしたり、再コンパイルをすることを望まなくても、
誰かがこの作業をしたか探すよりは、
いちいち手作業をしてインストールに挑戦しましょう。

2. インクルードファイルが 更新されているか確認します。
   このようにし:
      cd /usr/src
      make includes
   これは、ちょっと時間がかかるでしょう。
   いくつかの Makefiles に INSTALL 変数が定義されていなかったため、
   私は何度かトラブルに遭いました。

 "make includes" が失敗するごとに、
表示されている、最後のディレクトリーに行って、
 Makefile にこの行を加えました:
      INSTALL=/usr/bin/install

これを何度か行なうことで、エラーなしに終わることができました。


   (まず、 /usr/bin/make と /usr/share/mk 内の全てのファイルが
    更新されていることを確かめれば、 上の問題点を避けることができるでしょう。)

3.  libkvm を再構築し、インストールします:
      cd /usr/src/lib/libkvm
      make
      make install

   注意として、 libkvm を得る目的で
   私のシステムでコンパイルをするのに、
   次のようなリンクを加える必要がありました:
      cd /usr/include/machine
      ln -s ../m68k/kcore.h kcore.h
   これはたぶん私のシステムの癖なので、
   最初にこれをせずにコンパイルを試してください。

4. そして、 libkvm にスタティックリンクされたバイナリーを再構築します。
   私が気がついているスタティックリンクされたプログラムは
    "/bin/ps" だけで、  ps の再構築には、単純に:
      cd /usr/src/bin/ps
      make
      make install

5.  libkvm にダイナミックリンクされたバイナリーは、
   再構築が必要かもしれませんし、必要ないかもしれません。
   これは、なぜかと言うと(私が考えるに)、
   古いバイナリーに対し、 lib の メジャーバージョン番号 が変わるなら、
   古いバージョン番号を求めていて、新しいバージョンの lib では動かないでしょう。

   たとえば、 私の古い libkvm は libkvm.so.4.0 で、
   その新しいものは libkvm.so.5.0 です。
   ダイナミックリンクされたバイナリー を再コンパイルしなければ、
    "proc size mismatch" ( 4.0 lib がまだそこにあれば)か、
     some lib missing error ( /usr/lib から 4.0 lib が取り除かれていれば)
   と不平を言うでしょう。

   マイナーバージョンナンバーの変更 (たとえば 4.0 から 4.1) なら
    warning を出しながらも動き、
   これらの全てを再コンパイルする必要はないでしょう。

   私が気がついている ダイナミックリンクされたバイナリーは
    "proc size mismatch" エラー ( 4.0 lib がまだそこにあれば) か
    some lib missing エラー ( /usr/lib から 4.0 lib が取り除かれていれば) 
   を出すでしょう。
   マイナーバージョンナンバーの変更 (たとえば 4.0 から 4.1) なら
    warning を出しながらも動き、
   これらの全てを再コンパイルする必要はないでしょう。

   私が気がついているダイナミックリンクされたバイナリーは:
      /usr/bin/fstat
      /usr/bin/gdb
      /usr/bin/ipcs
      /usr/bin/netstat
      /usr/bin/nfsstat
      /usr/bin/systat
      /usr/bin/uptime ( /usr/bin/w にリンクされています)
      /usr/bin/vmstat
      /usr/bin/w
   注意 /usr/bin/uptime は /usr/bin/w にリンクされていて、
    w に対して "make install" をすることで、セットアップされるでしょう。

   これらを再コンパイルするには、次のようにし:
      cd /usr/src/usr.bin/&lt;cmd&gt;
      make 
      make install
   たとえば、 /usr/bin/vmstat を再コンパイルするには:
      cd /usr/src/usr.bin/vmstat
      make
      make install
</pre></blockquote>


これに関する具体的な答えをくれた John Wittkowski (jpw@netscape.com) に感謝

<p>

小さな背景: 
これらのシステムユーティリティーに、上にあげたすべての問題も含め、
カーネルメモリー情報を手に入れさせ続ける必要がある理由は、
この手段がカーネルクラッシュダンプに対しても働き、
カーネルデバック作業に便利な特徴になることが出来るからです。

</dd></dl>
<p><h3>
<a name="hash-map-alias0">'<b>hash map "Alias0":unsafe map file     <tt>/etc/aliases</tt>: No such file or directory</b>' が表示されます</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

ルート権限で '<b><tt>newaliases</tt></b>' と打つことで直せます。<br>

sendmail は <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=aliases&amp;sect=5">aliases(5)</a> ファイルが存在しないとこれを報告します。

注 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=sendmail&amp;sect=8">sendmail(8)</a> は実際には
   <tt>/etc/aliases.db</tt> ( <tt>/etc/aliases</tt> からつくられる高速 参照lookup 
   <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=hash&amp;sect=3">hash(3)</a> マップ) を使い、それで、このエラーメッセージは小さな誤解をおこすのです。

これは、 NetBSD 1.3 から 1.4 だけで、注意すべきで、
ほかのバージョンでは、
必要に応じて <tt>/etc/sendmail.cf</tt> を自動的に再構築する
異なる <tt>/etc/sendmail.cf</tt> を持っています。

もし、古くても NetBSD 1.4.1 を走らせていなければ、
新しい <a href="../../Releases/formal.html">公式リリース</a> 
にアップグレードするべきです。

</dd></dl>
<p><h3>
<a name="portmap-messup">どうやったら、 root でログインした時のシェルが出す <tt>portmap</tt> メッセージ を抑制できますか</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

 <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/security/sudo/README.html">sudo</a> をつかって、そして、決して root でログインしないでください。
<p>

root でログインする必要があるなら、
<tt>/etc/syslog.conf</tt> ファイルを編集することで、
うるさいメッセージを抑制するために
重要な 装備 を外すことができます。

たいていの場合、それは、次の行の
<tt>auth.debug</tt> を無効化することで充分で:
<pre>*.notice;auth.debug                                     root</pre>

これで、それらのうるさい 
<tt>portmap&nbsp;[pid]:&nbsp;connect&nbsp;from&nbsp;some.other.host&nbsp;...</tt> 
メッセージが消えるでしょう。

必ず
 <tt>kill&nbsp;-HUP</tt> <tt>syslogd</tt> の pid 
をしてください。
<p>

 <tt>xconsole</tt> を使うために、
 <a href="../x/#xconsole">FAQ entry</a> も見るのもいいかもしれません。

</dd></dl>
<p><h3>
<a name="locales">どうやったらウムラウト記号を表示できますか:</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

これは <a href="http://mail-index.netbsd.org/netbsd-users/2000/11/09/0019.html">メール アーカイブ</a>
 からの情報です:
<ol>
<li> <a href="ftp://ftp.netbsd.org/pub/NetBSD/arch/i386/french-1.4/locale.tgz">locale.tgz</a> を
取得してください。
<li> / にそれを展開し: <tt>tar plzvxCf / locale.tgz</tt>
<li> シェルで、 set LC_ALL=iso_8859_1 してください。
(常時設定にするには、 .cshrc 、 .profile 、 ...において)
<li> シェルを再起動するか、ログインしなおしてください。
<li> シェルを見ると、 vi その他 キーボードからのこれらウムラウトのすべてを
受け付けます: &ouml;&auml;&uuml;&Auml;&Ouml;&Uuml;...
(訳者注:環境によっては化けているかもしれません)
</ol>

</dd></dl>
<hr>
<h2>ほかの疑問</h2><hr>
<p><h3>
<a name="editing-files">NetBSD でのファイル編集</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
基本システムには2通りの明らかな選択肢があって:
<ul>

<li><b><a href="http://www.flame.org/cgi-bin/uncgi/hman?page=ed&amp;sect=1">ed(1)</a> (Line 指向 のテキストエディター)</b><br>

    <tt>ed</tt> は非常に単純なテキストエディターです。
    これには、コマンドモード(起動時に選択されている)と
    入力(インプット)モードがあります。

    その一番の利点は、 '/' ファイルシステムだけがマウントされた
    シングルユーザーモードでも存在していて、
    正しいターミナルタイプに設定されていなくても動作することです。

     <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=ed&amp;sect=1">ed(1)</a> の基本的な理解をすることは、価値のあることで、
    - 非常時に、 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=fstab&amp;sect=5">fstab(5)</a> と <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=rc.conf&amp;sect=5">rc.conf(5)</a> ファイルを直すのに充分です。

<li><b><a href="http://www.flame.org/cgi-bin/uncgi/hman?page=vi&amp;sect=1">vi(1)</a> (Screen 指向のテキストエディター)</b><br>

    <tt>vi</tt> は <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=ex&amp;sect=1">ex(1)</a> のコマンドモードとインプットモードを持ち、
    だが、フルスクリーンビジュアルインターフェースが加えられています。

    vi は基本インストールで存在する唯一のスクリーンエディタで、
    実行には、妥当なターミナルタイプが要求されます。<br>

    たくさんのオンラインの vi チュートリアル(個人指導)があって:
    <ul>
    <li><a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/editors/vilearn/README.html">vilearn</a> - pkgsrc にあって、高く推奨します。
    <li><a href="http://www.thomer.com/thomer/vi/vi.html">
	VI 愛好者ホームページ(英文)</a>.
    <li><a href="http://ecn.www.ecn.purdue.edu/ECN/Documents/VI/">
	Purdue University Engineering Computer Network</a>.
    <li><a href="http://www.smu.edu/smunet/docs/vi/">
	 Southern Methodist University のいくつかの参考文献
</a>
    </ul>

     <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=rc.conf&amp;sect=5">rc.conf(5)</a> の設定に vi を使うことを試みるなら、
      <a href="#why-single-user">シングルユーザーモード</a> の
     項目を読むべきです。
</ul>
<p>

pkgsrc の <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/editors/README.html">editors</a> カテゴリーには、沢山の数のエディターがあって:
<ul>
<li><b><a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/editors/joe/README.html">joe</a></b><br>

    WordStar と emacs のキーバインド (<i>jstar</i>, <i>jmacs</i>) を
    エミュレートできる小さくて高速なエディター
    <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/editors/joe/README.html">joe</a> は Borland IDEs を使う人達に知られているでしょう。
<li><b><a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/editors/pico/README.html">pico</a></b><br>
    非常にシンプルに使えるテキストエディターで、
    <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/mail/pine/README.html">pine</a> メール パッケージで使われています。
<li><b><a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/editors/nedit/README.html">nedit</a></b><br>
    シンプルだけど便利な、融通の利く X ベースの GUI エディター。
<li><b><a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/editors/emacs/README.html">emacs</a></b><br>
    ことわざにある 'なんでもかんでも (everything and the kitchen sink)'
    なエディターで、完全な lisp インタープリターを含みます。
    小さな機械には推奨されません。
</ul>

</dd></dl>
<p><h3>
<a name="adding-a-disk">存在しているシステムにディスクを追加する</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
<ol>
<li>システムを Halt(停止) します
<li>新しいドライブをつなぎます
<li>マシンが PROM か BIOS を持っていて、ドライブ一覧が出せるなら、
    そのドライブが認識されているかチェックします:
    <ul>
    <li><b>最近の sparc</b>: 起動開始以前に
 <tt><b>[STOP][A]</b></tt> を押し、そして "<tt>ok</tt>" プロンプトの所で <tt><b>probe-scsi</b></tt>。

    <li><b>adaptec BIOS の入っている i386 </b>:起動開始以前に、
 <tt><b>[CTRL][A]</b></tt> を押し、BIOS にはいります。
    <li><b>他のもの</b>: もっと詳しいこと(を寄せられること)を歓迎します :)
    </ul>
<li>boot します。
<li> <tt><b><a href="http://www.flame.org/cgi-bin/uncgi/hman?page=dmesg&amp;sect=8">dmesg(8)</a></b></tt> 出力に ドライブが記録されているか確かめます
<li>ディスクラベルを用いてパーティションに <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=disklabel&amp;sect=8">disklabel(8)</a> を書きこみます<br>
        (もし、ディスクにディスクラベルがまだなければ、たぶんこのようにし:<br>
  <tt><b> disklabel sd1 &gt; foo</b></tt> # "sd1: no disk label" という警告はすべて無視します<br>
  <tt><b> vi foo</b></tt>  # 何をするか知っていれば<br>
  <tt><b> disklabel -r -R sd1 foo<br>
          disklabel -i foo</b></tt> # もし、適切な -current の disklabel を持っていて、
                                      上の vi で 何をすれば良いか正確にわかっていないなら
        )

<li>追加されたファイルシステムごとに、
 <tt><b>newfs &lt;filesystem&gt;</b></tt>
    (ここで <em>&lt;filesystem&gt;</em> は生(raw)デバイスのパーティションです。
      /dev/rsd1e, /dev/rwd1f, ... のような)

<li>ファイルシステムを
 <tt>/etc/fstab</tt> に書きこみます。
<li>それを <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=fsck&amp;sect=8">fsck(8)</a> します: <tt><b>fsck -p &lt;filesystem&gt;</b></tt>
<li>それを <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=mount&amp;sect=8">mount(8)</a> します: <tt><b>mount -va</b></tt>
</ol>

</dd></dl>
<p><h3>
<a name="softdeps">soft updates (softdeps) はどうやって使うの?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
    Frank van der Linden
    (<A HREF="mailto:frank@wins.uva.nl">frank@wins.uva.nl</A>)
    はメインツリーに
     Kirk McKusick の 精巧な sync + FFS soft update コードを
    持ってきました。

     soft updates は、その著作権の為、分離できる必要があり、
    まだ実験的なものとみなされています。
    <p>
    使うには、次のようにします:

    <ol>
    <li>ソースを 1999年11月15日以降の NetBSD-current にアップデートします。
        <i> NetBSD 1.5 やそれ以上である必要はありません, soft updates は含まれているから。</i>

    <li>カーネルコンフィグファイルに "<tt>options SOFTDEP</tt>" がある新しいカーネルをコンパイルします。
    <li>新しいカーネルを走らせます。
    <li>なにも起こらなければ、 <tt>/sys/sys</tt> から新しいインクルードファイルを
        インストールします。(すなわち、いずれにせよ <tt>cd /usr/src/sys ; make includes</tt> をする。)
        安全に行なうには、単にそれら全部をインストールします。
        (<tt>cd /usr/src ; make includes</tt>)
        <i>この段階(ステップ)は NetBSD 1.5 以上では必要ありません。</i>

    <li>少なくても lib/libc, sbin/mount, sbin/mount_ffs, sbin/fsck_ffs,
        sbin/tunefs, を再コンパイルし、インストールします。
        <i>この段階(ステップ)は NetBSD 1.5 以上では必要ありません。</i>

    <li> softdeps を有効にする前に、既に <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=tunefs&amp;sect=8">tunefs(8)</a> を使っている場合、
        シングルユーザーモードで起動して、それらをもう一度、無効にします:
         "<tt>tunefs -n disable /dev/rXd0x</tt>" 。
        softdeps は 今、 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=mount&amp;sect=8">mount(8)</a>のオプションで有効になっています。
        <i>この段階(ステップ)は NetBSD 1.5 や 20000616 以降のシステムでは必要ありません。</i>

    <li> <tt>/etc/fstab</tt> の中で、 softdeps を使いたい全てのファイルシステムに
 "<tt>softdep</tt>" マウントオプションを追加します。
たとえば、このような行は
<pre>
/dev/wd0e    /usr    ffs     rw                      1 2
</pre>
このように変更します:
<pre>
/dev/wd0e    /usr    ffs     rw<b>,softdep</b>              1 2
</pre>
    <li>システムにそれがまだあれば、 <tt>/etc/rc.conf</tt> から "<tt>update=YES</tt>" を取り除きます。
     <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=update&amp;sect=8">update(8)</a> はもはや必要ありません。

それは、現在では、カーネルスレッドによる、より洗練された方法で動き、
-  もし、この理由によって、ファイルシステムの soft updates を有効にしたくなくても、
 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=update&amp;sect=8">update(8)</a> を無効にすることができます。

        <i>この段階(ステップ)は NetBSD 1.5 以上では必要ありません。</i>
    <li>リブートします。
    <li>遊ぼう!
    </ol>


</dd></dl>
<p><h3>
<a name="softdep-impact">softdep による改善はどう判断してるの?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

変化したデータが直ちにディスクに書き込まれない事実から、
システムがもっと速くなったと思われます。
現時点では、これを表わす数字はありません。
<p>

Paul Vixie は、softdep が
<a href="http://www.vix.com/~vixie/fbsd-flat.png">あり</a> と
<a href="http://www.vix.com/~vixie/bsdi-flat.png">なし</a>
の両方のシステムで、一つのディレクトリーに (ランダム順に) 75.000 ファイル を蓄え検索する
ベンチマークを走らせました。
この結果は、大きなディレクトリーにおいて、生成および配置の両方のファイルアクセス時間が、
一般的に、soft dependencies なシステムのほうが良い結果であることを
示しています。(この場合の softdep システムは FreeBSD 4.2で、
非-softdep システムは BSD/OS 3.1 です。
 NetBSD システムでも softdep の有る無しで見られる挙動は似たものであるはずです)。

<p>


</dd></dl>
<p><h3>
<a name="swap">スワップスペース(空間)はどのくらい</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
    古い unix システムでは、RAM の倍ほどの大きさのスワップスペースが推奨されています。
    これはなぜなら RAM のアクティブページは swap 上に配置されていなければならず、
    事実上、 仮想メモリーの合計は、 スワップ空間の大きさによって制限されていたからです。
     NetBSD では、これはもはや正しくなく、仮想メモリー合計は、スワップ + RAM が近似値です。
    <p>
     NetBSD の下では、スワップ空間は3つの基本的な利用目的があって:
    <p>
    <ol>
    <li><strong>仮想メモリーの追加</strong><br>
    変更されたデータを含むアクティブページが少なくなると、
    物理メモリーより大きく準備された仮想メモリーとして
    データがスワップ空間へ移動することができます。

    <p>
    <li><strong>カーネルのコアダンプのための場所</strong><br>
	これは起動時、 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=savecore&amp;sect=8">savecore(8)</a> に読まれます。
	これが機能するためには、プライマリースワップパーティションは
	全 RAM 容量よりわずかでも大きい必要があります。
    <p>
    <li><strong> <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=mfs&amp;sect=8">mfs(8)</a> ファイルシステムのため</strong><br>

	 /tmp を使うあらゆるプログラムの高速化のために、
	古典的に /tmp をマウントすることで、
	 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=fstab&amp;sect=5">fstab(5)</a> ファイルに次のように加えることによって:
	<pre>	swap  /tmp  mfs  rw,-s=<em>SIZE</em> 0 0</pre>
	ここで <em>SIZE</em> は 512byte ブロックのものです。
	この要求されたスペースは、スワップ空間から
	ファイルシステムとして使うために持ってこられます。

    </ol>
    <p>

    スワップの'正しい'値と言うのは、システムの利用法に依存しますが、
    いくつか一般的なルールがあって:
    <ul>
    <li>基本容量として良いのは、 RAM容量か 32MB の大きい方に
        <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=mfs&amp;sect=8">mfs(8)</a> ファイルシステムの全容量を足した量です。
    <li>
         X(1) を実行するつもりなら、 RAM 容量の 1/2 か 16MBの大きい方を加えます。

    <li>いつもスワップ帯域が増加するように、
        可能な限り沢山のディスクをまたがるようスワップを分割してみます。

    <li>少ないよりは多いほうがと思います。- スワップを使い果たすと、
	システムは実行しているプロセスを kill させることができます。

    </ul>

</dd></dl>
<p><h3>
<a name="adding-swap">動作中のシステムにスワップを追加する</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

システムは、
 <a href="#swap">スワップスペースはどのくらい</a>のとおりの
充分なスワップ空間が設定されているべきです。
    <p>
    設定されているシステムにスワップを追加するには3通りの方法があります:
    <p>
    <ol>
    <li><strong>システムディスクを再構築し、
	大きなスワップパーティションを使います。
	</strong><br>
	この方法は、きちんと設定されるまでの間
	これは明らかに重大な困難を伴います。
    <p>
    <li><strong>スワップパーティションを追加します。</strong><br>

	ディスク追加時に、 小さい 'b' パーティションをスワップの追加のために
	含めるのは、大抵良いアイデアで、
	 <tt>/etc/fstab</tt> ファイルに 起動時に自動的に有効になるように
	次の形式のエントリーを追加します
	<pre>	/dev/<em>DISK</em>b       none    swap sw 0 0</pre>
	(ここで、 <tt><em>DISK</em></tt> は 'sd1' や 'wd2' のような ディスクの名前です).
    <p>
    <li><strong>スワップファイルを作ります。</strong><br>
	もっとも早く、簡単な選択は、
	存在するファイルシステムにファイルをつくり、
	追加スワップ空間として使うことです。

	これをアクセスすることは、
	専用のスワップパーティションをアクセスするよりわずかながら
	遅いでしょうが、
	 (フラグメンテーションやファイルシステムオーバーヘッドによる)
	スワップの不足を解決する一時的なものとしてはよいでしょう。

	<p>
	10 MByte のスワップ空間を追加することは、
	充分な空き空間のあるファイルシステムを選ぶだけの簡単なことで:

	<pre>	# <b>dd if=/dev/zero bs=1m count=10 of=/somefilesystem/swap</b>
	# <b>chmod 600 /somefilesystem/swap</b>
	# <b>swapctl -a -p 1 /somefilesystem/swap</b></pre>
	
	 `<a href="http://www.flame.org/cgi-bin/uncgi/hman?page=dd&amp;sect=1">dd(1)</a>' コマンド が creates a 10 MByte の
	`<tt>/somefilesystem/swap</tt>' ファイルをつくります。

	  このスワップファイルは
	 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=chmod&amp;sect=1">chmod(1)</a> 600 をする必要があり、それで、特権のないユーザーが
	その内容を読めなくなります
	(<a href="http://www.flame.org/cgi-bin/uncgi/hman?page=swapctl&amp;sect=8">swapctl(8)</a> は読むことができるファイルの世界を
	拒否します).

	そして、 `<a href="http://www.flame.org/cgi-bin/uncgi/hman?page=swapctl&amp;sect=8">swapctl(8)</a>' コマンドは 
	優先度1 のシステムスワップ領域として
	 <tt>/somefilesystem/swap</tt> に加えます。

	優先度 0 は (デフォルトの) 最も高い優先度で、
	 ファイルへのスワップはその部分についてだけは、
	すべて従来型のスワップを使うよりもわずかに遅いからです。

    </ol>

</dd></dl>
<p><h3>
<a name="moving-usr">/usr をルートからほかのパーティションに移す</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
    <ol>
	<li>

	希望する新しい位置(例えば <tt>/dev/sd0e</tt>)が
	存在する他のどのパーティションとも重ならないことを確かめます。
	   <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=disklabel&amp;sect=8">disklabel(8)</a> の出力をチェックします。
	<li>それにまだファイルシステムがないなら、実行し
	<dl>
	<dd><tt># <b>newfs /dev/sd0e</b></tt></dd>
	</dl>
	<li>それをマウントし、データを向こうへコピーします:
	<dl>
	<dd><tt># <b>mount /dev/sd0e /mnt</b></tt></dd>
	<dd><tt># <b>cd /usr</b></tt></dd>
	<dd><tt># <b>pax -rw -pe . /mnt</b></tt></dd>
	<dd><tt># <b>umount /mnt</b></tt></dd>
	</dl>
	<li>
Edit
 <tt>/etc/fstab</tt> を編集し、
	   '<tt>/dev/sd0e /usr ffs rw 1 2</tt>' を加えます。
 ( <tt>/dev/sd0e</tt> はあなたの状況に 変えて下さい)。
	<li>シングルユーザーモードに shutdown し、
	    新しいマウントポイントをつくります:
	<dl>
	<dd><tt># <b>shutdown now</b></tt></dd>
	<dd><tt># <b>mv /usr /usr.old</b></tt></dd>
	<dd><tt># <b>mkdir /usr</b></tt></dd>
	</dl>
	<li>システムを起動し、テストし、まったく良好なら、
	 '<tt>rm -rf /usr.old</tt>' します。
    </ol>

</dd></dl>
<p><h3>
<a name="rebuilding-dev">/dev の再構築</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

 /dev ディレクトリーには、
ハードウエアと 擬似デバイスをアクセスするために必要な
デバイスファイルが含まれています。
もしそれが、ダメージを受けていれば、
もっと不思議なことが結果として起こるでしょう。<br>


 /dev ディレクトリーを再構築するには、
まずシングルユーザーで起動するべきです。
 (マルチユーザーででもできるかもしれないが、推奨しません), そして:

<blockquote>
<ul>
<li><b>mkdir /newdev</b>
<li><b>cd /newdev</b>
<li><b>cp /dev/M* .</b>
<li><b>sh MAKEDEV all</b>
<li><b>cd /</b>
<li><b>mv dev olddev; mv newdev dev</b>
<li><b>rm -r olddev</b>
</ul>
</blockquote>

</dd></dl>
<p><h3>
<a name="connecting-a-ups">NetBSD システムに UPS をつなぐ</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

UPS をつなぐのは単純なことだけど、
監視して、電源が落ちたときに、
きちんと NetBSD をシャットダウンするには、ちょっとした事が必要で:<br>

Simon J. Gerraty は
<a href="http://www.quick.com.au/sjg/apcmon.html">APC Smart-UPS</a> を使うための
ページを開設しています。

UPS と通信するソフトウエアを書くには、 tcsetattr() 経由で
 softcar フラグを設定する必要があるでしょう。

Wolfgang Rupprecht は、簡単なフィールド調査をしました:
<p>
<blockquote>

UPS インターフェースは異なる2種類の型があって、
ときどき、同じ UPS に両方存在しています。

 UPS についている 9ピンのコネクターには、決して、普通の PC-style RS-232 として配線しないでください。
最善のものは、 3芯で、それを保つようにピンを再配置した RS-232 インターフェースです。

最悪なのは、内部信号端子(??)が RS-232 の 信号電圧 ですらなく、
変わったケーブルを使う必要のあるもので、
そのケーブルは電圧レベル変換装置がついていて、
それによってRS-232 ポートから見えるようになっているものです。

後者の型のインターフェースからの信号は、
1bit(通常/電源断)の信号を送出するだけです。

それは DCD のような モデム制御信号 で処理されるべきで、
プログラム経由でモデム制御信号の状態をチェックして検出するべきです。

  注意しないと、 UPS に付いてきた、モデム制御信号だけのケーブルと
本物の RS-232 ケーブルがごっちゃになってしまいます。
<br><br>

 APC web page を捜しまわったり、
 altavista でいくつか当たった有望なものによると、
 3 つの基本的なインターフェースがあることがわかりました。

  低価格帯の UPS ("back UPS") は
 モデムコントロールライン タイプのインターフェースだけを持っています。

高価格帯の2つ ("Back UPS Pro", "Smart UPS") は
モデムコントロールラインと 3芯 RS-232 信号の両方の組み合わせを持っています。
どちらかのケースでは、
2つのうちのどらちかの種類の特殊ケーブルを使う必要があります。

モデムコントロールラインインターフェースのケーブルには、
レベルシフトのためにトランジスターとダイオードが入っています。
(電源はほかの線のどれかからとってきます)。

それは UGLY という単語がぴったりだと思えるほど
本当にぶざまな解決法で、正しく変更するべきです。(???)

2番目のタイプのケーブルは， UPS とシリアルで会話できるでしょうが、
いくつかの 3-rd party のドキュメントには、 UPS は
ストップビットを2ビットで送信する時だけ喋ると示されています。	

プロトコルに関する公式ドキュメントは無いようで、
また、 back-UPS pro と smart UPS は異なるシリアルラインプロトコルを
喋るようです。

 back-UPS pro ラインだけが いくつかの サードパーティー のサポートがあるようで、
プロトコルの詳細の多くが推測だけのようです。

<br><br>

競合品のどれもが、 (modem コントロール信号 だけ、および、
特殊ケーブルで(知的財産)権利のある シリアル信号プロトコル)を真似しているようです。
  私は、標準規格ついての公開された文書を見つけることができませんでした。
</blockquote>

</dd></dl>
<p><h3>
<a name="non-export-useability">インストールで secr.tgz 配布物を入れずに NetBSD を実行することができますか?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

はい。 security distributions は、
 NetBSD 1.5 以前のバージョンにおいて、 DES 解読コードに加えて、
kerberized 版の telnet のようなユーティリティーが含まれているにすぎないです。


  標準 NetBSD 配布物 は NetBSD システムが動くのに充分な 暗号化をするコードが入っています。

 NetBSD 1.5 から始めると、
暗号化コードのために分離されたアーカイブ 'secr.tgz' はもはやありません。

 secr.tgz 配布物を見つけられず、それなしに走らせることができるのか
単純に不思議に思っただけなら、
1.5 リリース前の NetBSD リリース配布物 tree の 
"&lt;arch&gt;/binary/security" サブディレクトリー
に見つけることができるでしょう。

</dd></dl>
<p><h3>
<a name="why-single-user">シングルユーザーモードってなに、どうして、なんのため?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
'single-user' モードはカーネルがブートした時の状態で、
コンソール上で1つのシェルが動いています。

シングルユーザーで起動すると、ルートファイルシステムだけが
リードオンリーでマウントされます。

多くのユーザーにとって、シングルユーザーモードは:

<ul>
<li>傷んでる疑いのためにファイルシステムに <tt>fsck</tt> をかける
<li> <tt>/etc</tt> にある傷んだシステム設定ファイルを編集する。
<li>ダウンロードあるいは自分でコンパイルした新しいバイナリーセットをインストールする。
<li>ユーザープロセスからの干渉を気にせずにファイルシステムのバックアップをとる
</ul>

動作中のシステムから、 root 権限で 
 '<tt><b>shutdown now</b></tt>' を実行することで、
シングルユーザーモードに入れます。
または、システムの起動中に、
 '-s' フラグを使う(この方法は port ごとによってさまざまです)
ことでもできます。

<p>

シングルユーザーで起動すると、
次のようないくつかの便利なコマンドが見つけます:

<ul>
<li><tt><b>fsck -p ; mount -va</b></tt><br>
 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=fsck&amp;sect=8">fsck(8)</a> でファイルシステムをチェックし、それを <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=mount&amp;sect=8">mount(8)</a> で使える状態にします。
<li><tt><b>set -E</b></tt><br>
    コマンドライン編集を有効にします。
<li><tt><b>TERM=vt220 ; export TERM</b></tt><br>
      '<a href="http://www.flame.org/cgi-bin/uncgi/hman?page=vi&amp;sect=1">vi(1)</a>' のようなエディターが動作できるように、
     TERM 変数を設定し、 export します。
 注意: コンソールタイプによって 'vt220' を別のターミナルタイプにする必要があります。

<li><tt><b>sh /etc/netstart</b></tt><br>
    ネットワークを起動します。
   nfs マウントされたファイルシステムがあるなら、
fsck と mount の前にこうしたくなるはずです。

</ul>

</dd></dl>
<p><h3>
<a name="single-user-to-multi-user">どうやって、シングルユーザーからマルチユーザーに移行するの</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
シングルユーザーシェルを "exit" か ctrl-D で抜けてください。

</dd></dl>
<p><h3>
<a name="read-only-to-read-write">どうやって'リードオンリー'ファイルシステムを読み書きできるようにマウントするの?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=mount&amp;sect=8">mount(8)</a> の <tt>-u</tt> (update) スイッチを使ってください:
 '<b><tt>mount -u /</tt></b>'。

より好ましいことに、シングルユーザーで起動すると、
 root ファイルシステムは、標準でリードオンリーでマウントされます。

これは、マルチユーザーでシステムが起動する前に、
手動で fsck を走らせる機会を与えてくれます。

読み書きできるように、
 <tt>/etc/fstab</tt> の全てのファイルシステムをマウントするもうひとつの方法は
 '<b><tt>mount -a</tt></b>' をつかうことです。

<p>
しかしながら、これをする一番良い方法は、シングルユーザーシェルを抜けて
マルチユーザーモードに入ることです。
これで、 <tt>/etc/fstab</tt> に載せられているモードで
その全てのファイルシステムをマウントします。

</dd></dl>
<p><h3>
<a name="using-fsck">いつ fsck を使うのが安全なの?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=fsck&amp;sect=8">fsck(8)</a> は、アンマウントされているか、
リードオンリーのファイルシステムにだけ
使うようにしてください。

読み書きできるファイルシステムに
 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=fsck&amp;sect=8">fsck(8)</a> をかけることは危険で、ファイルシステムをより悪くしてしまうかもしれません。
シングルユーザーモードでシステムを起動すれば、リードオンリーでマウントされます。

そこで '<b><tt>fsck -p</tt></b>' とすることで、
システムがマルチユーザーモードで起動する前に、
全てのファイルシステムをチェックすることができます。

もし、ファイルシステムに既に "clean," とマークされているけど、
それでもまだチェックしたいなら、
 <tt><a href="http://www.flame.org/cgi-bin/uncgi/hman?page=fsck&amp;sect=8">fsck(8)</a></tt> に <tt>-f</tt> フラグ を使うことができます。
<p>

fsck を使って、ファイルシステムがなにかの変更がされたら
たぶん、ディスクを同期せずに機械をすぐリブートするために
 '<b><tt>reboot -n</tt></b>'
と打つのが、一番良いことでしょう。

</dd></dl>
<p><h3>
<a name="boot-messages">ブートメッセージはどうやって読むの?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

システムメッセージバッファーは <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=dmesg&amp;sect=8">dmesg(8)</a>で表示できます。
これは(1.4 以降では)いつも起動後ごとにすぐに
 /var/run/dmesg.boot に自動的に貯められます。
カーネルインストールで kernfs ( <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=mount_kernfs&amp;sect=8">mount_kernfs(8)</a> を見よ) 
が有効になっているなら、
 <tt><b>more /kern/msgbuf</b></tt> もしてください。

</dd></dl>
<p><h3>
<a name="shutting-down">どうやって機械をシャットダウンするの?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

シングルユーザーモードに落ちるなら、
 '<b><tt>shutdown now</tt></b>' を使ってください。

機械を停止するのなら
 '<b><tt>shutdown -h now</tt></b>' を使ってください。

いくつかの port では、実際に電源を落とすなら
 '<b><tt>shutdown -p now</tt></b>' を使う必要があります。
完全な詳しいことは <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=shutdown&amp;sect=8">shutdown(8)</a> マニュアルページを見てください。

</dd></dl>
<p><h3>
<a name="rebooting">どうやって、機械をリブートするの?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
'<b><tt>shutdown -r now</tt></b>' か '<b><tt>reboot</tt></b>' を使ってください。
  より細かいことは<a href="http://www.flame.org/cgi-bin/uncgi/hman?page=shutdown&amp;sect=8">shutdown(8)</a> や <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=reboot&amp;sect=8">reboot(8)</a> マニュアルページを見てください。

</dd></dl>
<p><h3>
<a name="kernfs"><tt>/kern</tt> は何に使われているの?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
それは、 kernfs ファイルシステムのマウントに使われています。
 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=mount_kernfs&amp;sect=8">mount_kernfs(8)</a> マニュアルページを見てください。

</dd></dl>
<p><h3>
<a name="procfs"><tt>/proc</tt> は何に使われているの?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

それは、 procfs ファイルシステムのマウントに使われています。

 <i>The Design and Implementation of the 4.3BSD UNIX Operating System</i>
 by Leffler,McKusick, et al., p. 104-5, 436. を調べてください。
 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=mount_procfs&amp;sect=8">mount_procfs(8)</a>  マニュアルページも見てください。
<p>

これは、普通 root で '/proc' ディレクトリを使うのに使われ、
 /etc/fstab ( <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=fstab&amp;sect=5">fstab(5)</a> を見よ) に次のように加えられています:<br>
<tt>/proc /proc procfs rw 0 0</tt>

</dd></dl>
<p><h3>
<a name="changing-motd"><tt>/etc/motd</tt> を何らかの変更をしてももとの内容に戻ってしまいます</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

ヘッダーを消すと、起動時にスタートアッププロセスがあなたのした変更を上書きします。

これは、 <tt>/etc/rc.conf</tt> 内で <tt>update_motd=NO</tt> と
設定することで無効にすることができ、
これで、<tt>/etc/motd</tt> にはまったく手が加わらなくなり、
あなたが、変更することができるようになります。

</dd></dl>
<p><h3>
<a name="selling-hardware">どこへ NetBSD 関連のハードウエアを売ればいいの?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

補助アイテムのために、一般的に、
その port の <a href="../../MailingLists/">メーリングリスト</a> と、
 <a href="mailto:netbsd-forsale@mono.org">netbsd-forsale@mono.org</a> 
に投稿することができます。
<br>

NetBSD の開発を支援するために何らかのハードウエアを寄付したいのなら、
 <a href="../../contrib/hardware.html">ハードウエア寄付ページ</a> をチェックするか、
 <a href="mailto:core@netbsd.org">core@netbsd.org</a> に連絡してください。

</dd></dl>
<p><h3>
<a name="create-mpeg3">オーディオ CD からMP3 (MPEG layer 3) ファイルを作る</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

<i><b>どうか注意:</b> これらの方法は <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/audio/cdd/README.html">cdd</a> パッケージ だけで確認をしていて、
 <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/audio/tosha/README.html">tosha</a> や <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/audio/cdparanoia/README.html">cdparanoia</a> パッケージでは確認していません。
</i>


 <p> オーディオ CD から MPEG layer 3 (<tt>MP3</tt>) ファイルを作る
 基本的な 段階step は
 ( <a href="../software/packages.html">NetBSD パッケージコレクション </a> のソフトウエアを使って)
こうやって:
<p>
<ol>
<li> CDから オーディオデータを 抽出 (<i>rip</i>) します。
    <p>
    <ul>
    <li>ATAPI や SCSI の CD-ROM のドライブで <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/audio/cdd/README.html">cdd</a> パッケージが使えます。
    cdd でトラック2を抽出するには、打つ:
    <p>
    <dl><dd><tt><b>cdd -t 2 `pwd`</b></tt></dd></dl>
    <p>
    これで、カレントディレクトリに <tt>track-02.cda</tt> というファイルができます。
    <p>
    <li>SCSI CD-ROM ドライブでは <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/audio/tosha/README.html">tosha</a> package が使えます。
    トラック2 を tosha で抽出するには、このように打つとでき:
    <p>
    <dl><dd><tt><b>tosha -d <i>CD-ROM-device</i> -t 2
	-o track-02.cda</b></tt></dd></dl>
    <p>
    <li>

ほとんどの ATAPI、 SCSI 、いくつかの独自仕様の CDROM ドライブで、
    <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/audio/cdparanoia/README.html">cdparanoia</a> パッケージが使えます。


 cdparanoia を使うことで、データを WAV, AIFF, AIFF-C あるいは raw(生) フォーマットで
ファイルにセーブするか、あるいは、直接標準出力に出力することができます。
    現在 NetBSD版の cdparanoia には -g オプションが必要です。

仮の例で、
トラック2 を WAV ファイルとしてセーブするには次のように:
    <p>
    <dl><dd><tt><b>cdparanoia -g /dev/rcd0d 2 track-02.wav</b></tt></dd></dl>
    <p>
    これで、次は ステップ 3 に直接行って、 WAV ファイルを MP3 にエンコードできます。

<br>
    </ul>
<p>
<li> CD オーディオフォーマットを WAV フォーマットに変換します。
    <p>
    <ul>
    <li>
 <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/audio/sox/README.html">sox</a> package をつかって、(次のように)打ちます:
    <p>
    <dl><dd><tt><b>sox -s -w -c 2 -r 44100 -t cdr track-02.cda
	track-02.wav</b></tt></dd></dl>
    <p>

    これで raw CD フォーマット <tt>track-02.cda</tt> が
    符合あり( <b>s</b>igned) 16-bit 語長(<b>w</b>ords)、
     2 チャンネル(<b>c</b>hannels)、
    サンプリングレート(sampling <b>r</b>ate) 44100kHz の 
     WAV フォーマット <tt>track-02.wav</tt>
    に変換されるでしょう。

    </ul>
<p>
<li> WAV ファイルを MP3 フォーマットにエンコードします。
    <p>
    <ul>
    <li> <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/audio/bladeenc/README.html">bladeenc</a> パッケージを使って、打ちます:
    <p>
    <dl><dd><tt><b>bladeenc -128 -QUIT track-02.wav</b></tt></dd></dl>
    <p>

    これで、 <tt>track-02.wav</tt> は
    ビットレート <b>128</b>kBit/sec の MP3 フォーマットで、
     <tt>track-02.mp3</tt> にエンコードされるでしょう。

 bladeenc のドキュメンテーションが ビットレートのより詳しいことを記述しています。
    <p>
    <li> <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/audio/lame/README.html">lame</a> パッケージをつかって、打ちます:
    <p>
    <dl><dd><tt><b>lame -p -o -v -V 5 -h track-02.wav
	track-02.mp3</b></tt></dd></dl>
    <p>
    あなたの好みやハードウエアによって、
    もっと低い品質で使いたいかもしれません。
    </ul>
</ol>
<p>
できあがった MP3 ファイルは、
<a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/audio/maplay/README.html">maplay</a>, <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/audio/mpg123/README.html">mpg123</a>, や <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/audio/splay/README.html">splay</a> パッケージの
いずれでも再生できます。

</dd></dl>
<p><h3>
<a name="cron-reboot">起動時にプログラムを開始する</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

( NetBSD で使っている) Vixie <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=cron&amp;sect=8">cron(8)</a> の
 特別な <strong>@reboot</strong> 時 仕様は、
 <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=cron&amp;sect=8">cron(8)</a> 起動時 に与えられたプログラムを開始することが可能でした。
それはたいてい、システム起動時と一致します。

これは root 特権 の無いユーザーに、
起動時にコマンドを自動的に実行させることを許しているということです。

</dd></dl>
<p><h3>
<a name="setup-ccd">ccd ドライブを設定する</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
<ol>
<li>全てのディスクに disklabel をつけます:<br>

結合したいパーティションをつくり、
開始オフセットを 確かめます
( 16 セクターでまったく充分 - 確信しているわけじゃないけど)。

この種の問題が起こっても、私にはわかりません。
"普通の" 4.2BSD パーティション を使っているので。

<li> ccd を設定します。<br>

性能チューニングで、
最も良いインターリーブを見つけるために少し試してみる必要があるでしょう。
私の場合、2つのディスクで 48 が良く動作します。

私が知る限り、16 かいくつかのほかの数字では、
全ての inode が同じディスク上に存在してしまうので、
パフォーマンス向上にはならないでしょう。

 IIRC 
コンポーネントのセクター数をインターリーブの倍数にしないと、
いくつかの問題がありました。

<li>普通のハードディスクと同様に ccd に disklabel を書きます。
<li>ccd を newfs します。
<li>それをマウントします。
</ol>
<p>

より詳しい情報は <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=ccd&amp;sect=4">ccd(4)</a> と <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=ccdconfig&amp;sect=8">ccdconfig(8)</a> のマニュアルページを見てください.

</dd></dl>
<hr>

<table width="100%"><tr><td>
  <table><tr><td>
    <a href="../../"><img
	src="/images/NetBSD-flag.gif" border="0"
	width="91" height="42" alt=""></a>
  </td><td>
    <a href="../../"><img
	src="/images/empty.gif" border="0"
	width="1" height="1" alt="NetBSD ">ホームページ</a>
  </td></tr></table>
</td><td>
  <table><tr><td>
    <a href="../../Documentation/"><img
	src="/images/NetBSD-flag.gif" border="0"
	width="91" height="42" alt=""></a>
  </td><td>
    <a href="../../Documentation/"><img
	src="/images/empty.gif" border="0"
	width="1" height="1" alt="NetBSD ">Documentation top level</a>
  </td></tr></table>
</td></tr></table>

<hr>
<address>
  <small>
  <a href="../../Misc/feedback.html">(Contact us)</a>
  $NetBSD: index.html,v 1.4 2001/04/02 16:06:50 kano Exp $<br>
  <a href="../../Misc/disclaimer.html">Copyright &copy;
    1996, 1998, 1999, 2000
    The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED.</a>
  </small>
</address>

</body>
</html>
