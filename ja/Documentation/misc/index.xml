<?xml version="1.0" encoding="ISO-2022-JP"?>
<!DOCTYPE webpage
  PUBLIC "-//Norman Walsh//DTD Website V2.2//EN"
    "http://docbook.sourceforge.net/release/website/2.2/website.dtd" [

<!ENTITY % man-refs.ent SYSTEM "../../../share/xml/man-refs.ent"> %man-refs.ent;

]>

<webpage id="ja-faqs-howtos">
<config param="desc" value="NetBSD ドキュメンテーション: 他の FAQ と HOWTO"/>
<config param="cvstag" value="$NetBSD: index.xml,v 1.3 2005/02/06 14:29:58 hubertf Exp $"/>
<!-- Based on english version: -->
<!-- NetBSD: index.xml,v 1.3 2005/02/06 14:29:58 hubertf Exp   -->
<config param="rcsdate" value="$Date: 2005/02/06 14:29:58 $"/>
<head>
<!-- Copyright (c) 2005
	The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED. -->
<title>NetBSD ドキュメンテーション: 他の FAQ と HOWTO</title>
</head>

<sect1 id="top">
</sect1>

<sect1 role="toc">

<sect2 id="general">
<title>NetBSD に関する一般的な疑問</title>

<sect3 id="release-changes">
<title>NetBSD リリース間で何が変わったの?</title>
<para>
全ての変更の最新の一覧 ( NetBSD-current での物も含まれています)
が<ulink url="../../Changes/">あります</ulink>。
</para>
<para>これは、各リリースの最上位ディレクトリーの
<code>CHANGES</code> ファイルにもあり、また、
<ulink url="http://cvsweb.NetBSD.org/bsdweb.cgi/~checkout~/src/doc/CHANGES.prev?content-type=text/plain">前回</ulink>
および
<ulink url="http://cvsweb.NetBSD.org/bsdweb.cgi/~checkout~/src/doc/CHANGES?content-type=text/plain">次回</ulink>
のリリースのものがオンラインで保守されています。

</para>
</sect3>

<sect3 id="64-bit">
<title>NetBSD は 64 bit オペレーティングシステム?</title>
<para>

NetBSD は 32 bit と 64 bit CPU のどちらでも動いています。
<ulink url="../../Ports/alpha/">alpha</ulink> CPU では、
カーネルとユーザーランドは LP64 として知られているモードで走り、
それは、 <emphasis role="bold">int</emphasis> が 32 bit で <emphasis role="bold">long</emphasis> と
ポインター (とアドレス空間) が 64 bit です。
<ulink url="../../Ports/amd64/">amd64</ulink> および
<ulink url="../../Ports/sparc64/">sparc64</ulink> ポートは 32 ビットと 64 ビット
いずれの設定でも動作します。 64 ビットカーネル (LP64) は、 64 ビットモード
において 32 ビットのアプリケーションをサポートします。
32 ビットカーネルは整数、ポインター、 long 整数すべてに 32 ビットを使い、
64 ビットプログラムは動作しません。
</para>
<para>

R4000 とそれ以降の MIPS といった、ほかの 64bit capable CPU (<ulink
url="../../Ports/#in-tree-ports">いくつかのポートで使われています</ulink>)
では、 NetBSD は 32 bit モードで走りますが、 64 bit に変更中です。
</para>
<para>

全ての NetBSD ポートは
カーネルとユーザーランドプログラムで 64 bit 演算に対応しています。
カーネル内では、それはさまざまなカウンターと、
FFS 、64 bit 'Fast File System' に使われています。
</para>
</sect3>

<sect3 id="exportability">
<title>NetBSD は米国から輸出できる?</title>
<para>
NetBSD 1.4.x まで(とそれを含む)では、
security 配布物 (すなわち secr.tgz) 以外の全ては
米国から輸出できます。
secr.tgz 配布物ファイルには、暗号のためのライブラリーが含まれています。
NetBSD 1.5 からは、 暗号化コードは
NetBSD の base 配布物に含まれています。
<ulink url="../../Misc/crypto-export.html">
輸出制限されたコードとバイナリーに関する NetBSD ドキュメントを参照してください </ulink>。
</para>
</sect3>

<sect3 id="netbsd-uses">
<title>何のために NetBSD を使うの?</title>
<para>
Chris G. Demetriou (cgd@NetBSD.org) の言葉では:
<blockquote><quote>
NetBSD は、一般的に、  "安定した研究プラットフォーム" を意味します  -- 
それは、商用、家庭、研究作業……に使えるシステムであり、
何に使うかは、あなた次第です。一般的に、 私たちが NetBSD でしている仕事は、
私たちに可能なあらゆる方法による、システムを改善する試みです -- 
より多くのハードウェアのサポート、より高い安定性、より良い性能、より多くの文書化……
</quote></blockquote>

我々の
<ulink url="../../Misc/features.html">特色のページ</ulink> を
NetBSD があなたに与える機会(能力)のアイデアとして見てください!
</para>
</sect3>
</sect2>

<sect2 id="user-configuration">
<title>ユーザー設定</title>

<sect3 id="adding-a-user">
<title>ユーザーの追加</title>
<para>
最近の NetBSD リリースでは &man.useradd.8; コマンドを使ってユーザーを追加できます。
古いリリースでは、 <pkg>sysutils/user</pkg> パッケージをインストールして
同等のことができるようになります。 <code>/etc/passwd</code>
を編集してもユーザーは追加できません。パスワードデータベースを編集したい場合は
&man.vipw.8; を使ってください。さらなる情報は、 &man.pwd.mkdb.8; も参照してください。
</para>
</sect3>

<sect3 id="gecos-field">
<title><code>finger</code> によって表示される情報の変更は?</title>
<para>
&man.chfn.1; および &man.chsh.1; コマンドを使うか、または、
vipw(8) を使って <code>/etc/master.passwd</code> を編集してください。
</para>
</sect3>

<sect3 id="problems-with-root">
<title>root としてログインあるいは 'su' する時の問題</title>
<para>
以下のような、いくつもの場合がありえます:
</para>
<para>
<itemizedlist>
    <listitem><emphasis role="bold">root として直接ログインできません</emphasis><html:br/>
	NetBSD は <code>/etc/ttys</code> 中に 'secure' が書かれている端末からのみ、
	root として直接ログインすることを許します ( &man.ttys.5; を見よ)。
	ネットワークをまたいで直接ログインできるようにする( 推奨され <emphasis role="bold">ない</emphasis> )には、
	'<code>secure</code>' を各ネットワーク端末行の最後に加える必要があります。
	こうするためには、 root になって
	以下のようにすればよく、各行をいちいち編集する必要はありません。
	<programlisting>
		cd /etc
		cp ttys ttys.orig
		cat ttys.orig | sed 's/network$/network secure/' &gt; ttys</programlisting>
    </listitem>
    <listitem><emphasis role="bold">root に 'su' できません</emphasis><html:br/>
	NetBSD は誰かが root に &man.su.1; しようとすると、
	<code>/etc/group</code> の 'wheel' グループに誰が入っているかチェックします。
	もしこのグループが空 (wheel:*:0:) なら誰もが正しいパスワードで root に su できます。
	グループが空でない場合は、root になることが許可されたアカウントを、
        コンマで区切って (スペースを入れてはいけません) 並べておきます。</listitem>
    <listitem><emphasis role="bold">誰にも 'su' できません</emphasis>
        <para>"<emphasis role="bold"><code>ls -l /usr/bin/su</code></emphasis>" と入力してください。
	出力の最初の 'word' は '-r-sr-xr-x' であるべきです。
        もし、それがなにか違う ('-r-xr-xr-x' みたいに) なら
	(root になって)  "<emphasis role="bold"><code>chmod 4555 /usr/bin/su</code></emphasis>"
	と入力してください。
	その位置の 's' は 'setuid' バイナリーを示していて、この場合、
	'su' が root 特権で走ることを認めています。
	</para>
	<para>
	この問題は、配布物を展開した時に tar に '-p' (パーミッション保護) フラグが
	与えられていなかったことによるものです。この場合、
	ほかのさまざまなユーティリティーもまた壊れているでしょうから、
	全ての tar ファイル ( etc.tar.gz 以外)を再展開してください。
        </para>
    </listitem>
</itemizedlist>
</para>
</sect3>

<sect3 id="adding-to-path">
<title> あなたのパスに何かを加える</title>
<para>
例えば、あなたのパスに /usr/X11R6/bin を加えるなら、
ホームディレクトリーの <emphasis>.login</emphasis> ファイルを編集し
次のように加えます:
<programlisting>set path = ( /usr/X11R6/bin $path )</programlisting>
</para>
<para>
これは C-shell &man.csh.1; と、その派生物の
<emphasis><pkg>shells/tcsh</pkg></emphasis> のようなものでのみ、働きます。
&man.sh.1; と派生物( <pkg>shells/bash2</pkg> のような)では
正しい文法は:
<programlisting>
PATH=/usr/X11R6/bin:$PATH
export PATH</programlisting>
</para>
</sect3>

<sect3 id="setting-something-for-all-users">
<title>全ユーザーのためになにか設定する</title>
<para>
次に示すファイルのいずれか一つに書き加えると、
&man.csh.1; や <pkg>shells/tcsh</pkg> を走らせている全ユーザー向けの設定をすることができます。
<itemizedlist>
<listitem><emphasis role="bold"><code>/etc/csh.cshrc</code></emphasis><html:br/>
    これは、新しいシェルが開かれるごとに、
    ユーザーのホームディレクトリーにある、いかなる <emphasis role="bold"><code>.cshrc</code></emphasis> よりも先に実行されます。</listitem>
<listitem><emphasis role="bold"><code>/etc/csh.login</code></emphasis><html:br/>
    これは、ユーザーがログインする時、
    <emphasis role="bold"><code>/etc/csh.cshrc</code></emphasis> よりも後だけど、ユーザーのホームディレクトリーにあるいかなる <emphasis role="bold"><code>.login</code></emphasis>
    よりも先に実行されます。</listitem>
<listitem><emphasis role="bold"><code>/etc/csh.logout</code></emphasis><html:br/>
    これは、ユーザーがログアウトする時、ユーザーのホームディレクトリーにあるいかなる <emphasis role="bold"><code>.logout</code></emphasis>
    よりも先に実行されます。</listitem>
</itemizedlist>
</para>
</sect3>

<sect3 id="shells">
<title>シェルでのカーソルキー編集またはファイルネーム補完</title>
<para>
これは、使っているシェルの種類によります。
<itemizedlist>
<listitem>&man.sh.1; (Bourne シェル)<html:br/>
	これは、シングルユーザーモードで使われるシェルで、
	'<code>set -E</code>' コマンドで、コマンドライン編集を有効にできます。
	シングルユーザーモードでいつもコマンドライン編集ができるように、
	<code>/.profile</code> にこれを加えることができます。
</listitem>
<listitem>&man.csh.1; ('C' シェル)<html:br/>
	これは標準のユーザーシェルで、ファイルネーム補完をサポートしています 
	('<emphasis role="bold">set filec</emphasis>' してから、 ESCAPE キーを使って) が、
	コマンドライン編集はサポートしていません。
	けれども、 <ulink url="../software/packages.html">NetBSD パッケージコレクション</ulink> 
	からファイルネーム補完とコマンドライン編集が標準で有効になっている
	<pkg>shells/tcsh,</pkg> や <pkg>shells/bash2</pkg> をインストールすることができます。</listitem>
<listitem>&man.ksh.1; (Korn Shell)<html:br/>
	これはパブリックドメイン版の Korn Shell 、別名 pdksh です。
	Emacs モードまたは Vi モードのコマンドライン編集に対応しています
	('set -o {emacs,vi}' で設定します) 。 Emacs モードで
	ファイル名を補完するにはエスケープキー 2 回
	('bind "^I"=complete' コマンドで TAB キーにかえられます) を使います。
	Vi モードで TAB や ESC でのファイル名補完をするには、それぞれ、
	'set -o vi-tabcomplete' や 'set -o vi-esccomplete' を使います。<html:br/>
	このパブリックドメイン版 korn shell は NetBSD のベースシステムに含まれていますが、
	他のオペレーティングシステム用として
	<ulink url="../software/packages.html">NetBSD パッケージコレクション</ulink>の
	shells/<pkg>shells/pdksh</pkg> からも利用可能です。また、 KSH-93 も
	shells/<pkg>shells/ast-ksh</pkg> から利用可能です。</listitem>
<listitem><emphasis role="bold">bash (GNU Bourne Again Shell)</emphasis><html:br/>
	'bash' はもうひとつの、コマンドライン編集拡張されているシェルで、
	これは 'sh' が基になっています。
	<ulink url="../software/packages.html">NetBSD パッケージコレクション</ulink>
	中の shells/<pkg>shells/bash2</pkg> からインストールすることができます。</listitem>
<listitem><emphasis role="bold">tcsh (拡張された 'C' シェルの一つ)</emphasis><html:br/>
	'tcsh' はほぼ完璧な csh のスーパーセット(拡張物)で
	ファイルネーム補完(TAB を使います)と
	コマンドライン編集を含む沢山の便利な特別な機能があります。
	 <ulink url="../software/packages.html">NetBSD パッケージコレクション</ulink> 
	中の shells/<pkg>shells/tcsh</pkg> からインストールすることができます。</listitem>
<listitem><emphasis role="bold">ほかの shell たち</emphasis><html:br/>
	<ulink url="../software/packages.html">NetBSD パッケージコレクション</ulink> 
	の <pkg>shells</pkg> カテゴリーの下には、
	さまざまな他のコマンドラインシェルが含まれています。</listitem>
</itemizedlist>
</para>
</sect3>

<sect3 id="languages">
<title>メッセージ言語の指定</title>
<para>
NetBSD は、エラーメッセージやそのようなものに用いる言語を
決めるのに
'<code>LANG</code>' 環境変数を使います。
csh や tcsh では
'<code>setenv LANG <emphasis role="bold">XX</emphasis></code>' コマンドで設定でき、
ここで、 XX は2文字の国コードです。
サポートされているコードタイプの一覧は
'<code> /usr/share/nls</code>' にあります。
</para>
<para>
<emphasis role="bold">どうか注意</emphasis>:確実に翻訳されているものだけにしてください。
確認するには、 <code>LANG</code> 変数をセットし、
<programlisting>
  cd /a_directory_that_does_not_exist</programlisting>
と打ってください。
</para>
</sect3>

</sect2>

<sect2 id="printing-scanning">
<title>印刷とスキャン</title>

<sect3 id="postscript-manpages">
<title>PostScript でマニュアルページを印刷する</title>
<para>
   マニュアルページは、
    &man.nroff.1; ソースとして /usr/share/man/man<emphasis>X</emphasis>/<emphasis>manpage</emphasis>.<emphasis>X</emphasis> 
    にあります。ここで <emphasis>X</emphasis> はセクション番号です (例: nroff の場合は 1 )。
    それを PostScript に変換するにはこれが使えて:
    <programlisting>groff -Tps -mandoc /usr/share/man/man<emphasis>X</emphasis>/<emphasis>manpage</emphasis>.<emphasis>X</emphasis></programlisting>
    たとえば、 &man.ls.1; マニュアルページ を PostScript に変換し、
    &man.lpr.1; を通して直接デフォルトのプリンターに送るには、以下のコマンドを使うことができます。
    <programlisting>groff -Tps -mandoc /usr/share/man/man1/ls.1 |lpr</programlisting>
    ほかのタイプのプリンターで印刷したいなら、
    pkgsrc の <pkg>print/ghostscript</pkg> パッケージを使うとよいでしょう。
</para>
</sect3>

<sect3 id="smbprint">
  <title>NetBSD からリモート SMB プリンターへの印刷</title>
<para>
詳細は<ulink url="smbprint/">このページ</ulink>をご覧ください。
</para>
</sect3>

<sect3 id="jetdirect">
<title>DHCP 経由の HP JetDirect Card 設定</title>
<para>
JetDirect EX Plus のような、 JetDirect プリントサーバーを持っていれば、
プリントサーバーを設定するために、 NetBSD のもとで dhcpd(8) を使うことができます。 このステップは:

JetDirect サーバーのために <code>/etc/dhcpd.conf</code> にエントリーを作ります。
<programlisting>
options jd-tftp-cfg		code 144 = string;
options jd-tftp-server		code 150 = string;

allow				bootp;

# [...]

host hp690c {
	fixed-address		hp690c;			# set to the DNS name or address of the JetDirect
	hardware ethernet	00:60:b0:00:11:22;	# set to the MAC address of the JetDirect
	option	log-servers	servername;		# set to the DNS name or address of log server
	option	jd-tftp-server	servername;		# set to the DNS name or address of tftp server
	option	jd-tftp-cfg	"hpnp/hp690c.cfg";	# name of the JetDirect config file
}</programlisting>
このファイルの書き方について、より詳しい情報は &man.dhcpd.conf.5; を見てください。
</para>
<para>
<code>/etc/inetd.conf</code> 内で、 <code>tftpd</code> が有効になっていることを確かめてください。
注意として、
 "-s" 引数を <code>/etc/inetd.conf</code> の <code>tftp</code> の行につけるようにしてください。
この引数は、 &man.tftpd.8; のルートディレクトリーを設定するものです。
以下、この例においては、
&man.tftpd.8; のルートディレクトリーを <code>/tftpboot</code> に設定していると仮定します。
</para>
<para>
<code>/etc/rc.conf</code> 内で、 <code>dhcpd</code> が有効になっていることを確かめてください。
</para>
<para>

次に Network Printer Interface (NPI) 設定ファイルをつくります。
この例では、ファイルは <code>/tftpboot/hpnp/hp690c.cfg</code> で、
このファイルは次のようになっているべきです:
<programlisting>
name: printer name
location: Location of the Printer 
contact: Contact Person 
idle-timeout: 1800
banner: 0</programlisting>

<code>/etc/inetd.conf</code> に変更を加えた場合は、
かならず <code>kill -HUP `cat /var/run/inetd.pid`</code> して、
&man.inetd.8; に &man.inetd.conf.5; を再読込みさせてください。
JetDirect プリントサーバー (または HP JetDirect カードのついたプリンター)
をリブートすると、サーバーは DHCP で設定を読みこみます。
いくつかのプリンターでは、フロントパネル(の操作)で BOOTP/DHCP の設定を
明示的に有効にする必要があるかもしれません。
</para>
</sect3>

<sect3 id="burstpage">
<title>なぜ <emphasis>sh</emphasis> は、 HP JetDirect の「バースト」ページを抑制しないのですか?</title>
<para>
この「バースト」ページは、プリンターとローカル接続されているホスト、特にこのケースでは
&man.lpd.8; をエミュレートする専用ハードウェアの機能です。 NetBSD がリモートスプーラーとして
<emphasis>rm</emphasis> とともに使われる場合は、バーストページを追加することはありません。
この JetDirect の「バースト」ページは、専用デバイスの非標準な機能です。
<ulink url="http://h20015.www2.hp.com/en/document.jhtml?lc=en&amp;docName=bpj02755&amp;prodId=jd2337a">HP (TM)
ではこのページを実際には "trailer" と呼んでいます</ulink>。
この機能は、 <code>banner: 0</code> を設定するか、または、デバイスの 23 番ポートに単純に
telnet して <code>banner 0</code> コマンドを実行してから <code>quit</code> することで、
止めることができます。
</para>
<para>
JetDirect の個体によっては、この <code>banner</code> コマンドを追加するために、
ファームウェアをアップグレードする必要があるかもしれません。
ファームウェアをアップグレードするには、 HP による JetDirect
ネットワーク管理ツールを適切に使う必要があります
このアップグレードを行うために、 SNMP read and write community strings
を、既知の価に設定する必要があるかもしれません。
この設定をするには、以下の内容を NPI 設定に使います。
<programlisting>
get-community-name: read-password
set-community-name: write-password</programlisting>
(DHCP を使った JetDirect カードの設定については、前の項目を参照してください。)
なお、 (TFTP 経由で) 公開される設定ファイルにこれらの項目を置くことによる
セキュリティー上の影響を認識するようにしてください。

</para>
</sect3>

<sect3 id="scanning">
<title>NetBSD でスキャナーを使う</title>
<para>
NetBSD は、 <pkg>graphics/sane-backends</pkg>スキャニングパッケージを用いて、
さまざまな SCSI スキャナーをサポートしています。この API にアクセスするための
フロントエンドは <pkg>graphics/sane-frontends</pkg> パッケージで提供されており、
また、 <pkg>graphics/gimp</pkg> のようなグラフィックツールから直接呼び出すことができます。
</para>
<para>
注意: 
1.4.2 より前のバージョンの NetBSD では、
カーネル内の &man.ss.4; スキャナードライバーは
<pkg>graphics/sane-backends</pkg> といくつかのスキャナーで
問題を起こすかもしれません。
 - その解決法は、カーネルを &man.ss.4; デバイスを使わずに &man.uk.4; を使うように再コンパイルするか、
 1.4.2 以降にアップグレードすることのどちらかです。
</para>
</sect3>
</sect2>

<sect2 id="removable-media">
<title>リムーバブルメディアを使う</title>

<sect3 id="using-floppies">
<title>フロッピーディスクを初期化して使用する</title>
<para>
PC-style フロッピーディスクは最初に low-level フォーマット(物理フォーマット)
をしなければならないことを除いて、大抵ハードディスクのような
他のディスクデバイスと同じように動作します。
</para>
<para>
1番目のフロッピードライブで 一般的な 1440 KB フロッピーとして使うには、
最初に(root になって)フォーマットし:
<programlisting>
fdformat -f /dev/rfd0a</programlisting>
それから、 &man.disklabel.8; を使ってディスクに1つのパーティションをつくります:
<programlisting>
disklabel -rw /dev/rfd0a floppy3</programlisting>
空間に最適化された小さいファイルシステムを作ります:
<programlisting>
newfs -m 0 -o space -i 16384 -c 80 /dev/rfd0a</programlisting>
これで、フロッピーディスクは他のディスクのようにマウントすることができます。<html:br/>
または、既に MS-DOS ファイルシステムになっているフロッピーディスクを
持っていて、単に NetBSD からアクセスしたいだけなら、単にこのようにするだけで:
<programlisting>
mount -t msdos /dev/fd0a /mnt</programlisting>
</para>
<para>
しかしながら、フロッピーを標準(より大きい)ディスクとして使うのは、
ファイルシステム間をバイパスするのに便利だからで、
直接 raw device にファイルのアーカイブを置く( splat )なら、たとえば:
<programlisting>
tar cvfz /dev/rfd0a file1 file2 ...</programlisting>
このバリエーションとして、
 <pkg>sysutils/mtools</pkg> パッケージを使って
 MS-DOS フロッピーを扱うことができ、
カーネルバッファーキャッシュを通さないという利益があって、
ファイルシステムがマウントされている最中に
フロッピーを取り出す危険にさらさずにすみます。
</para>
</sect3>

<sect3 id="using-zips">
<title>ZIP ディスクの使い方</title>
<para>
<orderedlist>
<listitem> システムが ZIP ドライブを持っているか見てみます:
<programlisting>
yui# dmesg | grep -i zip
sd0 at atapibus0 drive 1: &lt;IOMEGA  ZIP 100       ATAPI, , 14.A&gt; type 0 direct removable</programlisting>
   一つあるのが見え、 単に他の SCSI ディスクと同じような sd0 として記録されています。
   この ZIP ドライブは ATAPI ですが、そのことは問題ではありません
                - SCSI の ZIP もここに現われます。
   ZIP は "removable" と記されていて、
   これは、 "<code>eject sd0</code>" で取り出すことができるという意味です。</listitem>
<listitem> ZIP ディスクを挿入します</listitem>
<listitem> ZIP 内のパーティションを眺めます:
<programlisting>
yui# disklabel sd0
# /dev/rsd0d:
type: ATAPI
 ...
8 partitions:
#        size   offset     fstype   [fsize bsize   cpg]
  d:   196608        0     unused        0     0         # (Cyl.    0 - 95)
  h:   196576       32      MSDOS                        # (Cyl.    0*- 95)
disklabel: boot block size 0
disklabel: super block size 0</programlisting>
   <variablelist>
   <varlistentry><term>d</term>
    <listitem> はディスク全体です。 i386 ではたいてい。</listitem>
   </varlistentry>
   <varlistentry><term>h</term>
<listitem> があなたの望んでいるもので、 msdos ファイルシステムとして見えます。
</listitem>
   </varlistentry>
   </variablelist>
   それゆえ、 zip 上のパーティションをアクセスするには、 /dev/sd0h をつかいます。</listitem>
<listitem> それをマウントします:
<programlisting>
yui# mount -t msdos /dev/sd0h /mnt
yui# </programlisting>
</listitem>
<listitem> ファイルにアクセスします:
<programlisting>
yui# ls -la /mnt
total 40809
drwxr-xr-x   1 root  wheel     16384 Dec 31  1979 .
drwxr-xr-x  28 root  wheel      1024 Aug  2 22:06 ..
-rwxr-xr-x   1 root  wheel   1474560 Feb 23  1999 boot1.fs
-rwxr-xr-x   1 root  wheel   1474560 Feb 23  1999 boot2.fs
-rwxr-xr-x   1 root  wheel    548864 Feb 23  1999 boot3.fs
-rwxr-xr-x   1 root  wheel  38271173 Feb 23  1999 netbsd19990223.tar.gz</programlisting>
</listitem>
<listitem> ZIP をアンマウントする:
<programlisting>
yui# umount /mnt
yui#</programlisting>
</listitem>
<listitem> ZIP を取り出す:
<programlisting>
yui# eject sd0
yui#</programlisting>
</listitem>
</orderedlist>
</para>
</sect3>

<sect3 id="cdrom">
<title>NetBSD で CD のデータを読む</title>
<para>

Data CD は、プログラム、音声ファイル (mp3, wav)、動画 (mp3, quicktime) から、
ソースコード、テキストファイル、その他にいたるまで、
あらゆる物を入れることができます。
これらのファイルにアクセスする前に、 CD はハードディスクみたいに、
ディレクトリーにマウントされる必要があります。
ハードディスクが異なるファイルシステム( ffs, lfs, ext2fs, ...)で使えるように、
CD に固有のファイルシステムがあって、 "cd9660" です。
NetBSD cd9660 ファイルシステムは、
Rockridge と Joliet 拡張として、あるいは拡張とせず に扱うことができます。
</para>
<para>
CD デバイスは SCSI,  IDE (ATAPI) 共に /dev/cd0a と名づけられています。
</para>
<para>
この情報で、始めることができ:
</para>
<para>

<orderedlist>
<listitem> システムが CD ドライブを持っているか見てみます:
     <programlisting>
     # dmesg | grep ^cd
     cd0 at atapibus0 drive 0: &lt;CD-R/RW RW8040A, , 1.12&gt; type 5 cdrom removable
     cd0: 32-bit data port
     cd0: drive supports PIO mode 4, DMA mode 0
     cd0(pciide0:1:0): using PIO mode 0, DMA mode 0 (using DMA data transfers)</programlisting>
     ここに一つのドライブがあり、 "cd0" です。
     それは IDE/ATAPI ドライブで  atapibus0 上に見つかっています。
     もちろんそのドライブ (より正確にはそのメディア) はリムーバブルで、
     すなわち取り出すことができます。下記を見てください。</listitem>
<listitem> CD を挿入します</listitem>
<listitem> CD を手動でマウントします:
     <programlisting>
     # mount -t cd9660 /dev/cd0a /mnt
     # </programlisting>

     このコマンドはなにも表示しません。
     それは、システムが CD を /dev/cd0a に見つけ、 "cd9660" ファイルシステムを使って
      /mnt にマウントしたという(暗黙の)知らせです。
     マウントポイント "/mnt" は存在するディレクトリーでなければなりません。
     </listitem>
<listitem> CD の内容を確かめます:
     <programlisting>
     # ls /mnt
     INSTALL.html INSTALL.ps   TRANS.TBL    boot.catalog
     INSTALL.more INSTALL.txt  binary       installation
     # </programlisting>
     全部良く見えています! これは NetBSD CD です、もちろん。 :)
     </listitem>
<listitem> CD をアンマウントします:
     <programlisting>
     # umount /mnt
     # </programlisting>

     CD がアクセスされたまま(たとえば、どれか他のシェルがまだその中に "cd"したまま)
     だと、これは、働きません。
     もし、システムをシャットダウンされるなら、 CD は自動的に アンマウントされ、
     それに関してはなにも心配はいりません。
</listitem>
<listitem> /etc/fstab にエントリーを作ります:
     <para>
     もし、いちいち "mount"コマンドを完全に打ちたくなければ、
     /etc/fstab の行中にその値を置くことができ:
     <programlisting>
     # Device        mountpoint      filesystem  mount options 
     /dev/cd0a       /cdrom          cd9660      ro,noauto    </programlisting>
     例示したマウントポイント - "/cdrom" はあらかじめ存在しなければなりません:
     </para>
     <programlisting>
     # mkdir /cdrom
     # </programlisting>
     これで、次のコマンドで CD をマウントすることができ:
     <programlisting>
     # mount /cdrom
     #</programlisting>

     前の通り、アクセスとアンマウントをします。
     <para>
     CD は "noauto" によって、起動時はマウントされません。
     - これは、多分、常時ドライブに CD を入れていないだろうから便利です。
     他のいくつかの便利なオプションは  &man.mount.8; と &man.mount.cd9660.8;
     を見てください。
     </para></listitem>
     
<listitem> CD を取り出します:
     <programlisting>
     # eject cd0
     # </programlisting>

     CD がまだマウントされたままなら、もし可能ならアンマウントし、
     それでイジェクトします。
</listitem>
</orderedlist>
</para>
</sect3>

<sect3 id="multisession">
<title>NetBSD でマルチセッション CD を読む</title>
<para>

&man.mscdlabel.8; を使って CD のディスクラベルに全セッションを追加してから、
適切なデバイスノードを使って必要なセッションをマウントします。
対応するデバイスノードを /dev 以下に手動で作る必要があるかもしれません。
以下に例を示します。
<programlisting>
# mscdlabel cd1                                                                
track (ctl=4) at sector 142312
 adding as 'a'
track (ctl=4) at sector 0
 adding as 'b'
# ls -l /dev/cd1b
ls: /dev/cd1b: No such file or directory
# cd /dev
# ls -l cd1*
brw-r-----  1 root  operator       6,  8 Mar 18 21:55 cd1a
brw-r-----  1 root  operator       6, 11 Mar 18 21:55 cd1d
# mknod cd1b b 6 9</programlisting>
以上で cd1b が作成されました。
あらたに作成した各デバイスノードのパーミッションが適切か確認します。
<programlisting>
# ls -l cd1*
brw-r-----  1 root  operator       6,  8 Mar 18 21:55 cd1a
brw-r--r--  1 root  wheel          6,  9 Mar 18 22:23 cd1b
brw-r-----  1 root  operator       6, 11 Mar 18 21:55 cd1d
# chgrp operator cd1b
# chmod 640 cd1b
# ls -l cd1*          
brw-r-----  1 root  operator       6,  8 Mar 18 21:55 cd1a
brw-r-----  1 root  operator       6,  9 Mar 18 22:24 cd1b
brw-r-----  1 root  operator       6, 11 Mar 18 21:55 cd1d</programlisting>
これで、マウントできるようになったはずです。
<programlisting>
# mount /dev/cd1b /mnt</programlisting>
</para>
</sect3>

<sect3 id="cdrom-users">
<title>一般ユーザーが CD にアクセスできるようにする</title>
<para>

NetBSD では、 "root" だけがファイルシステムをマウントすることができます。
どのユーザーでもそうできるようにするには、以下のような方法があります:
</para>
<itemizedlist>
    <listitem>グループおよび他者に、デバイスへのアクセス権限を与える。
        <programlisting>chmod go+rw /dev/cd0a</programlisting>
	</listitem>
    <listitem>ユーザーがファイルシステムをマウントできるよう NetBSD にお願いする。
        <programlisting>sysctl -w vfs.generic.usermount=1</programlisting>
	</listitem>
</itemizedlist>
<para>
注意: マウントポイントはマウントするユーザーの所有でなければなりません。つまり、例としては:
</para>
<programlisting>
  cd
  mkdir cdrom</programlisting>
<para>
&man.mount.8; と、その代わりとなる &man.amd.8; のマニュアルをあわせて参照してください。
</para>
</sect3>

<sect3 id="vnconfig">
<title>ISO イメージをマウントする</title>
<para>

時には、 CD を焼く前に ISO9660 イメージファイルをマウントしたくなることがあります;
そうすれば、 CD の内容を確認できますし、個々のファイルを外にコピーすることもできます。
Linux を使っている方は、特殊な <emphasis>loop</emphasis>
ファイルシステムを使ってマウントできることを知っているはずです。
NetBSD ではこれとは方法が異なり、 <emphasis>vnode</emphasis> 仮想ディスクを使います。
</para>
<para>

ここでは、例を示しながらその方法を説明します。ホームディレクトリーに
ISO イメージファイルがあり、 <code>mycd.iso</code> という名前であると仮定します。

<orderedlist>
  <listitem>まず、この ISO ファイルを「参照」する新しい vnode を設定します。
      <programlisting># vnconfig -c vnd0 ~/mycd.iso</programlisting>
  </listitem>
  <listitem>次に、この vnode をマウントします。
      <programlisting># mount -t cd9660 /dev/vnd0a /mnt</programlisting>
  </listitem>
  <listitem>はい、これでイメージの内容が <code>/mnt</code> 以下に現れます。
      このディレクトリーに異動してイメージを探索してください。
  </listitem>
  <listitem>問題なければ、イメージを umount してください。
      <programlisting># umount /mnt</programlisting>
  </listitem>
  <listitem>最後に、 vnode の設定を解除します。
      <programlisting># vnconfig -u vnd0</programlisting>
  </listitem>
</orderedlist>

</para>
<para>
なお、この手順は、 ISO イメージに限らず、ファイルシステムを含むファイルなら
どんなファイルに対しても可能です。
</para>

<para>
さらなる情報は、 &man.vnd.4; および &man.vnconfig.8; マニュアルページを参照してください。

</para>
</sect3>

<sect3 id="cdrom-video">
<title>NetBSD で ビデオCD を使う</title>
<para>
     多くの DVD プレイヤーのように、 NetBSD のもとで、
     MPEG ビデオストリームを再生するには、
     CD を普通の (データ) CD としてマウントし ( <ulink url="#cdrom">上</ulink> を見てください ) 、
     CD 上に蓄えられた mpeg ファイルを再生するために
     <pkg>graphics/mtv,</pkg> 
     <pkg>multimedia/xine-ui,</pkg> 
     <pkg>multimedia/mplayer</pkg> または 
     <pkg>multimedia/gmplayer</pkg> 
     パッケージを使ってください。
</para>
</sect3>

<sect3 id="cdrom-audio">
<title>NetBSD で音楽 CD を使う</title>
<para>
音楽 CD を扱うには2つの方法があって:
</para>
<para>
<orderedlist>
<listitem><para> CD ドライブにヘッドフォンか、たいていの
     CDROM ドライブが内部的に接続されているサウンドカードの、
     いずれで再生するか指定して下さい。 &man.cdplay.1;,
     <pkg>audio/xmcd</pkg>,  <pkg>audio/kdemultimedia</pkg> パッケージの "kscd"
     のようなプログラムや、 &man.mixerctl.1;,
     <pkg>audio/xmix</pkg>, <pkg>audio/xmmix</pkg>,
     Curses ベースの <pkg>audio/cam</pkg> 
     や <pkg>audio/kdemultimedia</pkg> に含まれる kmix 
     のようなミキサープログラムを使ってください。
     </para>
     <para>
     これは、SCSI と IDE (ATAPI) 両方の CDROM, CDRW, DVD ドライブで、
     大抵きちんと動きます。
     </para>
</listitem>
     
<listitem> オーディオトラックを、デジタル -&gt; アナログ変換してもう一回戻すことなしに
     バイナリー形式で<ulink name="rip">読み出す ("rip")</ulink> 。
     これを行なうためのプログラムは、いくつかあります:
    <itemizedlist>
    <listitem>ATAPI と SCSI の CD-ROM のドライブで <pkg>audio/cdd</pkg>
         パッケージが使えます。 cdd でトラック 2 を抽出するには、
         以下のようにタイプします:
         <programlisting> # cdd -t 2 `pwd`</programlisting>
         これで、カレントディレクトリーに <code>track-02.cda</code>
         というファイルができます。
    </listitem>

    <listitem>SCSI CD-ROM ドライブでは <pkg>audio/tosha</pkg> パッケージが使えます。
        tosha でトラック 2 を抽出するには、以下のようにタイプします:
        <programlisting> # tosha -d <emphasis>CD-ROM-device</emphasis> -t 2 -o track-02.cda</programlisting>
    </listitem>

    <listitem> ほとんどの ATAPI、 SCSI、いくつかの独自仕様の CDROM ドライブで、
         <pkg>audio/cdparanoia</pkg> パッケージが使えます。 cdparanoia を使うと
         データを WAV、 AIFF、 AIFF-C あるいは raw(生) フォーマットで、
         ファイルにセーブするか、あるいは直接標準出力に出力することができます。
         現在、 NetBSD版の cdparanoia には -g オプションが必要です。
         たとえば、トラック 2 を WAV ファイルとしてセーブするには、
         次のようにします:
         <programlisting> $ cdparanoia -g /dev/rcd0d 2 track-02.wav</programlisting>
         CD の内容をすべて抽出したい場合は、 cdparanoia の
         バッチモードが便利です:
         <programlisting> $ cdparanoia -g /dev/rcd0d -B</programlisting>
    </listitem>
    </itemizedlist>

    これで、このデータを、たとえば <ulink
     url="#create-mpeg3">MP3 ストリームにエンコード</ulink>したり、 <ulink
     url="#cdr-audio">CD-R に焼いたり</ulink>
     するといった処理ができるようになります。
</listitem>
</orderedlist>

</para>
</sect3>

<sect3 id="create-mpeg3">
<title>オーディオ CD からMP3 (MPEG layer 3) ファイルを作る</title>
<para>
<emphasis><emphasis role="bold">どうか注意:</emphasis> これらの方法は
<pkg>audio/cdd</pkg> パッケージだけで確認をしていて、<pkg>audio/tosha</pkg>
や <pkg>audio/cdparanoia</pkg> パッケージでは確認していません。</emphasis>
</para>
<para> オーディオ CD から MPEG layer 3 (<code>MP3</code>) ファイルを (<ulink
url="../software/packages.html">NetBSD パッケージコレクション </ulink> のソフトウェアを使って)
を作るための基本的な手順は、以下のとおりです。
</para>
<orderedlist>
<listitem> CD からオーディオデータを<ulink url="#rip">抽出 (<emphasis>rip</emphasis>)</ulink> します。
     さらなる説明は、 ``<ulink url="#cdrom-audio">NetBSD で音楽 CD を使う</ulink>''
     を参照してください。</listitem>

<listitem>CD オーディオフォーマットを WAV フォーマットに変換します。
    この作業は、リッピングプログラム(tosha、 cdd など)がやってくれて
    いない場合にだけ必要です。
    <itemizedlist>
    <listitem><pkg>audio/sox</pkg> パッケージを使い、以下のように実行します。
    <programlisting>sox -s -w -c 2 -r 44100 -t cdr track-02.cda track-02.wav</programlisting>
    これで raw CD フォーマット <code>track-02.cda</code> が
    符号あり( <emphasis role="bold">s</emphasis>igned) 16-bit 語長(<emphasis role="bold">w</emphasis>ords)、
     2 チャンネル(<emphasis role="bold">c</emphasis>hannels)、
    サンプリングレート(sampling <emphasis role="bold">r</emphasis>ate) 44100kHz の 
     WAV フォーマット <code>track-02.wav</code>
    に変換されます。
    </listitem>
    </itemizedlist>
</listitem>
<listitem>WAV ファイルを MP3 フォーマットにエンコードします。
    <itemizedlist>
    <listitem><pkg>audio/bladeenc</pkg> パッケージを使い、以下のように実行します。
    <programlisting>bladeenc -128 -QUIT track-02.wav</programlisting>
    これで、 <code>track-02.wav</code> が
    ビットレート <emphasis role="bold">128</emphasis>kBit/sec の MP3 フォーマットで、
    <code>track-02.mp3</code> にエンコードされます。
    bladeenc のドキュメンテーションに、ビットレートのより詳しい説明があります。
    </listitem>
    <listitem><pkg>audio/lame</pkg> パッケージを使い、以下のように実行します。
    <programlisting>lame -p -o -v -V 5 -h track-02.wav track-02.mp3</programlisting>
    あなたの好みやハードウェアによって、
    もっと低い品質で使いたいかもしれません。
    </listitem>
    </itemizedlist>
  </listitem>
</orderedlist>
<para>

できあがった MP3 ファイルは、
<pkg>audio/maplay</pkg>, <pkg>audio/mpg123</pkg>, <pkg>audio/splay</pkg> パッケージのいずれでも再生できます。

</para>
</sect3>

<sect3 id="cdr">
<title>CD-R ライターを使ってデータ CD を書き込む</title>
<para>
CD に書きこむ過程は、 2 段階にわたります:
最初に、データの "イメージ" を作る必要があり、
第2段階で CD-R に書きこみます。
</para>
<para>

<orderedlist>
<listitem> すでに有る ISO イメージを読み込む
     <programlisting>
     # dd if=/dev/rcd0a of=filename.iso bs=2k
     #</programlisting>
     このほか、以下のようにして自分で新しい ISO イメージを作ることもできます。
</listitem>
<listitem> ISO イメージをつくる
     <para>
     CD に入れたい全てのデータを1つのディレクトリーに入れてください。
     つぎに、ディスクのような ISO イメージをつくる必要があります。
     イメージは、データを ISO 9660 フォーマットを使って
     後で CD に書きこむのと同じ形式でたくわえます。
     基本 ISO9660 フォーマットは 8+3 ファイル名だけ
     (最大で8文字のファイルネームと、加えて3文字までの拡張子)
     が使えます。
     これは Unix のファイル名としては実用的ではないので、
     長いファイル名を使うために "Rockridge Extension" (ロックリッジ拡張) というものを使う必要があります。
     </para>
     <para>
     ISO イメージは <pkg>sysutils/cdrecord</pkg> パッケージに入っている
     mkisofs コマンドを使ってつくります。
     </para>
     <para>
     例: データが /usr/tmp/data にあって、 /usr/tmp/data.iso に ISO イメージをつくる場合は、
     以下のようなコマンドを実行します。
     <programlisting>
     $ <command>cd /usr/tmp</command>
     $ <command>mkisofs -o data.iso -r data</command>
     Using NETBS000.GZ;1 for  data/binary/kernel/netbsd.INSTALL.gz (netbsd.INSTALL_TINY.gz)
     Using NETBS001.GZ;1 for  data/binary/kernel/netbsd.GENERIC.gz (netbsd.GENERIC_TINY.gz)
       5.92% done, estimate finish Wed Sep 13 21:28:11 2000
      11.83% done, estimate finish Wed Sep 13 21:28:03 2000
      17.74% done, estimate finish Wed Sep 13 21:28:00 2000
      23.64% done, estimate finish Wed Sep 13 21:28:03 2000
      ...
      88.64% done, estimate finish Wed Sep 13 21:27:55 2000
      94.53% done, estimate finish Wed Sep 13 21:27:55 2000
     Total translation table size: 0
     Total rockridge attributes bytes: 5395
     Total directory bytes: 16384
     Path table size(bytes): 110
     Max brk space used 153c4
     84625 extents written (165 Mb)
     $</programlisting>
     出版者 (publisher) や作成者 (preparer) についての記述の指定など、
     他のオプションについては、 mkisofs(8) マニュアルページを見てください。
     <ulink url="../bootcd.html">Bootable CD ROM How-To</ulink> が、
     ブータブル(起動可能) CD の作り方を説明してます。</para>
     </listitem>
<listitem> CD-R に ISO イメージを書きこむ
     <para>
     ISO イメージファイルがあれば、単に CD に書くだけです。
     これは<pkg>sysutils/cdrecord</pkg> パッケージの "cdrecord" コマンドで行ないます。
     ブランク CD-R を入れて、さあ、始めましょう:
     <programlisting>
     # cdrecord -v dev=/dev/rcd0d data.iso
     ...
     #</programlisting>
     コマンドの実行が始まると、 'cdrecord' はドライブ、ディスク、
     書きこむイメージに関する沢山の情報を表示します。
     止めるためのラストチャンスとして10秒間カウントダウンし
     - 中止したければ ^C を押します。
     中止しなければ、このプロセスは CD に全イメージを書き
     シェルプロンプトにもどります。
     </para>
     <para>
     なお、 cdrecord(8) は SCSI と IDE (ATAPI) ドライブ両方で動きます。
     </para>
     </listitem>
<listitem> 試験
     <para>
     書き上がったばかりの CD をマウントし、 まったくの"標準"CD として試します。
     <ulink url="#cdrom">上</ulink>を見てください。
     </para></listitem>
</orderedlist>

</para>
</sect3>

<sect3 id="cdr-audio">
<title>CD-R ライターを使ってオーディオ CD を作る</title>
<para>

オーディオ CD のバックアップコピーを作りたい場合、 CD から
<ulink url="#cdrom-audio">オーディオトラック</ulink>を抽出 ("リッピング") して、
ブランク CD に書くことができます。
もちろん、複数の CD から個々のトラックを抽出して、
あなただけのミックス CD を作ることだってできます!
</para>
<para>

手順は以下のとおりです:
</para>
<para>

<orderedlist>
<listitem> <ulink url="#rip">NetBSD で音楽 CD を使う</ulink>の説明に従って、
     オーディオトラックを抽出し、
     .wav ファイルにします。
</listitem>
<listitem> この .wav ファイル群を <pkg>sysutils/cdrecord</pkg> を使って書き込みます:
     <programlisting> # cdrecord -v dev=/dev/rcd0d -audio -pad *.wav</programlisting>
</listitem>
</orderedlist>
</para>
</sect3>

<sect3 id="cdr-mp3">
<title>mp3 からオーディオ CD を作る</title>
<para>

あなたがお持ちのオーディオ CD がすべて mp3 に変換済であって、
(たとえば) クルマで使うためにミックス CD を作りたいような場合、
まずはその .mp3 ファイルを .wav フォーマットに戻せばよいです。
それから、その .wav ファイルから通常のオーディオ CD として書き込みます。
</para>
<para>

この場合の手順は以下のとおりです:
</para>
<para>

<orderedlist>
<listitem> .mp3 ファイルから .wav ファイルを作る:
     <programlisting> $ mpg123 -w foo.wav foo.mp3 </programlisting>
     これを、オーディオ CD 化したいすべての mp3 ファイルについて行ないます。
     .wav のファイル名はお好きなように付けてかまいません。
</listitem>
<listitem> ``<ulink url="#cdr-audio">CD-R ライターを使ってオーディオ CD を作る</ulink>''
     の説明に従い、 .wav ファイルを CD に書き込む。
</listitem>
</orderedlist>
</para>
</sect3>

<sect3 id="copy-audio-cd">
<title>オーディオ CD をコピーする</title>
<para>

オーディオ CD をコピーするには、 CDDA 標準で定められただけの休止が挿入されていない
CD であっても、 cdrdao を使っておこなうことができます。

<programlisting>
# cdrdao read-cd --device /dev/rcd0d data.toc
# cdrdao write   --device /dev/rcd1d data.toc</programlisting>
</para>
</sect3>

<sect3 id="copy-cd">
<title>2 台のドライブを使ってデータ CD をコピーする</title>
<para>

CD-R と CD-ROM ドライブの両方を持つマシンでは、
下記のコマンドでデータ CD をコピーできます。

<programlisting>
# cdrecord dev=/dev/rcd1d /dev/rcd0d</programlisting>

ここで、 CD-ROM (cd0) にはコピーしたい CD 、 CD-R (cd1) にはブランク
CD を入れておきます。この方法は、データの入ったコンピューターディスク
でのみ使え、オーディオ CD では<emphasis>使えない</emphasis>ことに注意してください。
実際には、より速くするために "<code>speed=8</code>" などを追加しても
よいでしょう。
</para>
<para>

</para>
</sect3>

<sect3 id="cdrw">
<title>CD-RW リライタブルを使う</title>
<para>

NetBSD では CD-RW ドライブは <ulink url="#cdr">CD-R</ulink> ドライブのように扱うことができ、
mkisofs(8) でイメージをつくり、 cdrecord(8) で CD-RW メディアに書きこむことができます。
</para>
<para>
ブランク CD-RW が欲しいなら、 cdrecord の "blank" オプションで作ることができ:
</para>
<para>
<programlisting>
# cdrecord dev=/dev/rcd0d blank=fast</programlisting>
ブランク CD-RW を作る他のいくつかの方法があり、
"blank=help" をつけ cdrecord(8) を呼ぶとリストが得られます。
より多くの情報は cdrecord(8) マニュアルページを見てください。

</para>
</sect3>

<sect3 id="dvd">
<title>DVD サポート</title>
<para>
現在、 NetBSD は CD-ROM でも使われている ISO9660 として だけども
DVD メディアをサポートしています。
DVD 上にある 新しい UDF ファイルシステムはサポートしていませんが、
ほとんど全ての DVD は ISO 9660 ファイルシステムを使っていて、良く使えます。
DVD、 DivX および多くの avi ファイルは、 <pkg>graphics/ogle</pkg> や
<pkg>graphics/gmplayer</pkg> で再生できます。
</para>
<para>
DVD 作成のうえでのいくつかのヒントについては、この
<ulink url="http://mail-index.NetBSD.org/current-users/2004/01/06/0021.html">
growisofs に関する記事</ulink>を参照してください。
</para>
</sect3>
</sect2>

<sect2 id="common-problems">
<title>一般の(それと一般ではない)問題</title>

<sect3 id="nroff-missing">
<title>'man' を実行すると <emphasis role="bold">/usr/bin/nroff: not found</emphasis> となります</title>
<para>
'text' セット (text.tgz) をインストールする必要があります。インストールノートを見てください。
</para>
</sect3>

<sect3 id="var-mail-permissions">
<title>メールを読んでいる時 '<emphasis role="bold">Unable to lock mailbox: Permission denied</emphasis>'が出ます</title>
<para>
<code>/var/mail</code> ディレクトリーのパーミッションをチェックしてください。
それは '<code>drwxrwxrwt</code>'となっているべきで:
<programlisting>
% <emphasis role="bold">ls -ld /var/mail</emphasis>
drwxrwxrwt  2 root  wheel  512 Nov  6 08:21 /var/mail</programlisting>
そうでなければ、 root になって '<code><emphasis role="bold">chmod 1777 /var/mail</emphasis></code>' を実行します。
</para>
</sect3>

<sect3 id="kernel-not-netbsd">
<title>'<code>netstat -r</code>' を実行すると <emphasis role="bold">netstat: kvm_read kvm_read: Bad address</emphasis> となります</title>
<para>
これはなにも心配はいりません。
基本的に、 <code>/netbsd</code> というファイルは
あなたの現在のカーネルではありません。
たくさんのプログラム( <code>ps</code>, <code>who</code>, <code>systat</code> 等のような)
や libkvm &man.kvm.3; は
カーネル内がどうなっているかを知るために <code>/netbsd</code> をアクセスします。
それで、この手のエラーを回避する為に、
あなたの現在のカーネルを <code>/netbsd</code> に単純にリネームすることができます。
これをしている時に動作中のカーネルを上書きしていないか確かめてください。
それが、あなたがしようとしていることではないかぎり。
</para>
</sect3>

<sect3 id="libkvm-mismatch">
<title>'<code>netstat -r</code>' をしてみると、限りないクエスチョンマークの列が帰ってきます。 何が悪いの?</title>
<para>
それは、 <code>libkvm/netstat</code> と <code>/netbsd</code> の間で不適合になっているからです。
または、 <code>/netbsd</code> という名前ではないカーネルを走らせているからです。
この問題のほかの兆候は、
 <code>who</code>, <code>ps</code>, <code>ifconfig</code> や <code>systat</code> 
のようなものも良く動かないことでしょう。
もし、カーネルとバイナリーを同時にアップデートすれば、解決するでしょう。
</para>
</sect3>

<sect3 id="kernel-upgrade">
<title>新しいカーネルにアップデートしたあと、 <code>w</code>, <code>ps</code>, と <code>netstat</code> が働きません</title>
<para>
2つのうちの1つです。
 現在起動しているカーネルが <code>/netbsd</code> と名づけられていないか、
使っているカーネルとバイナリーの間で不適合があるかのどちらかです。
 最初の場合、単純に現在起動されているカーネルを
 <code>/netbsd</code> にリンクをつくることで、問題は解決します。
</para>
<para>
2番目の場合、ダイナミックリンクされたバイナリーは、
 libkvm を新しいカーネルに適合するようにアップグレードすることで、
直せます。
スタティックリンクされたバイナリーは
より新しいバージョンの物に置きかえる必要があります。
それらはスタティックリンクされているので、
それらを再コンパイルしようとするなら、
問題のプログラムの再構築をする <emphasis role="bold">前に</emphasis> <code>libkvm.a</code> を再構築する必要が
あります。
</para>
<para>
John Wittkowski (jpw@netscape.com) に感謝、
これは彼による ( <code>/bin/ps</code> のほかに)
libkvm に依存するプログラムのほとんどの一覧です
(これらの全ては <code>/usr/bin</code> にあります): 
<itemizedlist>
<listitem><code>fstat</code></listitem>
<listitem><code>gdb</code></listitem>
<listitem><code>ipcs</code></listitem>
<listitem><code>netstat</code></listitem>
<listitem><code>nfsstat</code></listitem>
<listitem><code>systat</code></listitem>
<listitem><code>uptime</code></listitem>
<listitem><code>vmstat</code></listitem>
<listitem><code>w</code></listitem>
</itemizedlist>
</para>
</sect3>

<sect3 id="proc-size-mismatch">
<title>カーネル変更後 'ps' が <emphasis role="bold">"proc size mismatch"</emphasis> と言います</title>
<para>
この前にある3つの疑問のように、
その答えは、たいてい、
libkvm がカーネルやバイナリーと同期がとれていないからです。
この問題を解決するには、
カーネルに適合したバイナリー配布物を手に入れるか、
下に示した方法で構築するかのどちらかの方法がとれます:

<programlisting>
"proc size mismatch" エラーが出て、 lib のアップデートが必要だと決意した場合、
次のようにします:

1. 全ソースコードを手に入れます。
   もし、あなたがこれをしたり、再コンパイルをすることを望まなくても、
   誰かがこの作業をしたか探すよりは、
   いちいち手作業をしてインストールに挑戦しましょう。

2. インクルードファイルが 更新されているか確認します。
   このようにし:
      cd /usr/src
      make includes
   これは、ちょっと時間がかかるでしょう。
   いくつかの Makefile に INSTALL 変数が定義されていなかったため、
   私は何度かトラブルに遭いました。
   "make includes" が失敗するごとに、
   表示されている、最後のディレクトリーに行って、
   Makefile にこの行を加えました:
      INSTALL=/usr/bin/install
   これを何度か行なうことで、エラーなしに終わることができました。

   (まず、 /usr/bin/make と /usr/share/mk 内の全てのファイルが
   更新されていることを確かめれば、 上の問題点を避けることができるでしょう。)

3. libkvm を再構築し、インストールします:
      cd /usr/src/lib/libkvm
      make
      make install
   注意として、 libkvm を得る目的で
   私のシステムでコンパイルをするのに、
   次のようなリンクを加える必要がありました:
      cd /usr/include/machine
      ln -s ../m68k/kcore.h kcore.h
   これはたぶん私のシステムの癖なので、
   最初にこれをせずにコンパイルを試してください。

4. そして、 libkvm にスタティックリンクされたバイナリーを再構築します。
   私が気がついているスタティックリンクされたプログラムは
   "/bin/ps" だけで、  ps の再構築には、単純に:
      cd /usr/src/bin/ps
      make
      make install

5.  libkvm にダイナミックリンクされたバイナリーは、
   再構築が必要かもしれませんし、必要ないかもしれません。
   これは、なぜかと言うと(私が考えるに)、
   古いバイナリーに対し、 lib の メジャーバージョン番号 が変わるなら、
   古いバージョン番号を求めていて、新しいバージョンの lib では動かないでしょう。
   たとえば、 私の古い libkvm は libkvm.so.4.0 で、
   その新しいものは libkvm.so.5.0 です。
   ダイナミックリンクされたバイナリー を再コンパイルしなければ、
   "proc size mismatch" ( 4.0 lib がまだそこにあれば)か、
   some lib missing error ( /usr/lib から 4.0 lib が取り除かれていれば)
   と不平を言うでしょう。
   マイナーバージョンナンバーの変更 (たとえば 4.0 から 4.1) なら
    warning を出しながらも動き、
   これらの全てを再コンパイルする必要はないでしょう。

   私が気がついている ダイナミックリンクされたバイナリーは
    "proc size mismatch" エラー ( 4.0 lib がまだそこにあれば) か
    some lib missing エラー ( /usr/lib から 4.0 lib が取り除かれていれば) 
   を出すでしょう。
   マイナーバージョンナンバーの変更 (たとえば 4.0 から 4.1) なら
    warning を出しながらも動き、
   これらの全てを再コンパイルする必要はないでしょう。

   私が気がついているダイナミックリンクされたバイナリーは:
      /usr/bin/fstat
      /usr/bin/gdb
      /usr/bin/ipcs
      /usr/bin/netstat
      /usr/bin/nfsstat
      /usr/bin/systat
      /usr/bin/uptime (linked to /usr/bin/w)
      /usr/bin/vmstat
      /usr/bin/w
   注意 /usr/bin/uptime は /usr/bin/w にリンクされていて、
   w に対して "make install" をすることで、セットアップされるでしょう。

   これらを再コンパイルするには、次のようにし:
      cd /usr/src/usr.bin/&lt;cmd&gt;
      make 
      make install
   たとえば、 /usr/bin/vmstat を再コンパイルするには:
      cd /usr/src/usr.bin/vmstat
      make
      make install</programlisting>

これに関する具体的な答えをくれた John Wittkowski (jpw@netscape.com) に感謝

</para>
<para>
小さな背景: 
これらのシステムユーティリティーに、上にあげたすべての問題も含め、
カーネルメモリー情報を手に入れさせ続ける必要がある理由は、
この手段がカーネルクラッシュダンプに対しても働き、
カーネルデバッグ作業に便利な特徴になることが出来るからです。
</para>
</sect3>

<sect3 id="hash-map-alias0">
<title><emphasis role="bold">hash map "Alias0":unsafe map file</emphasis>
    <emphasis role="bold"><code>/etc/aliases</code>: No such file or directory</emphasis>' が表示されます</title>
<para>
root 権限で '<emphasis role="bold"><code>newaliases</code></emphasis>' と打つことで直せます。<html:br/>
sendmail は &man.aliases.5; ファイルが存在しないとこれを報告します。

注 sendmail(8) は実際には
   <code>/etc/aliases.db</code> ( <code>/etc/aliases</code> からつくられる高速参照
   hash(3) マップ) を使い、それで、このエラーメッセージは小さな誤解をおこすのです。

これは、 NetBSD 1.3 から 1.4 だけで、注意すべきで、
ほかのバージョンでは、
必要に応じて <code>/etc/sendmail.cf</code> を自動的に再構築する
異なる <code>/etc/sendmail.cf</code> を持っています。

もし、古くても NetBSD 1.4.1 を走らせていなければ、
新しい <ulink url="../../Releases/formal.html">公式リリース</ulink> 
にアップグレードするべきです。
</para>
</sect3>

<sect3 id="portmap-messup">
<title>どうやったら、 root でログインした時のシェルが出す <code>portmap</code> メッセージ を抑制できますか</title>
<para>
<pkg>security/sudo</pkg> をつかって、そして、決して root でログインしないでください。
</para>
<para>
root でログインする必要があるなら、
<code>/etc/syslog.conf</code> ファイルを編集することで、
うるさいメッセージを抑制するために
重要な 装備 を外すことができます。

たいていの場合、それは、次の行の
<code>auth.debug</code> を無効化することで充分で:
<programlisting>*.notice;auth.debug                                     root</programlisting>
これで、それらのうるさい 
<code>portmap&nbsp;[pid]:&nbsp;connect&nbsp;from&nbsp;some.other.host&nbsp;...</code> 
メッセージが消えるでしょう。

必ず
 <code>kill&nbsp;-HUP</code> <code>syslogd</code> の pid 
をしてください。
</para>
<para>
<code>xconsole</code> を使うために、
<ulink url="../x/#xconsole">FAQ 項目</ulink>も見るのもいいかもしれません。
</para>
</sect3>

<sect3 id="locales">
<title>どうやったらウムラウトその他の地域的な文字を表示できますか?</title>
<para>

NetBSD 1.6 には、デフォルトで数々のロケールがインストールされています。これらのロケールは
<code>/usr/share/locales</code> にあります。あなたの居住地にもっとも合ったロケールを選んで、
環境変数 LC_ALL を適切に設定してください。なお、 LC_ALL をたとえば ``de_DE''
に設定するのでは不十分なことに注意してください。 ``de_DE.ISO8859-15'' のような
<emphasis>完全な</emphasis>ロケールを使う必要があります
</para>
<para>
古いバージョンの NetBSD 向けに、<ulink
url="http://mail-index.NetBSD.org/netbsd-users/2000/11/09/0019.html">メール アーカイブ</ulink>
からの情報を以下に示します:
<orderedlist>
<listitem> <ulink url="ftp://ftp.NetBSD.org/pub/NetBSD/arch/i386/french-1.4/locale.tgz">locale.tgz</ulink> を
取得してください。</listitem>
<listitem> / にそれを展開し: <code>tar plzvxCf / locale.tgz</code></listitem>
<listitem> シェルで、 set LC_ALL=iso_8859_1 してください。
(常時設定にするには、 .cshrc 、 .profile 、 ...において)</listitem>
<listitem> シェルを再起動するか、ログインしなおしてください。</listitem>
<listitem> シェルを見ると、 vi その他 キーボードからのこれらウムラウトのすべてを
受け付けます: &ouml;&auml;&uuml;&Auml;&Ouml;&Uuml;...
(訳者注:環境によっては化けているかもしれません)</listitem>
</orderedlist>
</para>
</sect3>
</sect2>

<sect2 id="disks-filesystems">
<title>ディスクおよびファイルシステム</title>
<sect3 id="adding-a-disk">
<title>存在しているシステムにディスクを追加する</title>
<para>
<orderedlist>
<listitem>システムを Halt(停止) します</listitem>
<listitem>新しいドライブをつなぎます</listitem>
<listitem>マシンが PROM か BIOS を持っていて、ドライブ一覧が出せるなら、
    そのドライブが認識されているかチェックします:
    <itemizedlist>
    <listitem><emphasis role="bold">最近の sparc</emphasis>: 起動開始以前に
	<code><emphasis role="bold">[STOP][A]</emphasis></code> を押し、そして "<code>ok</code>" プロンプトの所で <code><emphasis role="bold">probe-scsi</emphasis></code>。</listitem>
    <listitem><emphasis role="bold">adaptec BIOS の入っている i386 </emphasis>:起動開始以前に、
	<code><emphasis role="bold">[CTRL][A]</emphasis></code> を押し、BIOS にはいります。</listitem>
    <listitem><emphasis role="bold">他のもの</emphasis>: もっと詳しいこと(を寄せられること)を歓迎します :)</listitem>
    </itemizedlist></listitem>
<listitem>boot します。</listitem>
<listitem>ドライブが認識されていることを、&man.dmesg.8; 出力で確かめます</listitem>
<listitem>ディスクラベルを用いてパーティションに &man.disklabel.8; を書きこみます<html:br/>
        (もし、ディスクにディスクラベルがまだなければ、
         たぶん以下のようにすることになるでしょう:<programlisting> disklabel -i -I sd1 # "sd1: no disk label" という警告はすべて無視します</programlisting>
    パーティション 'c' は、ディスクのうち NetBSD 部分全体として予約されており、
    一部のポート (特に i386) では同様に 'd' がディスク全体として予約されています。
    以下はセッションの例で、ディスク全体をひとつのパーティション 'e'
    として設定しています:
<programlisting>
	partition&gt; <emphasis role="bold">e</emphasis>
	Filesystem type [?] [unused]: <emphasis role="bold">4.2BSD</emphasis>
	Start offset [0c, 0s, 0M]: 
	Partition size ('$' for all remaining) [0c, 0s, 0M]: <emphasis role="bold">$</emphasis>
 	e: 234375000         0     4.2BSD      0     0     0   # (Cyl.    0 - 232514*)
	partition&gt; <emphasis role="bold">W</emphasis>
	Label disk [n]? <emphasis role="bold">y</emphasis>
	partition&gt; <emphasis role="bold">Q</emphasis></programlisting>
    <code>disklabel -i</code> の実行中は、さらなるヘルプを '?' で参照できます。
</listitem>
<listitem>追加されたファイルシステムごとに、
    <code><emphasis role="bold">newfs &lt;filesystem&gt;</emphasis></code>
    (ここで <emphasis>&lt;filesystem&gt;</emphasis> は生(raw)デバイスのパーティションです。
      /dev/rsd1e, /dev/rwd1f, ... のような)
</listitem>
<listitem>ファイルシステムを <code>/etc/fstab</code> に書きこみます。</listitem>
<listitem>それを &man.fsck.8; します: <programlisting>fsck -f &lt;filesystem&gt;</programlisting></listitem>
<listitem>それを &man.mount.8; します: <programlisting>mount -va</programlisting></listitem>
</orderedlist>
</para>
</sect3>

<sect3 id="softdeps">
<title>soft updates (softdeps) はどうやって使うの?</title>
<para>
    Frank van der Linden
    (<ulink HREF="mailto:frank@wins.uva.nl">frank@wins.uva.nl</ulink>)
    はメインツリーに
     Kirk McKusick の 精巧な sync + FFS soft update コードを
    持ってきました。
</para>
    <para>
    使うには、次のようにします:

    <orderedlist>
    <listitem>カーネルコンフィグファイルに "<code>options SOFTDEP</code>" をつけて
        新しいカーネルをコンパイルします。
        このオプションは GENERIC カーネルでは有効になっています。</listitem>
    <listitem>新しいカーネルを走らせます。</listitem>
    <listitem> <code>/etc/fstab</code> の中で、 softdeps を使いたい全てのファイルシステムに
        "<code>softdep</code>" マウントオプションを追加します。
        たとえば、このような行は
<programlisting>
/dev/wd0e    /usr    ffs     rw                      1 2</programlisting>
このように変更します:
<programlisting>
/dev/wd0e    /usr    ffs     rw<emphasis role="bold">,softdep</emphasis>              1 2</programlisting></listitem>
    <listitem>リブートします。</listitem>
    <listitem>遊ぼう!</listitem>
    </orderedlist>

</para>
</sect3>

<sect3 id="softdep-impact">
<title>softdep による改善はどう判断してるの?</title>
<para>

変化したデータが直ちにディスクに書き込まれない事実から、
システムがもっと速くなったと思われます。
現時点では、これを表わす数字はありません。
</para>
<para>

Paul Vixie は、softdep が
ありとなし
の両方のシステムで、一つのディレクトリーに (ランダム順に) 75.000 ファイル を蓄え検索する
ベンチマークを走らせました。
この結果は、大きなディレクトリーにおいて、生成および配置の両方のファイルアクセス時間が、
一般的に、soft dependencies なシステムのほうが良い結果であることを
示しています。(この場合の softdep システムは FreeBSD 4.2で、
非-softdep システムは BSD/OS 3.1 です。
 NetBSD システムでも softdep の有る無しで見られる挙動は似たものであるはずです)。
</para>
<para>
</para>
</sect3>

<sect3 id="ffs-integ">
<title>Fast File System (FFS)、 softdeps を使った FFS および NetBSD の ext2fs の実装の、不適切なシャットダウンに対する回復性はどうですか?</title>
<para>

FFS では、ファイルシステムがクラッシュ後に修復可能であることを保証すべく、
メタデータ操作をそれが参照するデータの実体の操作より先に行うことと、
さらに、あらゆるメタデータ操作は適切な順序で行なうことに注意を払っています。
最後の N 秒 (N は同期間隔) ぶんの<emphasis>ファイルデータ</emphasis>は、修復不可能に
なるかもしれませんが、それでもファイルシステムメタデータは修復可能です。
この N は通常は 30 です。
</para>
<para>    
softdeps を使うと、通常の FFS と<emphasis>ほとんど</emphasis>同じだけの信頼性が得られます。
softdeps では、クラッシュ前のある時点における、
矛盾のないファイルシステムのスナップショットを得られることが保証されます。
このため、たとえば、ロックファイルのリネームといった不可分な操作を行なった場合、
softdeps を使わない場合と同じく、ロックファイルが本当にあることはわかりません;
しかし、そのファイルのあったディレクトリーが消されないことと、
この不可分な操作と将来の不可分な操作の間の依存関係の順序が保持されることはわかります。
このため、制御が不可分な操作に依存している場合、
たとえば、ある種のデータベース的なプロセス (大量のメールスプールファイルの
書き込み、取引システムからのデータ集計などなど) では、
それが終わったように見えた時点で、安全にバックアップを取ることができます。
</para>
<para>
NetBSD の ext2fs の実装は、メタデータに関して、 (Linux の実装とは違って)
旧来の FFS 並の保証をしていますので、 Linux でネイティブの ext2fs
を使う場合よりも多くの信頼を持って実際に使うことができます。
若干遅くなるという欠点はあります。しかしこれは、
システムクラッシュ時に適切な扱いをして、
潜在的なファイルシステム破壊の可能性を避けるようにしたためなのです。
</para>
</sect3>

<sect3 id="moving-usr">
<title> /usr をルートからほかのパーティションに移す</title>
<para>
    <orderedlist>
	<listitem>希望する新しい位置(例えば <code>/dev/sd0e</code>)が
	   存在する他のどのパーティションとも重ならないことを確かめます。
	   &man.disklabel.8; の出力をチェックします。</listitem>
	<listitem>移動先にまだファイルシステムがなければ、以下を実行します。
	<programlisting># <emphasis role="bold">newfs /dev/sd0e</emphasis></programlisting>
        </listitem>
	<listitem>それをマウントし、データを向こうへコピーします:
	<programlisting># <emphasis role="bold">mount /dev/sd0e /mnt</emphasis></programlisting>
        </listitem>
<listitem><programlisting># <emphasis role="bold">cd /usr</emphasis></programlisting></listitem>
<listitem><programlisting># <emphasis role="bold">pax -rw -pe . /mnt</emphasis></programlisting></listitem>
<listitem><programlisting># <emphasis role="bold">umount /mnt</emphasis></programlisting></listitem>
	<listitem><code>/etc/fstab</code> を編集し、
	   '<code>/dev/sd0e /usr ffs rw 1 2</code>' を加えます。
	   ( <code>/dev/sd0e</code> はあなたの状況に応じて変えて下さい)。
        </listitem>
	<listitem>シングルユーザーモードに shutdown し、
	    新しいマウントポイントをつくります:
	<programlisting># <emphasis role="bold">shutdown now</emphasis></programlisting></listitem>
<listitem><programlisting># <emphasis role="bold">mv /usr /usr.old</emphasis></programlisting></listitem>
<listitem><programlisting># <emphasis role="bold">mkdir /usr</emphasis></programlisting></listitem>
	<listitem>システムを起動し、テストし、まったく良好なら、
	   '<code>rm -rf /usr.old</code>' します。</listitem>
    </orderedlist>
</para>
</sect3>

<sect3 id="read-only-to-read-write">
<title>どうやって'リードオンリー'ファイルシステムを読み書きできるようにマウントするの?</title>
<para>
&man.mount.8; の <code>-u</code> (update) スイッチを使ってください:
'<emphasis role="bold"><code>mount -u /</code></emphasis>'。
あなたはおそらくシングルユーザーで起動したのでしょうが、この場合、
ルートファイルシステムは、標準でリードオンリーでマウントされます。
これは、マルチユーザーでシステムが起動する前に、
手動で fsck を走らせる機会を与えてくれます。
読み書きできるように、
<code>/etc/fstab</code> の全てのファイルシステムをマウントするもうひとつの方法は
'<emphasis role="bold"><code>mount -a</code></emphasis>' をつかうことです。
</para>
<para>
しかしながら、これをする一番良い方法は、シングルユーザーシェルを抜けて
マルチユーザーモードに入ることです。
これで、 <code>/etc/fstab</code> に載せられているモードで
その全てのファイルシステムをマウントします。
</para>
</sect3>

<sect3 id="using-fsck">
<title>いつ fsck を使うのが安全なの?</title>
<para>
&man.fsck.8; は、アンマウントされているか、
リードオンリーのファイルシステムにだけ
使うようにしてください。
読み書きできるファイルシステムに
fsck(8) をかけることは危険で、ファイルシステムをより悪くしてしまうかもしれません。
シングルユーザーモードでシステムを起動すれば、リードオンリーでマウントされます。
そこで '<emphasis role="bold"><code>fsck -p</code></emphasis>' とすることで、
システムがマルチユーザーモードで起動する前に、
全てのファイルシステムをチェックすることができます。
もし、ファイルシステムに既に "clean," とマークされているけど、
それでもまだチェックしたいなら、
&man.fsck.8; に <code>-f</code> フラグ を使うことができます。
</para>
<para>
fsck を使って、ファイルシステムになにかの変更がされたら
たぶん、ディスクを同期せずに機械をすぐリブートするために
 '<emphasis role="bold"><code>reboot -n</code></emphasis>'
と打つのが、一番良いことでしょう。
</para>
</sect3>

<sect3 id="kernfs">
<title> <code>/kern</code> は何に使われているの?</title>
<para>
それは、 kernfs ファイルシステムのマウントに使われています。
&man.mount.kernfs.8; マニュアルページを見てください。
</para>
</sect3>

<sect3 id="procfs">
<title> <code>/proc</code> は何に使われているの?</title>
<para>
それは、 procfs ファイルシステムのマウントに使われています。
<emphasis>The Design and Implementation of the 4.3BSD UNIX Operating System</emphasis>
by Leffler, McKusick, et al., p. 104-5, 436 を調べてください。
&man.mount.procfs.8; マニュアルページも見てください。
</para>
<para>

これは、普通 root で '/proc' ディレクトリーを作って、
/etc/fstab ( &man.fstab.5; を見よ) に次のように加えることで使われています:<html:br/>
<code>/proc /proc procfs rw 0 0</code>
</para>
<para>

NetBSD では <code>/proc</code> はプロセス関連のデータ専用になっているため、
それ以外の linux で使われているような項目は提供されません。しかし、
以下のようにファイルシステムフラグに "<code>linux</code>" オプションを加えることで、
変えることができます。<html:br/>
<code>/proc /proc procfs rw<emphasis role="bold">,-olinux</emphasis> 0 0</code>
</para>
<para>
</para>
</sect3>

<sect3 id="cgd-swap">
<title>&man.cgd.4; を使ったスワップの暗号化</title>
<para>
スワップの暗号化については時々話題にのぼるため、ここで示す情報は
スワップスペースの暗号化に関心がある人にとっては有用かもしれませんが、
必須のものではありません。
</para>
<para>
現在、制約がひとつあります。 cgd デバイスは、 4.2BSD
と記されているスライスただひとつを含んだディスクラベルから作られますが、
これはスワップに使うには不適切です。
これが、 cgd ドライブをスワップデバイスとして使うことが面倒な理由です。
Roland Dowdeswell がこのことを調べており、近い将来解決されるはずです。
</para>
<para>

実際の例を示します:

  スワップデバイス wd0b を、 256 ビット aes-cbc 鍵を使って cgd1
  として設定します。手順の説明は以下のとおりです。

<programlisting>
  1) cgd デバイス用のパラメーターファイルを作ります。デフォルトでは /etc/cgd/wd0b
     になりますが、ここでは説明しやすくするため /etc/cgd/swap を使います。

     # cgdconfig -g -V none -k randomkey aes-cbc > /etc/cgd/swap

  2) wd0b 上の cgd デバイスを設定します (この時点では wd0b
     がスワップデバイスとして使われていないことを確認してください)。

     # cgdconfig cgd1 /dev/wd0b /etc/cgd/swap

  3) cgd1 用にディスクラベルを編集します。妥当なスワップスライスを作る必要があるからです。
     編集したディスクラベルをファイルに保存します。

     # disklabel -e -I cgd1

     # /dev/rcgd1d:
     type: cgd
     disk: cgd
     label: default label
     flags:
     bytes/sector: 512
     sectors/track: 2048
     tracks/cylinder: 1
     sectors/cylinder: 2048
     cylinders: 128
     total sectors: 263655
     rpm: 3600
     interleave: 1
     trackskew: 0
     cylinderskew: 0
     headswitch: 0           # microseconds
     track-to-track seek: 0  # microseconds
     drivedata: 0

     4 partitions:
     #        size    offset     fstype  [fsize bsize cpg/sgs]
      d:    263655         0     4.2BSD      0     0     0   # (Cyl.    0 - 128*)

     スワップスライスを作り、ラベルを変更します (これは本当に必要なわけではなく、
     単に自分用の情報としてのものです)。

     # /dev/rcgd1d:
     type: cgd
     disk: cgd
     label: swap
     flags:
     bytes/sector: 512
     sectors/track: 2048
     tracks/cylinder: 1
     sectors/cylinder: 2048
     cylinders: 128
     total sectors: 263655
     rpm: 3600
     interleave: 1
     trackskew: 0
     cylinderskew: 0
     headswitch: 0           # microseconds
     track-to-track seek: 0  # microseconds
     drivedata: 0

     4 partitions:
     #        size    offset     fstype  [fsize bsize cpg/sgs]
      a:    263655         0       swap                      # (Cyl.    0 - 128*)

    そして、ファイルに保存します。

     # disklabel cgd1 > /etc/cgd/swap.disklabel

  4) cgd デバイスを、ブート時に自動的に設定されるようにします。
     /etc/cgd/cgd.conf に以下の行を追加します。

     cgd1 /dev/wd0b /etc/cgd/swap

  5) ここで、ブート時に新たに作られた cgd デバイスにディスクラベルを書き戻す必要があります。
     以下のような単純な関数が書かれた /etc/rc.conf.d/cgd を作ります。

     swap_device="cgd1"
     swap_disklabel="/etc/cgd/swap.disklabel"
     start_postcmd="cgd_swap"

     cgd_swap()
     {
             if [ -f $swap_disklabel ]; then
                     disklabel -R -r $swap_device $swap_disklabel
             fi
     }

  6) cgd デバイスを、スワップデバイスとして /etc/fstab に追加します。

     /dev/cgd1a none swap sw 0 0</programlisting>

以上ですべてです。これで、 'swapctl -a /dev/cgd1a' または単にリブートすることで、
スワップパーティションを有効化できます。
</para>
<para>

以上でお見せした設定は、筆者のラップトップの設定です。
<programlisting>
   Device      1K-blocks     Used    Avail Capacity  Priority
   /dev/cgd1a     131827     8828   122999     7%    0</programlisting>
</para>
</sect3>
</sect2>

<sect2 id="boot-related">
<title>ブート関連の質問</title>
<sect3 id="why-single-user">
<title>シングルユーザーモードってなに? 必要な理由と使い方は?</title>
<para>
'single-user' モードはカーネルがブートした時の状態で、
コンソール上で1つのシェルが動いています。
シングルユーザーで起動すると、ルートファイルシステムだけが
リードオンリーでマウントされます。
多くのユーザーにとって、シングルユーザーモードは:
<itemizedlist>
<listitem>傷んでる疑いのためにファイルシステムに <code>fsck</code> をかける。</listitem>
<listitem> <code>/etc</code> にある傷んだシステム設定ファイルを編集する。</listitem>
<listitem>ダウンロードあるいは自分でコンパイルした新しいバイナリーセットをインストールする。</listitem>
<listitem>ユーザープロセスからの干渉を気にせずにファイルシステムのバックアップをとる</listitem>
</itemizedlist>
動作中のシステムから、 root 権限で 
 '<code><emphasis role="bold">shutdown now</emphasis></code>' を実行することで、
シングルユーザーモードに入れます。
または、システムの起動中に、
 '-s' フラグを使う(この方法はポートごとによってさまざまです)
ことでもできます。
</para>
<para>
シングルユーザーで起動した場合には、次のようないくつかのコマンドが便利かもしれません:
<itemizedlist>
<listitem><code><emphasis role="bold">fsck -p ; mount -va</emphasis></code><html:br/>
    &man.fsck.8; でファイルシステムをチェックし、それを &man.mount.8; で使える状態にします。
</listitem>
<listitem><code><emphasis role="bold">set -E</emphasis></code><html:br/>
    コマンドライン編集を有効にします。
</listitem>
<listitem><code><emphasis role="bold">TERM=vt220 ; export TERM</emphasis></code><html:br/>
    &man.vi.1; のようなエディターが動作できるように、
    TERM 変数を設定し、 export します。
    注意: コンソールタイプによって 'vt220' を別のターミナルタイプにする必要があります。
</listitem>
<listitem><code><emphasis role="bold">sh /etc/rc.d/network start</emphasis></code><html:br/>
    ネットワークを起動します。
    nfs マウントされたファイルシステムがあるなら、
    fsck と mount の前に実行する必要があるでしょう。
    NetBSD 1.5 より前のシステムの場合は、このコマンドは
    <code><emphasis role="bold">sh /etc/netstart</emphasis></code> にします。
</listitem>
</itemizedlist>
</para>
</sect3>

<sect3 id="single-user-to-multi-user">
<title>どうやって、シングルユーザーからマルチユーザーに移行するの</title>
<para>
シングルユーザーシェルを "exit" か ctrl-D で抜けてください。
</para>
<para>

これで、システムはマルチユーザーモードで起動し、各種サービス等が開始されます。
シングルユーザーからマルチユーザーへの移行の際にはディスクが検査されないことに
注意してください。
</para>
</sect3>

<sect3 id="boot-messages">
<title>ブートメッセージはどうやって読むの?</title>
<para>
システムメッセージバッファーは &man.dmesg.8; で表示できます。
これは(1.4 以降では)いつも起動後ごとにすぐに
 /var/run/dmesg.boot に自動的に貯められます。
カーネルインストールで kernfs ( &man.mount.kernfs.8; を見よ) 
が有効になっているなら、
 <code><emphasis role="bold">more /kern/msgbuf</emphasis></code> もしてください。
</para>
</sect3>

<sect3 id="shutting-down">
<title>どうやって機械をシャットダウンするの?</title>
<para>
シングルユーザーモードに落ちるなら、
 '<emphasis role="bold"><code>shutdown now</code></emphasis>' を使ってください。
機械を停止するのなら
 '<emphasis role="bold"><code>shutdown -h now</code></emphasis>' を使ってください。
いくつかのポートでは、実際に電源を落とすなら
 '<emphasis role="bold"><code>shutdown -p now</code></emphasis>' を使う必要があります。
完全な詳しいことは &man.shutdown.8; マニュアルページを見てください。
</para>
</sect3>

<sect3 id="rebooting">
<title>どうやって、機械をリブートするの?</title>
<para>
'<emphasis role="bold"><code>shutdown -r now</code></emphasis>' か '<emphasis role="bold"><code>reboot</code></emphasis>' を使ってください。
  より細かいことは &man.shutdown.8; や &man.reboot.8; マニュアルページを見てください。
</para>
</sect3>

<sect3 id="cron-reboot">
<title>起動時にプログラムを開始する</title>
<para>
システムのブート時にプログラムを起動するために、 <code>/etc/rc.local</code>
にあらゆるコマンドを追加することができます。これは、ブート過程の
一番最後に実行されます。
</para>
<para>

root 以外の大多数のユーザー向けの代替策として、
( NetBSD で使っている) Vixie &man.cron.8; の特別な時間指定 <emphasis role="bold">@reboot</emphasis>
は、与えられたプログラムを &man.cron.8; 起動時に開始することが可能です。
それはたいてい、システム起動時と一致します。これは root 特権の無いユーザーに、
起動時にコマンドを自動的に実行させることを許しているということです。
</para>
</sect3>
</sect2>

<sect2 id="memory-swap">
<title>メモリー/スワップの構成</title>

<sect3 id="swap">
<title>スワップスペース(空間)はどのくらい</title>
<para>
    古い unix システムでは、RAM の倍ほどの大きさのスワップスペースが推奨されています。
    これはなぜなら RAM のアクティブページは swap 上に配置されていなければならず、
    事実上、 仮想メモリーの合計は、 スワップ空間の大きさによって制限されていたからです。
     NetBSD では、これはもはや正しくなく、仮想メモリー合計は、スワップ + RAM が近似値です。
</para>
    <para>
    NetBSD の下では、スワップ空間は3つの基本的な利用目的があって:
</para>
    <orderedlist>
    <listitem><emphasis role="bold">仮想メモリーの追加</emphasis><html:br/>
	変更されたデータを含むアクティブページが少なくなると、
	物理メモリーより大きく準備された仮想メモリーとして
	データがスワップ空間へ移動することができます。
    </listitem>
    <listitem><emphasis role="bold">カーネルのコアダンプのための場所</emphasis><html:br/>
	これは起動時、 &man.savecore.8; に読まれます。
	これが機能するためには、プライマリースワップパーティションは
	全 RAM 容量よりわずかでも大きい必要があります。
    </listitem>
    <listitem><emphasis role="bold"> &man.mfs.8; ファイルシステムのため</emphasis><html:br/>
	/tmp を使うあらゆるプログラムの高速化のために、
	古典的に /tmp をマウントすることで、
	&man.fstab.5; ファイルに次のように加えることによって:
	<programlisting>	swap  /tmp  mfs  rw,-s=<emphasis>SIZE</emphasis> 0 0</programlisting>
	ここで <emphasis>SIZE</emphasis> は 512byte ブロックのものです。
	この要求されたスペースは、スワップ空間から
	ファイルシステムとして使うために持ってこられます。
    </listitem>
    </orderedlist>
    <para>
    スワップの'正しい'値と言うのは、システムの利用法に依存しますが、
    いくつか一般的なルールがあって:
    <itemizedlist>
    <listitem>基本容量として良いのは、 RAM容量か 32MB の大きい方に
	&man.mfs.8; ファイルシステムの全容量を足した量です。
    </listitem>
    <listitem>&man.X.7; を実行するつもりなら、 RAM 容量の 1/2 か 16MBの大きい方を加えます。
    </listitem>
    <listitem>いつもスワップ帯域が増加するように、
	可能な限り沢山のディスクをまたがるようスワップを分割してみます。
    </listitem>
    <listitem>少ないよりは多いほうがと思います。- スワップを使い果たすと、
	システムは実行しているプロセスを kill させることができます。
    </listitem>
    </itemizedlist>
</para>
</sect3>

<sect3 id="adding-swap">
<title>動作中のシステムにスワップを追加する</title>
<para>
    システムは、
    <ulink url="#swap">スワップスペースはどのくらい</ulink>のとおりの
    充分なスワップ空間が設定されているべきです。
</para>
    <para>
    設定されているシステムにスワップを追加するには3通りの方法があります:
</para>
    <para>
    <orderedlist>
    <listitem><emphasis role="bold">システムディスクを再構築し、大きなスワップパーティションを使います。
	</emphasis><html:br/>
	この方法はおそらく最も美しい解決法ですが、
	明らかに重大な困難を伴います。
    </listitem>
    <listitem><emphasis role="bold">スワップパーティションを追加します。</emphasis><html:br/>
	ディスク追加時に、 小さい 'b' パーティションをスワップの追加のために
	含めるのは、大抵良いアイデアで、
	 <code>/etc/fstab</code> ファイルに 起動時に自動的に有効になるように
	次の形式のエントリーを追加します
	<programlisting>	/dev/<emphasis>DISK</emphasis>b       none    swap sw 0 0</programlisting>
	(ここで、 <code><emphasis>DISK</emphasis></code> は 'sd1' や 'wd2' のような ディスクの名前です).
    </listitem>
    <listitem><para><emphasis role="bold">スワップファイルを作ります。</emphasis></para><para>
	もっとも早く、簡単な選択は、
	存在するファイルシステムにファイルをつくり、
	追加スワップ空間として使うことです。
	これをアクセスすることは、
	専用のスワップパーティションをアクセスするよりわずかながら
	遅いでしょうが、
	 (フラグメンテーションやファイルシステムオーバーヘッドによる)
	スワップの不足を解決する一時的なものとしてはよいでしょう。
	</para>
	<para>
	10 MByte のスワップ空間を追加することは、
	充分な空き空間のあるファイルシステムを選ぶだけの簡単なことで:
	<programlisting>	# <emphasis role="bold">dd if=/dev/zero bs=1m count=10 of=/somefilesystem/swap</emphasis>
	# <emphasis role="bold">chmod 600 /somefilesystem/swap</emphasis>
	# <emphasis role="bold">swapctl -a -p 1 /somefilesystem/swap</emphasis></programlisting>
	&man.dd.1; コマンド が 10 MByte の
	`<code>/somefilesystem/swap</code>' ファイルをつくります。
	このスワップファイルは、特権のないユーザーが
	その内容を読めないように、 &man.chmod.1; 600 をする必要があります
	(&man.swapctl.8; は誰でも読めるファイルは拒否します) 。
	そして、 &man.swapctl.8; コマンドは 
	<code>/somefilesystem/swap</code> を
	優先度 1 のシステムスワップ領域として加えます。
	優先度 0 が (デフォルトの) 最も高い優先度です。
	優先度 1 にする理由は、ファイルへのスワップはわずかに遅いので、
	これを使うのは従来型のスワップを使い切ったときだけにしたいからです。
	</para>
	<para>
	このファイルをずっとスワップとして使うようにし、
	リブートの都度有効にするため、 /etc/fstab
	に以下のように書いておきます:
	</para>
	<programlisting>/somefilesystem/swap none swap sw,priority=1 0 0</programlisting>
    </listitem>
    </orderedlist>
</para>
</sect3>
<sect3 id="tuning-vm">
<title>メモリーが少ないシステムでの性能改善のための仮想メモリーの調整</title>
<para>
tech-kern メーリングリストの <ulink url="http://mail-index.NetBSD.org/tech-kern/2002/11/27/0005.html">
Simon Burge の記事</ulink>によれば、仮想メモリーの設定に手を加えることで、
メモリーの少ないマシンの性能を大幅に改善することができます。
この記事をすべて読んだうえで、どう設定すべきか決めることが最善ではありますが、
要点は、 <code>sysctl -w vm.anonmax=95</code> を実行するとよいということです。 &man.sysctl.3;
マニュアルページによれば、これは「匿名アプリケーションデータを保持するために、
他のメモリーの用途から取り戻される物理メモリーのパーセンテージ」を変更します。
</para>
</sect3>
</sect2>

<sect2 id="other-questions">
<title>その他の疑問</title>

<sect3 id="editing-files">
<title> NetBSD でのファイル編集</title>
<para>
基本システムには2通りの明らかな選択肢があって:
<itemizedlist>
<listitem>&man.ed.1; (Line 指向 のテキストエディター)<html:br/>
    <code>ed</code> は非常に単純なテキストエディターです。
    これには、コマンドモード(起動時に選択されている)と
    入力(インプット)モードがあります。

    その一番の利点は、 '/' ファイルシステムだけがマウントされた
    シングルユーザーモードでも存在していて、
    正しいターミナルタイプに設定されていなくても動作することです。

     &man.ed.1; の基本的な理解をすることは、価値のあることで、
    - 非常時に、 &man.fstab.5; と &man.rc.conf.5; ファイルを直すのに充分です。</listitem>
<listitem>&man.vi.1; (Screen 指向のテキストエディター)<html:br/>
    <code>vi</code> は &man.ex.1; のコマンドモードとインプットモードを持ち、
    だが、フルスクリーンビジュアルインターフェースが加えられています。

    vi は基本インストールで存在する唯一のスクリーンエディターで、
    実行には、妥当なターミナルタイプが要求されます。<html:br/>
    たくさんのオンラインの vi チュートリアル(個人指導)があって:
    <itemizedlist>
    <listitem><pkg>editors/vilearn</pkg> - pkgsrc にあって、高く推奨します。</listitem>
    <listitem><ulink url="http://www.thomer.com/vi/vi.html">
	VI 愛好者ホームページ(英文)</ulink>.</listitem>
    <listitem><ulink url="https://engineering.purdue.edu/ECN/Resources/KnowledgeBase/Categories/editors/vi/">Purdue
	University Engineering Computer Network</ulink>.</listitem>
    <listitem><ulink url="http://engr.smu.edu/co/help/vi-tutorial.html">
	Southern Methodist University のいくつかの参考文献</ulink>.
    </listitem>
    </itemizedlist>
    &man.rc.conf.5; の設定に vi を使うことを試みるなら、
    <ulink url="#why-single-user">シングルユーザーモード</ulink> の
    項目を読むべきです。
    </listitem>
</itemizedlist>
<para>
pkgsrc の <pkg>editors</pkg> カテゴリーには、沢山の数のエディターがあって:
</para>
<itemizedlist>
<listitem><emphasis role="bold"><pkg>editors/joe</pkg></emphasis><html:br/>
    WordStar と emacs のキー割り当て (<emphasis>jstar</emphasis>, <emphasis>jmacs</emphasis>) を
    エミュレートできる小さくて高速なエディター
    <pkg>editors/joe</pkg> は Borland IDE を使う人達に知られているでしょう。
    </listitem>
<listitem><emphasis role="bold"><pkg>editors/pico</pkg></emphasis><html:br/>
    非常にシンプルに使えるテキストエディターで、
    <pkg>mail/pine</pkg> メール パッケージで使われています。
    </listitem>
<listitem><emphasis role="bold"><pkg>editors/nedit</pkg></emphasis><html:br/>
    シンプルだけど便利な、融通の利く X ベースの GUI エディター。
    </listitem>
<listitem><emphasis role="bold"><pkg>editors/emacs</pkg></emphasis><html:br/>
    ことわざにある 'なんでもかんでも (everything and the kitchen sink)'
    なエディターで、完全な lisp インタープリターを含みます。
    小さな機械には推奨されません。
    </listitem>
</itemizedlist>

</para>
</sect3>

<sect3 id="rebuilding-dev">
<title>/dev の再構築</title>
<para>
 /dev ディレクトリーには、
ハードウェアと 擬似デバイスをアクセスするために必要な
デバイスファイルが含まれています。
もしそれが、ダメージを受けていれば、

もっと不思議なことが結果として起こるでしょう。<html:br/>
 /dev ディレクトリーを再構築するには、
まずシングルユーザーで起動するべきです
 (マルチユーザーででもできるかもしれないが、推奨しません)。そして:
<programlisting>
mkdir /newdev
cd /newdev
cp /dev/M* .
sh MAKEDEV all
cd /
mv dev olddev; mv newdev dev
rm -r olddeV</programlisting>
</para>
</sect3>

<sect3 id="connecting-a-ups">
<title>NetBSD システムに UPS をつなぐ</title>
<para>
UPS をつなぐのは単純なことだけど、
監視して、電源が落ちたときに、
きちんと NetBSD をシャットダウンするには、ちょっとした事が必要で:<html:br/>
Simon J. Gerraty は
<ulink url="http://www.crufty.net/sjg/apcmon.html">APC Smart-UPS</ulink> を使うための
ページを開設しています。
UPS と通信するソフトウェアを書くには、 tcsetattr() 経由で
 softcar フラグを設定する必要があるでしょう。
Wolfgang Rupprecht は、簡単なフィールド調査をしました:
</para>
<para>
<blockquote>
UPS インターフェースは異なる2種類の型があって、
ときどき、同じ UPS に両方存在しています。
UPS についている 9ピンのコネクターには、決して、普通の PC-style RS-232 として配線しないでください。
最善のものは、 3芯で、それを保つようにピンを再配置した RS-232 インターフェースです。
最悪なのは、内部信号端子(??)が RS-232 の 信号電圧 ですらなく、
変わったケーブルを使う必要のあるもので、
そのケーブルは電圧レベル変換装置がついていて、
それによってRS-232 ポートから見えるようになっているものです。
後者の型のインターフェースからの信号は、
1bit(通常/電源断)の信号を送出するだけです。
それは DCD のような モデム制御信号 で処理されるべきで、
プログラム経由でモデム制御信号の状態をチェックして検出するべきです。
注意しないと、 UPS に付いてきた、モデム制御信号だけのケーブルと
本物の RS-232 ケーブルがごっちゃになってしまいます。
<html:br/><html:br/>
 APC web page を捜しまわったり、
 altavista でいくつか当たった有望なものによると、
 3 つの基本的なインターフェースがあることがわかりました。

  低価格帯の UPS ("back UPS") は
 モデムコントロールライン タイプのインターフェースだけを持っています。

高価格帯の2つ ("Back UPS Pro", "Smart UPS") は
モデムコントロールラインと 3芯 RS-232 信号の両方の組み合わせを持っています。
どちらかのケースでは、
2つのうちのどらちかの種類の特殊ケーブルを使う必要があります。

モデムコントロールラインインターフェースのケーブルには、
レベルシフトのためにトランジスターとダイオードが入っています。
(電源はほかの線のどれかからとってきます)。

それは UGLY という単語がぴったりだと思えるほど
本当にぶざまな解決法で、正しく変更するべきです。(???)

2番目のタイプのケーブルは、 UPS とシリアルで会話できるでしょうが、
いくつかの 3-rd party のドキュメントには、 UPS は
ストップビットを2ビットで送信する時だけ喋ると示されています。	

プロトコルに関する公式ドキュメントは無いようで、
また、 back-UPS pro と smart UPS は異なるシリアルラインプロトコルを
喋るようです。

 back-UPS pro ラインだけが いくつかの サードパーティー のサポートがあるようで、
プロトコルの詳細の多くが推測だけのようです。
<html:br/><html:br/>
競合品のどれもが、 (modem コントロール信号 だけ、および、
特殊ケーブルで(知的財産)権利のある シリアル信号プロトコル)を真似しているようです。
  私は、標準規格についての公開された文書を見つけることができませんでした。
</blockquote>
</para>
</sect3>

<sect3 id="changing-motd">
<title><code>/etc/motd</code> を何らかの変更をしてももとの内容に戻ってしまいます</title>
<para>
<code>/etc/motd</code> のヘッダーを消すと、
起動時にスタートアッププロセスがあなたのした変更を上書きします。
これは、 <code>/etc/rc.conf</code> 内で <code>update_motd=NO</code> と
設定することで無効にすることができ、
これで、<code>/etc/motd</code> にはまったく手が加わらなくなり、
あなたが、変更することができるようになります。

</para>
</sect3>

<sect3 id="selling-hardware">
<title>どこへ NetBSD 関連のハードウェアを売ればいいの?</title>
<para>
補助アイテムのために、一般的に、
その port の <ulink url="../../MailingLists/">メーリングリスト</ulink> と、
 <ulink url="mailto:netbsd-forsale@mono.org">netbsd-forsale@mono.org</ulink> 
に投稿することができます。<html:br/>
NetBSD の開発を支援するために何らかのハードウェアを寄付したいのなら、
 <ulink url="../../contrib/hardware.html">ハードウェア寄付ページ</ulink> をチェックするか、
 <ulink url="mailto:finance-exec@NetBSD.org">finance-exec@NetBSD.org</ulink> に連絡してください。
</para>
</sect3>

<sect3 id="setup-ccd">
<title>ストライプ (ccd) ドライブを設定する</title>
<para>

ディスクストライピングは、 NetBSD では RAIDframe または &man.ccd.4; を使っておこなうことができます。
ここでは &man.ccd.4; の使い方を説明します。

<orderedlist>
<listitem>全てのディスクに disklabel をつけます:<html:br/>
結合したいパーティションをつくり、
開始オフセットを 確かめます
( 16 セクターでまったく充分 - 確信しているわけじゃないけど)。

この種の問題が起こっても、私にはわかりません。
"普通の" 4.2BSD パーティション を使っているので。
</listitem>   
<listitem>ccd を設定します。<html:br/>
性能チューニングで、
最も良いインターリーブを見つけるために少し試してみる必要があるでしょう。
私の場合、2つのディスクで 48 が良く動作します。

私が知る限り、16 かいくつかのほかの数字では、
全ての inode が同じディスク上に存在してしまうので、
パフォーマンス向上にはならないでしょう。
私の記憶が確かなら、
コンポーネントのセクター数をインターリーブの倍数にしないと、
いくつかの問題がありました。
</listitem>   
   
<listitem>普通のハードディスクと同様に ccd に disklabel を書きます。</listitem>
<listitem>ccd を newfs します。</listitem>
<listitem>それをマウントします。</listitem>
</orderedlist>
</para>
<para>
より詳しい情報は &man.ccd.4; と &man.ccdconfig.8; のマニュアルページを見てください。
</para>
</sect3>
</sect2>

<sect2 id="other-links">
<title>他のリンク</title>

<sect3 id="mreriksson">
<title><ulink url="http://www.mreriksson.net/faqs/netbsd/">Ola Eriksson の NetBSD FAQ</ulink></title>
</sect3>

<sect3 id="cynjut">
<title><ulink url="http://cynjut.neonramp.com/">*BSD FAQ site</ulink> (もはやあまり手入れがされていません)</title>
</sect3>

<sect3 id="japanese-language-support">
<title><ulink url="http://www.daemonnews.org/200202/japanese-netbsd.html">NetBSD の日本語サポート</ulink></title>
</sect3>

</sect2>
</sect1>

</webpage>
