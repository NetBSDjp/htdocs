<!-- $NetBSD: chapter.xml,v 1.2 2003/05/24 04:12:27 grant Exp $ -->

<chapter id="build"> <?dbhtml filename="build.html"?>
<title>The build process</title>
<para>
The basic steps for building a program are always the same.  First the
program's source (distfile) must be brought to the local system and
then extracted.  After any patches to compile properly on NetBSD are
applied, the software can be configured, then built (usually by
compiling), and finally the generated binaries etc.  can be put into
place on the system.  These are exactly the steps performed by the
NetBSD package system, which is implemented as a series of targets in
a central Makefile, <filename>pkgsrc/mk/bsd.pkg.mk</filename>.
</para>

<sect1 id="build.prefix">
<title>Program location</title>
<para>
Before outlining the process performed by the NetBSD package system in the
next section, here's a brief discussion on where programs are installed,
and which variables influence this.
</para>

<para>
The automatic variable <varname>PREFIX</varname> indicates where all files
of the final program shall be installed.  It is usually set to
<varname>LOCALBASE</varname> (<filename>/usr/pkg</filename>), or
<varname>CROSSBASE</varname> for pkgs in the <quote>cross</quote>
category, though its value becomes that of <varname>X11BASE</varname> if
<varname>USE_IMAKE</varname> or <varname>USE_X11BASE</varname> is set.
The value of <varname>PREFIX</varname> needs to be put into the various
places in the program's source where paths to these files are encoded
<!-- XXX ; see sections 4.3 and 6.2 for details on this. -->
</para>

<para>
When choosing which of these variables to use, follow the following rules:
</para>

<itemizedlist>
<listitem>
<para>
<varname>PREFIX</varname> always points to the location where the current
pkg will be installed.  When referring to a pkg's own installation path,
use <quote>${PREFIX}</quote>.
</para>
</listitem>

<listitem>
<para>
<varname>LOCALBASE</varname> is where all non-X11 pkgs are installed.
If you need to construct a -I or -L argument to the compiler to find
includes and libraries installed by another non-X11 pkg, use
<quote>${LOCALBASE}</quote>.
</para>
</listitem>

<listitem>
<para>
<varname>X11BASE</varname> is where the actual X11 distribution (from
xsrc etc.) is installed.  When looking for _standard_ X11 includes (not
those installed by a pkg), use <quote>${X11BASE}</quote>.
</para>
</listitem>

<listitem>
<para>
X11 based pkgs are special in that they may be installed in either
<varname>X11BASE</varname> or <varname>LOCALBASE</varname>. To install X11
packages in <varname>LOCALBASE</varname>, simply install
<pkg>pkgtools/xpkgwedge</pkg>. If you need to find includes or libraries
installed by a pkg that has <varname>USE_IMAKE</varname> or
<varname>USE_X11BASE</varname> in its pkg Makefile, you need to use _both_
<quote>${X11BASE}</quote> and <quote>${LOCALBASE}</quote>.
</para>
</listitem>

<listitem>
<para>
<varname>X11PREFIX</varname> should be used to refer to the installed
location of an X11 package. <varname>X11PREFIX</varname> will be set to
<varname>X11BASE</varname> if xpkgwedge is not installed,
and to <varname>LOCALBASE</varname> if xpkgwedge is installed.
</para>
</listitem>

<listitem>
<para>
If xpkgwedge is installed, it is possible to have some packages installed
in <varname>X11BASE</varname> and some in <varname>LOCALBASE</varname>.
To determine the prefix of an installed package, the
<varname>EVAL_PREFIX</varname> definition can be used. It takes pairs in the
format <quote>DIRNAME=&lt;package&gt;</quote>, and the make(1) variable
<varname>DIRNAME</varname> will be set to the prefix of the installed
package &lt;package&gt;, or <quote>${X11PREFIX}</quote> if the package is
not installed.
</para>

<para>
This is best illustrated by example.
</para>

<para>
The following lines are taken from
<filename>pkgsrc/wm/scwm/Makefile</filename>:
</para>

<programlisting>EVAL_PREFIX+=		GTKDIR=gtk+
CONFIGURE_ARGS+=	--with-guile-prefix=${LOCALBASE}	\
			--with-gtk-prefix="${GTKDIR}"		\
			--enable-multibyte</programlisting>

<para>
Specific defaults can be defined for the packages evaluated using
<varname>EVAL_PREFIX</varname>, by using a definition of the form:
</para>

<programlisting>GTKDIR_DEFAULT= ${LOCALBASE}</programlisting>

<para>
where <varname>GTKDIR</varname> corresponds to the first definition in
the <varname>EVAL_PREFIX</varname> pair.
</para>
</listitem>
</itemizedlist>

</sect1>

<sect1>
<title>Main targets</title>
<para>
The main targets used during the build process defined in
<filename>bsd.pkg.mk</filename> are:
</para>

<itemizedlist>
<listitem>
<para>fetch</para>
<para>
   This will check if the file(s) given in the variables
   <varname>DISTFILES</varname> and <varname>PATCHFILES</varname> (as
   defined in the package's Makefile) are present on the
   local system in <filename>/usr/pkgsrc/distfiles</filename>. If they
   are not present, an attempt will be made to fetch them using commands
   of the form:
</para>

<programlisting>${FETCH_CMD} ${FETCH_BEFORE_ARGS} ${site}${file} ${FETCH_AFTER_ARGS}</programlisting>

<para>
   where ${site} varies through several possibilities in turn: first,
   <varname>MASTER_SITE_OVERRIDE</varname> is tried, then the sites
   specified in either <varname>SITES_file</varname> if defined, else
   <varname>MASTER_SITES</varname> or <varname>PATCH_SITES</varname>, as
   applies, then finally the value of
   <varname>MASTER_SITE_BACKUP</varname>. The order of all except the
   first can be optionally sorted by the user, via setting either
   <varname>MASTER_SORT_AWK</varname> or
   <varname>MASTER_SORT_REGEX</varname>.
</para>
</listitem>

<listitem>
<para>checksum</para>
<para>
   After the distfile(s) are fetched, their checksum is generated and
   compared with the checksums stored in the distinfo file. If the
   checksums don't match, the build is aborted. This is to ensure the same
   distfile is used for building, and that the distfile wasn't changed,
   e.g. by some malign force, deliberately changed distfiles on the master
   distribution site or network lossage.
</para>
</listitem>

<listitem>
<para>extract</para>
<para>
   When the distfiles are present on the local system, they need to be
   extracted, as they are usually in the form of some compressed archive
   format, most commonly <filename>.tar.gz</filename>. If only some of
   the distfiles need to be uncompressed, the files to be uncompressed
   should be put into <varname>EXTRACT_ONLY</varname>. If the distfiles
   are not in <filename>.tar.gz</filename> format, they can be
   extracted by setting <varname>EXTRACT_CMD</varname>,
   <varname>EXTRACT_BEFORE_ARGS</varname> and/or
   <varname>EXTRACT_AFTER_ARGS</varname>. 
</para>
</listitem>

<listitem>
<para>patch</para>
<para>
   After extraction, all the patches named by the
   <varname>PATCHFILES</varname>, those present in the patches
   subdirectory of the package as well as in $LOCALPATCHES/$PKGPATH (e.g.
   <filename>/usr/local/patches/graphics/png</filename>) are applied.
   Patchfiles ending in <filename>.Z</filename> or
   <filename>.gz</filename> are uncompressed before they are applied,
   files ending in <filename>.orig</filename> or
   <filename>.rej</filename> are ignored. Any special options to patch(1)
   can be handed in <varname>PATCH_DIST_ARGS</varname>.
   <!-- XXX See section 4.3 for more details. -->
</para>

<para> 
   By default patch is given special args to make it fail if the
   patches with some lines of fuzz. Please fix (regen) the patches
   so that they apply cleanly. The rationale behind this is that
   patches that apply cleanly may end up being applied in the wrong
   place, and cause severe harm there.
</para> 
</listitem>

<listitem>
<para>configure</para>
<para>
   Most pieces of software need information on the header files,
   system calls, and library routines which are available in NetBSD. 
   This is the process known as configuration, and is usually
   automated.  In most cases, a script is supplied with the source,
   and its invocation results in generation of header files,
   Makefiles, etc.
</para>

<para>
   If the program's distfile contains its own configure script, this can
   be invoked by setting <varname>HAS_CONFIGURE</varname>. If the
   configure script is a GNU autoconf script,
   <varname>GNU_CONFIGURE</varname> should be specified instead. In either
   case, any arguments to the configure script can be specified in the
   <varname>CONFIGURE_ARGS</varname> variable, and the configure script's
   name can be set in <varname>CONFIGURE_SCRIPT</varname> if it differs
   from the default <quote>configure</quote>.
</para>

<para>
   If the program uses an Imakefile for configuration, the appropriate
   steps can be invoked by setting <varname>USE_IMAKE</varname> to
   <quote>YES</quote>. (If you only want the package installed in
   <varname>$X11PREFIX</varname> but xmkmf not being run, set
   <varname>USE_X11BASE</varname> instead!)
</para>
</listitem>

<listitem>
<para>build</para>
<para>
   Once configuration has taken place, the software can be built on
   NetBSD by invoking <varname>$MAKE_PROGRAM</varname> on
   <varname>$MAKEFILE</varname> with <varname>$ALL_TARGET</varname> as
   the target to build.  The default <varname>MAKE_PROGRAM</varname> is
   <quote>gmake</quote> if <varname>USE_GMAKE</varname> is set,
   <quote>make</quote> otherwise. <varname>MAKEFILE</varname> is set to
   <quote>Makefile</quote> by default, and <varname>ALL_TARGET</varname>
   defaults to <quote>all</quote>.  Any of these variables can be set to
   change the default build process.
</para>
</listitem>

<listitem>
<para>install</para>
<para>
   Once the build stage has completed, the final step is to install
   the software in public directories, for users.  As in the
   build-target, <varname>$MAKE_PROGRAM</varname> is invoked on
   <varname>$MAKEFILE</varname> here, but with the
   <varname>$INSTALL_TARGET</varname> instead, the latter defaulting to
   <quote>install</quote> (plus <quote>install.man</quote>, if
   <varname>USE_IMAKE</varname> is set). 
</para>
</listitem>
</itemizedlist>

<para>
If no target is specified, the default is <quote>build</quote>. If a
subsequent stage is requested, all prior stages are made: e.g.
<command>make build</command> will also perform the equivalent of:
</para>

<programlisting>make fetch
make checksum
make extract
make patch
make configure
make build</programlisting>

</sect1>

<sect1>
<title>Other helpful targets</title>
<itemizedlist>

<listitem>
<para>pre/post-*</para>
<para>
   For any of the main targets described in the previous section, two
   auxiliary targets exist with <quote>pre-</quote> and
   <quote>post-</quote> used as a prefix
   for the main target's name.  These targets are invoked before and
   after the main target is called, allowing extra configuration or
   installation steps, for example, which program's configure script
   or install target omitted.
</para>
</listitem>

<listitem>
<para>do-*</para>
<para>
   Should one of the main targets do the wrong thing, and should there
   be no variable to fix this, you can redefine it with the do-*
   target.  (Note that redefining the target itself instead of the
   do-* target is a bad idea, as the pre-* and post-* targets won't be
   called anymore, etc.) You will not usually need to do this.
</para>
</listitem>

<listitem>
<para>reinstall</para>
<para>
   If you did a <command>make install</command> and you noticed some file
   was not installed properly, you can repeat the installation with this
   target, which will ignore the <quote>already installed</quote> flag.
</para>
</listitem>

<listitem>
<para>deinstall</para>
<para>
   This target does a pkg_delete(1) in the current directory,
   effectively de-installing the package. The following variables can
   be used either on the command line or in
   <filename>/etc/mk.conf</filename> to tune the behaviour:
</para>

	<itemizedlist>
	<listitem>
	<para>PKG_VERBOSE</para>
	<para>Add a "-v" to the pkg_delete(1) command.</para>
	</listitem>

	<listitem>
	<para>DEINSTALLDEPENDS</para>
	<para>
      Remove all packages that require (depend on) the given package.
      This can be used to remove any packages that may have been pulled in
      by a given package, e.g. if <command>make deinstall
      DEINSTALLDEPENDS=1</command> is done in
      <filename>pkgsrc/x11/kde</filename>, this is likely to remove whole
      KDE. Works by adding <quote>-R</quote> to the pkg_delete command line.
	</para>
	</listitem>
	</itemizedlist>

</listitem>

<listitem>
<para>update</para>
<para>
   This target causes the current package to be updated to the latest
   version.  The package and all depending packages first get de-installed,
   then current versions of the corresponding packages get compiled and
   installed.  This is similar to manually noting which packages are
   currently installed, then performing a series of <quote>make
   deinstall</quote> and <quote>make install</quote> (or whatever
   <varname>UPDATE_TARGET</varname> is set to) for these packages.
</para>

<para>
   You can use the <quote>update</quote> target to resume package
   updating in case a previous <quote>make update</quote> was interrupted
   for some reason.  However, in this case, make sure you don't call
   <quote>make clean</quote> or otherwise remove the list of dependent
   packages in <varname>${WRKDIR}</varname>.  Otherwise you lose the
   ability to automatically update the current package along with the
   dependent packages you have installed.
</para>

<para>
   Resuming an interrupted <quote>make update</quote> will only work as
   long as the package tree remains unchanged.  If the source code for
   one of the packages to be updated has been changed, resuming
   <quote>make update</quote> will most certainly fail!
</para>

<para>
   The following variables can be used either on the command line or in
   <filename>/etc/mk.conf</filename> to alter the behaviour of
   <quote>make update</quote>:
</para>

<!-- XXX -->

    - UPDATE_TARGET:
      Install target to recursively use for the updated package and the
      dependent packages.  Defaults to ${DEPENDS_TARGET} if set, "install"
      otherwise for "make update".
      E.g. "make update UPDATE_TARGET=package"

    - NOCLEAN:
      Don't clean up after updating.  Useful if you want to leave the
      work sources of the updated packages around for inspection or
      other purposes.  Be sure you eventually clean up the source
      tree (see the "clean-update" target below) or you may run into
      troubles with old source code still lying around on your next
      "make" or "make update".

    - REINSTALL:
      Deinstall each package before installing (making ${DEPENDS_TARGET}).
      This may be necessary if the "clean-update" target (see below) was
      called after interrupting a running "make update".

    - DEPENDS_TARGET:
      Allows you to disable recursion and hardcode the target for
      packages.  The default is "update" for the update target,
      facilitating a recursive update of prerequisite packages.
      Only set DEPENDS_TARGET if you want to disable recursive updates.
      Use "UPDATE_TARGET" instead to just set a specific target for
      each package to be installed during "make update" (see above).

</listitem>

<listitem>
<para>clean-update</para>
<para>
   Clean the source tree for all packages that would get updated if
   <quote>make update</quote> was called from the current directory.
   This target should not be used if the current package (or any of its
   depending packages) have already been de-installed (e.g., after calling
   <quote>make update</quote>) or you may lose some packages you intended
   to update. As a rule of thumb: only use this target
   <emphasis>before</emphasis> the first time you call
   <quote>make update</quote> and only if you have a dirty package tree
   (e.g., if you used <varname>NOCLEAN</varname>).
</para>

<para>
   If you unsure about whether your tree is clean you can either perform
   a <quote>make clean</quote> at the top of the tree, or use the
   following sequence of commands from the directory of the package you
   want to update (<emphasis>before</emphasis> running
   <quote>make update</quote> for the first time, otherwise you lose
   all the packages you wanted to update!):
</para>

<programlisting>make clean-update
make clean CLEANDEPENDS=YES
make update</programlisting>

<para>
   The following variables can be used either on the command line or in
   <filename>/etc/mk.conf</filename> to alter the behaviour of
   <command>make clean-update</command>:
</para>

   <itemizedlist>
   <listitem><para>CLEAR_DIRLIST</para>
   <para>
   After <quote>make clean</quote>, do not reconstruct the list of
   directories to update for this package.  Only use this if <quote>make
   update</quote> successfully installed all packages you wanted to
   update.  Normally, this is done automatically on <quote>make
   update</quote>, but may have been suppressed by the
   <varname>NOCLEAN</varname> variable (see above).
   </para>
   </listitem>
   </itemizedlist>

</listitem>

<listitem>
<para>info</para>
<para>
   This target invokes <command>pkg_info</command> for the current
   package. You can use this e.g. to check which version of a package is
   installed.
</para>
</listitem>

<listitem>
<para>readme</para>
<para>
   This target generates a <filename>README.html</filename> file, which
   can be viewed using a browser such as <pkg>www/navigator</pkg> or
   <pkg>www/lynx</pkg>. The generated files contain references to any
   packages which are in the <varname>${PACKAGES}</varname> directory on
   the local host. The generated files can be made to refer to URLs based on
   <varname>FTP_PKG_URL_HOST</varname> and
   <varname>FTP_PKG_URL_DIR</varname>. For example, if I wanted to generate
   <filename>README.html</filename> files which pointed to binary packages
   on the local machine, in the directory
   <filename>/usr/packages</filename>, set
   <varname>FTP_PKG_URL_HOST=file://localhost</varname> and
   <varname>FTP_PKG_URL_DIR=/usr/packages</varname>. The
   <varname>${PACKAGES}</varname> directory and its subdirectories will be
   searched for all the binary packages.
</para>
</listitem>

<listitem>
<para>readme-all</para>
<para>
   Use this target to create a file <filename>README-all.html</filename>
   which contains a list of all packages currently available in the NetBSD
   Packages Collection, together with the category they belong to and a
   short description. This file is compiled from the
   <filename>pkgsrc/*/README.html</filename> files, so be sure to run
   this <emphasis>after</emphasis> a <command>make readme</command>.
</para>
</listitem>

<listitem>
<para>cdrom-readme</para>
<para>
   This is very much the same as the <quote>readme</quote> target (see
   above), but is to be used when generating a pkgsrc tree to be written
   to a CD-ROM.  This target also produces
   <filename>README.html</filename> files, and can be made to refer
   to URLs based on <varname>CDROM_PKG_URL_HOST</varname> and
   <varname>CDROM_PKG_URL_DIR</varname>.
</para>
</listitem>

<listitem>
<para>show-distfiles</para>
<para>
   This target shows which distfiles and patchfiles are needed to build
   the package. (<varname>DISTFILES</varname> and
   <varname>PATCHFILES</varname>, but not patches/*)
</para>
</listitem>

<listitem>
<para>show-downlevel</para>
<para>
   This target shows nothing if the package is not installed. If a version
   of this package is installed, but is not the version provided in this
   version of pkgsrc, then a warning message is displayed. This target can
   be used to show which of your installed packages are downlevel, and so
   the old versions can be deleted, and the current ones added.
</para>
</listitem>

<listitem>
<para>show-pkgsrc-dir</para>
<para>
   This target shows the directory in the pkgsrc hierarchy from which the
   package can be built and installed. This may not be the same directory
   as the one from which the package was installed. This target is intended
   to be used by people who may wish to upgrade many packages on a single
   host, and can be invoked from the top-level pkgsrc Makefile by using the
   <quote>show-host-specific-pkgs</quote> target.
</para>
</listitem>

<listitem>
<para>show-installed-depends</para>
<para>
   This target shows which installed packages match the current package's
   <varname>${DEPENDS}</varname>. Useful if out of date DEPENDS are
   causing build problems.
</para>
</listitem>

<listitem>
<para>check-shlibs</para>
<para>
   After a package is installed, check all its binaries and (on ELF 
   platforms) shared libraries to see if they find the shared libs they need.
   Run by default if <varname>PKG_DEVELOPER</varname> is set in
   <filename>/etc/mk.conf</filename>.
</para>
</listitem>

<listitem>
<para>print-PLIST</para>
<para>
   After a <quote>make install</quote> from a new or upgraded pkg, this
   prints out an attempt to generate a new <filename>PLIST</filename> from
   a <command>find -newer work/.extract_done</command>.
   An attempt is made to care for shared libs etc., but it is STRONGLY 
   recommended to review the result before putting it into
   <filename>PLIST</filename>. On upgrades, it's useful to diff the output
   of this command against an already existing <filename>PLIST</filename>
   file.
</para>

<para>
   If the package installs files via tar(1) or other methods that don't
   update file access times, be sure to add these files manually to your
   <filename>PLIST</filename>, as <quote>find -newer</quote> won't catch
   them!
</para>
</listitem>

<listitem>
<para>bulk-package</para>
<para>
   Used to do bulk builds. If an appropriate binary package already exists,
   no action is taken. If not, this target will compile, install and
   package it (and it's depends, if <varname>PKG_DEPENDS</varname> is
   set properly. <!-- , see section 3.2.1). --> After creating the binary
   package, the sources, the just-installed package and it's required
   packages are removed, preserving free disk space. 
</para>
</listitem>

<listitem>
<para>bulk-install</para>
<para>
   Used during bulk-installs to install required packages. If an
   appropriate binary package is available, it will be installed via
   pkg_add. If not, <command>make bulk-package</command> will be executed,
   but the installed binary not be removed. A binary package is
   <quote>appropriate</quote> to be installed via <command>pkg_add</command>
   if:
</para>

   <itemizedlist>
   <listitem>None of the package's files (<filename>Makefile</filename>,
      ...) were modified since it was built.</listitem>
   <listitem>None of the package's required (binary) packages were
      modified since it was built.</listitem>
   </itemizedlist>

</listitem>
</itemizedlist>

</sect1>

</chapter>
