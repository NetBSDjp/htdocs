<!-- $NetBSD: chapter.xml,v 1.7 2003/12/14 15:56:15 hrs Exp $ -->
<!-- Based on english version: -->
<!-- NetBSD: chapter.xml,v 1.7 2003/12/14 15:56:15 hrs Exp   -->

<chapter id="build">
  <title>構築の手順</title>

  <para>プログラムを構築するための基本的な手順は常に同じです。最初に、プログラムの
    ソースファイル(<emphasis>distfile</emphasis>)をローカルシステムへ持ってきて展開します。&os;
    上でコンパイルするためのいくつかのパッチを適用した後に、ソフトウェアを設定
    し、構築(通常、コンパイルすることによって)します。最後に作成されたバイナリー
    等を、システムにインストールします。これはまさに&os;パッケージシステム
    によって実行される手順です。この手順は、中心となるMakefile、
    <filename>pkgsrc/mk/bsd.pkg.mk</filename>の中で一連のターゲットとして実装されています</para>

  <sect1 id="build.prefix">
    <title>プログラムの場所</title>

    <para>次のセクションで&os;パッケージシステムによって実行される手順の概略を述
      べる前に、プログラムがインストールされる場所、その場所に影響をおよぼす変数
      について簡単に記述します。</para>

    <para>自動変数<varname>PREFIX</varname>は、最終的にプログラムのすべてのファイルがインストールされる
      場所をしめします。通常、<varname>LOCALBASE</varname> (<filename>/usr/pkg</filename>)、または<quote>cross</quote>カテゴリーの
      パッケージのための<varname>CROSSBASE</varname>と同じ場所になっています。もし<varname>USE_IMAKE</varname> あるい
      は<varname>USE_X11BASE</varname>が定義されていれば、その値は<varname>X11BASE</varname>と同じになります。
      <varname>PREFIX</varname>の値は、プログラムのソース中でこれらのファイルが符号化されるさまざ
      まな場所に使用されるべきです。
      詳細に関しては、<xref linkend="components.patches"/>および<xref
	linkend="fixes.libtool"/>を参照して下さい。</para>

    <para>これらの変数のどれかを選択し使用する場合には、
      以下のルールに従ってください。</para>

    <itemizedlist>
      <listitem>
	<para><varname>PREFIX</varname>は常に現在のパッケージがインストールされる場所を指します。パッ
	  ケージ自身のインストール先のパスを参照する時に、<quote>${PREFIX}</quote>を使用してくだ
	  さい。</para>
      </listitem>

      <listitem>
	<para><varname>LOCALBASE</varname>は、すべての非X11パッケージがインストールされる場所です。他
	  の非X11パッケージによってインストールされたインクルードファイルやライブ
	  ラリーの場所をさがすためのコンパイラーの-Iや-Lオプションを指定する場合に、
	  <quote>${LOCALBASE}</quote>を使用してください。</para>
      </listitem>

      <listitem>
	<para><varname>X11BASE</varname>は、実際に(xsrcなどに由来する)X11ディストリビューションがイン
	  ストールされる場所です。
	  <emphasis>通常の</emphasis>X11のインクルードファイル(パッケージとして
	  インストールされていない)をさがす場合、<quote>${X11BASE}</quote>を使用してください。</para>
      </listitem>

      <listitem>
	<para>X11ベースのパッケージは特別です。<varname>X11BASE</varname>、または<varname>LOCALBASE</varname>に依存するかも
	  しれません。X11パッケージを<varname>LOCALBASE</varname>にインストールする方法は、単に
	  <pkg>pkgtools/xpkgwedge</pkg>をインストールするだけです。
	  もし、<varname>USE_IMAKE</varname>や<varname>USE_X11BASE</varname>をMakefileで定義したpkgとしてインストールさ
	  れたインクルードファイルやライブラリーをさがす場合、<quote>${X11BASE}</quote> と
	  <quote>${LOCALBASE}</quote>の<emphasis>両方</emphasis>を使用する必要があります。</para>
      </listitem>

      <listitem>
	<para>X11パッケージのインストール場所を参照する用途には、<varname>X11PREFIX</varname>を使って
	  ください。<varname>X11PREFIX</varname>は、xpkgwedgeがインストールされていない場合は
	  <varname>X11BASE</varname>となり、xpkgwedgeがインストールされている場合は<varname>LOCALBASE</varname>と
	  なります。</para>
      </listitem>

      <listitem>
	<para>xpkgwedgeがインストールされている場合、パッケージによってインストール先
	  が<varname>X11BASE</varname>になっていたり<varname>LOCALBASE</varname>になっていたりすることがあります。インス
	  トールされているパッケージのprefixを決めるために、<varname>EVAL_PREFIX</varname>定義を使う
	  ことができます。この定義に<quote>DIRNAME=&lt;package&gt;</quote>の形式の組を書くと、make(1)変
	  数<varname>DIRNAME</varname>が、インストールされているパッケージpackage &lt;package&gt;のprefixに設定され
	  ます。そのパッケージがインストールされていない場合は<quote>${X11PREFIX}</quote>に設定さ
	  れます。</para>

	<para>例を使って説明するのが一番いいでしょう。</para>

	<para>以下は、
	  <filename>pkgsrc/wm/scwm/Makefile</filename>からの抜粋です。</para>

	<programlisting>EVAL_PREFIX+=		GTKDIR=gtk+
CONFIGURE_ARGS+=	--with-guile-prefix=${LOCALBASE}	\
			--with-gtk-prefix="${GTKDIR}"		\
			--enable-multibyte</programlisting>

	<para><varname>EVAL_PREFIX</varname>を使って評価するパッケージに対して、以下のような定義を使って
	  デフォルトを定義することができます。</para>

	<programlisting>GTKDIR_DEFAULT= ${LOCALBASE}</programlisting>

	<para>ここで<varname>GTKDIR</varname>は、
	  <varname>EVAL_PREFIX</varname>
	  での最初の定義の組に対応します。</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1>
    <title>主なターゲット</title>

    <para><filename>bsd.pkg.mk</filename>で定義された、構築手順で使用される主なターゲットについて述べます。</para>

    <variablelist>
      <varlistentry>
	<term>fetch</term>

	<listitem>
	  <para>これは、変数<varname>DISTFILES</varname>と<varname>PATCHFILES</varname> (パッケージのMakefileで定義された)で指
	    定されたファイルが、ローカルシステムの<filename>/usr/pkgsrc/distfiles</filename>に存在するか
	    どうかをチェックします。もし、存在しなければ、そのファイルを以下のような
	    コマンドを使って取得しようとします。</para>

	  <programlisting>${FETCH_CMD} ${FETCH_BEFORE_ARGS} ${site}${file} ${FETCH_AFTER_ARGS}</programlisting>

	  <para>この${site}には、複数の候補が決まった順序で使われます: 最初に
	    <varname>MASTER_SITE_OVERRIDE</varname>を試み、次に、<varname>SITES_file</varname>が定義されていればそれ
	    を、定義されていなければ、<varname>MASTER_SITES</varname>か<varname>PATCH_SITES</varname>のどちらかを試
	    みます。そして、最後に<varname>MASTER_SITE_BACKUP</varname>の値を試みます。最初のもの以
	    外の順序は、<varname>MASTER_SORT_AWK</varname>か<varname>MASTER_SORT_REGEX</varname>を設定して、ユーザー
	    が入れ換えることができます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>checksum</term>

	<listitem>
	  <para>distfileを取得した後に、チェックサムを生成し、distinfoファイルに保存され
	    たチェックサムと比較します。もし、チェックサムが一致しなければ、構築は中
	    断されます。これはパッケージ作成時と同じdistfileが、構築に使用されている
	    こと、つまり、悪意や一次配布サイトでの意図的な差し替えやネットワークの損
	    失によってdistfileが変更されていないことを保証するためです。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>extract</term>

	<listitem>
	  <para>distfileがローカルシステム上に存在している場合、通常、それらは圧縮アーカ
	    イブフォーマットで保存されているので、展開する必要があります。もっとも一
	    般なフォーマットは<filename>.tar.gz</filename>です。もし、すべてのdistfileを伸張する必要がな
	    いのであれば、伸張するファイルを<varname>EXTRACT_ONLY</varname>に設定してください。もし
	    distfileが<filename>.tar.gz</filename>フォーマットでなければ、<varname>EXTRACT_CMD</varname>、
	    <varname>EXTRACT_BEFORE_ARGS</varname>、そして<varname>EXTRACT_AFTER_ARGS</varname>を設定することにより、それ
	    らを展開することができます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>patch</term>

	<listitem>
	  <para>展開の後で、<varname>PATCHFILES</varname>で指定されたパッチとパッケージのpatchesサブディレ
	    クトリーに存在するパッチ、さらに、$LOCALPATCHES/$PKGPATH (たとえば 
	    <filename>/usr/local/patches/graphics/png</filename>)に存在するパッチのすべてが適用されます。
	    <filename>.Z</filename>、あるいは<filename>.gz</filename>で終る名前のパッチファイルは、適用する前に伸張されます。
	    <filename>.orig</filename>、<filename>.rej</filename>で終るものは無視されます。patch(1)のためのいくつかのオプショ
	    ンは、<varname>PATCH_DIST_ARGS</varname>で指定する事ができます。
	    詳細に関しては<xref linkend="components.patches"/>を参照して下さい。</para>

	  <para>デフォルトでは、パッチに曖昧さがあった場合にはpatchが異常終了するような
	    特別な引数が渡されます。パッチを修正(再作成)して、きれいに適用できるよう
	    にしてください。そうする理由は、パッチがうまく適用できても、実は誤った場
	    所に適用されていて、深刻な問題を起こす可能性があるからです。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>configure</term>

	<listitem>
	  <para>ほとんどのソフトウェアは、&os;で利用できるヘッダーファイル、システムコー
	    ル、およびライブラリールーチンについての情報を必要とします。これはコンフィ
	    ギュレーションとして知られているプロセスであり、通常、自動化されています。
	    大抵の場合、スクリプトがソースと一緒に提供され、それを実行することにより
	    ヘッダーファイルやMakefile等が生成されます。</para>

	  <para>もし、プログラムのdistfileが専用のconfigureスクリプトを含んでいる場合、
	    <varname>HAS_CONFIGURE</varname>を設定することにより、実行することができます。もし、そのス
	    クリプトがGNUのautoconfスクリプトである場合は、かわりに、<varname>GNU_CONFIGURE</varname>を
	    指定してください。どちらの場合も、configureスクリプトの引数は、変数
	    <varname>CONFIGURE_ARGS</varname>で指定されます。もし設定スクリプトの名前がデフォルトの
	    <quote>configure</quote>でない場合は、その名前を<varname>CONFIGURE_SCRIPT</varname>に設定してください。</para>

	  <para>もし、プログラムがコンフィギュレーションのためにImakefileを使用するので
	    あれば、<varname>USE_IMAKE</varname>を<quote>YES</quote>に設定することにより、適切な手順が実行されます。
	    (もし、<varname>$X11PREFIX</varname>にインストールされるパッケージが欲しいだけで、xmkmfを実
	    行したくない場合、かわりに<varname>USE_X11BASE</varname>を使用してください!)</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>build</term>

	<listitem>
	  <para>コンフィギュレーションが終ったら、<varname>$MAKEFILE</varname>の中で、構築のターゲットとし
	    て<varname>$ALL_TARGET</varname>を指定し<varname>$MAKE_PROGRAM</varname>を起動することにより、&os;上にソフト
	    ウェアを構築することができます。もし、<varname>USE_GMAKE</varname>が設定されていれば、デフォ
	    ルトの<varname>MAKE_PROGRAM</varname>は<quote>gmake</quote>です。そうでなければ、<quote>make</quote>が使用されます。
	    <varname>MAKEFILE</varname>にはデフォルトで<quote>Makefile</quote>が設定されます。そして、<varname>ALL_TARGET</varname>のデフォ
	    ルトは<quote>all</quote>です。デフォルトの構築手順を変更するために、これらの変数を設定
	    することができます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>install</term>

	<listitem>
	  <para>構築の段階が完了すると、ユーザーのためにソフトウェアをパブリックなディレ
	    クトリーにインストールする必要があります。buildターゲットと同様に、
	    <varname>$MAKE_PROGRAM</varname>が<varname>$MAKEFILE</varname>中で起動されます。ただし、<varname>$INSTALL_TARGET</varname>が指定
	    されます。この変数のデフォルトは<quote>install</quote>です。(もし<varname>USE_IMAKE</varname>が設定さ
	    れていれば、<quote>install.man</quote>も追加されます)。</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>もし、ターゲットが指定されなければ、デフォルトは<quote>build</quote>です。手順の途中の
      ターゲットが指定された場合、それ以前のすべての手順が実行されます。例えば
      <command>make build</command>は、以下と同等のことを実行します。</para>

    <programlisting>make fetch
make checksum
make extract
make patch
make configure
make build</programlisting>
  </sect1>

  <sect1 id="build.helpful-targets">
    <title>他の役に立つターゲット</title>

    <variablelist>
      <varlistentry>
	<term>pre/post-*</term>

	<listitem>
	  <para>前のセクションで述べた主ターゲットのために、二つの補助ターゲットが存在し
	    ます。これは主ターゲットに<quote>pre-</quote>や<quote>post-</quote>というプレフィックスをつけ
	    たものです。これらのターゲットは、特別な設定やインストール手順のために、
	    主ターゲットが実行される前や後に実行されます。例えば、プログラムのコンフィ
	    ギュレーションスクリプトやインストールターゲットが省略された場合に有用で
	    す。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>do-*</term>

	<listitem>
	  <para>主なターゲットがおかしな動作をし、それを修正するための変数が存在しない場
	    合、do-*ターゲットを使用することにより、それらを再定義することができます
	    (do-*ターゲットのかわりに、ターゲット自体を再定義してはいけません。pre-*
	    やpost-*ターゲットが実行されなくなってしまいます)。通常、再定義する必要
	    はありません。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>reinstall</term>

	<listitem>
	  <para>もし、<command>make install</command>実行後に、いくつかのファイルがきちんとインストール
	    されなかった事に気がついた場合、このターゲットを使い、再びインストールす
	    る事ができます。この場合、<quote>インストール済み</quote>フラグは無視されます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>deinstall</term>

	<listitem>
	  <para>このターゲットは、パッケージをアンインストールするためにカレントディレク
	    トリーでpkg_delete(1)を実行します。動作を制御するために、以下の変数をコ
	    マンドライン、または<filename>/etc/mk.conf</filename>で使用することができます。</para>

	  <variablelist>
	    <varlistentry>
	      <term><varname>PKG_VERBOSE</varname></term>

	      <listitem>
		<para>&man.pkg.delete.1;コマンドに「-v」オプションを渡します。</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><varname>DEINSTALLDEPENDS</varname></term>

	      <listitem>
		<para>指定されたパッケージに必要な(依存する)すべてのパッケージを削除します。
		  このターゲットは、指定されたパッケージによってインストールされたパッ
		  ケージを削除するために使用されます。例えば、<command>make deinstall
		    DEINSTALLDEPENDS=1</command>が<filename>pkgsrc/x11/kde</filename>で実行された場合、KDE全体を削除し
		  ます。&man.pkg.delete.1;のコマンドラインに<quote>-R</quote>を指定すると設定されます。</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>update</term>

	<listitem>
	  <para>このターゲットは、現在のパッケージを最新のものに更新します。最初にパッケー
	    ジと、それに依存するすべてのパッケージをアンインストールします。それから
	    最新のバージョンのパッケージをコンパイル、インストールします。これは、現
	    在どのパッケージがインストールされているかを調べ、<command>make deinstall</command>、
	    <command>make install</command>(または、<varname>UPDATE_TARGET</varname>で設定されたターゲット)を続けて実
	    行するのと同じです。</para>

	  <para>以前に実行した<command>make update</command>がさまざまな理由で中断された場合、パッケー
	    ジの更新のために、このターゲットを使用することができます。ただし、この場
	    合は、<command>make clean</command>を実行していない事、あるいは<varname>$WRKDIR</varname>の依存パッケー
	    ジのリストを削除していない事を確認してください。そうでなければ、インストー
	    ル済みの依存パッケージを使用し、現在のパッケージを自動更新することができ
	    ません。</para>

	  <para>中断された<command>make update</command>の再開は、パッケージツリーの他の部分が変更され
	    ていない場合に限って動作します。更新対象のパッケージのソースコードが変更
	    されていた場合は、<command>make update</command>の再開はきっと失敗するでしょう。</para>

	  <para><command>make update</command>の動作を変更するために、以下の変数をコマンドライン、また
	    は<filename>/etc/mk.conf</filename>で使うことができます。</para>

	  <variablelist>
	    <varlistentry>
	      <term><varname>UPDATE_TARGET</varname></term>

	      <listitem>
		<para>更新されたパッケージや依存パッケージのために再帰的に使用されるインス
		  トールターゲット。<command>make update</command>用のデフォルトは、<varname>DEPENDS_TARGET</varname>が
		  設定されている場合はその値、それ以外の場合は<quote>install</quote>です。
		  例えば、<command>make update UPDATE_TARGET=package</command>のように使用します。</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><varname>NOCLEAN</varname></term>

	      <listitem>
		<para>更新した後、きれいに掃除をしません。調査やその他の目的のために、更新
		  されたパッケージの作業用ソース等をそのままにしておきたい場合に役に立
		  ちます。最終的にはソースツリーを掃除してください(以下の
		  <quote>clean-update</quote>ターゲットを見てください)。そうしなければ、次回の
		  <command>make</command>や<command>make update</command>の時に古いソースコードが残っていることで
		  トラブルがおこるかもしれません。</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><varname>REINSTALL</varname></term>

	      <listitem>
		<para>インストール(make <varname>DEPENDS_TARGET</varname>)の前に各パッケージをアンインストー
		  ルします。これは、<command>make update</command>の実行中断後に<quote>clean-update</quote>ターゲット
		  (以下参照)が呼ばれた場合に必要となることがあります。</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><varname>DEPENDS_TARGET</varname></term>

	      <listitem>
		<para>再帰を無効化し、パッケージのターゲットをハードコードすることができま
		  す。updateターゲット用のデフォルトは<quote>update</quote>であり、事前に必要なパッ
		  ケージを再帰的に更新するようになっています。<varname>DEPENDS_TARGET</varname>を設定する
		  のは、再帰的な更新を無効化したいときだけにしてください。<command>make update</command>
		  (後述します)の最中にインストールされる各パッケージに対して、特定のター
		  ゲットを指定するだけの場合は、これのかわりに<varname>UPDATE_TARGET</varname>を使ってく
		  ださい。</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>clean-update</term>

	<listitem>
	  <para>カレントディレクトリーで<command>make update</command>が実行された時に更新されるすべて
	    のパッケージのソースツリーを掃除します。カレントパッケージ(あるいは、依
	    存パッケージ)がすでにアンインストールされている(例えば<command>make update</command>を実行
	    した後)場合には、このターゲットを使ってはいけません。もし使用すると、更
	    新するつもりのパッケージのいくつかを失う可能性があります。経験的には、初
	    めて<command>make update</command>を実行する<emphasis>前</emphasis>、あるいは汚れたパッケージツリーがある場
	    合(例えば<varname>NOCLEAN</varname>を使用した場合)にのみ使用するとよいでしょう。</para>

	  <para>パッケージのツリーが掃除されているかどうかわからない場合は、ツリーの最上
	    層で<command>make clean</command>を実行するか、更新しようとしているパッケージのディレクト
	    リーで以下のコマンドをこの順に使うか、どちらかをおこなうことができます。
	    (<command>make update</command>を初めて実行するより<emphasis>前</emphasis>におこなってください。それ以外の場
	    合、更新しようとしているパッケージをすべて失ってしまいます)</para>

	  <screen><prompt>#</prompt> <userinput>make clean-update</userinput>
<prompt>#</prompt> <userinput>make clean CLEANDEPENDS=YES</userinput>
<prompt>#</prompt> <userinput>make update</userinput></screen>

	  <para><command>make clean-update</command>の動作を変更するために、以下の変数をコマンドライン、
	    または<filename>/etc/mk.conf</filename>で使うことができます。</para>

	  <variablelist>
	    <varlistentry>
	      <term><varname>CLEAR_DIRLIST</varname></term>

	      <listitem>
		<para><command>make clean</command>の後で、パッケージのためのディレクトリーのリストを再構
		  築しません。<command>make update</command>で、更新したいすべてのパッケージがインストー
		  ルされた場合にのみ使用してください。通常、これは<command>make update</command>で自動
		  的に実行されます。ただし、<varname>NOCLEAN</varname>変数の設定によって実行されない事もあ
		  ります(上を参照してください)。</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>info</term>

	<listitem>
	  <para>このターゲットは、現在のパッケージに対して&man.pkg.info.1;をおこないます。これ
	    を使って、インストールされているパッケージのバージョンを調べる
	    ことができます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>readme</term>

	<listitem>
	  <para>このターゲットは、<filename>README.html</filename>ファイルを作成します。このファイルは
	    <pkg>www/navigator</pkg>や<pkg>www/lynx</pkg>のようなブラウザー
	    で閲覧することができます。作成されたファイルは、ローカルホストの
	    <varname>PACKAGES</varname>ディレクトリーにあるパッケージへの参照を含んでいます。また、
	    <varname>FTP_PKG_URL_HOST</varname>と<varname>FTP_PKG_URL_DIR</varname>を元にしたURLを参照させることもできます。
	    例えば、ローカルマシン上の<filename>/usr/packages</filename>ディレクトリーのバイナリーパッ
	    ケージを参照する<filename>README.html</filename>ファイルを作成したい場合、
	    <varname>FTP_PKG_URL_HOST=file://localhost</varname>と<varname>FTP_PKG_URL_DIR=/usr/packages</varname>をセット
	    してください。<varname>${PACKAGES}</varname>ディレクトリーと、そのサブディレクトリーはすべ
	    てのバイナリーパッケージで検索されます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>readme-all</term>

	<listitem>
	  <para>このターゲットを使い、<filename>README-all.html</filename>を作成することができます。このファ
	    イルは&os;パッケージコレクションの中の、現在利用可能なすべてのパッケー
	    ジのリスト、また、それらが属するカテゴリーと簡単な説明を含んでいます。こ
	    のファイルは<filename>pkgsrc/*/README.html</filename>から作りだされます。したがって、<command>make readme</command>
	    の<emphasis>後</emphasis>に、このターゲットを実行してください。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>cdrom-readme</term>

	<listitem>
	  <para>これは<quote>readme</quote>ターゲット(上を見てください)とほとんど同じですが、CD-ROMに焼
	    かれるpkgsrcツリーを作る時に使われます。また、このターゲットは
	    <filename>README.html</filename>ファイルを作成し、<varname>CDROM_PKG_URL_HOST</varname>と<varname>CDROM_PKG_URL_DIR</varname>に基づ
	    くURLへの参照を作ります。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>show-distfiles</term>

	<listitem>
	  <para>このターゲットは、パッケージを構築するために、どのdistfileやパッチファイ
	    ルが必要かを表示します。(<varname>DISTFILES</varname>および<varname>PATCHFILES</varname>であって、<filename>patches/*</filename>は
	    含みません)</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>show-downlevel</term>

	<listitem>
	  <para>このターゲットは、パッケージがインストールされていない場合は何も表示しま
	    せん。もし、あるバージョンのパッケージがインストールされているが、現在の
	    pkgsrcのバージョンでインストールされたものでない場合、警告メッセージを表
	    示します。このターゲットは、インストール済みのパッケージが古いバージョン
	    であり、そのバージョンが削除可能で、最新の物が追加されることを表示するた
	    めに使用されます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>show-pkgsrc-dir</term>

	<listitem>
	  <para>当該パッケージの構築とインストールが可能な、パッケージ階層におけるディレ
	    クトリーを表示します。このディレクトリーは、そのパッケージがインストール
	    された際のディレクトリーと同じとは限りません。このターゲットは、単一ホス
	    ト上で多数のパッケージの更新をしたい場合に使うためのもので、pkgsrc の最
	    上層のMakefileから<quote>show-host-specific-pkgs</quote>ターゲットで呼び出すことがで
	    きます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>show-installed-depends</term>

	<listitem>
	  <para>このターゲットは、インストールされているパッケージのうち、どれが当該パッ
	    ケージの<varname>DEPENDS</varname>と合致するかを表示します。DEPENDSが古いせいで構築に問題が
	    起きる場合に便利です。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>check-shlibs</term>

	<listitem>
	  <para>パッケージのインストール後に、すべてのバイナリーおよび(ELFプラットフォー
	    ムでは) 共有ライブラリーが必要な共有ライブラリーを見つけられるかどうか確
	    認します。<filename>/etc/mk.conf</filename>で<varname>PKG_DEVELOPER</varname>が設定されている場合はデフォルトで
	    実行します。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>print-PLIST</term>

	<listitem>
	  <para>パッケージを新規に、または更新のために<quote>make install</quote>した後、
	    <command>find -newer work/.extract_done</command>をもとに新しい<filename>PLIST</filename>を生成して表示します。PLIST生成は、
	    共有ライブラリーなどに配慮して行われますが、生成した結果を<filename>PLIST</filename>に置く前
	    に再確認するよう<emphasis>強く</emphasis>おすすめします。パッケージ更新時には、このコマンド
	    の出力と、更新前の<filename>PLIST</filename>ファイルとを比較すると便利でしょう。</para>

	  <para>パッケージが、tar(1)その他のファイルのアクセス時刻を更新しない方法を使っ
	    てファイルをインストールする場合は、それらのファイルは<quote>find -newer</quote>で検
	    出されないので、手で<filename>PLIST</filename>に書き足すよう注意してください!</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>bulk-package</term>

	<listitem>
	  <para>バルクビルドの実行に使われます。適切なバイナリーパッケージがすでに存在す
	    る場合は、何もしません。そうでない場合は、コンパイル、インストール、パッ
	    ケージ作成をおこないます
	    (<varname>PKG_DEPENDS</varname>が適切に設定されている場合は、依存するパッケージも。<xref linkend="binary.configuration"/>参照)。
	    バイナリーパッケージ作成後、ディスクの空き領域
	    を確保するために、ソース、インストールしたばかりのパッケージと依存パッケー
	    ジは削除されます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>bulk-install</term>

	<listitem>
	  <para>依存パッケージ群をインストールするためのバルクインストールで使われます。
	    適切なバイナリーパッケージが利用可能な場合、pkg_addでそれをインストール
	    します。そうでない場合は、<command>make bulk-package</command>が実行されますが、インストー
	    ルされたバイナリーは削除されません。バイナリーパッケージが&man.pkg.add.1;でイン
	    ストールされるのに<quote>適切</quote>である条件は、以下のとおりです:</para>

	  <itemizedlist>
	    <listitem>
	      <para>パッケージファイル(<filename>Makefile</filename>, ...)が、いずれも構築時から変更されていな
		いこと。</para>
	    </listitem>

	    <listitem>
	      <para>そのパッケージが依存している(バイナリー)パッケージが、いずれも構築時
		から変更されていないこと。</para>
	    </listitem>
	  </itemizedlist>
	</listitem>
      </varlistentry>
    </variablelist>
  </sect1>
</chapter>
