<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<!-- Copyright (c) 1994-2003
        The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED. -->
<link rev="made" href="mailto:www@JP.NetBSD.ORG">
<link rel="shortcut icon" href="../../../favicon.ico" origlink="/favicon.ico" type="image/x-icon">
<title>NetBSD Documentation: Debugging the NetBSD kernel with GDB HOWTO</title>
</head>
<body bgcolor="#FFFFFF" text="#000000">

<HEADING> GDB を使い NetBSD カーネルをデバッグする HOWTO

<LIST>

<SECTION>KGDB の使用方法

<ENTRY>introduction 概要

NetBSD カーネルに含まれている DDB デバッガーは、クラッシュ・トレースバック
を入手したり、変数の値の検査、その他のこまかいデバッグのために、役に立ちま
す。しかしながら、もし、真剣にカーネルをハックしているのであれば、DDB のか
わりに、リモートデバッガー KGDB が動作するように設定したいと思うでしょう。
<p>
DDB に対する KGDB の利点は、ディスアセンブルされたマシンコードでなく
カーネルの <em>ソースコード</em> を見ることができることです。実際のところ、
ほとんどすべての GDB の機能が使用可能で、gdb のいくつかのグラフィカル
インターフェースを使うこともできます(例えば <PKGSRC>devel/ddd など)。

<ENTRY>prerequisites 事前に準備しておくこと

<ul>
<li>同一アーキテクチャーで NetBSD の動作しているマシン二台(オブジェクトコード
のフォーマットも同一であること):
<p>

<pre>
  TARGET - デバッグするカーネルを実行するマシン
  REMOTE - gdb を実行、表示するマシン
</pre>

あるアーキテクチャーのホストで、他のアーキテクチャーのターゲット用の gdb 
を構築することも可能です。しかし、今のところこれについてはここでの対象範囲外です。
<p>
</li>

<li>空きのシリアルポートが両方のマシンに存在すること。</li>
<li>null モデムケーブル (詳しくは
<a href="../../Documentation/Hardware/Misc/serial.html">NetBSD
シリアルポート入門</a>参照)。</li>
<li>カーネルの構築とインストール、そして gdb の使用法についての知識
</li>
</ul>

<ENTRY>instructions 手順

(以下の文中では、REMOTE マシン上(gdb が動作している)で tty01 を、TARGET 
マシン(デバッグされる)では tty00 を使用していると仮定して説明します。
お使いのマシンに合わせて、シリアルポートのデバイスを適切なもの─たとえば
dty00 ─に置き換える必要があるかもしれません。
<p><p>

<ol>
<li>KGDB を有効にしたカーネルの構築
<p>
(注意: たぶん、これがリモートマシン上でカーネルを構築する最良の方法
でしょう。これで、デバッグする時には、すべての必要なソースファイルと
シンボルファイルはすでに準備されています。)
<p>

<ul>
<li>TARGET マシンのためにカーネルのコンフィグファイル内の以下の行を
コメントアウトしてください。
<p>

<pre>
  #options 	DDB			# in-kernel debugger
  #options 	DDB_HISTORY_SIZE=100	# enable history editing 
</pre>

以下の三行をアンコメントアウト(あるいは追加)してください。<p><p>

<pre>
  options 	KGDB		# remote debugger
  options 	"KGDB_DEVNAME=\"com\"",KGDBADDR=0x3f8,KGDBRATE=9600
  makeoptions	DEBUG="-g"	# compile full symbol table
</pre>

TARGET マシン上で使用するシリアルポートの IO アドレス(0x3f8 は tty00、
0x2f8 は tty01 用です)に一致するように、KGDBADDR を変更してください。
それから、KGDBRATEを、使用するビットレートに一致させてください。<p><p>

<li> TARGET マシンのカーネルの設定と<a href="./#how_to_build_a_kernel">
構築</a>をおこなってください。
<p>
</ul></li>

<li> TARGET マシンの準備
<p>

ファイル「netbsd」を、カーネルを構築したディレクトリーから TARGET マシンの
ルートディレクトリーにコピーしてください。<b>このカーネルをリモートマシンに
インストールしてはいけません</b>。(特に、両方のマシンで同じ tty を使っている
時には注意してください!)
<p>

<li>REMOTE マシンの準備
<p>

<ul>
<li> TARGET マシンでカーネルを構築したのであれば、/usr/src/sys すべてを、
REMOTE マシンにコピーしてください。(注意: TARGET マシンのディレクトリー
を 単に NFS マウントしてはいけません。gdb がブレークポイントで停止した
時に、TARGET マシン上の nfsd を含む<b>すべてのプロセス</b>は停止します。)
<p>

<li>REMOTE マシン上で使う予定の(そして REMOTE マシンで<b>だけ</b>使う) tty の
ために /etc/ttys を変更してください。例えば以下のように。
<p>

<pre>
  tty01 "/usr/libexec/getty std.9600" unknown off local
</pre>

ここで重要なのは、「off」(これで、init がこのポートで getty を起動する
ことはありません)と「local」です。なぜならば、ttyflags は、/etc/ttys に従ってブート
時にポートのデフォルトを設定します。そして、gdb を使うには、DTR を待た
ないようにするために「local」が設定されていなければなりません。
<p>

「std.9600」を別のビットレートに変更したい場合もあるかもしれません。この
場合、ビットレートは、gdb で設定する remotebaudrate (後で説明します)と
同様に、TARGET 用のカーネルオプションで設定したレートと一致していなけ
ればなりません。/etc/gettytab の中に、あなたが使う名前と一致するエントリー
があることを確認してください。<p><p>
<p>

<li>REMOTE マシンをリブートするか、ttyflags を起動し /etc/ttys を再
読み込みさせてください。(「kill -1 1」で十分かもしれません。しかし、
/etc/ttys の項目の順番を変更したことにより、init が混乱する可能性があります)
<p>
</ul></li>

<li>null モデムケーブルを使い、シリアルポートに接続してください。
<p>

<li>TARGET マシンをリブートし、ブートローダーのメッセージが表示されたら
すぐに、スペースキーを押してください。そして、次のコマンドを入力して
ください。
<p>

<pre>
  boot -d
</pre>

これによりカーネルがロードされます。「waiting for kgdb」というメッセージ
が表示された後、TARGET は停止します。
<p>

<li>REMOTE マシン側で、カーネルを構築したディレクトリー
(一般的には /usr/src/sys/arch/&lt;something&gt;/compile/&lt;config-name&gt;) 
に移動し、gdb を起動します。
<p>

<pre>
  gdb netbsd.gdb
</pre>

数秒後、(gdb) プロンプトが表示されるはずです。

<li>gdb のいくつかのフラグを設定する
<p>

<pre>
  # いつでも Ctrl-C により TARGET を停止させることができるようにする。
  (gdb) set remotebreak 1
  # gdb の使用するボーレートを設定する。(デフォルトは 9600、
  # TARGET にインストールされたカーネルの設定と一致していること)
  (gdb) set remotebaud 9600
  # シリアル上でラインエラーが発生した場合の再送速度を速くする。
  (gdb) set remotetimeout 3
</pre>
<p>

<li> TARGET マシンに接続します(REMOTEマシン側で tty01 を使用していると
仮定しています)
<p>

<pre>
  target remote /dev/tty01
</pre>
<p>

以下のようなメッセージが表示されます。
<p>

<pre>
  Remote debugging using /dev/tty01
  kgdb_connect (verbose=1) at 	../../../../arch/i386/i386/kgdb_machdep.c:244
  244             if (verbose)
  (gdb)
</pre>
<p>

もし、これらのメッセージが表示されるかわりに、GDB が 「hang」しているよう
なら、シリアルハードウェア、ケーブル、あるいは設定に何か間違いがあります。
トラブルシューティングのセクションを参照してください。
<p>

<li>さて、プロンプトが表示されれば、ハックする準備はできています。
ブレークポイントを設定したり、データを確認したり、一ステップ毎に実行する
ことができます。ちょうど、ローカルマシン上で動作しているユーザーレベル
アプリケーションを gdb でデバッグするのと同じです。カーネルのブートプロ
セスを続行させるには、「cont」を使ってください。後でデバッガーにもどるため
には、Ctrl-C を押してください。
<p>

<li>5 から 7 の手順を自動化するためには、カーネルを構築するディレクトリーに
以下の内容のファイル .gdbinit を作成してください。
<p>

<pre>
  file netbsd.gdb
  set remotebreak 1
  set remotebaud 9600
  target remote /dev/tty01
</pre>
<p>

さて、これで「gdb」とタイプするだけで、デバッグを始めることができます。
</ol>

<ENTRY>troubleshooting トラブルシューティング

もし、うまく動作しない場合は、以下の事を試してみてください。
<p>

<ul>
<li>-d を指定せずに TARGET マシンをリブートしてください。デバイスの
プローブ時に以下のようなメッセージが表示されるはずです。二行目が表示
されていなければ、構築したカーネルでは KGDB が有効になっていないか、
間違ったカーネルを使用しています。
<p>

<pre>
  com0 at isa0 port 0x3f8-0x3ff irq4: ns16550a, working fifo
  com0: kgdb
</pre>
<p>

<li>シリアルポートとケーブルが「通常」のアプリケーションで動作すること
を確認してください。KGDB を無効にしたカーネルで TARGET マシンをリブート
し、二つのマシン間で「tip 」を実行してみてください。もし、tip について
知らないのであれば、以下の簡単な手順を参考にしてください。
<p>

* 以下の行を、TARGET と REMOTE 両マシンの /etc/remote に追加してください。
<p>

<dl><dd><code>
	tty00-9600:dv=/dev/tty00:br#9600:pa=none:dc:<br>
	tty01-9600:dv=/dev/tty01:br#9600:pa=none:dc:<br>
</code></dd></dl>
<p>

* TARGET マシン上で「tip tty00-9600」を、REMOTE マシン上で「tip tty01-9600」
を実行してください。
<p>

* 両方のマシンのキーボードで適当な文字を入力してください。文字は
他のマシンのディスプレイに表示されるはずです。
<p>

<li>/etc/ttys の中の、自分が使っている tty の行を再度確認し、それが有効
かどうかを確認するためにリブートしてください。
<p>

<li>今まで書いてた文章の中では、root で作業している事を仮定していました。
一般ユーザーの場合、tip と gdb は動作しません。(/dev/tty0* のパーミッション
に依存します)。もちろん、root での作業は、一般的にはおすすめできません。
かわりに、以下のようにしてください。
<p>

   * /dev/tty0* のグループを「wheel」にしてください(そうなっていなければ)<p>
   * あなたのユーザー名を、/etc/group の「wheel」行に追加してください<p>
   * あなたのユーザー名を、/etc/group の「dialer」行に追加してください<p>
<p>
(2) により、gdb のプロセスが(そして、あなたが起動している他のプロセスも)、
tty をオープンできるようになる。(3) により、tip を起動することができる
ようになる。
</ul>

<ENTRY>general_caveats 一般的な注意

<ol>
<li>コマンドを入力してから反応が返ってくるまでに、時々長い時間がかかる
ことがあります。これは、おそらくシリアルコネクション上の不正なデータの
せいです。みじかい休止と再送の後、すべて正常にもどります。
「remotetimeout」の値をデフォルトの 20 秒より短かく設定するとよいでしょう。
(これはある人から報告がありました。(彼の場合は)カーネルのsprintf() が
コマンドの間に実行されたことが原因でした。これにより gdb のデータがこわれ
たようです)。
<p>
<li>カーネルが高優先度の割り込み(機種依存)ロック中は、Ctrl-C は動作しません。
例えば、i386 では、splimp() の中の永久ループを停止させることはできません。
しかし、ブレークポイントを、そのループの前にセットすれば、そこを一ステップ
ずつ実行することができます。
</ol>

</LIST>

<a href="./"><em>NetBSD Documentation: Kernel</em>にもどる</a>
<hr>

<DOCLINK>

<hr>
<address>
  <small>
  (連絡先 - <a href="http://www.netbsd.org/cgi-bin/feedback.cgi">英語</a>,
       <a href="mailto:www@JP.NetBSD.ORG">日本語:
       www@JP.NetBSD.ORG</a>)<br>
  $NetBSD: kgdb.list,v 1.9 2003/03/08 19:44:18 grant Exp $<br>
  <a href="../../Misc/disclaimer.html">Copyright &copy; 1994-2003
  The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED.</a>
  </small>
</address>

</body>
</html>
