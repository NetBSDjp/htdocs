<html>
<head>
<!-- Copyright (c) 1996, 1998, 1999, 2000
	The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED. -->
<link rev="made" href="mailto:www@JP.NetBSD.ORG">
<title>NetBSD Documentation: Kernel</title>
</head>
<body bgcolor="#FFFFFF" text="#000000">

<HEADING>カーネル

<LIST>

<h2>NetBSD に特有のドキュメント</h2>
<ul>
<li><a href="programming.html">カーネルプログラミング FAQ</a>
<li><a href="pseudo/">疑似(pseudo)デバイスドライバーを書くには</a>
<li><a href="elf-notes.html">ベンダー特有の ELF Note Element</a>
<li><a href="uvm.html">UVM、あたらしい仮想メモリーシステム</a>
<li><a href="vfork.html">なぜ伝統的な vfork() を実装したか</a>
<li><a href="kgdb.html">GDB を用いた NetBSD カーネルのデバッグの方法</a>
</ul>

<h2>その他のオンライン ドキュメント</h2>
<ul>
<li><a href="http://tofu.alt.net/~lk/291.paper/291.paper.html">
    Porting BSD UNIX to a New Platform</a>
<li><a href="http://www.netapp.com/tech_library/nfsbook.html">
    4.4BSD のデザインと実装、第9章 (NFS)</a>
</ul>

<SECTION>FAQ - よくある質問

<ENTRY>downloading_kernel_source どこでカーネルソースをダウンロードできますか
<h4><a name="official_release_kernel_source">公式リリース</a></h4>
すでにインストールされているものと同じリリースのカスタマイズしたカーネルを
コンパイルするには、カーネルの <tt>syssrc.tgz</tt> ファイルだけあれば十分です。
特定のリリースに対して、このファイルは、そのリリースのメインディレクトリの中の
gzip された tar ファイル 'source/sets/syssrc.tgz' にあります。
たとえば、NetBSD 1.4.1 のカーネルソースは次のファイルにあります:
<pre>   <a
href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.4.1/source/sets/syssrc.tgz">/pub/NetBSD/NetBSD-1.4.1/source/sets/syssrc.tgz</a></pre>
もし <a href="http://www.netbsd.com/">NetBSD CD-Rom</a>を持っていたら、
'source/sets/syssrc.tgz' も含まれています。ソースはどこでも展開できますが、
習慣的に /usr/src に置かれます。
展開するには "<b><tt>cd / ; tar xvzpf &lt;ファイル名&gt;</tt></b>" と
してください。
<p> <h4>'流血の刃先' -current ソース、冒険好きな人限定!</h4>
最新のカーネルソースは ftp.netbsd.org かミラーサイトの <a
href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-current/src/sys/">/pub/NetBSD/NetBSD-current/src/sys/</a>
ディレクトリーにあります。<br>
カーネルをコンパイルするには、以下のものを <a
href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-current/tar_files/src/">
/pub/NetBSD/NetBSD-current/tar_files/src</a> からダウンロードした方が
いいでしょう:  <ul>
   <li><a
   href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-current/tar_files/src/config.tar.gz">config.tar.gz</a>
   ('config(8)' プログラムのソース) <li><a
   href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-current/tar_files/src/sys.tar.gz">sys.tar.gz</a>
   (全てのアーキテクチャーの完全なカーネルソース) </ul> 
あなたが使っているバージョンから変更があった場合、最初に 'config'
プログラムをビルドとインストールすべきです。
-current は NetBSD 開発の最先端なので、<a
href="#problems_compiling_a_current_kernel">-current カーネルの
コンパイルに関する問題</a> があるかもしれません。
あなたがコンフィグの手順に慣れるまでは <a
href="#official_release_kernel_source">公式リリース</a> のソースを
使うことをお勧めします。
<p><h4>特定の日付のカーネルソースをダウンロードするには</h4>
スナップショットをあなたのマシンにインストールしていて、
カーネルを作り直したい(でも -current カーネルは新しすぎる)場合に、
このような事が必要かもしれません。
<a href="../../Documentation/current/#using-anoncvs">anoncvs
を用いた NetBSD-current の追跡</a>の方法に従ってください。

<ENTRY>building_a_kernel カーネルの作り方
<ol>
    <li>あなたのベースシステムに付属していたコンパイラーセット(<tt>comp.tgz</tt>)を
        インストールしたことを確認してください。
 <p><li>カーネルソースをダウンロードし展開します(
	<a href="#downloading_kernel_source">どこからカーネルソースを
	ダウンロードできますか</a>参照)。
 <p><li>-current を使っている場合、新しいバージョンの config のコンパイルが
	必要かもしれません。完全な -current のソースをダウンロードしたら:
	<br>
	"<b><tt>cd /usr/src/usr.sbin/config ; make && make install</tt></b>"
 <p><li>"<b><tt>cd /sys/arch/&lt;ARCH&gt;/conf</tt></b>"<br>
	&lt;ARCH&gt; には 'i386', 'sparc', 'mac68k' のような
	あなたのマシンアーキテクチャーが入ります。
 <p><li>"<b><tt>cp GENERIC &lt;MYCONF&gt;</tt></b>"<br>
	&lt;MYCONF&gt; はこの設定にあなたが名づけた名前です。ホスト名や
	マシンタイプ、あなたの名前を使ってもよいのです。英文字、数字、
	そして _ 文字が使えます。
 <p><li><b>&lt;MYCONF&gt;</b> の編集<br>
	最初はこのステップは飛ばしても構いません。
	i386 上で仮想コンソールを得るために
	 'pc0' をコメントアウトして 'vt0' を有効にしたりするように、
	あなたが持っていなかったり使っていない CPU タイプやハードウェア、
	デバイスのドライバーを削除することができます。
	あなたがどのハードウェアドライバーを使い続けるかを決めるよい第一歩
	となるのは、"<b><tt>dmesg</tt></b>" か
	"<b><tt>dmesg | grep ' at '</tt></b>" の出力を読むことです。
	'&lt;XXX&gt; at &lt;YYY&gt;' を含む全ての行について
	&lt;XXX&gt; と &lt;YYY&gt; の両方のエントリーを残す必要があります。
	他のカーネル設定のオプションの情報のために、"<b>options(4)</b>"
	も読んでください。
 <p><li>"<b><tt>config &lt;MYCONF&gt;</tt></b>"<br>
	&lt;MYCONF&gt; のカーネルをビルドするためのディレクトリーを
	生成します。
 <p><li>"<b><tt>cd ../compile/&lt;MYCONF&gt;</tt></b>"<br>
	カーネルをビルドするためのディレクトリーに移動します。
 <p><li>"<b><tt>make depend</tt></b>"<br>
	make プログラムがどのファイルをリビルドすればいいのか
	わかるように(この時点では全て!)、'.depend' ファイルを生成します 。
 <p><li>"<b><tt>make</tt></b>"<br>
	カーネルをコンパイルします。もし全てがうまくいけば、'netbsd'
	カーネルができているでしょう。もしあなたが VAX を使っていれば
	これは相当時間がかかり、大規模な Alpha マシンならとても短い時間であり、
	残りの人たちはこの中間の時間になります。
 <p><li>"<b><tt>mv /netbsd /netbsd.old ; mv netbsd /</tt></b>"<br>
	現在のカーネルを保存し、(_とても_ 重要)、
	新しいカーネルをブートできるよう移動します。
 <p><li>"<b><tt>reboot</tt></b>"<br>
	これであなたの新しいカーネルを使ってリブートします -
	ブートメッセージには次の行が含まれているはずです:
	'NetBSD &lt;VERSION&gt; (&lt;MYCONF&gt;) #0: &lt;COMPILE_DATE&gt;'
 <p><li><b>何か問題があったら:</b><br>
	シングルユーザーモードで 'netbsd.old' カーネルをブートしましょう。
	変更する手順はブート手順に依存していますが、i386 ではこうでしょう:
	<ol>
	    <li><b>最初の NetBSD のメッセージが表示されたら <tt>SPACE</tt> を押す</b></li>
	    <li>"<b><tt>boot netbsd.old -s</tt></b>"</li>
	</ol>
	<p>
	次にカーネルを元に戻す:
	<ol>
	    <li>"<b><tt>fsck /</tt></b>"</li>
	    <li>"<b><tt>mount /</tt></b>"</li>
	    <li>"<b><tt>mv netbsd.old netbsd</tt></b>"</li>
	    <li>"<b><tt>exit</tt></b>"</li>
	</ol>
	</p>
</ol>

<ENTRY>generic_kernel GENERIC カーネルっていったい何なんですか?
<p>
GENERIC という言葉はマシンアーキテクチャーでサポートされている
全てのマシンで実行できるように設定されたカーネルを意味します。
この言葉はもともとカーネルの設定ファイル中に含まれていた、
設定オプションでもあるルートデバイスを"汎用(generic)"と
することを示す行に由来します。このオプションと設定行の書式は
すでに用いられていませんが、この名称はしばらく残ることでしょう。
<p>
このため、GENERIC カーネルは、全てのデバイスドライバとたくさんの
マシンモデルをサポートするコードを含んでいます。
多くはあなたにとって必要ないものなので,
<a href="#building_a_kernel">あなた用のカスタム化したカーネルを
コンパイルする</a>事をお勧めします。

<ENTRY>mclpool-limit <tt><b>mclpool limit reached: increase NMBCLUSTERS</b></tt> ってどういう意味ですか?
これはカーネルが、mbuf クラスターにマップした空間を使い果たしたことを意味します。
mbuf クラスターはネットワークコードでパケットやその他の
ネットワーク関係のデータを格納するのに使用されています。
これを解決するには
<blockquote>
      options NMBCLUSTERS=1024<br>
</blockquote>
を<a href="#building_a_kernel">カーネル設定ファイル</a>に加えるか、
カーネルを直接変更してください:
<blockquote>
        # <strong>gdb --write /netbsd</strong><br>
        (gdb) <strong>set nmbclusters=1024</strong><br> 
        (gdb) <strong>quit</strong><br>
</blockquote>
デフォルトの設定は 256 なので、もしこの問題が起きたならば、例えば
1024 にしてみるといいでしょう。ビジーなサーバマシンならばもっと
大きな値が必要かもしれません。
<p>
カーネル設定に関するオプションについてのより詳しい情報は
options(4) を参照して下さい。

<ENTRY>spl_not_lowered <tt><b>WARNING: SPL NOT LOWERED ON SYSCALL EXIT</b></tt> ってどういう意味ですか?
このカーネルメッセージはカーネル中に 
int x = splfoo(); したのに復帰する前に splx(x); を実行しなかった syscall が
あるというバグがあることを意味します。
この例で splx(x); 関数はシステムの優先度レベルを x にエンコードされた状態、
つまり他の spl 関数(この場合は splfoo(); という関数)によって返された値に
レストアします。
<p>
このカーネルメッセージが出力された場合、カーネル内デバッガーである ddb(4) に
入って下さい。ddb 内で 't' を押すことによりスッタクトレースを得ることができ、
問題の syscall() を確認することができるかもしれません。
このカーネルメッセージは本来出力されるはずが
ないものですので、trace コマンドの出力(ほかの関連情報も含めて)を
send-pr(1) する方がいいでしょう。
<p>
spl 関数についてのより詳しい情報は spl(9) を参照して下さい。

<ENTRY>why_msoft_float なぜカーネルを <tt><b>-msoft-float</b></tt> 付きでコンパイルするのですか
<p>
プロセスがシステムコールを呼び出したとき、
後でそのプロセスに戻ってこられるように、
カーネルはプロセッサーの状態を保存する必要があります。
浮動小数点レジスターは比較的大きくなりがちなので、それらを保存したり
回復したりすることは高価な操作です。もし FPU がまだ処理を実行途中であっ
たなら、CPU はその処理が完了するまで待ってからでないと、レジスターのコピー
を行うことができません。
<p>
カーネル内で浮動小数点レジスターを利用するのを避けることで、システムコール実行
の効率を、かなり向上させることができます。
また sparc など、いくつかのプロセッサーでは、浮動小数点コンテキストの切
り替えを lazy に行うことによって、プロセス切り替えの際の浮動小数点レジ
スターの保存/回復処理を、場合によっては省略することもできます。
<p>
いくつかのアーキテクチャーではコンパイラーは主要な操作 (メモリーブロック転送など)
のスピードアップのために浮動小数点レジスターを使うことができ、
上記の動作を止めるためには '-msoft-float' が必要です。

<ENTRY>kernel-compile-slow メモリーの少ないマシンでカーネルをコンパイルするとすごい遅いのですが
デフォルトでは NetBSD はサポートしているほとんど全てのハードウェアに対する
ドライバー、ネットワークプロトコル、ファイルシステムを含む GENERIC カーネルを
インストールします。これは、そのポートのいかなる計算機でもそのカーネルが
実行されることを保証しますが、結果として、特にメモリーが少ない計算機では、
必要以上の(メモリー)空間を占有します。また、カーネルのコンパイルの際には
 -O2 最適化が行われています。コンパイラーが、この最適化を行うことにより
出来上がるカーネルは可能な限り速くなりますが、コンパイルの際には
通常より多くのメモリーと時間を必要とします。
<p>
<a href="#building_a_kernel">あなた専用のカーネルを構築する</a>
際のひとつの方法としては、コンパイラーに対して通常の使用にとって
十分である最適化のみを行うように指示するために
"<tt><b>make&nbsp;COPTS=-O</b></tt>" を使うことです。この結果として
できあがったカーネルはほんの少し遅くなりますが、コンパイルにかかる
時間は短くなります。
<p>
もし、メモリーの少ないマシンを使用していて、カーネルをカスタマイズ
するために何度も 'コンパイル、新しいカーネルでリブート' を繰り返す
つもりがあるのならば、始めのの何回かは "<tt><b>make&nbsp;COPTS=-O</b></tt>"
を使い、最後に "<tt><b>make</b></tt>" を使うのが良いかもしれません。
<p>
もちろん、メモリーが少ししかないマシンでカーネルをコンパイルするのに、
一般的にもっとも速い方法は、別のマシンを使用すること、または一時的に
もっとメモリーを増設することです!

<ENTRY>problems_compiling_a_current_kernel -current カーネルのコンパイルに関する問題
最初に注意すべき点は、
<a href="../../MailingLists/#current-users">current-users</a>
メーリングリストに参加した方がよいということです。
current-users を読まずに -current を追うことはライトを灯けずに夜道を
ドライブしているようなものです。警告しましたよ :)<p>
最新の
<a href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-current/tar_files/src/config.tar.gz">config.tar.gz</a>
をダウンロードし、コンパイル、インストールし、あなたの
コンフィグファイルに対して再度 config を実行してください。
 (config コマンドはリリースごとにかなり頻繁に変更されますから)

<ENTRY>debugging_a_kernel_crash_dump カーネルクラッシュダンプのデバッグの方法
<ol>
<li>同じソースを用いて設定ファイルの中で <tt>DEBUG</tt> と '<tt>makeoptions
    DEBUG="-g"</tt>'を有効にして
    <a href="#building_a_kernel">カーネルの作成</a>をしたことを
    確認してください。
<li>"<b><tt>gdb netbsd.gdb</tt></b>"
    (カーネルをコンパイルしているディレクトリーで)
<li>gdb プロンプトで "<b><tt>target kcore /var/crash/netbsd.0.core</tt></b>"
</ol>
一般の gdb(1) コマンドも使えます。例えばバックトレースを得るには
'<b><tt>bt</tt></b>' とします。

<ENTRY>backtraces カーネルクラッシュダンプをデバッグしているときにバックトレースを得る方法
カーネルのクラッシュダンプをデバッグしている場合、
次の簡単な 2ステップで任意のプロセスのバックトレースを gdb から得ることができます。
<p>
<ol>
<li>プロセスの proc addr を調べる "<b>ps -ax -O paddr -M netbsd.x.core</b>"
<li>gdb に id として "<b>proc 0x&lt;addr&gt;</b>" を使うように指示する
</ol>

<ENTRY>ddb DDB ってなんですか、それを使うと何ができるんですか
DDB はオプションとして提供されるカーネル内部のデバッガーです。
次の 3通りの方法で起動することができます:
<ul>
<li>いつでも、ポート特有のキーの組合せで起動する(組合せについては ddb(4) 参照)。
<li>カーネルがパニックした時に起動するように設定できます。
<li>'-d' をブートフラグに指定する(<tt><b>boot netbsd -d</b></tt>)。
</ul>
いくつかの有用なコマンドは次の通りです:
<ul>
<li><tt><b>trace</b></tt> - スタックトレースを作ります。
    カーネルパニックの
    <a href="../../Misc/send-pr.html#submitting">問題報告を送る</a>のに
    とても便利です。
<li><tt><b>reboot</b></tt> - システムをリブートします。
<li><tt><b>sync</b></tt> - クラッシュダンプを作った後、リブートします(NetBSD
    1.4.X <em>より後</em>で導入されました)。
</ul>

<ENTRY>generating-a-crash-dump カーネルのクラッシュダンプを作るには
通常、カーネルはパニックした時に自動的にクラッシュダンプを生成し、
リブート時に savecore(8) によって回収されます。
しかし、 ddb(4) で <tt><b>'reboot&nbsp;0x100'</b></tt>
(NetBSD 1.5以降では <tt><b>sync</b></tt>) を用いると
強制的にクラッシュダンプを作る事ができます。もし、
カーネルが buffer キャッシュをシンク(同期)しようとしている間に panic したり
ハングするならば、シンクを行わない
<tt><b>'reboot&nbsp;0x104'</b></tt>を使うことができます。

<ENTRY>adding_a_kernel_to_a_boot_floppy ブートフロッピーにカーネルを追加する方法
いくつかのポートでは既に
"<b><tt>cd /usr/src/distrib/<em>&lt;ARCH&gt;</em>/floppies ; make </tt></b>"
としてブートフロッピーを構築することができます。
これを実行する前に INSTALL カーネルを手動で構築する必要があるかもしれません。
既に <b>boot.fs</b> ファイルがあるのなら、次の手順でカーネルを置き換え
ることもできます:
<ol>
<li><b><tt>vnconfig -c vnd0 boot.fs</tt></b>
<li><b><tt>mount /dev/vnd0a /mnt</tt></b>
<li><b><tt>gzip -c -9 &lt; netbsd &gt; /mnt/netbsd.gz</tt></b>
<li><b><tt>umount /mnt</tt></b>
<li><b><tt>vnconfig -u vnd0</tt></b>
</ol>
この手順は、コンフィグファイルに "<tt>pseudo-device vnd</tt>" を指定して
作成したカーネルを、現在利用していることを前提としています。

<ENTRY>scsi_device_numbers 新しく SCSI デバイスを増設したら、今までマウントできていたデバイスがマウントできなくなってしまいました。いったいどういう規則でデバイスに番号をつけてるんですか?
<!-- I'm having trouble mounting the SCSI device for a new partition I've just created.  What's up with this device-numbering scheme? -->
<!-- 今作ったばかりの新しいパーティションを含む SCSI デバイスをマウントしようとしたのにできません。いったいどういう規則でデバイスに番号をつけてるんですか? -->
<p>
デフォルトでは、NetBSD での SCSI デバイスは SCSI ID 番号の順に 0 から
番号付けされます。いいかえると、一番小さな番号の SCSI デバイスが
<tt>/dev/sd0</tt> となり、次のデバイスが <tt>/dev/sd1</tt> という
ふうになります。これはブートプロセスの間に対応づけられる事に
注意してください。
</p><p>
もし、あなた専用のカーネルをコンパイルするならば、
お好きな SCSI ID 番号を示す SCSI デバイスをセットすることができます。
そのためのカーネル設定ファイルは次のようになります:
<blockquote><pre>
sd0             at scsibus0 target 4 lun 0
sd*             at scsibus? target ? lun ?
</pre></blockquote>
上の 2行を用いると sd0 は SCSI ID 番号が 4 のディスクとなり、
残りのデバイスは上で述べられたルールで対応づけられます。
これは、しばしば、SCSI デバイスの "hardwiring" と呼ばれ、
RAID や <tt>ccd</tt> を使う場合には使用することをお勧めします。
こうしておくと、一つのデバイスの電源が入っていなかったり
故障した場合にデバイス ID が変わってしまうことを避けることができます。


<SECTION>よくあるハードウェアに関する質問


<ENTRY>device-not-configured <tt><b>device not configured</b></tt> ってどういう意味ですか?
<ul><li><p>
このメッセージがシステムブートの autoconfiguration の出力中に
現れたのならば、それはカーネルがシステム中に、あるハードウェアを
検出したがそれに対応するデバイスドライバが無いことを意味します。
これにはデバイスドライバは存在するがブートに使用したカーネルには
含まれていない場合と、デバイスドライバが本当に存在しない場合の
両方の可能性があります。
(後者の場合、優しい開発者に連絡を取り、テスト用のハードウェアを
提供してデバイスドライバーを書いてもらいましょう)
</p><p>
GENERIC カーネルは基本インストールに用いられるので、
安定で動くことが保証されている事が重要です。そのため、
まだ安定ではないデバイスドライバーは GENERIC カーネルに含まれていません。
あなたのシステム用の GENERIC カーネルの設定ファイルを見てみると
「コメントアウト」されている実験的なデバイスドライバーが見つかるかも
しれません。もしあなた用のカーネル(それを GENERIC とは呼ばないでください)を
コンパイルするならば、実験的なデバイスドライバーを試すことができます。
</p></li>
<li><p>
もし、このメッセージが <tt>/dev</tt>にあるデバイスノード
(例えば SCSI ディスク)へアクセスしようとしたときに出力されたならば、
それはアクセスしようとしたそのデバイスユニットを見つけられなかった
事を意味します。例えば、存在しない SCSI ディスクにアクセスしようと
した場合です。
</p><p>
しばしば、これは <tt>/etc/fstab</tt> に書かれたデバイスノードと
カーネルがブート時の autoconfiguration で見つけたものが一致しない状態で、
<tt>/etc/rc</tt>中の "mount" コマンドが全てのファイルシステムを
マウントしようとした時に起ります。いま一度、使用しようとした
デバイスがブート時にカーネルによって検出されているかを確認してください。
確認には <tt>/var/run/dmesg.boot</tt> (ブート時の autoconfiguration の
出力のコピーが保存されています) を用いることができます。
</p></li></ul>


<ENTRY>atapi_devices ATAPI や ATA (IDE) デバイスのデバッグ
もしカーネルが <tt>WDCDEBUG</tt> を有効にしてコンパイルされていれば、
gdb が <code>wdcdebug_atapi_mask</code> と <code>wdcdebug_mask</code> 
の値の変更に使用できます。
これらの変数中の適切なビットを設定することで、カーネルは ATAPI と ATA 操作に
ついての詳しい情報を出力するようになります。<br>
(現在 NetBSD のデフォルトでは <tt>WDCDEBUG</tt> は有効になっています。)<p>
最高レベルの出力を得るには次の手順に従ってください:
<pre>	# <strong>gdb --write /netbsd</strong>
	(gdb) <strong>set wdcdebug_atapi_mask=0xff</strong>
	(gdb) <strong>set wdcdebug_mask=0xff</strong>
	(gdb) <strong>quit</strong>
</pre>
註: この例の設定は<em>非常に</em>大量の出力を行います。
個々のオプションを選択するためには、次に掲げる行のすぐ上に
ある、ビットフラグのリストを見てください:
<ul>
<li>
<CURRENTSRC>/sys/dev/scsipi/atapi_wdc.c 中の <tt>wdcdebug_atapi_mask</tt>
<li>
<CURRENTSRC>/sys/dev/ic/wdc.c 中の <tt>wdcdebug_mask</tt> 
</ul>

<ENTRY>usb-debugging USB デバイスのデバッグ
USB デバイスの問題が起きた場合、USB ドライバのメッセージを冗長にすることが
できます。
<ul>
<li><tt>USB_DEBUG</tt> と <tt>DDB</tt> を含むカーネルをコンパイルする。
<li><tt><b>-d</b></tt> をつけてブートし、ddb(4) に入る。
<li>ddb で変数 usbdebug と uhcidebug を 5 にセットする。 ("<b>set
usbdebug=5</b>" と "<b>set uhcidebug=5</b>")
<li>デバイスを挿入して<b><tt>continue</tt></b> と入力する。
</ul>

<ENTRY>new_pnp_device あたらしい PnP デバイスを認識させるには
この手順は対応する汎用のデバイスがすでにサポートされており、
デバイス ID が認識されないだけである時のみ有効です。
動作の異なるデバイスを加えるにはソースコードを書く必要があります。
<ol>
<li>デバイスは、ブートメッセージ中に '<tt>not configured</tt>' として
表示されているはずです。出力中に含まれる
デバイス ID を記録して下さい(この例だと <tt><b>USR3031</b></tt>です):
<pre>	isapnp0: &lt;U.S. Robotics 56K FAX INT, <b>USR3031</b>, , &gt; port 0x3e8/8 irq 5 not configured</pre>
<li>適切なエントリーを<tt>
<CURRENTSRC>/sys/dev/isapnp/isapnpdevs</tt> に加えて下さい:
<pre>	devlogic       com     USR3031         USR 56k Faxmodem</pre>
<li><tt>isapnpdevs.{c,h}</tt> を
	'<tt>make -f Makefile.isapnpdevs</tt>'
として作り直します。
<li><a href="#building_a_kernel">カーネルの再構築</a>をしてください。
</ol>

<ENTRY>new_pcmcia_device あたらしい PCMCIA デバイスを認識させるには
この手順は対応する汎用のデバイスがすでにサポートされており、
デバイス ID が認識されないだけである時のみ有効です。
動作の異なるデバイスを加えるにはソースコードを書く必要があります。
<ol>
<li>カーネルを options(4) <tt>PCMCIA_VERBOSE</tt> を有効にしてコンパイルします。
<li>ブートメッセージをチェックします - 該当のカードは '<tt>not configured</tt>' と
    レポートされているはずです。製造元(Manufacturer) とプロダクトコード(例題では
    <tt><b>0x143</b></tt> と <tt><b>0x201</b></tt>です)を記録します:
<pre>pcmcia0: CIS version PCMCIA 2.0 or 2.1
pcmcia0: CIS info: Grey Cell, GCS2000, Gold II, 1
pcmcia0: Manufacturer code <b>0x143</b>, product <b>0x201</b>
pcmcia0: function 0: network adapter, ccr addr 3f8 mask 1
</pre>
<li><tt>ベンダー(vendor)</tt> と <tt>プロダクトコード(product)</tt> を <tt>
<CURRENTSRC>/sys/dev/pcmcia/pcmciadevs</tt>に加えます:
<li><tt>pcmciadevs.h</tt> と <tt>pcmciadevs_data.h</tt> を
	'<tt>make -f Makefile.pcmciadevs</tt>'
    として作り直します。
<li>付け加えたエントリーを適切な <tt>/sys/dev/pcmcia/</tt> にある bus attach ファイルの
    先頭部分にあるデバイステーブルに付け加えます。例えば ne2000互換カードの場合には
    <CURRENTSRC>/sys/dev/pcmcia/if_ne_pcmcia.c に加えます。
<li><a href="#building_a_kernel">カーネルの再構築</a>をします。
<li>変更点を send-pr(1) または <a href="../../Misc/send-pr.html#submitting">オンラインフォーム</a>を用いて
    報告して下さい。
</ol>

<ENTRY>plip_support PLIP (Parallel Line IP) をサポートしていますか
NetBSD/i386 で PLIP をサポートするための Martin Husemann のパッチが
<a href="http://www.NetBSD.org/cgi-bin/query-pr-single.pl?number=1278">
PR 1278</a> として出ています。
この PR の末尾にあるパッチは、NetBSD 1.3.3 ソースツリーに対して適用す
ることができます。

</LIST>

<DOCLINK>

<hr>
<address>
  <a href="../../Misc/feedback.html">(Contact us)</a>
  $NetBSD: index.list,v 1.36 2000/05/19 10:15:00 abs Exp $<br>
  <a href="../../Misc/disclaimer.html">Copyright &copy;
    1996, 1998, 1999, 2000
    The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED.</a>
</address>

</body>
</html>
