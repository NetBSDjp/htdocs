<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html lang="ja">
<head>
<!-- Copyright (c) 1994-2003
	The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED. -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-2022-JP">
<link rev="made" href="mailto:www@jp.NetBSD.org">
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
<title>NetBSD Documentation: Kernel Programming FAQ</title>
</head>
<body bgcolor="#FFFFFF" text="#000000">

<HEADING>カーネルプログラミング

<LIST>

<h2>他の関連するリンク</h2>
<ul>
<li> driver(9) - デバイスドライバーが利用する NetBSD の自動コンフィギュレーションのインターフェース
<li> autoconf(9) - NetBSD の自動コンフィギュレーションフレームワークについての
     全般的な説明
<li> config(9) - 自動コンフィギュレーションフレームワークの「デバイス定義」言語
<li> bus_dma(9) - NetBSD のバスとマシン独立な DMA フレームワーク、これに
        関する<a href="bus_dma.ps">論文</a> (120k、ポストスクリプト)
<li> bus_space(9) - NetBSD のバススペースの操作のためのインターフェース
<li><a href="scsidma.html">SCSI DMA はどのように動作するか</a> - Tohru Nishimura による
<li><a href="lazyfpu.html">lazy FPU コンテキストスイッチはどのように動作するか</a> - Tohru
	Nishimura による
<li><a href="/Documentation/kernel/converting-ethernet-drivers.html" origlink="converting-ethernet-drivers.html">
        昔の BSD のイーサネットドライバーの NetBSD-1.2D 以降への移植</a>
<li><a href="porting-freebsd-net.html">
        FreeBSD のネットワークドライバーを NetBSD に移植するためのメモ</a>
</ul>

<SECTION>Misc

<ENTRY>knf KNF とは何ですか
KNF は Kernel Normal Form の略で、/usr/share/misc/style に記述されている 
C のコーディングスタイルです。ソースツリーに
<CURRENTSRC>/usr/src/share/misc/style
として含まれています。

<ENTRY> packed-attribute pack された属性を使用する
wire プロトコルデータフォーマットを記述する構造体の中では、いつも
pack された属性を使用しています。

<ENTRY>printf デバッグのための printf() の使い方
カーネルドライバーのデバッグ用の情報を出力するもっとも簡単な方法は、
printf() を使うことでしょう。カーネルの printf は コンソールに出力
されるので、多く出力しすぎ、システムが使いものにならないように注意
しなければなりません。

<ENTRY>forcing-ddb 強制的に DDB に落とす
カーネルのコンフィグファイルが '<code>options&nbsp;DDB</code>'を
含んでいる事を確認してください。
ファイルに'<code>#include&nbsp;"opt_ddb.h"</code>' を記述し、
'<code>Debugger()</code>' を使ってください。


<ENTRY>adding_a_new_driver カーネルに新しいドライバーを追加する
全てのドライバーは、すくなくとも以下の二つの関数を必要とします。
<ul>
<p>
<li><tt><i>xxx</i>probe()</tt> (NetBSD がデバイスの存在を調べる時)</li>
<li><code><i>xxx</i>attach()</code> ルーチンはデバイスを設定、アタッチします。</li>
</ul>
<p>
プローブとアタッチルーチンを書いたら、
<p>
<tt>/usr/src/sys/arch/&lt;your-arch&gt;/&lt;your-arch&gt;/conf.c</tt>
<p>
にエントリーを追加してください。そこには以下の二つのテーブルがあります。
<p>
<ul>
<li><code>cdevsw</code> キャラクターデバイス用。</li>
<li><code>bdevsw</code> ブロックデバイス用(ブロックI/O とストラテジー・
ルーチンとして使用する)。</li>
</ul>
<p>
ほとんどのエントリーは <code>cdev_<i>xxx</i>_init()</code> という形式と
なります。これは標準的な Unix のデバイススイッチルーチンのプロトタイプ
のためのマクロです。
<p>
プローブとアタッチルーチンはブート時によばれます。
<code>open()</code>、<code>close()</code>、<code>read()</code>、
<code>write()</code> ルーチンは、メジャー番号がテーブルのインデックス
に一致するデバイススペシャルファイルがオープンされた時によばれます。
例えば、メジャー番号18 のデバイスをオープンした場合、<tt>cdevsw[]/bdevsw</tt>
の中のデバイス番号18の "open" ルーチンがよばれます。
<p>
ほとんどのドライバーはバス固有のアタッチコードとマシン独立のコアに分割
されています。例えば、PCI lance イーサネットドライバーは以下のファイルで
構成されています。
<p>
<ul>
<li><CURRENTSRC>/sys/dev/pci/files.pci
       - アタッチ情報 ('le at pci'を見てください)。
<li><CURRENTSRC>/sys/dev/pci/if_le_pci.c
       - ドライバーのためのPCI バスのアタッチのコード。
<p>
<li><CURRENTSRC>/sys/conf/files
       - MI コアのアタッチ情報('le:'を見てください)。
<li><CURRENTSRC>/sys/dev/ic/am7990.c
       - MI ドライバー、24ビットアクセスのコード。
<li><CURRENTSRC>/sys/dev/ic/am79900.c
       - MI ドライバー、32ビットアクセスのコード。
<li><CURRENTSRC>/sys/dev/ic/lance.c
       - MI コアのドライバーのコード。
</ul>
<p>
<a href="#autoconf">autoconf の説明</a>もご覧ください。


<ENTRY>autoconf この autoconf の素材は、どのように動作するのか?
<p>
autoconf の仕組みは、その動作方法を一度理解してしまえば非常に単純なものです。
実行時にデバイスプローブツリーがどのように構築されて使われるのかについて、
正確な詳細は無視したいのであれば、
個々の「葉」のドライバーに関して必要なことは以下のとおりです。
<ol>
    <li> 各ドライバーは、 3 個の構成要素からなる構造体を規定します -
         構成要素は、そのプライベート構造体のサイズ、プローブ関数、アタッチ関数です。
         これはコンパイルされて実行時に使われます - たとえば以下のようになります:
<p>
<pre>
struct cfattach foo_baz_ca = {
    sizeof(struct foo_baz_softc), foo_baz_match, foo_baz_attach
};
</pre>
    <li> カーネル起動に際して、このデバイスをアタッチする時に、
         autoconf のコードはデバイスのプローブルーチンを呼んで、
         親へのポインター (<tt>struct device *parent</tt>)・
         アタッチタグ構造体へのポインター (<tt>void *aux</tt>)・
         適切な autoconf ノード (<tt>struct cfdata *cf</tt>) を渡します。
         ドライバーは、呼ばれるべき場所かどうかを判断することになっています
         (通常、ロケーションおよびコンフィギュレーション情報がアタッチタグによって渡されます)。
         そこがしかるべき場所だった場合は、プローブルーチンは 1 を返すべきです。
         もしデバイスがそこになければ、プローブルーチンは 0 を返す必要があります。
         いずれの場合も、<b>いかなる状態も保持されてはいけません</b>。
    <li> プローブが成功して戻ると、 autoconf は、デバイスの *_ca
         で指定されたサイズのメモリー塊を割り当て、そのデバイスのアタッチルーチンを呼んで、
         親へのポインター (<tt>struct device *parent</tt>)・
         今割り当てたメモリーへのポインター(<tt>struct device *self</tt>)・
         アタッチタグ構造体へのポインター (<tt>void *aux</tt>) を渡します。
         ドライバーは、正確なポートとメモリーを見つけ出し、資源を割り当て、
         これに応じてドライバー内の構造体を初期化することになっています。
         ドライバーのインスタンスに固有な情報は、
         極力、ここで割り当てられたメモリーに保持すべきです。
</ol>
<p>
例: PCI イーサネットドライバー 'baz' を考えましょう。
カーネルコンフィグは以下のようになっています:
<pre>
pci*    at mainbus?
baz*    at pci? dev ? function ?
</pre>
<p>
実行時、 autoconf はマシンの pci バス上の物理デバイスすべてに対して
繰り返し実行されます。各物理デバイスに対して、 autoconf は、
pci バス上にあることがカーネルに設定されているすべてのデバイスの
ドライバーのプローブルーチンを呼ぶことを繰り返します。
いずれかのプローブルーチンがそのデバイスについて 1 を返すと、
autoconf はこれを中止し、上述の 3) で説明した作業をおこないます。
アタッチ関数が戻ると、 autoconf は次の物理デバイスの処理を続けます。
<p>
<a href="#adding_a_new_driver">カーネルに新しいドライバーを追加する</a>もご覧ください。


<ENTRY>adding_a_system_call システムコールを追加する
<tt>syscalls.master</tt> にエントリーを追加し、syscall スタブを
<tt>
<CURRENTSRC>/usr/src/lib/libc/sys/Makefile.inc
</tt> の適当な場所に追加してください。

<ENTRY>adding_a_sysctl sysctl を追加する
<a href="http://mail-index.NetBSD.org/tech-kern/">tech-kern</a>
メーリングリストに、この質問への答えが
<a href="http://mail-index.NetBSD.org/tech-kern/2001/06/24/0000.html">投稿</a>
されているので、そちらを参照してください。
<p>

なお、 NetBSD 1.6 とそれ以降では、ベンダー特有の項目用として、
特別な "vendor" カテゴリーが予約されています。さらなる情報は
sysctl(8) を参照してください。

<ENTRY>mmap_in_pseudo-device 仮想デバイスに mmap を実装する方法
あなたの作ったデバイスは、おそらくキャラクターデバイスでしょう。もし、
そうであれば、デバイスページャーを使っているはずです。(VM システムは、
これらすべてを隠蔽しているので、心配しないでください)。
<p>
最初に、mmap インターフェースのために、適当なオフセットをいくつか選
んでください。例えば「mmap オフセット 0-M は オブジェクトAをあたえる、
N-O はオブジェクト B をあたえる」等のように。
<p>
これが終ると、mmap ルーチンは以下のように実装できます。
<p>
<pre>
int
foommap(dev, off, prot)
        dev_t dev;
        int off, prot;
{

        if (off &amp; PAGE_MASK)
                panic("foommap");

        if ((u_int)off &gt;= FOO_REGION1_MMAP_OFFSET &amp;&amp;
            (u_int)off &lt; (FOO_REGION1_MMAP_OFFSET + FOO_REGION1_SIZE))
                return (atop(FOO_REGION1_ADDR + ((u_int)off -
                    FOO_REGION1_MMAP_OFFSET)));

        if ((u_int)off &gt;= FOO_REGION2_MMAP_OFFSET &amp;&amp;
            (u_int)off &lt; (FOO_REGION2_MMAP_OFFSET + FOO_REGION2_SIZE))
                return (atop(FOO_REGION1_ADDR + ((u_int)off -
                    FOO_REGION2_MMAP_OFFSET)));

        /* Page not found. */
        return (-1);
}
</pre>
<p>
さて、実際には単純なカーネルメモリーオブジェクトを mmap するので、
コードはもうすこし複雑になります(結局は仮想デバイスですから)。
<p>
これを動作させるためには、アロケートしたメモリーオブジェクトをページ調整
された境界に確実に mmap しなければなりません。もし、アロケートしたメモリー
のサイズ &gt;= PAGE_SIZE なら、これは保証されます。そうでなければ、
uvm_km_alloc() を使い、アロケーションサイズをページサイズに切りあげてください。
<p>
若干の修正を加えると以下のようになります。
<p>
<pre>
int
foommap(dev, off, prot)
        dev_t dev;
        int off, prot;
{
        paddr_t pa;

        if (off &amp; PAGE_MASK)
                panic("foommap: offset not page aligned");

        if ((u_int)off &gt;= FOO_REGION1_MMAP_OFFSET &amp;&amp;
            (u_int)off &lt; (FOO_REGION1_MMAP_OFFSET + FOO_REGION1_SIZE)) {
                if ((vaddr_t)foo_object1 &amp; PAGE_MASK)
                        panic("foommap: foo_object1 not page aligned");
                if (pmap_extract(pmap_kernel(), foo_object1 +
                    (u_int)off - FOO_REGION1_MMAP_OFFSET, &amp;pa) == FALSE)
                        panic("foommap: foo_object1 page not mapped");
                return (atop(pa));
        }

        if ((u_int)off &gt;= FOO_REGION2_MMAP_OFFSET &amp;&amp;
            (u_int)off &lt; (FOO_REGION2_MMAP_OFFSET + FOO_REGION2_SIZE)) {
                if ((vaddr_t)foo_object2 &amp; PAGE_MASK)
                        panic("foommap: foo_object2 not page aligned");
                if (pmap_extract(pmap_kernel(), foo_object2 +
                    (u_int)off - FOO_REGION2_MMAP_OFFSET, &amp;pa) == FALSE)
                        panic("foommap: foo_object2 page not mapped");
                return (atop(pa));
        }

        /* Page not found. */
        return (-1);
}
</pre>

<ENTRY>accessing_a_kernel_structure_from_userland ユーザーランドからカーネルの構造体へアクセスする
良い例が <tt>
<CURRENTSRC>/usr/src/usr.bin/vmstat/dkstats.c
</tt> にあります。
ここではディスクの統計情報を読んでいます。

<ENTRY>sample_driver 参考にできそうな簡単な PCI ドライバーはありませんか
sys/dev/pci/puc.c を参考にしてください。これは、最も簡単なドライバーの
ひとつです。PUC は、ひとつ以上のシリアル、パラレルポートを持つデバイス
で、通常、標準的なチップを使用しています(例えば、シリアルの 16550 UART)。
ドライバーは、単に シリアル、あるいはパラレルコントローラーのレジスター
の I/O アドレスをさがし、それをシリアル、またはパラレルドライバーへ渡す
だけです。

</LIST>

<a href="./"><em>NetBSD ドキュメンテーション: カーネル</em> に戻る</a>
<hr>

<DOCLINK>

<hr>
<address>
  <small>
  (連絡先 - <a href="http://www.NetBSD.org/cgi-bin/feedback.cgi">英語</a>,
       <a href="mailto:www@jp.NetBSD.org">日本語:
       www@jp.NetBSD.org</a>)<br>
  $NetBSD: programming.list,v 1.29 2004/03/20 20:38:25 snj Exp $<br>
  <!-- based on english translation: -->
  <!-- NetBSD: programming.list,v 1.29 2004/03/20 20:38:25 snj Exp   -->
  <a href="../../Misc/disclaimer.html">Copyright &copy; 1994-2003
  The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED.</a>
  </small>
</address>

</body>
</html>
