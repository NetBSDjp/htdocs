<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<!-- Copyright (c) 1998, 1999, 2000
	The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED. -->
<link rev="made" href="mailto:www@NetBSD.ORG">
<title>Kernel programming FAQ</title>
</head>
<body bgcolor="#FFFFFF" text="#000000">

<HEADING>Kernel programming

<LIST>

<h2>Other related links</h2>
<ul>
<li><a href="scsidma.html">How SCSI DMA works</a> - by Tohru Nishimura
<li><a href="lazyfpu.html">How lazy FPU context switch works</a> - by Tohru
	Nishimura
<li> bus_dma(9) - NetBSD's bus and machine independent DMA framework, 
        described in it's own <a href="bus_dma.ps">paper</a> (120k, postscript)
<li> bus_space(9) - NetBSD's bus space manipulation interface
<li><a href="converting-ethernet-drivers.html">
	Converting ancient BSD Ethernet drivers to NetBSD-1.2D and later</a>
<li><a href="porting-freebsd-net.html">
	Notes on porting FreeBSD network drivers to NetBSD</a>
</ul>

<SECTION>Misc

<ENTRY>knf What is KNF
KNF stands for "Kernel Normal Form" - it's a C coding style documented in
/usr/share/misc/style, which is included in the source tree as
<CURRENTSRC>/usr/src/share/misc/style.

<ENTRY>packed-attribute Using the `packed' attribute
Always use the `packed' attribute in structures which describe
wire protocol data formats.

<ENTRY>printf Using printf() for debugging
Probably the simplest way of generating debugging information from a kernel
driver is to use printf(). The kernel printf will send output to the console,
so beware of generating too much output and making the system unusable.

<ENTRY>forcing-ddb Forcing code to enter DDB.
Ensure your kernel config file contains '<code>options&nbsp;DDB</code>',
the file has '<code>#include&nbsp;"opt_ddb.h"</code>', then use
'<code>Debugger()</code>'.

<ENTRY>adding_a_new_driver Adding a new driver to the kernel
Every driver needs at least
<p>
<ul>
<li><tt><i>xxx</i>probe()</tt> (during which NetBSD will attempt to determine if the device is present)</li>
<li><code><i>xxx</i>attach()</code> routine which will configure and attach the device.</li>
</ul>
<p>
Once probe and attach routines have been written, add an entry to
<p>
<tt>/usr/src/sys/arch/&lt;your-arch&gt;/&lt;your-arch&gt;/conf.c</tt>.
<p>
There are two tables:
<p>
<ul>
<li><code>cdevsw</code> for character devices.</li>
<li><code>bdevsw</code> for block devices (for those that also perform "block"
I/O and use a strategy routine).</li>
</ul>
<p>
Most entries will be of the form <code>cdev_<i>xxx</i>_init()</code>, which
is a macro handling prototyping of the standard Unix device switch routines.
<p>
The probe/attach routines are called at boot time.  The
<code>open()</code>, <code>close()</code>, <code>read()</code>, and
<code>write()</code> routines are called when you open up the device
special file who's major number corresponds to the index into that
table.  For example, if you open up a device who's major number is 18,
the "open" routine for device number 18 in <tt>cdevsw[]/bdevsw</tt>
will be called.
<p>
Most drivers are split between bus specific attach code, and a machine
independent core. As an example, the driver for the PCI lance ethernet chip
has entries in the following files:
<p>
<ul>
<li><CURRENTSRC>/sys/dev/pci/files.pci
	- attach information (look for 'le at pci').
<li><CURRENTSRC>/sys/dev/pci/if_le_pci.c
	- PCI bus attach code for the driver.
<p>
<li><CURRENTSRC>/sys/conf/files
	- MI core attach information (look for 'le:').
<li><CURRENTSRC>/sys/dev/ic/am7990.c
	- MI driver 24bit access code.
<li><CURRENTSRC>/sys/dev/ic/am79900.c
	- MI driver 32bit access code.
<li><CURRENTSRC>/sys/dev/ic/lance.c
	- MI core driver code.
</ul>

<ENTRY>adding_a_system_call Adding a system call
Add an entry in <tt>syscalls.master</tt>, and add the syscall stub to the
appropriate place in <tt>
<CURRENTSRC>/usr/src/lib/libc/sys/Makefile.inc
</tt>.

<ENTRY>mmap_in_pseudo-device How to implement mmap in a pseudo-device
Your device is most likely a character device, so you will be using the device
pager (the VM system hides all of this from you, don't worry).
<p>
The first thing you need to do is pick some arbitrary offsets for your mmap
interface.  Something like "mmap offset 0-M gives object A, N-O gives object
B", etc.
<p>
After that, your mmap routine would look something like this:
<p>
<pre>
int
foommap(dev, off, prot)
        dev_t dev;
        int off, prot;
{

        if (off &amp; PAGE_MASK)
                panic("foommap");

        if ((u_int)off &gt;= FOO_REGION1_MMAP_OFFSET &amp;&amp;
            (u_int)off &lt; (FOO_REGION1_MMAP_OFFSET + FOO_REGION1_SIZE))
                return (atop(FOO_REGION1_ADDR + ((u_int)off -
                    FOO_REGION1_MMAP_OFFSET)));

        if ((u_int)off &gt;= FOO_REGION2_MMAP_OFFSET &amp;&amp;
            (u_int)off &lt; (FOO_REGION2_MMAP_OFFSET + FOO_REGION2_SIZE))
                return (atop(FOO_REGION1_ADDR + ((u_int)off -
                    FOO_REGION2_MMAP_OFFSET)));

        /* Page not found. */
        return (-1);
}
</pre>
<p>
Now, this is slightly more complicated by the fact that you are going to be
mmap'ing what are simply kernel memory objects (it is a pseudo-device after
all).
<p>
In order to make this work, you're going to want to make sure you allocate the
memory objects to be mmap'd on page-aligned boundaries.  If you are allocating
something &gt;= PAGE_SIZE in size, this is guaranteed.  Otherwise, you are going
to have to use uvm_km_alloc(), and round your allocation size up to page size.
<p>
Then it would look a bit more like this:
<p>
<pre>
int
foommap(dev, off, prot)
        dev_t dev;
        int off, prot;
{
        paddr_t pa;

        if (off &amp; PAGE_MASK)
                panic("foommap: offset not page aligned");

        if ((u_int)off &gt;= FOO_REGION1_MMAP_OFFSET &amp;&amp;
            (u_int)off &lt; (FOO_REGION1_MMAP_OFFSET + FOO_REGION1_SIZE)) {
                if ((vaddr_t)foo_object1 &amp; PAGE_MASK)
                        panic("foommap: foo_object1 not page aligned");
                if (pmap_extract(pmap_kernel(), foo_object1 +
                    (u_int)off - FOO_REGION1_MMAP_OFFSET, &amp;pa) == FALSE)
                        panic("foommap: foo_object1 page not mapped");
                return (atop(pa));
        }

        if ((u_int)off &gt;= FOO_REGION2_MMAP_OFFSET &amp;&amp;
            (u_int)off &lt; (FOO_REGION2_MMAP_OFFSET + FOO_REGION2_SIZE)) {
                if ((vaddr_t)foo_object2 &amp; PAGE_MASK)
                        panic("foommap: foo_object2 not page aligned");
                if (pmap_extract(pmap_kernel(), foo_object2 +
                    (u_int)off - FOO_REGION2_MMAP_OFFSET, &amp;pa) == FALSE)
                        panic("foommap: foo_object2 page not mapped");
                return (atop(pa));
        }

        /* Page not found. */
        return (-1);
}
</pre>

<ENTRY>accessing_a_kernel_structure_from_userland Accessing a kernel structure from userland
The canonical example for this is:  <tt>
<CURRENTSRC>/usr/src/usr.bin/vmstat/dkstats.c
</tt>, which reads disk statistics.

<ENTRY>sample_driver Is there a simple PCI driver I can use as an example?
You can look at sys/dev/pci/puc.c, which is one of the simplest drivers.
PUCs are devices with one or more serial or parallel ports on it, usually
using standard chips (e.g. 16550 UART for serial).
This driver just locates the I/O adresses of the registers of the serial or
parallel controller and passes it to the serial or parallel driver.

</LIST>

<a href="">Up to <em>NetBSD Documentation: Kernel</em></a>
<hr>

<DOCLINK>

<hr>
<address>
  <small>
  <a href="../../Misc/feedback.html">(Contact us)</a>
  $NetBSD: programming.list,v 1.18 2001/01/19 13:33:14 darcy Exp $<br>
  <a href="../../Misc/disclaimer.html">Copyright &copy;
    1998, 1999, 2000
    The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED.</a>
  </small>
</address>

</body>
</html>
