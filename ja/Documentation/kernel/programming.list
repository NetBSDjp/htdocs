<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<!-- Copyright (c) 1994-2003
	The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED. -->
<link rev="made" href="mailto:www@NetBSD.org">
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
<title>NetBSD Documentation: Kernel Programming FAQ</title>
</head>
<body bgcolor="#FFFFFF" text="#000000">

<HEADING>Kernel programming

<LIST>

<h2>Other related links</h2>
<ul>
<li> driver(9) - NetBSD autoconfiguration interface utilised by device drivers
<li> autoconf(9) - General description on the NetBSD autoconfiguration
     framework
<li> config(9) - The autoconfiguration framework ``device definition'' language
<li> bus_dma(9) - NetBSD's bus and machine independent DMA framework, 
        described in its own <a href="bus_dma.ps">paper</a> (120k, postscript)
<li> bus_space(9) - NetBSD's bus space manipulation interface
<li><a href="scsidma.html">How SCSI DMA works</a> - by Tohru Nishimura
<li><a href="lazyfpu.html">How lazy FPU context switch works</a> - by Tohru
	Nishimura
<li><a href="converting-ethernet-drivers.html">
	Converting ancient BSD Ethernet drivers to NetBSD-1.2D and later</a>
<li><a href="porting-freebsd-net.html">
	Notes on porting FreeBSD network drivers to NetBSD</a>
</ul>

<SECTION>Misc

<ENTRY>knf What is KNF
KNF stands for "Kernel Normal Form" - it's a C coding style documented in
/usr/share/misc/style, which is included in the source tree as
<CURRENTSRC>/usr/src/share/misc/style.

<ENTRY>packed-attribute Using the `packed' attribute
Always use the `packed' attribute in structures which describe
wire protocol data formats.

<ENTRY>printf Using printf() for debugging
Probably the simplest way of generating debugging information from a kernel
driver is to use printf(). The kernel printf will send output to the console,
so beware of generating too much output and making the system unusable.

<ENTRY>forcing-ddb Forcing code to enter DDB.
Ensure your kernel config file contains '<code>options&nbsp;DDB</code>',
the file has '<code>#include&nbsp;"opt_ddb.h"</code>', then use
'<code>Debugger()</code>'.

<ENTRY>adding_a_new_driver Adding a new driver to the kernel
Every driver needs at least
<p>
<ul>
<li><tt><i>xxx</i>probe()</tt> (during which NetBSD will attempt to determine if the device is present)</li>
<li><code><i>xxx</i>attach()</code> routine which will configure and attach the device.</li>
</ul>
<p>
Once probe and attach routines have been written, add an entry to
<p>
<tt>/usr/src/sys/arch/&lt;your-arch&gt;/&lt;your-arch&gt;/conf.c</tt>.
<p>
There are two tables:
<p>
<ul>
<li><code>cdevsw</code> for character devices.</li>
<li><code>bdevsw</code> for block devices (for those that also perform "block"
I/O and use a strategy routine).</li>
</ul>
<p>
Most entries will be of the form <code>cdev_<i>xxx</i>_init()</code>, which
is a macro handling prototyping of the standard Unix device switch routines.
<p>
The probe/attach routines are called at boot time.  The
<code>open()</code>, <code>close()</code>, <code>read()</code>, and
<code>write()</code> routines are called when you open up the device
special file who's major number corresponds to the index into that
table.  For example, if you open up a device who's major number is 18,
the "open" routine for device number 18 in <tt>cdevsw[]/bdevsw</tt>
will be called.
<p>
Most drivers are split between bus specific attach code, and a machine
independent core. As an example, the driver for the PCI lance ethernet chip
has entries in the following files:
<p>
<ul>
<li><CURRENTSRC>/sys/dev/pci/files.pci
	- attach information (look for 'le at pci').
<li><CURRENTSRC>/sys/dev/pci/if_le_pci.c
	- PCI bus attach code for the driver.
<p>
<li><CURRENTSRC>/sys/conf/files
	- MI core attach information (look for 'le:').
<li><CURRENTSRC>/sys/dev/ic/am7990.c
	- MI driver 24bit access code.
<li><CURRENTSRC>/sys/dev/ic/am79900.c
	- MI driver 32bit access code.
<li><CURRENTSRC>/sys/dev/ic/lance.c
	- MI core driver code.
</ul>
<p>
See also <a href="#autoconf">the autoconf explanation</a>.


<ENTRY>autoconf How does all this autoconf stuff work?
<p>
The autoconf machinery is quite simple once you figure out the way
it works. If you want to ignore the exact details of how the device
probe tree is built and walked on runtime, the bits needed for
each individual "leaf" driver are like this:
<ol>
    <li> each driver specifies a structure holding three things - size
         of its private structure, probe function and attach function;
         this is compiled in and used in runtime - example:
<p>
<pre>
struct cfattach foo_baz_ca = {
    sizeof(struct foo_baz_softc), foo_baz_match, foo_baz_attach
};
</pre>
    <li> on kernel startup, once the time comes to attach the device,
         autoconf code calls device's probe routine and passes it
         pointer to parent (<tt>struct device *parent</tt>), pointer
         to attach tag structure (<tt>void *aux</tt>), and appropriate
         autoconf node (<tt>struct cfdata *cf</tt>). The driver is
         expected to find out if it's where it's supposed to be
         (commonly, the location and configuration information is
         passed by the attach tag). If yes, the probe routine should
         return 1.  If device is not there, probe routine has to
         return 0.  <b>NO STATE SHOULD BE KEPT</b> in either case.
    <li> if probe returned success, autoconf allocates chunk of memory
         sized as specified in device's *_ca and calls its attach
         routine, passing it pointer to parent (<tt>struct device
         *parent</tt>), pointer to the freshly allocated memory
         (<tt>struct device *self</tt>) and the attach tag (<tt>void
         *aux</tt>). Driver is expected to find out exact ports and
         memory, allocate resources and initialize its internal
         structure accordingly. Preferably, all driver instance
         specific information should be kept in the allocated memory.
</ol>
<p>
Example: Let's have a PCI ethernet device 'baz', kernel config
chunk looks like this:
<pre>
pci*    at mainbus?
baz*    at pci? dev ? function ?
</pre>
<p>
At runtime, autoconf iterates over all physical devices present on
machine's pci bus. For each physical device, it iterates over all
devices registered in kernel to be on pci bus, and calls drivers'
probe routine. If any probe routine claims the device by returning
1, autoconf stops iterating and does the job described under 3).
Once the attach function returns, autoconf continues with next
physical device.
<p>
See also <a href="#adding_a_new_driver">Adding a new driver</a>.


<ENTRY>adding_a_system_call Adding a system call
Add an entry in <tt>syscalls.master</tt>, and add the syscall stub to the
appropriate place in <tt>
<CURRENTSRC>/usr/src/lib/libc/sys/Makefile.inc
</tt>.

<ENTRY>adding_a_sysctl Adding a sysctl
See a
<a href="http://mail-index.NetBSD.org/tech-kern/2001/06/24/0000.html">posting</a>
answering this question on 
<a href="http://mail-index.NetBSD.org/tech-kern/">tech-kern</a>.
<p>

Note that NetBSD 1.6 and up will have a special "vendor" sysctl category
that is reserved for vendor specific entries. See sysctl(8) for more
information.

<ENTRY>mmap_in_pseudo-device How to implement mmap in a pseudo-device
Your device is most likely a character device, so you will be using the device
pager (the VM system hides all of this from you, don't worry).
<p>
The first thing you need to do is pick some arbitrary offsets for your mmap
interface.  Something like "mmap offset 0-M gives object A, N-O gives object
B", etc.
<p>
After that, your mmap routine would look something like this:
<p>
<pre>
int
foommap(dev, off, prot)
        dev_t dev;
        int off, prot;
{

        if (off &amp; PAGE_MASK)
                panic("foommap");

        if ((u_int)off &gt;= FOO_REGION1_MMAP_OFFSET &amp;&amp;
            (u_int)off &lt; (FOO_REGION1_MMAP_OFFSET + FOO_REGION1_SIZE))
                return (atop(FOO_REGION1_ADDR + ((u_int)off -
                    FOO_REGION1_MMAP_OFFSET)));

        if ((u_int)off &gt;= FOO_REGION2_MMAP_OFFSET &amp;&amp;
            (u_int)off &lt; (FOO_REGION2_MMAP_OFFSET + FOO_REGION2_SIZE))
                return (atop(FOO_REGION1_ADDR + ((u_int)off -
                    FOO_REGION2_MMAP_OFFSET)));

        /* Page not found. */
        return (-1);
}
</pre>
<p>
Now, this is slightly more complicated by the fact that you are going to be
mmap'ing what are simply kernel memory objects (it is a pseudo-device after
all).
<p>
In order to make this work, you're going to want to make sure you allocate the
memory objects to be mmap'd on page-aligned boundaries.  If you are allocating
something &gt;= PAGE_SIZE in size, this is guaranteed.  Otherwise, you are going
to have to use uvm_km_alloc(), and round your allocation size up to page size.
<p>
Then it would look a bit more like this:
<p>
<pre>
int
foommap(dev, off, prot)
        dev_t dev;
        int off, prot;
{
        paddr_t pa;

        if (off &amp; PAGE_MASK)
                panic("foommap: offset not page aligned");

        if ((u_int)off &gt;= FOO_REGION1_MMAP_OFFSET &amp;&amp;
            (u_int)off &lt; (FOO_REGION1_MMAP_OFFSET + FOO_REGION1_SIZE)) {
                if ((vaddr_t)foo_object1 &amp; PAGE_MASK)
                        panic("foommap: foo_object1 not page aligned");
                if (pmap_extract(pmap_kernel(), foo_object1 +
                    (u_int)off - FOO_REGION1_MMAP_OFFSET, &amp;pa) == FALSE)
                        panic("foommap: foo_object1 page not mapped");
                return (atop(pa));
        }

        if ((u_int)off &gt;= FOO_REGION2_MMAP_OFFSET &amp;&amp;
            (u_int)off &lt; (FOO_REGION2_MMAP_OFFSET + FOO_REGION2_SIZE)) {
                if ((vaddr_t)foo_object2 &amp; PAGE_MASK)
                        panic("foommap: foo_object2 not page aligned");
                if (pmap_extract(pmap_kernel(), foo_object2 +
                    (u_int)off - FOO_REGION2_MMAP_OFFSET, &amp;pa) == FALSE)
                        panic("foommap: foo_object2 page not mapped");
                return (atop(pa));
        }

        /* Page not found. */
        return (-1);
}
</pre>

<ENTRY>accessing_a_kernel_structure_from_userland Accessing a kernel structure from userland
The canonical example for this is:  <tt>
<CURRENTSRC>/usr/src/usr.bin/vmstat/dkstats.c
</tt>, which reads disk statistics.

<ENTRY>sample_driver Is there a simple PCI driver I can use as an example?
You can look at sys/dev/pci/puc.c, which is one of the simplest drivers.
PUCs are devices with one or more serial or parallel ports on it, usually
using standard chips (e.g. 16550 UART for serial).
This driver just locates the I/O adresses of the registers of the serial or
parallel controller and passes it to the serial or parallel driver.

</LIST>

<a href="./">Up to <em>NetBSD Documentation: Kernel</em></a>
<hr>

<DOCLINK>

<hr>
<address>
  <small>
  <a href="http://www.NetBSD.org/cgi-bin/feedback.cgi">(Contact us)</a>
  $NetBSD: programming.list,v 1.29 2004/03/20 20:38:25 snj Exp $<br>
  <a href="../../Misc/disclaimer.html">Copyright &copy; 1994-2003
  The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED.</a>
  </small>
</address>

</body>
</html>
