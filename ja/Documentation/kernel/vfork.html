<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">

<html>
<head>
<!-- Copyright (c) 1994-2003
	The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED. -->
<link rev="made" href="mailto:www@jp.NetBSD.ORG">
<title>NetBSD ドキュメンテーション: なぜ伝統的な vfork()を実装したのか</title>
</head>
<body bgcolor="#FFFFFF" text="#000000">

<table><tr><td>
<a href="../../Misc/disclaimer.html#bsd-daemon">
<img align="middle" src="../../../images/BSD-daemon.jpg" origlink="../../images/BSD-daemon.jpg" border=0 
width=146 height=129 alt="BSD daemon"></a>
</td><td align=center>
<h1>NetBSD ドキュメンテーション:</h1>
<h1>なぜ伝統的な <code>vfork()</code>を実装したのか</h1>
</td></tr></table>
<p>

<code>vfork()</code>
は、子プロセスがいずれ他のプログラムを <code>exec()</code>し、
かつ親プロセスはそれが起きるまで待っているという、特別な状況で
用いるために設計されたものです。
伝統的な <code>fork()</code> では、子プロセスに親プロセスの
すべてのページを複製するという著しいオーバーヘッドが生じます。

<p>
COW (コピーオンライト)が追加された
Mach VM システムでは
<code>fork()</code> の負荷が大変軽くなり、
BSD 4.4では <code>vfork()</code>は <code>fork()</code> と
同義のものとされました。
NetBSD 1.3 以降では、伝統的な <code>vfork()</code> が再実装されました。

<p>
 <a href="uvm.html"><strong>UVM</strong></a>で COW を
 よりよいものにするために多大な努力がおこなわれました。
  しかしアドレス空間を共有する <code>vfork()</code>が <em>いまだに</em>
勝ることが分かったのです。
 これにより、200MHz PPro での libcのビルドの所要時間を
 数秒削ることができます。
 

<p>
<strong>
4.4BSDの
<code>vfork()</code>/<code>exec()</code> を使った
<code>vfork()</code> と COW の処理
:
</strong>

<ul>
<li>
	親の vm_map をたどって、アドレス空間の書き込み可能な部分を COW とマークする。これは、 pmapを呼び出し、 PTEを修正し、 TLBをフラッシュすることを意味します。

<li> 子プロセスの vm_map を生成し、親の vm_map エントリーを子の vm_mapにコピーします。
	場合によっては、 pmapを呼び出して親のページテーブルから
	このページテーブルに PTE をコピーします。

<li>    親をブロックします。

<li>    子が走ります。 PTEがコピー <em>されてない</em>場合には、
	ページフォルトが起きて現在プログラムカウンタのある
	テキストページの物理マッピングが得られます。

<li>    子は exec し、そして 作られたばかりのアドレス空間全体を unmapして
	新しく作ります。
	これは、親の vm_mapを辿って COWとマークされた部分を
	非COWにする作業を伴います。
	
<li>    親のブロックを解きます.

<li>    親が走り、以前には R/W であって COWにするために R/Oとマークしたデータを
	変更するとページフォルトを起こします。この時点ではデータのコピーは行なわれません。

</ul>
アドレス空間共有を用いた
<strong>3.0BSD/NetBSD の <code>vfork()</code>
の処理
:</strong>

<ul>
<li>   親プロセスの vmspace構造体への参照を得ます。

<li>    親をブロックします。

<li>    子が走ります。 親のページテーブルが用いられるので、 PTEは既に
	有効でありページフォルトは起こりません。

<li>    子が exec し、親のもの(vmspace構造体)に対して持っていた参照を削除し、
	新しいものを作ります。

<li>    親のブロックを解きます。

<li>	親が走ります。(親の vm_mapは変更されていないので、
	ページフォルトは起こりません。)

</ul>

このように、fork してさらに execするような場合には、
明らかに後者がより高速です。
たとえ良い COWアルゴリズムを使っているとしても、仮想空間を共有する
場合と比べて大変多くの作業を行なわねばなりません!
<p>

<hr>
<a href="./"> <em>NetBSD Documentation: Kernel</em>に戻る</a>
<hr>
<table width="100%"><tr><td>
  <table><tr><td>
    <a href="../../../" origlink="../../"><img
        src="../../../images/NetBSD-flag.gif" origlink="../../images/NetBSD-flag.gif" border="0"
        width="91" height="42" alt=""></a>
  </td><td>
    <a href="../../../" origlink="../../"><img
        src="../../../images/empty.gif" origlink="../../images/empty.gif" border="0"
        width="1" height="1" alt="NetBSD ">ホームページ</a>
  </td></tr></table>
</td><td>
  <table><tr><td>
    <a href="../../../Documentation/" origlink="../../Documentation/"><img
        src="../../../images/NetBSD-flag.gif" origlink="../../images/NetBSD-flag.gif" border="0"
        width="91" height="42" alt=""></a>
  </td><td> 
    <a href="../../../Documentation/" origlink="../../Documentation/"><img
        src="../../../images/empty.gif" origlink="../../images/empty.gif" border="0"
        width="1" height="1" alt="NetBSD ">Documentation top level</a>
  </td></tr></table>
</td></tr></table>

<hr>
<address>
  <small>
  (連絡先 - <a href="http://www.netbsd.org/cgi-bin/feedback.cgi">英語</a>,
       <a href="mailto:www@JP.NetBSD.ORG">日本語:
       www@JP.NetBSD.ORG</a>)<br>
  $NetBSD: vfork.html,v 1.14 2003/03/08 19:40:18 grant Exp $<br>
  <a href="../../Misc/disclaimer.html">Copyright &copy; 1994-2003
  The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED.</a>
  </small>
</address>

</body>
</html>
