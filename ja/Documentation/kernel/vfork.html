<html>
<head>
<!-- Copyright (c) 1998
	The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED. -->
<link rev="made" href="mailto:www@jp.NetBSD.ORG">
<title>なぜ伝統的な vfork()を実装したのか</title>
</head>
<body bgcolor="#FFFFFF" text="#000000">

<table><tr><td>
<a href="../../Misc/daemon-copy.html">
<img align="center" src="../../images/BSD-demon.gif" alt="BSD demon"></a>
</td><td align=center>
<h1>なぜ伝統的な <code>vfork()</code>を実装したのか</h1>
</td></tr></table>
<p>

<hr>
<code>vfork()</code>
は、子プロセスがいずれ他のプログラムを <code>exec()</code>し、
かつ親プロセスはそれが起きるまで待っているという、特別な状況で
用いるために設計されたものです。
伝統的な <code>fork()</code> では、子プロセスに親プロセスの
すべてのページを複製するという著しいオーバーヘッドが生じます。

<p>
COW (コピーオンライト)が追加された
Mach VM システムでは
<code>fork()</code> の負荷が大変軽くなり、
BSD 4.4では <code>vfork()</code>は <code>fork()</code> と
同義のものとされました。
NetBSD 1.3 以降では、伝統的な <code>vfork()</code> が再実装されました。

<p>
 <a href="uvm.html"><strong>UVM</strong></a>で COW を
 よりよいものにするために多大な努力がおこなわれました。
  しかしアドレス空間を共有する <code>vfork()</code>が <em>いまだに</em>
勝ることが分かったのです。
 これにより、200MHz PPro での libcのビルドの所要時間を
 数秒削ることができます。
 

<p>
<strong>
4.4BSDの
<code>vfork()</code>/<code>exec()</code> を使った
<code>vfork()</code> と COW の処理
:
</strong>

<ul>
<li>
	親の vm_map をたどって、アドレス空間の書き込み可能な部分を COW とマークする。これは、 pmapを呼び出し、 PTEを修正し、 TLBをフラッシュすることを意味します。

<li> 子プロセスの vm_map を生成し、親の vm_map エントリーを子の vm_mapにコピーします。
	場合によっては、 pmapを呼び出して親のページテーブルから
	このページテーブルに PTE をコピーします。

<li>    親をブロックします。

<li>    子が走ります。 PTEがコピー <em>されてない</em>場合には、
	ページフォルトが起きて現在プログラムカウンタのある
	テキストページの物理マッピングが得られます。

<li>    子は exec し、そして 作られたばかりのアドレス空間全体を unmapして
	新しく作ります。
	これは、親の vm_mapを辿って COWとマークされた部分を
	非COWにする作業を伴います。
	
<li>    親のブロックを解きます.

<li>    親が走り、以前には R/W であって COWにするために R/Oとマークしたデータを
	変更するとページフォルトを起こします(この時点ではデータのコピーは行なわれません

</ul>
アドレス空間共有を用いた
<strong>3.0BSD/NetBSD の <code>vfork()</code>
の処理
:</strong>

<ul>
<li>   親プロセスの vmspace構造体への参照を得ます。

<li>    親をブロックします。

<li>    子が走ります。 親のページテーブルが用いられるので、 PTEは既に
	有効でありページフォルトは起こりません。

<li>    子が exec し、親のもの(vmspace構造体)に対して持っていた参照を削除し、
	新しいものを作ります。

<li>    親のブロックを解きます。

<li>	親が走ります。(親の vm_mapは変更されていないので、
	ページフォルトは起こりません。)

</ul>

このように、fork してさらに execするような場合には、
明らかに後者がより高速です。
たとえ良い COWアルゴリズムを使っているとしても、仮想空間を共有する
場合と比べて大変多くの作業を行なわねばなりません!

<hr>
<a href="index.html"> <em>NetBSD Documentation: Kernel</em>に戻る</a>

<hr>
<table width="100%"><tr>
  <td>
    <table><tr>
      <td>
	<a href="../../index.html">
	<img src="../../images/NetBSD-banner.gif" alt="NetBSD&nbsp;Home"></a>
      </td><td>
	<a href="../../index.html">Home Page</a>
      </td>
    </tr></table>
  </td><td>
    <table><tr>
      <td>
	<a href="index.html">
	<img src="../../images/NetBSD-banner.gif"
	alt="NetBSD&nbsp;Documentation"></a>
      </td><td>
	<a href="index.html">Documentation top level</a>
      </td>
    </tr></table>
  </td>
</tr></table>

<hr>
<address>
  www@jp.NetBSD.ORG<br>
  $NetBSD: vfork.html,v 1.3 1998/10/19 07:30:04 abs Exp $<br>
  <a href="../../Misc/disclaimer.html">Copyright &copy; 1998
    The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED.</a>
</address>

</body>
</html>
