<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML LANG="ja">
<HEAD>

<!-- DO NOT EDIT THIS FILE. EDIT 'index.list' AND RUN 'make' -->

<!-- Copyright (c) 1994-2003
        The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED. -->
<!--
  ==  By Brett Lymn
  -->
<link rev="made" href="mailto:www@jp.NetBSD.org">
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
<TITLE>NetBSD Documentation: Writing a pseudo device</TITLE>
</HEAD>
<BODY bgcolor="#FFFFFF" text="#000000">

<table><tr><td>
    <a href="../../../Misc/disclaimer.html#bsd-daemon"><img
     align="middle" src="../../../../images/BSD-daemon.jpg" border="0"
     width=146 height=129 alt="BSD daemon"></a>
  </td><td align=center>
    <h1>NetBSD ドキュメンテーション:</h1>
    <h1>Writing a pseudo device</h1>
</td></tr></table>
<p>

<h2><a name="top">擬似デバイスの書き方</a></h2>
<ul>
<li>
<a href="#intro">序説</a></li>
<li>
<a href="#yourcode">あなたのコード</a></li>
<li>
<a href="#functions">関数</a></li>
<li>
<a href="#newdevice">カーネルに新しいデバイスを知らせる</a></li>
<li>
<a href="#config">config<b></b>(1) に新しいデバイスを知らせる</a></li>
<li>
<a href="#kernelconfig">カーネルコンフィグファイルに新しいデバイスを追加する</a></li>
<li>
<a href="#userlevel">ユーザーレベルプログラム が新しいデバイスにアクセスすることを許す</a></li>
</ul>


<hr>
<h2>擬似デバイスの書き方</h2><hr>
<p><h3>
<a name="intro">序説</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

このドキュメントはカーネルドライバーを書いてみようという方へのガイドです。
ここではシンプルな擬似デバイスドライバーの書き方を扱います。
カーネルの構築、makefile 関連や新しいカーネルのインストールに関する他の奥義
はこれらはこのドキュメントには含まれてなく(別に)必要です。

また、カーネルプログラミングそれ自体も含まれていなく
 - これは、ユーザーレベルプログラミングとは多くの面でとても違います。

という断り書きをした上で、この文章を読めば、あなたのコードを
カーネルに加えて動作させることができるようになります。

</dd></dl>
<p><h3>
<a name="yourcode">あなたのコード</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

   <A HREF="../../../../Documentation/kernel/pseudo/pseudo_dev_skel.c">pseudo_dev_skel.c</A> ファイルが
    擬似デバイスとファイルの骨格となります。
   <A HREF="../../../../Documentation/kernel/pseudo/pseudo_dev_skel.h">pseudo_dev_skel.h</A>では 
   kernel 関数プロトタイプと ioctl データ構造 と加えて ioctl 番号自体を定義します。
   注として、普通のデバイスドライバーと違って、
   擬似デバイスドライバーには、プローブルーチンは必要ないので持っていません。
   このため、autoconfig フレームワークを扱う必要がなく、話が簡単になります。
   この skeleton ファイルは擬似デバイスの open, close, ioctl calls をサポートします。
   これは、実際の擬似デバイスにおいて最低限実用的なコールのセットです。
    read, write, mmap や ほかの デバイス 関数 をサポートするためのほかのコールもありますが、
   詳細を除けば全て open, close, ioctl のパターンと同様に扱えます。
   <p>

   たぶん、最初の重要な決定は、新しいデバイスをなんと呼ぶかを決めることです。
   関数コール名の前にデバイス名をくっつけた kernel 構造体をつくるのに
   便利なマクロがたくさんあることが知られていて、これは
   作りたいカーネルコンフィグファイルエントリーの助けになるでしょう。

    config ファイルエントリーはヘッダーファイル名と合わせる必要はありません。
   この skeleton ドライバー では、 "skeleton" 擬似デバイスと呼ぶ事にしたので
    skeleton というエントリーを コンフィグファイルに作る事になります。
   つまり、 attach, open, close, ioctl 関数 呼び出しcall の名前を、それぞれ
    skeletonattach, skeletonopen, skeletonclose, skeletonioctl とすると言う事です。
   もう1つの重要なのはデバイスの種類を決めることで -
   あなたのコードが、カーネルと、もちろん、あなたのコード自体と、どう相互作用するかで
   キャラクター型 か ブロック デバイス のどちらかにします。
   ブロック型対キャラクター型のデバイスの決定は、
   ドライバーが会話する根底の ハードウェアにかなり依存し、
   もしドライバーがデータの読書きを一定の塊で行なうデバイスなら
   ブロックデバイスが良い選択で、そのようなデバイスの例として、
   ハードディスクはたいてい 512 byte セクターをブロックとして読み書きします。

   ハードウェアが一度に読み書きするのが 1 byte のデータなら、
   普通、キャラクター型デバイスが最もよい選択で、
   例えば、シリアルラインドライバーがそうです。

   注として、いくつかのドライバーはデバイスのアクセスに
   ブロックモードとキャラクターモードの両方をサポートしていて、
   この場合、キャラクターモードはしばしば "raw" デバイスと呼ばれます。
   それは、アクセス時に
   データブロック抽出操作(the data blocking abstractions operating) なしに
   ハードウェアのアクセスができるからです。

   擬似デバイスでは、考慮するべき根底のハードウェアがないので、より柔軟に選べます。
   擬似デバイスを使ってする内容により選択し、ブロック型デバイスは 
   ハードディスクやそのようなもののエミュレートには便利でしょう。
   skeleton ドライバーは キャラクター型デバイスです。

   <p>
   それを決定したら、コードを編集することができますが、
   その前にファイルをどこに置くか決めることが必要です。

   複数のアーキテクチャーで使われる擬似デバイスを書くなら、
   そのドライバーのコードの置き場は <TT>/usr/src/sys/dev</TT> です。
   もし擬似デバイスが個別のアーキテクチャーに特有の物なら、
   ドライバーのコードは個別のディレクトリーの下に置き、
    i386 の例では、 <TT>/usr/src/sys/arch/i386/i386</TT> です。
   インクルードファイルについては、
   アーキテクチャー非依存のデバイスは <TT>/usr/src/sys/sys</TT> に、
   アーキテクチャー特有のデバイスでは、
   アーキテクチャー個別のディレクトリーの下の <TT>include</TT> ディレクトリー、
   例えば i386 アーキテクチャーでは
    <TT>/usr/src/sys/arch/i386/include</TT> に置くべきです。

どちらの場合でも、適切な <TT>Makefile</TT> を更新してください。
それで、インクルードファイルがインストールされます。

 <A HREF="../../../../Documentation/kernel/pseudo/pseudo_dev_skel.c">pseudo_dev_skel.c</A> の先頭に
   <STRONG>struct skeleton_softc</STRONG> を書いてください。
   デバイス名に "_softc" が書き添えられた名前で softc 構造体の宣言が必要で、
   この構造体の最初の要素は <STRONG>struct device</STRONG> 型である必要があり、
   エントリー名は重要ではありませんが、最初にある必要があり、
    autoconfig システムが softc struct が宣言されていることをあてにしているから
   <!-- ??? これ本当 ??? -->で、その最初の要素は struct device です。
   デバイスハンドル minor 番号 ごとに softc struct が必要です。
    softc 構造体は minor デバイスがそれを維持する状態の情報を、必要に応じて
   ただの struct device より多くの要素を持つことができます。

</dd></dl>
<p><h3>
<a name="functions">関数</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

   ユーザーレベルプログラムによるアクセスには
   カーネルインターフェースはデバイスに対しては関数のコールを通して行ないます。
   デバイスは後に示すように全ての関数をサポートする必要はありませんが、
   実用的なデバイスは最低限オープンとクローズをサポートする必要はあります。
   関数名はデバイス名を前につけることを思い出してください。
   この関数は:
<P>
<OL TYPE=i>
<LI><h4>attach</h4>
  
  この関数はカーネルが初期化するときに一度呼び出されます。
  これは、あらゆる変数の設定に使われ、
  後のコールや、バッファーが必要とするカーネルメモリー割り当て
  で参照されます。
   attach 関数には引数が一つ渡されます。これはこのドライバーが扱う
  デバイスの数です。

<P>
<LI><h4>open</h4>

  その名が示すように、ユーザーレベルプログラムが
  デバイスに対して <a href="http://man.NetBSD.org/man/open+2+NetBSD-current">open(2)</a> コールをした時に呼び出されます。
  一番簡単な場合、 open 関数は単に success で戻るだけです。

  より一般に open call は
バッファーの要求と可能なら allocate することや
他ドライバー関数のコールをサポートするため
他のドライバーの状態を初期化することを有効にします。

   open call は下記のパラメーターが使え:
<P><DL>
             <DT>dev
             <DD> open しようとするデバイスのマイナー番号
<P>
              <DT>flags
              <DD>  open call に渡されるフラグ
		<!-- ??? ユーザーによる open call のフラグを素通し ??? -->
<P>
              <DT>mode
              <DD>  open のモード
		 <!-- ??? open のモード ??? -->
<P>
              <DT>proc
              <DD>  オープン要求をしているプロセスの proc 構造体のポインター
                これは、そのプロセスが
                信頼できるものである(資格証明を有効にしてよい)ことを示します。
</DL>
<LI><h4>close</h4>

  open されていたデバイスを close します。

  ドライバーによって、これはただ単純に success で戻るだけのものだったり、
  あるいは、割り当てられていたメモリーの解放や
  ドライバーの状態変数を、もはや open されてはいないと示すように変更する
  必要があったりします。

 close 関数呼び出しのパラメーターは、 open で記述したのと同じです。
<P>
<LI><h4>read</h4>
  デバイスからデータを読み出します。
  この関数のパラメーターは:
<P><DL>
              <DT>dev
              <DD>  デバイスのマイナー番号

              <DT>uio
               <DD>  uio 構造体へのポインターです。
                read 関数は uio 構造体 にユーザーが欲しいデータを満たして戻ります。

              <DT>flags
              <DD>  flags <!-- ??? wuffor ??? -->
</DL><P>
<LI><h4>write</h4>
  
  デバイスにデータを書きこみます。
 write 関数 のパラメーターは、 read 関数のものと同じで - ただ、違うのは
 uio 構造体はデバイスに書きこまれるデータを含んでいることです。

<P>
<LI><h4>ioctl</h4>

  デバイスに ioctl をします。
 ioctl call のパラメーターは:
<P><DL>
              <DT>dev
              <DD>  デバイスのマイナー番号

              <DT>cmd
              <DD>  実行される ioctl コマンドです。
                このコマンドはヘッダーファイル内で定義され
                カーネルコードおよびユーザーレベルコードが参照します。
                例は<A HREF="../../../../Documentation/kernel/pseudo/pseudo_dev_skel.c">サンプルのヘッダー</A>を見てください。

              <DT>data
               <DD> ユーザーレベルコードで使えるパラメーターのポインターです。
                このパラメーターは ioctl の実装と、実際に発行されたコマンドに依存します。

              <DT>flags
              <DD>  flags <!-- ??? wuffor ??? -->

              <DT>proc
              <DD> ioctl 要求を出したユーザーレベルプロセスに関連する proc 構造体 です。

</DL><P>

<LI><h4>stop</h4>

  tty 様式デバイスで出力を停止します。
<P><DL>
              <DT>tty
              <DD>  デバイスに結び付けられた tty

              <DT>flags
              <DD>  flags <!-- ??? -->
</DL><P>

<LI><h4>poll</h4>

デバイスからデータが読めるかチェックします。
パラメーターは:
<P><DL>
              <DT>dev
              <DD>  デバイスが使っているマイナー番号

              <DT>events
              <DD>  ユーザーレベルコールがポーリングするイベント

              <DT>proc
               <DD> ioctl 要求を出したユーザーレベルプロセスに関連する proc 構造体 です。

</DL><P>

<LI><h4>mmap</h4>

  ドライバーのバッファーをユーザーレベルプログラムのメモリー空間に mmap する
  権限をサポートします。パラメーターは:
<P><DL>
              <DT>dev
              <DD>  デバイスが使っているマイナーデバイス番号

              <DT>offset
               <DD>  mmap 開始時のバッファーの先頭からのオフセット。

              <DT>prot
              <DD>  mmap の挙動のタイプで、
                    読みこみ専用、書きこみ専用、読み書き可能かのいずれかです。
                    デバイスドライバーは全てをサポートする必要はありません。
</DL></OL><P>
   
   このデバイスドライバーがサポートする関数を、
   キャラクター型デバイス用の <TT>struct cdevsw</TT> と
   <TT>struct bdevsw</TT> のいずれかまたは両方に含める必要があります。
   この構造体の名前は、モジュール名の後に <TT>_cdevsw</TT> または <TT>_bdevsw</TT>
   を付けたものです。
   ここで例示する疑似デバイスは、キャラクター型デバイスとしてのみふるまうので、
   構造体の名前は <TT>skeleton_cdevsw</TT> とします。
   なお、この構造体には、すべてのデバイスインターフェース関数のエントリーがありますが、
   デバイス側で実装するのは、この関数の一部分だけでかまいません。
   使われないスタブ関数をすべてのデバイスに実装させるのではなく、
   頭に <TT>no</TT> がついた (たとえば noread, nowrite など)、
   あらかじめ宣言されたスタブが用意されており、これらは呼ばれた時に <TT>ENODEV</TT>
   または、何の操作もせずに成功を返す <TT>null</TT> (たとえば nullread,
   nullwrite など) を返します。
   cdevsw や bdevsw にある関数でドライバーがサポートしていないものに対しては、
   あらかじめ宣言されたスタブのものを使うだけです。

</dd></dl>
<p><h3>
<a name="newdevice">カーネルに新しいデバイスを知らせる</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

   擬似デバイスのコーディングをしたら、
   アクセスできるよう、カーネルに組み込みます。

   注として、カーネルが擬似デバイスを組みこむ方法は
   通常のデバイスの場合と、いろいろ違います。

   擬似デバイスは、通常のデバイス検出と auto-configuration を飛ばし、
   実行時の代わりにソースレベルでカーネル構造体の中にエントリーを作ったり
   そうではなかったりするからです。

カーネルがあなたのコードを使うようにするには、
これらのファイルを変更する必要があって:
<P>
<OL TYPE=i>
<LI><h4>/usr/src/sys/conf/majors or /usr/src/sys/<I>arch</I>/conf/majors.<I>arch</I></h4>

   この各ファイルには、NetBSD におけるデバイスメジャー番号のリストが含まれます。
   <I>/usr/src/sys/conf/majors</I> にあるのは、機種独立なデバイス、すなわち
   NetBSD が対応しているすべてのアーキテクチャーで利用可能なデバイスのメジャー番号です。
   デバイスが特定のアーキテクチャーにのみ関連するものである場合は、
   <I>/usr/src/sys/<B>arch</B>/conf/majors.<B>arch</B></I>
   (<B>arch</B> は、関連するアーキテクチャーに置き換えます)
   ファイルを使う必要があります。
   この各ファイルに含まれるエントリーは、以下の形式をとります。
<PRE>
device-major    prefix		type      number	condition
</PRE>
   この行の正確な文法は、<a href="http://man.NetBSD.org/man/config+5+NetBSD-current">config(5)</a> マニュアルページで説明されていますが、
   ここで例示するドライバーのためにその内容を説明しておきます。
<P><DL>
		<DT>device-major
		<DD>  このエントリーが、
		デバイスメジャー番号のエントリーであることを示すキーワードです。

		<DT>prefix
		<DD>  すべてのドライバーの関数に対して、
		関数名が自動生成される時に与えられる接頭辞です。
		ここでの例においては、
		<TT>skeleton</TT> とします。

		<DT>type
		<DD>  メジャーデバイスの型で、
		<TT>char</TT> または <TT>block</TT> のいずれかです。
		char と block それぞれの type と number の組を繰り返し書くことで、
		両方の型のデバイスを指定することができます。

		<DT>number
		<DD> デバイスのメジャー番号です。次の空いている番号を選びます。
		なお、<TT>/dev</TT> にデバイスノードを作る必要があるので、
		選んだ番号を控えておきます。

		<DT>condition
		<DD> このデバイスがカーネルに含まれる条件です。
		これは、conf ファイル (後述)
		に含めた疑似デバイスのエントリーと一致させるようにします。
</DL><P>
   ここで例示する skeleton 疑似デバイスは、キャラクター型デバイスとし、
   ドライバーは <TT>i386</TT> アーキテクチャーに依存するものとします。
   このような仮定をしたので、<TT>/usr/src/sys/arch/i386/conf/majors.i386</TT>
   ファイルを編集すればよいことになります。すると、
   メジャー番号 140 が使えることがわかるので、以下のような行を追加します。
<PRE>
device-major	skeleton	char	140	skeleton
</PRE>
</OL>

</dd></dl>
<p><h3>
<a name="config">config<b></b>(1) に新しいデバイスを知らせる</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
   <a href="http://man.NetBSD.org/man/config+1+NetBSD-current">config(1)</a> に新しい擬似デバイスを知らせるには、
   <TT>/usr/src/sys/conf/files</TT> (アーキテクチャー独立なデバイスの場合) または
   <TT>/usr/src/sys/arch/<I>arch</I>/conf/files.<I>arch</I></TT>
   (<I>arch</I> は関連するアーキテクチャー) のいずれかのファイルを編集します。
   このファイルは  有効な デバイスの名前 と
   これらのデバイスと関連するファイルを config に教えます。
   最初に擬似デバイスを定義するセクションを捜します。
   この セクションは <TT>defpseudo</TT> で始まる行を持っています。
   ここでは、ドライバーはアーキテクチャー依存であることを仮定しているので、
   <TT>/usr/src/sys/arch/i386/conf/files.i386</TT> を編集します。
   正しいセクションを見つけると、こういう行を加えることができ:

<PRE>
defpseudo skeleton
</PRE>

    <a href="http://man.NetBSD.org/man/config+1+NetBSD-current">config(1)</a>に skeleton という擬似デバイスがあることを教えます。
   つぎに、 <a href="http://man.NetBSD.org/man/config+1+NetBSD-current">config(1)</a> に skeleton 擬似デバイスに関連するファイルを教えてあげる必要があります。
   この場合はひとつのファイル
   があるだけですが、より複雑な擬似デバイスでは より多くのファイルがあるかもしれず、
   同じ方法で必要とされるファイルごとに行を単純に追加していきます。

  例では、このような1行が必要なだけで:

<PRE>
file dev/skeleton.c	   skeleton	needs-flag
</PRE>

   行中の <B><TT>file</TT></B> はデバイスとファイルの関係の定義 
   を書くためのキーワードです。
   2番目のフィールドは、ファイルの
   カーネルソースツリールートからの相対位置 (通常、 <TT>/usr/src/sys</TT>) です。
   3番目のフィールドはドライバー名でこのファイルが関連しているもので、
   この場合 skeleton - サンプル擬似デバイスです。
   4番目 で 最後の フィールド は <a href="http://man.NetBSD.org/man/config+1+NetBSD-current">config(1)</a> に
   skeleton.h インクルードファイルを書かせるための制御フラグです。
   ここでファイル名が skeleton.c になっていますが、例示したファイルを使った場合、
   ファイル pseudo_dev_skel.c を skeleton.c にリネームするか、このエントリーを
   (pseudo_dev_skel.c に) 変更するかする必要がありますので注意してください。
   上述のとおり、私たちはこれを skeleton と呼んでいるので、ここは skeleton.c
   としたほうがおそらく素直でしょう。

</dd></dl>
<p><h3>
<a name="kernelconfig">カーネルコンフィグファイルに新しいデバイスを追加する</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
    <a href="http://man.NetBSD.org/man/config+1+NetBSD-current">config(1)</a> にデバイスのことを教えてやったあと、
   そのデバイスをカーネルコンフィグファイルに追加することは簡単です。
    skeleton デバイスを追加するには、このような行を加え:

<PRE>
pseudo-device  skeleton
</PRE>

   カーネルコンフィグファイルには、
   前節での <TT>defpseudo</TT> 行で与えられた名に揃えた
   擬似デバイス名を書きます。

   新しい定義は
    <B><TT>options</TT></B> カーネルコンフィグファイル キーワードをつかうことで、
   カーネル makefile に追加することができ、
    config は cc コマンドに対し -D コマンドラインオプションを指定した
    makefile を作ります。

</dd></dl>
<p><h3>
<a name="userlevel">ユーザーレベルプログラム が新しいデバイスにアクセスすることを許す</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

   新しいカーネルを構築しインストールした後、
最後にすることとして、新しい擬似デバイスにアクセスできるように
デバイスノードを作る必要があります。

   そのデバイスノードはアクセスすることができる
   どんなファイルシステム上に作ることもできますが、
   慣習によって、 デバイスノードは <I>/dev</I> に作られます。

   デバイスノード をつくるために <a href="http://man.NetBSD.org/man/mknod+8+NetBSD-current">mknod(8)</a>を使う必要があり、
    4.i 節で書きとめた major 番号で デバイスノード を作ります。
   この場合、 <a href="http://man.NetBSD.org/man/mknod+8+NetBSD-current">mknod(8)</a> コマンドでこのようにでき:
<PRE>
        mknod /dev/skel c 140 0
</PRE>

   これで、新しいデバイスをオープンして試すことができます。
   <A HREF="../../../../Documentation/kernel/pseudo/sample.c">sample.c</A> ファイルは
    skeleton 擬似デバイスが元気であることを示します。
  このファイルは、ここにある指示に従っていて
 <TT>/dev/skel</TT> が作られていると仮定していて、
   このデバイスはオープンされ、パラメーター構造体は
 ioctl call でデバイスドライバーに移されます。
  サンプルコードをコンパイルするには、コマンドラインで:
<PRE>
        cc -o sample sample.c
</PRE>
  これで、 sample というバイナリーができるでしょう。<STRONG>注意</STRONG>:
  ヘッダーファイル置き場で、 <TT>pseudo_dev_skel.h</TT> を入れた
  システムインクルードファイルのディレクトリーで
   <TT>make includes</TT> をする必要があります。
  さもなければ、コンパイラーはインクルードファイルが見つからないと訴えるでしょう。
  プログラムをコンパイルして実行すると、
  カーネルメッセージがコンソールと <TT>/var/log/messages</TT> の両方に現われ、
  それはこのようなもので:
<PRE>
May 17 20:32:57 siren /netbsd: Got number of 42 and string of Hello World
</PRE>
   SKELTEST ioctl 要求を受けた時に skeleton ioctl ハンドラーが表示する
   メッセージです; この番号と文字列は sample.c の <TT>param</TT>
   構造体の中に入れてあったものです。
</dd></dl>
<hr>

<table width="100%"><tr><td>
<table border="0" summary="Footer navigation"><tr>
<td class="foothome"><span class="foothome"><a href="../../../"><img src="../../../../images/NetBSD-flag.png" alt="" border="0" width="90" height="90"></a></span></td>
<td class="foothome">
<span class="foothome"><a href="../../../">ホームページ</a></span><br>
</td>
</tr></table>
</td><td>
<table border="0" summary="Footer navigation"><tr>
<td class="foothome"><span class="foothome"><a href="../../../Documentation/"><img src="../../../../images/NetBSD-flag.png" alt="" border="0" width="90" height="90"></a></span></td>
<td class="foothome">
<span class="foothome"><a href="../../../Documentation/">Documentation top level</a></span><br>
</td>
</tr></table>

</td></tr></table>

<hr>
<address>
  <small>
  (連絡先 - <a href="http://www.NetBSD.org/cgi-bin/feedback.cgi">英語</a>,
       <a href="mailto:www@jp.NetBSD.org">日本語:
       www@jp.NetBSD.org</a>)<br>
  $NetBSD: index.html,v 1.23 2007/01/08 13:42:57 kano Exp $<br>
  <!-- Based on english version: -->
  <!-- NetBSD: index.list,v 1.19 2006/12/29 03:41:31 kano Exp   -->
  <a href="../../../Misc/disclaimer.html">Copyright &copy; 1994-2005
  The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED.</a><br>
  <a href="../../../Misc/disclaimer.html">NetBSD<sup>&#174;</sup> は
  The NetBSD Foundation, Inc. の登録商標です。</a><br>
  </small>
</address>

</BODY>
</HTML>
