<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
<!-- Copyright (c) 2000
        The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED. -->
<!--
  ==  By Brett Lymn
  -->
<link rev="made" href="mailto:www@NetBSD.ORG">
<TITLE>Writing a pseudo device</TITLE>
</HEAD>
<BODY bgcolor="#FFFFFF" text="#000000">

<HEADING>Writing a pseudo device

<LIST>

<SECTION>How to write a pseudo device

<ENTRY>intro Introduction
   This document is meant to provide a guide to someone who wants to
   start writing kernel drivers.  The document covers the writing of a
   simple pseudo-device driver.  You will need to be familiar with
   building kernels, makefiles and the other arcana involved in
   installing a new kernel as these are not covered by this document.
   Also not covered is kernel programming itself - this is quite
   different to programming at the user level in many ways.  Having
   said all that, this document will give you the process that is
   required to get your code into and recognised by the kernel.

<ENTRY>yourcode Your code
   The file <A HREF="pseudo_dev_skel.c">pseudo_dev_skel.c</A> gives the
   framework for a pseudo-device and the file
   <A HREF="pseudo_dev_skel.h">pseudo_dev_skel.h</A> defines the kernel
   function prototypes and the ioctl data structure plus the ioctl
   number itself.  Note that, unlike a normal device driver, a
   pseudo-device does not have a probe routine because this is not
   necessary.  This simplifies life because we do not need to deal
   with the autoconfig framework.  The skeleton file given is for a
   pseudo-device that supports the open, close and ioctl calls.  This
   is about the minimum useful set of calls you can have in a real
   pseudo-device.  There are other calls to support read, write, mmap
   and other device functions but they all follow the same pattern as
   open, close and ioctl so they have been omitted for clarity.
   <p>
   Probably the first important decision you need to make is what you
   are going to call your new device.  This needs to be done up front
   as there are a lot of convenience macros that generate kernel
   structures by prepending your device name to the function call
   names, will help if you have an idea of the config file entry you
   want to have.  The config file entry does not have to match the
   source code file name.  In our skeleton driver we have decided to
   call the pseudo-device "skeleton", so we shall have a config file
   entry called skeleton.  This means that the attach, open, close and
   ioctl function calls are named skeletonattach, skeletonopen,
   skeletonclose and skeletonioctl respectively.  Another important
   decision is what sort of device you are writing - either a
   character or block device as this will affect how your code
   interacts with the kernel and, of course, your code itself.  The
   decision of block vs character device depends a lot on the
   underlying hardware the driver talks to, if the device the driver
   talks to operates by reading and write data in fixed chunks then a
   block device is a good choice, an example of such a device is a
   hard disk which usually reads and writes data in blocks of 512 byte
   sectors.  If the hardware reads and writes data one byte at a time
   then a character device is normally the best choice, an example of
   such a device is a serial line driver.  Note that some drivers
   support both a block mode and character mode of access to a device,
   in this case the character mode is sometimes called the "raw"
   device because it gives access to the hardware without the data
   blocking abstractions operating on the access.  For a pseudo-device
   the choice is more flexible because there is no underlying hardware
   to consider.  The choice is driven by the use the pseudo-device is
   going to be put to, a block device may be useful if you are going
   to emulate a hard-disk or similar.  Our skeleton driver is to be a
   character device.
   <p>
   Once the decisions have been made we can start cutting code, before
   we do this though we need to decide where our file should go.  If
   you are writing a pseudo-device that will be used by multiple
   architectures then the appropriate place to put the driver code is
   in <TT>/usr/src/sys/dev</TT>.  If the pseudo-device is specific to
   a particular architecture then put the driver code under the
   architecture specific directory, for example on the i386
   architecture this would be <TT>/usr/src/sys/arch/i386/i386</TT>.
   The include file should go into <TT>/usr/src/sys/sys</TT> for the
   architecture independent device and in the <TT>include</TT>
   directory under the architecture specific directory for an
   architecture specific device, for example, on the i386 architecture
   this would be <TT>/usr/src/sys/arch/i386/include</TT>.  In either
   case ensure that you update the relevant <TT>Makefile</TT> so your
   include file is installed.  One thing you will note is the
   <STRONG>struct skeleton_softc</STRONG> at the top of <A
   HREF="pseudo_dev_skel.c">pseudo_dev_skel.c</A>.  You must have a
   softc structure declared with the name of your device with "_softc"
   appended and the first element of this struct needs to be a
   <STRONG>struct device</STRONG> type, the name of the entry is not
   important but it must be first as the autoconfig system relies on
   the softc struct being declared (????is this really true????) and
   that it's first element is a struct device .  There needs to be a
   softc struct for each minor number a device handles.  The softc
   structure can hold more elements than just the struct device if the
   minor devices require state information to be kept about them.

<ENTRY>functions The functions
    The kernel interfaces to your device via a set of function calls
    which will be called when a user level program accesses your
    device.  A device need not support all the calls, as we will see
    later, but at a minimum a useful device needs to support an open
    and close on it.  Remember the function names need to be prepended
    with your device name.  The functions are:
<P>
<OL TYPE=i>
<LI><h4>attach</h4>
  
  This function is called once when the kernel is initialising.  It is
  used to set up any variables that are referenced in later calls or
  for allocating kernel memory needed for buffers.  The attach
  function is passed one parameter which is the number of devices this
  driver is expected to handle.
<P>
<LI> <h4>open</h4>

  As the name suggests, this function will be called when a user level
  programme performs an open(2) call on the device.  At it's simplest
  the open function may just return success.  More commonly, the open
  call will validate the request and may allocate buffers or
  initialise other driver state to support calls to the other driver
  functions.  The open call is passed the following parameters:
<P><DL>
             <DT>dev
             <DD> This is the device minor number the open is being
                performed on.
<P>
              <DT>flags
              <DD>  ??? flags passed to the open call by user ???
<P>
              <DT>mode
              <DD>  ??? mode for open ???
<P>
              <DT>proc
              <DD>  This is a pointer to the proc structure of the process
                that has requested the open.  It allows for validation
                of credentials of the process.
</DL>
<LI> <h4>close</h4>

  This closes an open device.  Depending on the driver this may be as
  simple as just returning success or it could involve free'ing
  previously allocated memory and/or updating driver state variables
  to indicate the device is no longer open.  The parameters for the
  close function call are the same as those described for open.
<P>
<LI> <h4>read</h4>
  
  Read data from your device.  The parameters for the function are:
<P><DL>
              <DT>dev
              <DD>  The minor number of the device.

              <DT>uio
               <DD> This is a pointer to a uio struct.  The read function
                will fill in the uio struct with the data it wants to
                return to the user.

              <DT>flags
              <DD>  ??? wuffor ??
</DL><P>
<LI> <h4>write</h4>
  
  Write data to your device.  The parameters for the write function
  are the same as those for a read function - the only difference
  being that the uio structure contains data to be written to the
  device.
<P>
<LI> <h4>ioctl</h4>

  Perform an ioctl on your device.  The parameters for the ioctl call
  are:
<P><DL>
              <DT>dev
              <DD>  The minor number of the device.

              <DT>cmd
              <DD>  The ioctl command to be performed.  The commands are
                defined in a header file which both the kernel code
                and the user level code reference.  See the sample
                header for an example.

              <DT>data
               <DD> This is a pointer to the parameters passed in by the
                user level code.  What is in this parameter depends on
                the implementation of the ioctl and also on the actual
                ioctl command being issued.

              <DT>flags
              <DD>  ??? wuffor ???

              <DT>proc
              <DD>  The proc structure that is associated with the user
                level process making the ioctl request.
</DL><P>

<LI><h4>stop</h4>

  Stop output on tty style device.
<P><DL>
              <DT>tty
              <DD>  tty associated with the device

              <DT>flags
              <DD>  ???
</DL><P>

<LI> <h4>poll</h4>

  Checks the device for data that can be read from it.  The parameters
  are:
<P><DL>
              <DT>dev
              <DD>  The minor number of the device used.

              <DT>events
              <DD>  The event(s) that the user level call is polling for.

              <DT>proc
               <DD> The proc structure that is associated with the user
                level process making the ioctl request.
</DL><P>

<LI> <h4>mmap</h4>

  Supports the capability of mmap'ing a driver buffer into a user
  level programme's memory space.  The parameters are:
<P><DL>
              <DT>dev
              <DD>  The minor device number of the device used.

              <DT>offset
               <DD> The offset from the start of the buffer at which to
                start the mmap.

              <DT>prot
              <DD>  The type of mmap to perform, either read only, write
                only or read write.  The device driver need not
                support all modes.
</DL></OL><P>


<ENTRY>newdevice Making the kernel aware of the new device

   Once you have done the coding of your pseudo-device it is then time
   to hook your code into the kernel so that it can be accessed.  Note
   that the process of hooking a pseudo-device into the kernel differs
   a lot from that of a normal device.  Since a pseudo-device is
   either there or not the usual device probe and auto-configuration is
   bypassed and entries made into kernel structures at the source
   level instead of at run time.  To make the kernel use your code you
   have to modify these files:
<P>
<OL TYPE=i>
<LI> <h4>/usr/src/sys/sys/conf.h</h4>

   This file contains some macro defines to set up the cdevsw
   (character device switch) and bdevsw (block device switch) table
   entries.  You should, by now, know what type of device you are
   writing.  In our example the skeleton driver is a character device
   so we want to create an entry.  Also, our skeleton driver only
   supports the open, close and ioctl calls.  Looking through the
   <I>conf.h</I> file we find there is a generic device defined called
   <TT>cdev__oci_init</TT> which does exactly what we
   want.  This saves us a bit of typing by adding this define into
   <I>conf.h</I>:

<PRE>
   #define cdev_skeleton_init(c,n)     cdev__oci_init(c,n)
</PRE>
   This defines a macro we can use to define the cdevsw entry in
   another file.  For a more complex driver you can just copy one of
   the other defines and modify as required.
<P>
<LI> <h4>/usr/src/sys/arch/i386/i386/conf.c (where is on other archs?)</h4>

   Once we have the cdevsw initialisation entry in <I>conf.h</I> we are set
   to do the next step.  The first thing to do is to include an
   include file and set up the prototype for the devsw entry.  We do
   this by putting this code in:

<PRE>
   #include "skeleton.h"
   cdev_decl(skeleton)
</PRE>

   Wait a minute!  We haven't created a skeleton.h!  That is correct,
   we don't create that file.  It will be created by config(8), we
   shall see later how this is done.  The second line there sets up
   the function prototypes for the skeleton driver - you should
   replace skeleton with the name of your pseudo-device.  That takes
   care of the declarations.  Now we need to add the device into the
   bdevsw/cdevsw table.  Since skeleton is a cdev we need to find the
   cdevsw array and add an entry to it.  You should add an entry to
   the end of the array - trying to add an entry in the middle of the
   cdevsw table will mess up all the other device drivers.  So, at the
   end of the cdevsw table we add an entry like this:

<PRE>
        cdev_skeleton_init(NSKELETON,
                         skeleton),      /* 71: Skeleton pseudo-device */
</PRE>

   Again, NSKELETON is not defined by us anywhere.  When
   config(8) is run it will generate a <I>skeleton.h</I> file
   with NSKELETON defined in it, the symbol defines the number of
   these devices to create - the number comes from the config file.
   Note that <TT>cdev_skeleton_init</TT> is the macro we
   defined in <I>conf.h</I> and that the second parameter ("skeleton") is the
   name of our pseudo-driver.  This macro concatenates the name of
   the pseudo-driver with the function call names (open, close, ioctl,
   etc) to produce the function names that we have defined in our
   code.  This is how the kernel knows to run your code.  The last bit
   of the puzzle is the number in the comment next to the entry.  You
   must copy the format of the other entries, increment the number and
   put the function of your device into the comment.  The number is
   important.  This number is the major number of your device.  You
   need to make a note of this number for later.
</OL>

<ENTRY>config Making config<b></b>(8) aware of the new device
   To make config(8) aware of our new pseudo device we need to
   edit the file in <TT>/usr/src/sys/conf/files</TT>.
   This file tells config what valid device names there are and which
   files are associated with these devices.  Firstly we look for the
   section that defines the pseudo-devices.  This section has lines
   that start with <TT>defpseudo</TT>.  Once we have found
   the correct section we can add a line like this:

<PRE>
defpseudo skeleton
</PRE>

   Which tells config(8) we have a pseudo-device called skeleton.
   Next we need to tell config(8) which files are associated with the
   skeleton pseudo-device.  In this case we only have on file but a
   more complex pseudo-device may have more files, simply add each
   file required on a line in the same manner.  For our example we
   only need one line that looks like this:

<PRE>
file dev/skeleton.c	   skeleton	needs-flag
</PRE>

   The <B><TT>file</TT></B> on the line is a key word to
   say we are defining a device to file association.  The second field
   is the location of the file relative to the root of the kernel
   source tree (normally, <TT>/usr/src/sys</TT>).  The
   third field is the name of the driver that this file is associated
   with, in our case this is skeleton - our sample pseudo-device.  The
   fourth and last field is a control flag that tells config(8) to
   write the skeleton.h include file.

<ENTRY>kernelconfig Adding the new device to the kernel config file
   Once config(8) has been told about the device, adding it to
   the kernel config file is simple.  To add our skeleton device we
   add the line:

<PRE>
pseudo-device  skeleton
</PRE>

   To the kernel config file, note the name of the pseudo-device
   matches the name given in the <TT>defpseudo</TT> line
   in the previous section.  New defines can be added to the kernel
   makefile by using the <B><TT>options</TT></B> kernel
   config file keyword, config will build a makefile with the options
   named added as -D command line options to the cc command.

<ENTRY>userlevel Allowing user level programmes access to the new device
   After building and installing a new kernel there is one last thing
   that needs to be done to access the new pseudo-device, this is to
   make a device node for talking to the new device.  The device node
   can be made on any file system that allows you to access devices
   from it but, by convention, device nodes are created in
   <I>/dev</I>.  To make the device node you will need to use
   mknod(8) to create a device node with the major number you
   noted in section 4.ii.  In our case the mknod(8) command would look
   like this:
<PRE>
        mknod /dev/skel c 71 0
</PRE>
   Once this has been done you should be able to open your new device
   and test it out.  The file <A HREF="sample.c">sample.c</A> shows
   the skeleton pseudo device in action.  This file assumes you have
   followed the instructions here and have created <TT>/dev/skel</TT>,
   this device is opened and a parameter structure passed to the
   device driver via an ioctl call.  To compile the sample code use
   this command line:
<PRE>
        cc -o sample sample.c
</PRE>
   Which will produce a binary called sample.  <STRONG>NOTE</STRONG>
   you will have to have run <TT>make includes</TT> in the directory
   you copied <TT>pseudo_dev_skel.h</TT> to to install the header file
   into the system includes directory otherwise the compiler will
   complain about a missing include file.  Once you have compiled the
   programme run it and then look at your kernel messages either on
   the console screen or in <TT>/var/log/messages</TT>, the should
   have a message that looks like this:
<PRE>
May 17 20:32:57 siren /netbsd: Got number of 42 and string of Hello World
</PRE>
   Which is a message printed by the skeleton ioctl handler when it
   receives a SKELTEST ioctl request, notice that the number and the
   string printed are the ones we put into the <TT>param</TT>
   structure in sample.c.
</LIST>

<DOCLINK>

<hr>
<address>
  <small>
  <a href="../../../Misc/feedback.html">(Contact us)</a>
  $NetBSD: index.list,v 1.5 2000/09/21 11:24:39 dent Exp $<br>
  <a href="../../../Misc/disclaimer.html">Copyright &copy;
    2000
    The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED.</a>
  </small>
</address>

</BODY>
</HTML>
