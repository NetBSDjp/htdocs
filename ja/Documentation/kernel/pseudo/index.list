<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
<!-- Copyright (c) 1994-2003
        The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED. -->
<!--
  ==  By Brett Lymn
  -->
<link rev="made" href="mailto:www@NetBSD.org">
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
<TITLE>NetBSD Documentation: Writing a pseudo device</TITLE>
</HEAD>
<BODY bgcolor="#FFFFFF" text="#000000">

<HEADING>Writing a pseudo device

<LIST>

<SECTION>How to write a pseudo device

<ENTRY>intro Introduction
   This document is meant to provide a guide to someone who wants to
   start writing kernel drivers.  The document covers the writing of a
   simple pseudo-device driver.  You will need to be familiar with
   building kernels, makefiles and the other arcana involved in
   installing a new kernel as these are not covered by this document.
   Also not covered is kernel programming itself - this is quite
   different to programming at the user level in many ways.  Having
   said all that, this document will give you the process that is
   required to get your code into and recognised by the kernel.

<ENTRY>yourcode Your code
   The file <A HREF="pseudo_dev_skel.c">pseudo_dev_skel.c</A> gives the
   framework for a pseudo-device and the file
   <A HREF="pseudo_dev_skel.h">pseudo_dev_skel.h</A> defines the kernel
   function prototypes and the ioctl data structure plus the ioctl
   number itself.  Note that, unlike a normal device driver, a
   pseudo-device does not have a probe routine because this is not
   necessary.  This simplifies life because we do not need to deal
   with the autoconfig framework.  The skeleton file given is for a
   pseudo-device that supports the open, close and ioctl calls.  This
   is about the minimum useful set of calls you can have in a real
   pseudo-device.  There are other calls to support read, write, mmap
   and other device functions but they all follow the same pattern as
   open, close and ioctl so they have been omitted for clarity.
   <p>
   Probably the first important decision you need to make is what you
   are going to call your new device.  This needs to be done up front
   as there are a lot of convenience macros that generate kernel
   structures by prepending your device name to the function call
   names, will help if you have an idea of the config file entry you
   want to have.  The config file entry does not have to match the
   header file name.  In our skeleton driver we have decided to
   call the pseudo-device "skeleton", so we shall have a config file
   entry called skeleton.  This means that the attach, open, close and
   ioctl function calls are named skeletonattach, skeletonopen,
   skeletonclose and skeletonioctl respectively.  Another important
   decision is what sort of device you are writing - either a
   character or block device as this will affect how your code
   interacts with the kernel and, of course, your code itself.  The
   decision of block vs character device depends a lot on the
   underlying hardware the driver talks to, if the device the driver
   talks to operates by reading and write data in fixed chunks then a
   block device is a good choice, an example of such a device is a
   hard disk which usually reads and writes data in blocks of 512 byte
   sectors.  If the hardware reads and writes data one byte at a time
   then a character device is normally the best choice, an example of
   such a device is a serial line driver.  Note that some drivers
   support both a block mode and character mode of access to a device,
   in this case the character mode is sometimes called the "raw"
   device because it gives access to the hardware without the data
   blocking abstractions operating on the access.  For a pseudo-device
   the choice is more flexible because there is no underlying hardware
   to consider.  The choice is driven by the use the pseudo-device is
   going to be put to, a block device may be useful if you are going
   to emulate a hard-disk or similar.  Our skeleton driver is to be a
   character device.
   <p>
   Once the decisions have been made we can start cutting code, before
   we do this though we need to decide where our file should go.  If
   you are writing a pseudo-device that will be used by multiple
   architectures then the appropriate place to put the driver code is
   in <TT>/usr/src/sys/dev</TT>.  If the pseudo-device is specific to
   a particular architecture then put the driver code under the
   architecture specific directory, for example on the i386
   architecture this would be <TT>/usr/src/sys/arch/i386/i386</TT>.
   The include file should go into <TT>/usr/src/sys/sys</TT> for the
   architecture independent device and in the <TT>include</TT>
   directory under the architecture specific directory for an
   architecture specific device, for example, on the i386 architecture
   this would be <TT>/usr/src/sys/arch/i386/include</TT>.  In either
   case ensure that you update the relevant <TT>Makefile</TT> so your
   include file is installed.  One thing you will note is the
   <STRONG>struct skeleton_softc</STRONG> at the top of <A
   HREF="pseudo_dev_skel.c">pseudo_dev_skel.c</A>.  You must have a
   softc structure declared with the name of your device with "_softc"
   appended and the first element of this struct needs to be a
   <STRONG>struct device</STRONG> type, the name of the entry is not
   important but it must be first as the autoconfig system relies on
   the softc struct being declared <!-- ??? is this really true ??? --> and
   that its first element is a struct device.  There needs to be a
   softc struct for each minor number a device handles.  The softc
   structure can hold more elements than just the struct device if the
   minor devices require state information to be kept about them.

<ENTRY>functions The functions
    The kernel interfaces to your device via a set of function calls
    which will be called when a user level programme accesses your
    device.  A device need not support all the calls, as we will see
    later, but at a minimum a useful device needs to support an open
    and close on it.  Remember the function names need to be prepended
    with your device name.  The functions are:
<P>
<OL TYPE=i>
<LI><h4>attach</h4>
  
  This function is called once when the kernel is initialising.  It is
  used to set up any variables that are referenced in later calls or
  for allocating kernel memory needed for buffers.  The attach
  function is passed one parameter which is the number of devices this
  driver is expected to handle.
<P>
<LI><h4>open</h4>

  As the name suggests, this function will be called when a user level
  programme performs an open(2) call on the device.  At its simplest
  the open function may just return success.  More commonly, the open
  call will validate the request and may allocate buffers or
  initialise other driver state to support calls to the other driver
  functions.  The open call is passed the following parameters:
<P><DL>
             <DT>dev
             <DD> This is the device minor number the open is being
                performed on.
<P>
              <DT>flags
              <DD>  flags passed to the open call
		<!-- ??? flags passed to the open call by user ??? -->
<P>
              <DT>mode
              <DD>  mode for open 
		 <!-- ??? mode for open ??? -->
<P>
              <DT>proc
              <DD>  This is a pointer to the proc structure of the process
                that has requested the open.  It allows for validation
                of credentials of the process.
</DL>
<LI><h4>close</h4>

  This closes an open device.  Depending on the driver this may be as
  simple as just returning success or it could involve free'ing
  previously allocated memory and/or updating driver state variables
  to indicate the device is no longer open.  The parameters for the
  close function call are the same as those described for open.
<P>
<LI><h4>read</h4>
  
  Read data from your device.  The parameters for the function are:
<P><DL>
              <DT>dev
              <DD>  The minor number of the device.

              <DT>uio
               <DD> This is a pointer to a uio struct.  The read function
                will fill in the uio struct with the data it wants to
                return to the user.

              <DT>flags
              <DD>  flags <!-- ??? wuffor ??? -->
</DL><P>
<LI><h4>write</h4>
  
  Write data to your device.  The parameters for the write function
  are the same as those for a read function - the only difference
  being that the uio structure contains data to be written to the
  device.
<P>
<LI><h4>ioctl</h4>

  Perform an ioctl on your device.  The parameters for the ioctl call
  are:
<P><DL>
              <DT>dev
              <DD>  The minor number of the device.

              <DT>cmd
              <DD>  The ioctl command to be performed.  The commands are
                defined in a header file which both the kernel code
                and the user level code reference.  See the
		<A HREF="pseudo_dev_skel.c">sample header</A> for an example.

              <DT>data
               <DD> This is a pointer to the parameters passed in by the
                user level code.  What is in this parameter depends on
                the implementation of the ioctl and also on the actual
                ioctl command being issued.

              <DT>flags
              <DD>  flags <!-- ??? wuffor ??? -->

              <DT>proc
              <DD>  The proc structure that is associated with the user
                level process making the ioctl request.
</DL><P>

<LI><h4>stop</h4>

  Stop output on tty style device.
<P><DL>
              <DT>tty
              <DD>  tty associated with the device

              <DT>flags
              <DD>  flags <!-- ??? -->
</DL><P>

<LI><h4>poll</h4>

  Checks the device for data that can be read from it.  The parameters
  are:
<P><DL>
              <DT>dev
              <DD>  The minor number of the device used.

              <DT>events
              <DD>  The event(s) that the user level call is polling for.

              <DT>proc
               <DD> The proc structure that is associated with the user
                level process making the ioctl request.
</DL><P>

<LI><h4>mmap</h4>

  Supports the capability of mmap'ing a driver buffer into a user
  level programme's memory space.  The parameters are:
<P><DL>
              <DT>dev
              <DD>  The minor device number of the device used.

              <DT>offset
               <DD> The offset from the start of the buffer at which to
                start the mmap.

              <DT>prot
              <DD>  The type of mmap to perform, either read only, write
                only or read write.  The device driver need not
                support all modes.
</DL></OL><P>
   
   The function names your device driver supports must be inserted
   into a <TT>struct cdevsw</TT> for a character device and/or a
   <TT>struct bdevsw</TT> that has the name of your module appended
   with either <TT>_cdevsw</TT> or <TT>_bdevsw</TT>.  For our sample
   pseudo-device this structure would be called
   <TT>skeleton_cdevsw</TT> since we decided that our pseudo-device
   would be a character device only.  Note that these structures have
   entries in them for all the device interface functions but your
   device may only implement a subset of these functions.  Instead of
   forcing everyone to implement stub functions for the unused ones
   there are a set of pre-declared stubs prefixed with either
   <TT>no</TT> (e.g. noread, nowrite and so on) which will return
   <TT>ENODEV</TT> when called or <TT>null</TT> (e.g. nullread,
   nullwrite and so on) which will return success, effectively
   providing a null operation.  For the functions in the cdevsw and/or
   bdevsw that your driver does not support simply use one of the
   predeclared stubs.

<ENTRY>newdevice Making the kernel aware of the new device

   Once you have done the coding of your pseudo-device it is then time
   to hook your code into the kernel so that it can be accessed.  Note
   that the process of hooking a pseudo-device into the kernel differs
   a lot from that of a normal device.  Since a pseudo-device is
   either there or not the usual device probe and auto-configuration is
   bypassed and entries made into kernel structures at the source
   level instead of at run time.  To make the kernel use your code you
   have to modify these files:
<P>
<OL TYPE=i>
<LI><h4>/usr/src/sys/conf/majors or /usr/src/sys/<I>arch</I>/conf/majors.<I>arch</I></h4>

   These files contain lists of device major numbers for NetBSD.  The
   file <I>/usr/src/sys/conf/majors</I> contains the major numbers for
   devices that are machine independent, that is, available on all
   architectures that NetBSD supports.  If the device is only relevant
   to a particular architecture then the file
   <I>/usr/src/sys/<B>arch</B>/conf/majors.<B>arch</B></I> must be used
   where <B>arch</B> is replaced with the architecture in question.
   These files contain entries of the form
<PRE>
device-major    prefix		type      number	condition
</PRE>
   The exact syntax for these lines is described in the config(5)
   man page but for the purposes of our example the  components of the
   line are:
<P><DL>
		<DT>device-major
		<DD>  A keyword indicating this is a device major
		number entry.

		<DT>prefix
		<DD>  The prefix that will be applied to all the
		driver functions when their names are automatically
		generated.  In our example this would be
		<TT>skeleton</TT>.

		<DT>type
		<DD>  The type of major device this is, it may be
		either <TT>char</TT> or <TT>block</TT>.  You may
		specify both a char and block device by repeating the
		type/number pair for both.

		<DT>number
		<DD> The major number for the device, choose the next
		available number.  Make a note of this number as you
		will need it to make the device node in <TT>/dev</TT>.

		<DT>condition
		<DD> The condition on which this device will be
		included in the kernel.  This should match the
		pseudo-device entry you put in the conf file
		(described below).
</DL><P>
   For our example skeleton pseudo device we want a character device,
   and have decided that the driver is machine specific to the
   <TT>i386</TT> architecture.  After making these decisions we can
   edit the <TT>/usr/src/sys/arch/i386/conf/majors.i386</TT> file, we find
   that major number 140 is available so we add the line:
<PRE>
device-major	skeleton	char	140	skeleton
</PRE>
</OL>

<ENTRY>config Making config<b></b>(1) aware of the new device
   To make
   config(1) aware of our new pseudo device we need to edit the file
   in either <TT>/usr/src/sys/conf/files</TT> (for architecture
   independent devices) or
   <TT>/usr/src/sys/arch/<I>arch</I>/conf/files.<I>arch</I></TT> where
   <I>arch</I> is the relevant architecture.  This file tells config
   what valid device names there are and which files are associated
   with these devices.  Firstly we look for the section that defines
   the pseudo-devices.  This section has lines that start with
   <TT>defpseudo</TT>.  Since we have decided that our driver is to be
   an architecture specific one we edit the
   <TT>/usr/src/sys/arch/i386/conf/files.i386</TT> file and once we
   have found the correct section we can add a line like this:

<PRE>
defpseudo skeleton
</PRE>

   Which tells config(1) we have a pseudo-device called skeleton.
   Next we need to tell config(1) which files are associated with the
   skeleton pseudo-device.  In this case we only have one file but a
   more complex pseudo-device may have more files, simply add each
   file required on a line in the same manner.  For our example we
   only need one line that looks like this:

<PRE>
file dev/skeleton.c	   skeleton	needs-flag
</PRE>

   The <B><TT>file</TT></B> on the line is a key word to
   say we are defining a device to file association.  The second field
   is the location of the file relative to the root of the kernel
   source tree (normally, <TT>/usr/src/sys</TT>).  The
   third field is the name of the driver that this file is associated
   with, in our case this is skeleton - our sample pseudo-device.  The
   fourth and last field is a control flag that tells config(1) to
   write the skeleton.h include file. Note that here the file is called
   skeleton.c, if we were using the example files here, we would have to
   either rename pseudo_dev_skel.c to skeleton.c or change this entry.
   Since we said above that we are calling it skeleton, it would probably
   be more suitable to call it skeleton.c.

<ENTRY>kernelconfig Adding the new device to the kernel config file
   Once config(1) has been told about the device, adding it to
   the kernel config file is simple.  To add our skeleton device we
   add the line:

<PRE>
pseudo-device  skeleton
</PRE>

   To the kernel config file, note the name of the pseudo-device
   matches the name given in the <TT>defpseudo</TT> line
   in the previous section.  New defines can be added to the kernel
   makefile by using the <B><TT>options</TT></B> kernel
   config file keyword, config will build a makefile with the options
   named added as -D command line options to the cc command.

<ENTRY>userlevel Allowing user level programmes access to the new device
   After building and installing a new kernel there is one last thing
   that needs to be done to access the new pseudo-device, this is to
   make a device node for talking to the new device.  The device node
   can be made on any file system that allows you to access devices
   from it but, by convention, device nodes are created in
   <I>/dev</I>.  To make the device node you will need to use
   mknod(8) to create a device node with the major number you
   noted in section 4.i.  In our case the mknod(8) command would look
   like this:
<PRE>
        mknod /dev/skel c 140 0
</PRE>
   Once this has been done you should be able to open your new device
   and test it out.  The file <A HREF="sample.c">sample.c</A> shows
   the skeleton pseudo device in action.  This file assumes you have
   followed the instructions here and have created <TT>/dev/skel</TT>,
   this device is opened and a parameter structure passed to the
   device driver via an ioctl call.  To compile the sample code use
   this command line:
<PRE>
        cc -o sample sample.c
</PRE>
   Which will produce a binary called sample.  <STRONG>NOTE:</STRONG>
   you will have to have run <TT>make includes</TT> in the directory
   you copied <TT>pseudo_dev_skel.h</TT> to install the header file
   into the system includes directory otherwise the compiler will
   complain about a missing include file.  Once you have compiled the
   programme, run it and then look at your kernel messages either on
   the console screen or in <TT>/var/log/messages</TT>, they should
   have a message that looks like this:
<PRE>
May 17 20:32:57 siren /netbsd: Got number of 42 and string of Hello World
</PRE>
   Which is a message printed by the skeleton ioctl handler when it
   receives a SKELTEST ioctl request; notice that the number and the
   string printed are the ones we put into the <TT>param</TT>
   structure in sample.c.
</LIST>

<DOCLINK>

<hr>
<address>
  <small>
  <a href="http://www.NetBSD.org/cgi-bin/feedback.cgi">(Contact us)</a>
  $NetBSD: index.list,v 1.19 2006/12/29 03:41:31 kano Exp $<br>
  <a href="../../../Misc/disclaimer.html">Copyright &copy; 1994-2005
  The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED.</a><br>
  <a href="../../../Misc/disclaimer.html">NetBSD<sup>&#174;</sup> is a
  registered trademark of The NetBSD Foundation, Inc.</a><br>
  </small>
</address>

</BODY>
</HTML>
