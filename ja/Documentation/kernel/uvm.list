<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<!-- Copyright (c) 1994-2003
	The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED. -->
<link rev="made" href="mailto:www@NetBSD.org">
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
<title>NetBSD Documentation: UVM, the new Virtual Memory system</title>
</head>
<body bgcolor="#FFFFFF" text="#000000">

<HEADING>UVM, the new Virtual Memory system

<LIST>

<hr>
<h2>Other related links</h2>
<ul>
<li><a href="vfork.html">Why implement a traditional vfork()</a>
<li>The <a href="http://www.ccrc.wustl.edu/pub/chuck/tech/uvm/">UVM web page</a>
<li> Charles D. Cranor's dissertation on <a href="http://www.ccrc.wustl.edu/pub/chuck/psgz/diss.ps.gz">Design and Implementation of UVM</a> (270 pages, gzipped PostScript)
<li><a href="http://www.usenix.org/events/usenix99/full_papers/cranor/">The
UVM Virtual Memory System</a> - a paper by Charles D. Cranor and Gurudatta
M. Parulkar
</ul>

<SECTION>UVM FAQs

<ENTRY>what-is-uvm What is UVM?
<strong>UVM</strong> is a complete rewrite of the NetBSD virtual memory
system, and has proven to be a much better performer than the Mach VM
system. <strong>UVM</strong> also supports advanced features such as
page loanout, and is being used in the development of a unified buffer
and page cache for NetBSD. For a detailed description, see the 
<a href="http://www.ccrc.wustl.edu/pub/chuck/tech/uvm/">UVM web page.</a>

<ENTRY>who-wrote-uvm Who wrote UVM?
Chuck Cranor designed and implemented <strong>UVM</strong>, Matthew
Green handled integration issues and wrote the swap subsystem, Chuck
Silvers wrote the anonymous memory object pager (which added support
for shared memory), and various other developers have converted the
appropriate ports across.  Andrew Brown modified <strong>UVM</strong>
to be able to do <strong><a href="#what-is-top-down">top down</a></strong>
memory management.

<ENTRY>uvm-out-of-memory How does UVM handle running out of memory?
UVM uses lazy allocation. This means programs can overallocate
virtual memory.  When UVM detects an out of VM completely condition
and a lazy allocated bit of memory is accessed, the offending process
will be KILLed and the system will continue.  There is also a small
buffer of reserve pages only for use by the paging system, which allows
the pagedaemon to run comfortably when there is otherwise no free ram.
Most of this work was done by Chuck Silvers.

<ENTRY>which-ports-use-uvm Which ports use UVM?
<strong>UVM</strong> is not available in the 1.3.X distributions, but
is used on all ports for 1.4 and later.

<ENTRY>for-what-does-the-u-stand For what does the U stand in UVM?
<strong>UVM</strong> used to be part of another project worked on by
Chuck Cranor that started with the letter "U" (for "universal")...
however, that project mutated into just <strong>UVM</strong>...  so the
"U" doesn't really stand for anything anymore: "<strong>UVM</strong>"
is just a name that is different from (but close to) "vm".

<ENTRY>vm-how-big How much virtual memory do I have?
In UVM, your total virtual memory is equal to the size of your
physical RAM (minus kernel overhead) plus the size of each swap
partition.  In other words, physical memory doesn't have to be backed
by a paging device.

<ENTRY>what-is-top-down What is ``top down'' memory allocation?
This rearranges mmap(2)'ed memory allocations that don't request a
specific address such that they start directly below the stack and
work from the <strong>top down</strong>, instead of from the middle
upwards.  By doing this, the area of space reserved for heap growth
and the area of space reserved for mmap(2)'ed allocations are merged,
meaning that the heap can grow larger, or a process can mmap more or
larger objects.  The kernel still uses the traditional ``bottom up''
scheme for its internal memory management.

<ENTRY>which-ports-use-top-down Which ports use ``top down'' memory allocation?
The <strong>top down</strong> memory allocation scheme is currently offered as
kernel option on the <b><a href="../../Ports/i386/">i386</a></b> port,
and the PowerPC ports: 
<b><a href="../../Ports/bebox/">bebox</a></b>,
<b><a href="../../Ports/macppc/">macppc</a></b>,
<b><a href="../../Ports/mvmeppc/">mvmeppc</a></b>,
<b><a href="../../Ports/ofppc/">ofppc</a></b>,
<b><a href="../../Ports/pmppc/">pmppc</a></b>,
<b><a href="../../Ports/prep/">prep</a></b>, and
<b><a href="../../Ports/sandpoint/">sandpoint</a></b>.
It is expected that most ports will eventually transition to using
<strong>top down</strong> unconditionally at some point.
Refer to the
<b><a href="http://man.NetBSD.org/man/options+4+NetBSD-current">options(4)</a></b>
man page for more information.

</LIST>

<a href="./">Up to <em>NetBSD Documentation: Kernel</em></a>
<hr>

<DOCLINK>

<hr>
<address>
  <small>
  <a href="http://www.NetBSD.org/cgi-bin/feedback.cgi">(Contact us)</a>
  $NetBSD: uvm.list,v 1.19 2004/03/20 20:38:25 snj Exp $<br>
  <a href="../../Misc/disclaimer.html">Copyright &copy; 1994-2003
  The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED.</a>
  </small>
</address>

</body>
</html>
