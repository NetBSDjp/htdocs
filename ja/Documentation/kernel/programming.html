<html>
<head>

<!-- DO NOT EDIT THIS FILE. EDIT 'programming.list' AND RUN 'make' -->

<!-- Copyright (c) 1998, 1999, 2000
	The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED. -->
<link rev="made" href="mailto:www@JP.NetBSD.ORG">
<title>Kernel programming FAQ</title>
</head>
<body bgcolor="#FFFFFF" text="#000000">


<table><tr><td>
<a href="/Misc/daemon-copy.html">
<img align="center" src="/images/BSD-daemon.jpg" border=0
width=146 height=129 alt="BSD daemon"></a>
</td><td align=center>
<h1>NetBSD ドキュメンテーション:</h1>
<h1>カーネルプログラミング</h1>
</td></tr></table>
<p>


現在、このドキュメントにはそれほど有用な情報が含まれていません。
人々が多くの項目を寄稿してくれれば、もっと役に立つようになるでしょう。

<hr>
<h2>他の関連するリンク</h2>
<ul>
<li> <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=bus_dma&amp;sect=9">bus_dma(9)</a> - NetBSD のバスとマシン独立な DMA フレームワーク、これに
        関する<a href="bus_dma.ps">論文</a> (120k、ポストスクリプト)
<li> <a href="http://www.flame.org/cgi-bin/uncgi/hman?page=bus_space&amp;sect=9">bus_space(9)</a> - NetBSD のバススペースの操作のためのインターフェース

<li><a href="/Documentation/kernel/converting-ethernet-drivers.html" origlink="converting-ethernet-drivers.html">
        昔の BSD のイーサネットドライバーの NetBSD-1.2D 以降への移植</a>
<li><a href="/Documentation/kernel/porting-freebsd-net.html" origlink="porting-freebsd-net.html">
        FreeBSD のネットワークドライバーを NetBSD に移植するためのメモ</a>
</ul>

<h2><a name="top">Misc</a></h2>
<font><ul>
<li><a href="#knf">KNF とは何ですか</a></li>
<li><a href="#packed-attribute">pack された属性を使用する</a></li>
<li><a href="#printf">デバッグのための printf() の使い方</a></li>
<li><a href="#forcing-ddb">強制的に DDB に落とす</a></li>
<li><a href="#adding_a_new_driver">カーネルに新しいドライバーを追加する</a></li>
<li><a href="#adding_a_system_call">システムコールを追加する</a></li>
<li><a href="#mmap_in_pseudo-device">仮想デバイスに mmap を実装する方法</a></li>
<li><a href="#accessing_a_kernel_structure_from_userland">ユーザーランドからカーネルの構造体へアクセスする</a></li>
</ul></font>


<hr>
<h2>Misc</h2><hr>
<p><dl><dt>
<font><h3><a name="knf">KNF とは何ですか</a>
<font size="-1">(<a href="#top">top</a>)</font></h3></font>
</dt><dd>
KNF は Kernel Normal Form の略で、/usr/share/misc/style に記述されている 
C のコーディングスタイルです。ソースツリーに
<a href="http://cvsweb.netbsd.org/bsdweb.cgi/sharesrc/share/misc/style?rev=HEAD&content-type=text/x-cvsweb-markup">/usr/src/share/misc/style</a>
として含まれています。

</dd></dl></p>
<p><dl><dt>
<font><h3><a name="packed-attribute">pack された属性を使用する</a>
<font size="-1">(<a href="#top">top</a>)</font></h3></font>
</dt><dd>
wire プロトコルデータフォーマットを記述する構造体の中では、いつも
pack された属性を使用しています。

</dd></dl></p>
<p><dl><dt>
<font><h3><a name="printf">デバッグのための printf() の使い方</a>
<font size="-1">(<a href="#top">top</a>)</font></h3></font>
</dt><dd>
カーネルドライバーのデバッグ用の情報を出力するもっとも簡単な方法は、
printf() を使うことでしょう。カーネルの printf は コンソールに出力
されるので、多く出力しすぎ、システムが使いものにならないように注意
しなければなりません。

</dd></dl></p>
<p><dl><dt>
<font><h3><a name="forcing-ddb">強制的に DDB に落とす</a>
<font size="-1">(<a href="#top">top</a>)</font></h3></font>
</dt><dd>
カーネルのコンフィグファイルが '<code>options&nbsp;DDB</code>'を
含んでいる事を確認してください。
ファイルに'<code>#include&nbsp;"opt_ddb.h"</code>' を記述し、
'<code>Debugger()</code>' を使ってください。


</dd></dl></p>
<p><dl><dt>
<font><h3><a name="adding_a_new_driver">カーネルに新しいドライバーを追加する</a>
<font size="-1">(<a href="#top">top</a>)</font></h3></font>
</dt><dd>
全てのドライバーは、すくなくとも以下の二つの関数を必要とします。
<ul>
<li><tt><i>xxx</i>probe()</tt> (NetBSD がデバイスの存在を調べる時)</li>
<li><code><i>xxx</i>attach()</code> ルーチンはデバイスを設定、アタッチします。</li>
</ul>
プローブとアタッチルーチンを書いたら、
<tt>/usr/src/sys/arch/&lt;your-arch&gt;/&lt;your-arch&gt;/conf.c</tt>.
にエントリーを追加してください。そこには以下の二つのテーブルがあります。
<ul>
<li><code>cdevsw</code> キャラクタデバイス用。</li>
<li><code>bdevsw</code> ブロックデバイス用(ブロックI/O とストラテジー・
ルーチンとして使用する)。</li>
</ul>
ほとんどのエントリーは <code>cdev_<i>xxx</i>_init()</code> という形式と
なります。これは標準的な Unix のデバイススイッチルーチンのプロトタイプ
のためのマクロです。
<p>
プローブとアタッチルーチンはブート時によばれます。
<code>open()</code>、<code>close()</code>、<code>read()</code>、
<code>write()</code> ルーチンは、メジャー番号がテーブルのインデックス
に一致するデバイススペシャルファイルがオープンされた時によばれます。
例えば、メジャー番号18 のデバイスをオープンした場合、<tt>cdevsw[]/bdevsw</tt>
の中のデバイス番号18の "open" ルーチンがよばれます。
<p>
ほとんどのドライバーはバス固有のアタッチコードとマシン独立のコアに分割
されています。例えば、PCI lance イーサネットドライバーは以下のファイルで
構成されています。
<ul>
<li><a href="http://cvsweb.netbsd.org/bsdweb.cgi/syssrc/sys/dev/pci/files.pci?rev=HEAD&content-type=text/x-cvsweb-markup">/sys/dev/pci/files.pci</a>
       - アタッチ情報 ('le at pci'を見てください)。
<li><a href="http://cvsweb.netbsd.org/bsdweb.cgi/syssrc/sys/dev/pci/if_le_pci.c?rev=HEAD&content-type=text/x-cvsweb-markup">/sys/dev/pci/if_le_pci.c</a>
       - ドライバーのためのPCI バスのアタッチのコード。
<p>
<li><a href="http://cvsweb.netbsd.org/bsdweb.cgi/syssrc/sys/conf/files?rev=HEAD&content-type=text/x-cvsweb-markup">/sys/conf/files</a>
       - MI コアのアタッチ情報('le:'を見てください)。
<li><a href="http://cvsweb.netbsd.org/bsdweb.cgi/syssrc/sys/dev/ic/am7990.c?rev=HEAD&content-type=text/x-cvsweb-markup">/sys/dev/ic/am7990.c</a>
       - MI ドライバー、24ビットアクセスのコード。
<li><a href="http://cvsweb.netbsd.org/bsdweb.cgi/syssrc/sys/dev/ic/am79900.c?rev=HEAD&content-type=text/x-cvsweb-markup">/sys/dev/ic/am79900.c</a>
       - MI ドライバー、32ビットアクセスのコード。
<li><a href="http://cvsweb.netbsd.org/bsdweb.cgi/syssrc/sys/dev/ic/lance.c?rev=HEAD&content-type=text/x-cvsweb-markup">/sys/dev/ic/lance.c</a>
       - MI コアのドライバーのコード。
</ul>

</dd></dl></p>
<p><dl><dt>
<font><h3><a name="adding_a_system_call">システムコールを追加する</a>
<font size="-1">(<a href="#top">top</a>)</font></h3></font>
</dt><dd>
<tt>syscalls.master</tt> にエントリーを追加し、syscall スタブを
<tt>
<a href="http://cvsweb.netbsd.org/bsdweb.cgi/basesrc/lib/libc/sys/Makefile.inc?rev=HEAD&content-type=text/x-cvsweb-markup">/usr/src/lib/libc/sys/Makefile.inc</a>
</tt> の適当な場所に追加してください。

</dd></dl></p>
<p><dl><dt>
<font><h3><a name="mmap_in_pseudo-device">仮想デバイスに mmap を実装する方法</a>
<font size="-1">(<a href="#top">top</a>)</font></h3></font>
</dt><dd>
あなたの作ったデバイスは、おそらくキャラクターデバイスでしょう。もし、
そうであれば、デバイスページャーを使っているはずです。(VM システムは、
これらすべてを隠蔽しているので、心配しないでください)。
<p>
最初に、mmap インターフェースのために、適当なオフセットをいくつか選
んでください。例えば「mmap オフセット 0-M は オブジェクトAをあたえる、
N-O はオブジェクト B をあたえる」等のように。
<p>
これが終ると、mmap ルーチンは以下のように実装できます。
<p>
<pre>
int
foommap(dev, off, prot)
        dev_t dev;
        int off, prot;
{

        if (off & PAGE_MASK)
                panic("foommap");

        if ((u_int)off &gt;= FOO_REGION1_MMAP_OFFSET &&
            (u_int)off &lt; (FOO_REGION1_MMAP_OFFSET + FOO_REGION1_SIZE))
                return (atop(FOO_REGION1_ADDR + ((u_int)off -
                    FOO_REGION1_MMAP_OFFSET)));

        if ((u_int)off &gt;= FOO_REGION2_MMAP_OFFSET &&
            (u_int)off &lt; (FOO_REGION2_MMAP_OFFSET + FOO_REGION2_SIZE))
                return (atop(FOO_REGION1_ADDR + ((u_int)off -
                    FOO_REGION2_MMAP_OFFSET)));

        /* Page not found. */
        return (-1);
}
</pre>
<p>
さて、実際には単純なカーネルメモリーオブジェクトを mmap するので、
コードはもうすこし複雑になります(結局は仮想デバイスですから)。
<p>
これを動作させるためには、アロケートしたメモリーオブジェクトをページ調整
された境界に確実に mmap しなければなりません。もし、アロケートしたメモリ
のサイズ &gt;= PAGE_SIZE なら、これは保証されます。そうでなければ、
uvm_km_alloc() を使い、アロケーションサイズをページサイズに切りあげてください。
<p>
若干の修正を加えると以下のようになります。
<p>
<pre>
int
foommap(dev, off, prot)
        dev_t dev;
        int off, prot;
{
        paddr_t pa;

        if (off & PAGE_MASK)
                panic("foommap: offset not page aligned");

        if ((u_int)off &gt;= FOO_REGION1_MMAP_OFFSET &&
            (u_int)off &lt; (FOO_REGION1_MMAP_OFFSET + FOO_REGION1_SIZE)) {
                if ((vaddr_t)foo_object1 & PAGE_MASK)
                        panic("foommap: foo_object1 not page aligned");
                if (pmap_extract(pmap_kernel(), foo_object1 +
                    (u_int)off - FOO_REGION1_MMAP_OFFSET, &pa) == FALSE)
                        panic("foommap: foo_object1 page not mapped");
                return (atop(pa));
        }

        if ((u_int)off &gt;= FOO_REGION2_MMAP_OFFSET &&
            (u_int)off &lt; (FOO_REGION2_MMAP_OFFSET + FOO_REGION2_SIZE)) {
                if ((vaddr_t)foo_object2 & PAGE_MASK)
                        panic("foommap: foo_object2 not page aligned");
                if (pmap_extract(pmap_kernel(), foo_object2 +
                    (u_int)off - FOO_REGION2_MMAP_OFFSET, &pa) == FALSE)
                        panic("foommap: foo_object2 page not mapped");
                return (atop(pa));
        }

        /* Page not found. */
        return (-1);
}
</pre>

</dd></dl></p>
<p><dl><dt>
<font><h3><a name="accessing_a_kernel_structure_from_userland">ユーザーランドからカーネルの構造体へアクセスする</a>
<font size="-1">(<a href="#top">top</a>)</font></h3></font>
</dt><dd>
良い例が <tt>
<a href="http://cvsweb.netbsd.org/bsdweb.cgi/basesrc/usr.bin/vmstat/dkstats.c?rev=HEAD&content-type=text/x-cvsweb-markup">/usr/src/usr.bin/vmstat/dkstats.c</a>
</tt> にあります。
ここではディスクの統計情報を読んでいます。

</dd></dl></p>
<hr>

<a href="" origlink=""><em>NetBSD Documentation: Kernel</em> に戻る</a>
<hr>


<table width="100%"><tr>
<td>
  <table><tr>
  <td>
    <a href="../../">
    <img src="/images/NetBSD-banner.gif" border=0 alt=""></a>
  </td><td>
    <font>
    <a href="../../">
    <img src="/images/empty.gif" border=0
     alt="NetBSD ">ホームページ</a>
    </font>
  </td>
  </tr></table>
</td><td>
  <table><tr>
  <td>
    <a href="../../Documentation/">
    <img src="/images/NetBSD-banner.gif" border=0 alt=""></a>
  </td><td>
    <font>
    <a href="../../Documentation/">
    <img src="/images/empty.gif" border=0
     alt="NetBSD ">Documentation top level</a>
    </font>
  </td>
  </tr></table>
</td>
</table>


<hr>
<address>
  <a href="../../Misc/feedback.html">(Contact us)</a>
  $NetBSD: programming.html,v 1.13 2000/11/15 21:00:35 jun Exp $<br>
  <a href="../../../Misc/disclaimer.html">Copyright &copy;
    1998, 1999, 2000
    The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED.</a>
</address>

</body>
</html>
