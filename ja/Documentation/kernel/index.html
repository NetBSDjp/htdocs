<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>

<!-- DO NOT EDIT THIS FILE. EDIT 'index.list' AND RUN 'make' -->

<!-- Copyright (c) 1994-2003
	The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED. -->
<link rev="made" href="mailto:www@JP.NetBSD.ORG">
<link rel="shortcut icon" href="../../../favicon.ico" origlink="/favicon.ico" type="image/x-icon">
<title>NetBSD Documentation: Kernel</title>
</head>
<body bgcolor="#FFFFFF" text="#000000">

<table><tr><td>
    <a href="../../Misc/disclaimer.html#bsd-daemon"><img
     align="middle" src="../../../images/BSD-daemon.jpg" origlink="../../images/BSD-daemon.jpg" border="0"
     width=146 height=129 alt="BSD daemon"></a>
  </td><td align=center>
    <h1>NetBSD ドキュメンテーション:</h1>
    <h1>カーネル</h1>
</td></tr></table>
<p>

<h2><a name="top">FAQ - よくあるカーネルに関する質問</a></h2>
<ul>
<li>
<a href="#downloading_kernel_source">どこでカーネルソースをダウンロードできますか</a></li>
<li>
<a href="#how_to_build_a_kernel">カーネルの作り方</a></li>
<li>
<a href="#generic_kernel">GENERIC カーネルっていったい何なんですか?</a></li>
<li>
<a href="#mclpool-limit"><tt><b>mclpool limit reached: increase NMBCLUSTERS</b></tt> ってどういう意味ですか?</a></li>
<li>
<a href="#spl_not_lowered"><tt><b>WARNING: SPL NOT LOWERED ON SYSCALL EXIT</b></tt> ってどういう意味ですか?</a></li>
<li>
<a href="#stray-ir7"><tt><b>Stray interrupt on IRQ 7</b></tt> ってどういう意味ですか?</a></li>
<li>
<a href="#why_msoft_float">なぜカーネルを <tt><b>-msoft-float</b></tt> 付きでコンパイルするのですか</a></li>
<li>
<a href="#kernel-compile-slow">メモリーの少ないマシンでカーネルをコンパイルするとすごい遅いのですが</a></li>
<li>
<a href="#problems_compiling_a_current_kernel">-current カーネルのコンパイルに関する問題</a></li>
<li>
<a href="#debugging_a_kernel_crash_dump">カーネルクラッシュダンプのデバッグの方法</a></li>
<li>
<a href="#backtraces">カーネルクラッシュダンプをデバッグしているときにバックトレースを得る方法</a></li>
<li>
<a href="#ddb">DDB ってなんですか、それを使うと何ができるんですか</a></li>
<li>
<a href="#generating-a-crash-dump">カーネルのクラッシュダンプを作るには</a></li>
<li>
<a href="#adding_a_kernel_to_a_boot_floppy">ブートフロッピーにカーネルを追加する方法</a></li>
<li>
<a href="#scsi_device_numbers">新しく SCSI デバイスを増設したら、今までマウントできていたデバイスがマウントできなくなってしまいました。いったいどういう規則でデバイスに番号をつけてるんですか?</a></li>
</ul>
<h2>よくあるハードウェアに関する質問</h2>
<ul>
<li>
<a href="#device-not-configured"><tt><b>device not configured</b></tt> ってどういう意味ですか?</a></li>
<li>
<a href="#atapi_devices">ATAPI や ATA (IDE) デバイスのデバッグ</a></li>
<li>
<a href="#usb-debugging">USB デバイスのデバッグ</a></li>
<li>
<a href="#new_pnp_device">あたらしい PnP デバイスを認識させるには</a></li>
<li>
<a href="#new_pcmcia_device">あたらしい PCMCIA デバイスを認識させるには</a></li>
<li>
<a href="#plip_support">PLIP (Parallel Line IP) をサポートしていますか</a></li>
<li>
<a href="#ubc">UBC ってなんですか?</a></li>
</ul>


<h2>NetBSD に特有のドキュメント</h2>
<ul>
<li><a href="programming.html">カーネルプログラミング FAQ</a>
<li><a href="pseudo/">疑似(pseudo)デバイスドライバーを書くには</a>
<li><a href="profiling/">カーネルプロファイリング HOWTO</a>
<li><a href="elf-notes.html">ベンダー特有の ELF Note Element</a>
<li><a href="uvm.html">UVM、あたらしい仮想メモリーシステム</a>
<li><a href="vfork.html">なぜ伝統的な vfork() を実装したか</a>
<li><a href="kgdb.html">GDB を用いた NetBSD カーネルのデバッグ HOWTO</a>
</ul>

<h2>その他のオンライン ドキュメント</h2>
<ul>
<li><a href="http://tofu.alt.net/~lk/291.paper/291.paper.html">
    Porting BSD UNIX to a New Platform</a>
<li><a href="http://www.netapp.com/tech_library/nfsbook.html">
    4.4BSD のデザインと実装、第9章 (NFS)</a>
<li><a href="config-torek.ps">4.4BSD のデバイスコンフィギュレーション</a>
<li><a href="http://www.mckusick.com/softdep/index.html">Soft Updates に関する情報 (Soft Dependencies、softdep) とスナップショット</a>
<li><a href="http://www.ccrc.wustl.edu/pub/chuck/">ATM ネットワーキングの BSD への統合</a>
<li><a href="http://www.pdl.cs.cmu.edu/RAID/index.html">RAID と RAIDframe 関連の多くのドキュメント</a>
<li><a href="http://dinsen.net/netbsd/kernel.html">Anders Dinsen の
    カーネルドキュメンテーションの概要</a>
</ul>

<hr>
<h2>FAQ - よくあるカーネルに関する質問</h2><hr>
<p><h3>
<a name="downloading_kernel_source">どこでカーネルソースをダウンロードできますか</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
<h4><a name="official_release_kernel_source">公式リリース</a></h4>
すでにインストールされているものと同じリリースのカスタマイズしたカーネルを
コンパイルするには、カーネルの <tt>syssrc.tgz</tt> ファイルだけあれば十分です。
特定のリリースに対して、このファイルは、そのリリースのメインディレクトリの中の
gzip された tar ファイル 'source/sets/syssrc.tgz' にあります。
たとえば、NetBSD 1.5.2 のカーネルソースは次のファイルにあります:
<pre>   <a
href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.5.2/source/sets/syssrc.tgz">/pub/NetBSD/NetBSD-1.5.2/source/sets/syssrc.tgz</a></pre>
もし <a href="../../Sites/cdroms.html">NetBSD CD-Rom</a>を持っていたら、
'source/sets/syssrc.tgz' も含まれています。ソースはどこでも展開できますが、
習慣的に /usr/src に置かれます。
展開するには "<b><tt>cd / ; tar xvzpf &lt;ファイル名&gt;</tt></b>" と
してください。
<p> <h4>'流血の刃先' -current ソース、冒険好きな人限定!</h4>
最新のカーネルソースは ftp.netbsd.org かミラーサイトの <a
href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-current/src/sys/">/pub/NetBSD/NetBSD-current/src/sys/</a>
ディレクトリーにあります。<br>
カーネルをコンパイルするには、以下のものを <a
href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-current/tar_files/src/">
/pub/NetBSD/NetBSD-current/tar_files/src</a> からダウンロードした方が
いいでしょう:  <ul>
   <li><a
   href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-current/tar_files/src/config.tar.gz">config.tar.gz</a>
   ('<a href="http://man.netbsd.org/man/config+8+NetBSD-current">config(8)</a>' プログラムのソース) <li><a
   href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-current/tar_files/src/sys.tar.gz">sys.tar.gz</a>
   (全てのアーキテクチャーの完全なカーネルソース) </ul> 
あなたが使っているバージョンから変更があった場合、最初に 'config'
プログラムをビルドとインストールすべきです。
-current は NetBSD 開発の最先端なので、<a
href="#problems_compiling_a_current_kernel">-current カーネルの
コンパイルに関する問題</a> があるかもしれません。
あなたがコンフィグの手順に慣れるまでは <a
href="#official_release_kernel_source">公式リリース</a> のソースを
使うことをお勧めします。
<p><h4>特定の日付のカーネルソースをダウンロードするには</h4>
スナップショットをあなたのマシンにインストールしていて、
カーネルを作り直したい(でも -current カーネルは新しすぎる)場合に、
このような事が必要かもしれません。
<a href="../current/#using-anoncvs">anoncvs
を用いた NetBSD-current の追跡</a>の方法に従ってください。

</dd></dl>
<p><h3>
<a name="how_to_build_a_kernel">カーネルの作り方</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>

<a name="building_a_kernel"></a>
<!-- Don't change the above targets - SAs reference them. -->

<ol>
    <li>あなたのベースシステムに付属していたコンパイラーセット(<tt>comp.tgz</tt>)を
        インストールしたことを確認してください。
 <p><li>カーネルソースをダウンロードし展開します(
	<a href="#downloading_kernel_source">どこからカーネルソースを
	ダウンロードできますか</a>参照)。
 <p><li>-current を使っている場合、新しい tool-chain のコンパイルが
	必要かもしれません:
	完全な -current のソースをダウンロードしたら:
	<br>
        <code><b>cd /usr/src && ./build.sh tools</b></code>
 <p><li>"<b><tt>cd /sys/arch/&lt;ARCH&gt;/conf</tt></b>"<br>
	&lt;ARCH&gt; には 'i386', 'sparc', 'mac68k' のような
	あなたのマシンアーキテクチャーが入ります。
 <p><li>"<b><tt>cp GENERIC &lt;MYCONF&gt;</tt></b>"<br>
	&lt;MYCONF&gt; はこの設定にあなたが名づけた名前です。ホスト名や
	マシンタイプ、あなたの名前を使ってもよいのです。英文字、数字、
	そして _ 文字が使えます。
 <p><li><b>&lt;MYCONF&gt;</b> の編集<br>
	最初はこのステップは飛ばしても構いません。
	i386 上で仮想コンソールを得るために
	 'pc0' をコメントアウトして 'vt0' を有効にしたりするように、
	あなたが持っていなかったり使っていない CPU タイプやハードウェア、
	デバイスのドライバーを削除することができます。
	あなたがどのハードウェアドライバーを使い続けるかを決めるよい第一歩
	となるのは、"<b><tt>dmesg</tt></b>" か
	"<b><tt>dmesg | grep ' at '</tt></b>" の出力を読むことです。
	'&lt;XXX&gt; at &lt;YYY&gt;' を含む全ての行について
	&lt;XXX&gt; と &lt;YYY&gt; の両方のエントリーを残す必要があります。
	他のカーネル設定のオプションの情報のために、"<b><a href="http://man.netbsd.org/man/options+4+NetBSD-current">options(4)</a></b>"
	も読んでください。
 <p><li>current のアップデートでは、新しい toolchain
        を使うようにするのが、おそらくよいでしょう:<br>
        <code><b>cd /usr/src && ./build.sh kernel=MYCONF</b></code><br>
        このようにした場合、次の 4 個のステップは省くことができます。
 <p><li>"<b><tt>config &lt;MYCONF&gt;</tt></b>"<br>
	&lt;MYCONF&gt; のカーネルをビルドするためのディレクトリーを
	生成します。
 <p><li>"<b><tt>cd ../compile/&lt;MYCONF&gt;</tt></b>"<br>
	カーネルをビルドするためのディレクトリーに移動します。
 <p><li>"<b><tt>make depend</tt></b>"<br>
	make プログラムがどのファイルをリビルドすればいいのか
	わかるように(この時点では全て!)、'.depend' ファイルを生成します 。
 <p><li>"<b><tt>make</tt></b>"<br>
	カーネルをコンパイルします。もし全てがうまくいけば、'netbsd'
	カーネルができているでしょう。もしあなたが VAX を使っていれば
	これは相当時間がかかり、大規模な Alpha マシンならとても短い時間であり、
	残りの人たちはこの中間の時間になります。
 <p><li>"<b><tt>mv /netbsd /netbsd.old ; mv /sys/arch/&lt;ARCH&gt;/compile/&lt;MYCONF&gt;/netbsd /</tt></b>"<br>
	現在のカーネルを保存し、(_とても_ 重要)、
	新しいカーネルをブートできるよう移動します。
 <p><li>"<b><tt>reboot</tt></b>"<br>
	これであなたの新しいカーネルを使ってリブートします -
	ブートメッセージには次の行が含まれているはずです:
	'NetBSD &lt;VERSION&gt; (&lt;MYCONF&gt;) #0: &lt;COMPILE_DATE&gt;'
 <p><li><b>何か問題があったら:</b><br>
	シングルユーザーモードで 'netbsd.old' カーネルをブートしましょう。
	変更する手順はブート手順に依存していますが、i386 ではこうでしょう:
	<ol>
	    <li><b>最初の NetBSD のメッセージが表示されたら <tt>SPACE</tt> を押す</b></li>
	    <li>"<b><tt>boot netbsd.old -s</tt></b>"</li>
	</ol>
	<p>
	次にカーネルを元に戻す:
	<ol>
	    <li>"<b><tt>fsck /</tt></b>"</li>
	    <li>"<b><tt>mount /</tt></b>"</li>
	    <li>"<b><tt>mv netbsd.old netbsd</tt></b>"</li>
	    <li>"<b><tt>exit</tt></b>"</li>
	</ol>
</ol>

</dd></dl>
<p><h3>
<a name="generic_kernel">GENERIC カーネルっていったい何なんですか?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
<p>
GENERIC という言葉はマシンアーキテクチャーでサポートされている
全てのマシンで実行できるように設定されたカーネルを意味します。
この言葉はもともとカーネルの設定ファイル中に含まれていた、
設定オプションでもあるルートデバイスを"汎用(generic)"と
することを示す行に由来します。このオプションと設定行の書式は
すでに用いられていませんが、この名称はしばらく残ることでしょう。
<p>
このため、GENERIC カーネルは、全てのデバイスドライバとたくさんの
マシンモデルをサポートするコードを含んでいます。
多くはあなたにとって必要ないものなので,
<a href="#how_to_build_a_kernel">あなた用のカスタム化したカーネルを
コンパイルする</a>事をお勧めします。

</dd></dl>
<p><h3>
<a name="mclpool-limit"><tt><b>mclpool limit reached: increase NMBCLUSTERS</b></tt> ってどういう意味ですか?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
これはカーネルが、mbuf クラスターにマップした空間を使い果たしたことを意味します。
mbuf クラスターはネットワークコードでパケットやその他の
ネットワーク関係のデータを格納するのに使用されています。
<p>
デフォルトの NMBCLUSTERS の設定は 1024 (NetBSD 1.5 以前では 256) なので、
もしこの問題が起きたならば、エラーメッセージが出なくなるまで、
この値を倍に増やしていってください。現在の NMBCLUSTERS の値は、以下のように
<a href="http://man.netbsd.org/man/sysctl+8+NetBSD-current">sysctl(8)</a> を使って表示できます:
<blockquote><code>
	# sysctl kern.mbuf.nmbclusters
</code></blockquote>
または、以下のようにすることもできます
<blockquote><code>
	# echo 'print nmbclusters' | gdb -q /netbsd
</code></blockquote>
カーネル設定に関するオプションについてのより詳しい情報は
<a href="http://man.netbsd.org/man/options+4+NetBSD-current">options(4)</a> を参照して下さい。
<p>
この値を変更するには、
<blockquote>
	options NMBCLUSTERS=2048<br>
</blockquote>
を<a href="#how_to_build_a_kernel">カーネル設定ファイル</a>に加えるか、
カーネルを直接変更してください:
<blockquote>
        # <strong>gdb --write /netbsd</strong><br>
        (gdb) <strong>set nmbclusters=2048</strong><br> 
        (gdb) <strong>quit</strong><br>
</blockquote>
カーネルを直接変更した場合は、変更が有効になるようにするためにリブートが必要です。
もし、使用中のプラットホームがサポートしていれば、次のコマンドを用いて
値を設定することもできます。
<blockquote>
	# <strong>sysctl -w kern.mbuf.nmbclusters=2048</strong><br>
</blockquote>
この方法はすぐに有効になりますが、次回のリブート時には設定されません。
この方法とカーネルの変更を組み合わせれば、新しくカーネルを作る必要も
リブートする必要もありません。
<p>

</dd></dl>
<p><h3>
<a name="spl_not_lowered"><tt><b>WARNING: SPL NOT LOWERED ON SYSCALL EXIT</b></tt> ってどういう意味ですか?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
このカーネルメッセージはカーネル中に 
int x = splfoo(); したのに復帰する前に splx(x); を実行しなかった syscall が
あるというバグがあることを意味します。
この例で splx(x); 関数はシステムの優先度レベルを x にエンコードされた状態、
つまり他の spl 関数(この場合は splfoo(); という関数)によって返された値に
レストアします。
<p>
このカーネルメッセージが出力された場合、カーネル内デバッガーである <a href="http://man.netbsd.org/man/ddb+4+NetBSD-current">ddb(4)</a> に
入って下さい。ddb 内で 't' を押すことによりスッタクトレースを得ることができ、
問題の syscall() を確認することができるかもしれません。
このカーネルメッセージは本来出力されるはずが
ないものですので、trace コマンドの出力(ほかの関連情報も含めて)を
<a href="http://man.netbsd.org/man/send-pr+1+NetBSD-current">send-pr(1)</a> する方がいいでしょう。
<p>
spl 関数についてのより詳しい情報は <a href="http://man.netbsd.org/man/spl+9+NetBSD-current">spl(9)</a> を参照して下さい。

</dd></dl>
<p><h3>
<a name="stray-ir7"><tt><b>Stray interrupt on IRQ 7</b></tt> ってどういう意味ですか?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
    このカーネルメッセージ "Stray interrupt on IRQ 7" は、割り込み
    コントローラーが、 IRQ 7 上のマスク解除された割り込みを報告したが、
    その IRQ で要求されたドライバーがないことを意味しています。
    <p>
    これが起きうる原因は、ふたつあります:
    <p>
    <ol> 
      <li>PC 以外では、ほとんどの場合は、その IRQ にドライバーがアタッチされたが、
        そのドライバーが不適切だったことを
        (この場合のほかは、その IRQ がマスクされていたことを) 意味します。
        <p>
      <li>PC では、もっとやっかいな 'default IR7' の問題があります。
	これは、デバイスがある IRQ をアサートした時に、
	PIC が割り込みを検知した後に CPU がそれを知る前にその IRQ がデアサートされたため、
	その IRQ が何だったかについて PIC が公然と嘘をつくのです。
	<p>
	'default IR7' を前提にするという方法もありますが、
	古いマシンの中にはかえって状況が悪化するものもありますし、
	一般論としても、まず第一にドライバーを改良してこれを出さないようにした方がよいです。
	とはいえ、エッジトリガーな割り込みを使っていると、
	完全な予防は困難な場合もありますが。
    </ol>
    <p>
    なお、このカーネルメッセージは、 DEBUG
    オプション付きのカーネルを走らせているときにしか出ません。

</dd></dl>
<p><h3>
<a name="why_msoft_float">なぜカーネルを <tt><b>-msoft-float</b></tt> 付きでコンパイルするのですか</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
<p>
プロセスがシステムコールを呼び出したとき、
後でそのプロセスに戻ってこられるように、
カーネルはプロセッサーの状態を保存する必要があります。
浮動小数点レジスターは比較的大きくなりがちなので、それらを保存したり
回復したりすることは高価な操作です。もし FPU がまだ処理を実行途中であっ
たなら、CPU はその処理が完了するまで待ってからでないと、レジスターのコピー
を行うことができません。
<p>
カーネル内で浮動小数点レジスターを利用するのを避けることで、システムコール実行
の効率を、かなり向上させることができます。
また sparc など、いくつかのプロセッサーでは、浮動小数点コンテキストの切
り替えを lazy に行うことによって、プロセス切り替えの際の浮動小数点レジ
スターの保存/回復処理を、場合によっては省略することもできます。
<p>
いくつかのアーキテクチャーではコンパイラーは主要な操作 (メモリーブロック転送など)
のスピードアップのために浮動小数点レジスターを使うことができ、
上記の動作を止めるためには '-msoft-float' が必要です。

</dd></dl>
<p><h3>
<a name="kernel-compile-slow">メモリーの少ないマシンでカーネルをコンパイルするとすごい遅いのですが</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
デフォルトでは NetBSD はサポートしているほとんど全てのハードウェアに対する
ドライバー、ネットワークプロトコル、ファイルシステムを含む GENERIC カーネルを
インストールします。これは、そのポートのいかなる計算機でもそのカーネルが
実行されることを保証しますが、結果として、特にメモリーが少ない計算機では、
必要以上の(メモリー)空間を占有します。また、カーネルのコンパイルの際には
 -O2 最適化が行われています。コンパイラーが、この最適化を行うことにより
出来上がるカーネルは可能な限り速くなりますが、コンパイルの際には
通常より多くのメモリーと時間を必要とします。
<p>
<a href="#how_to_build_a_kernel">あなた専用のカーネルを構築する</a>
際のひとつの方法としては、コンパイラーに対して通常の使用にとって
十分である最適化のみを行うように指示するために
"<tt><b>make&nbsp;COPTS=-O</b></tt>" を使うことです。この結果として
できあがったカーネルはほんの少し遅くなりますが、コンパイルにかかる
時間は短くなります。
<p>
もし、メモリーの少ないマシンを使用していて、カーネルをカスタマイズ
するために何度も 'コンパイル、新しいカーネルでリブート' を繰り返す
つもりがあるのならば、始めのの何回かは "<tt><b>make&nbsp;COPTS=-O</b></tt>"
を使い、最後に "<tt><b>make</b></tt>" を使うのが良いかもしれません。
<p>
もちろん、メモリーが少ししかないマシンでカーネルをコンパイルするのに、
一般的にもっとも速い方法は、別のマシンを使用すること、または一時的に
もっとメモリーを増設することです!

</dd></dl>
<p><h3>
<a name="problems_compiling_a_current_kernel">-current カーネルのコンパイルに関する問題</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
最初に注意すべき点は、
<a href="../../MailingLists/#current-users">current-users</a>
メーリングリストに参加した方がよいということです。
current-users を読まずに -current を追うことはライトを灯けずに夜道を
ドライブしているようなものです。警告しましたよ :)
<p>
最新の
<a href="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-current/tar_files/src/config.tar.gz">config.tar.gz</a>
をダウンロードし、コンパイル、インストールし、あなたの
コンフィグファイルに対して再度 config を実行してください。
 (config コマンドはリリースごとにかなり頻繁に変更されますから)
<p>
時々、あらかじめバイナリーやライブラリーをアップグレードしておかないと、
リリース版で -current の構築ができなくなることがあります。このような場合、
それらをバイナリースナップショットからインストールした上で
-current を構築したほうが簡単かもしれません。 i386 の -current
スナップショットは、 (たとえば) 
<a
href="ftp://ftp.netbsd.org/pub/NetBSD/arch/i386/snapshot/">/pub/NetBSD/arch/i386/snapshot/</a> にあります。
<a href="http://cvsweb.netbsd.org/bsdweb.cgi/src/UPDATING?rev=HEAD&amp;content-type=text/x-cvsweb-markup">src/UPDATING</a>
ファイルには、このような、 -current や -current カーネルの構築に際して
知っておくべき重要な変更点に関する情報が載っています。

</dd></dl>
<p><h3>
<a name="debugging_a_kernel_crash_dump">カーネルクラッシュダンプのデバッグの方法</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
<ol>
<li>同じソースを用いて設定ファイルの中で <tt>DEBUG</tt> と '<tt>makeoptions
    DEBUG="-g"</tt>'を有効にして
    <a href="#how_to_build_a_kernel">カーネルの作成</a>をしたことを
    確認してください。
<li>"<b><tt>gdb netbsd.gdb</tt></b>"
    (カーネルをコンパイルしているディレクトリーで)
<li>gdb プロンプトで "<b><tt>target kcore /var/crash/netbsd.0.core</tt></b>"
</ol>
一般の <a href="http://man.netbsd.org/man/gdb+1+NetBSD-current">gdb(1)</a> コマンドも使えます。例えばバックトレースを得るには
'<b><tt>bt</tt></b>' とします。

</dd></dl>
<p><h3>
<a name="backtraces">カーネルクラッシュダンプをデバッグしているときにバックトレースを得る方法</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
カーネルのクラッシュダンプをデバッグしている場合、
次の簡単な 2ステップで任意のプロセスのバックトレースを gdb から得ることができます。
<p>
<ol>
<li>プロセスの proc addr を調べる "<b>ps -ax -O paddr -M netbsd.x.core</b>"
<li>gdb に id として "<b>proc 0x&lt;addr&gt;</b>" を使うように指示する
</ol>

</dd></dl>
<p><h3>
<a name="ddb">DDB ってなんですか、それを使うと何ができるんですか</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
DDB はオプションとして提供されるカーネル内部のデバッガーです。
次の 3通りの方法で起動することができます:
<ul>
<li>いつでも、ポート特有のキーの組合せで起動する(組合せについては <a href="http://man.netbsd.org/man/ddb+4+NetBSD-current">ddb(4)</a> 参照)。
<li>カーネルがパニックした時に起動するように設定できます。
<li>'-d' をブートフラグに指定する(<tt><b>boot netbsd -d</b></tt>)。
</ul>
いくつかの有用なコマンドは次の通りです:
<ul>
<li><tt><b>trace</b></tt> - スタックトレースを作ります。
    カーネルパニックの
    <a href="../../Misc/send-pr.html#submitting">問題報告を送る</a>のに
    とても便利です。
<li><tt><b>reboot</b></tt> - システムをリブートします。
<li><tt><b>sync</b></tt> - クラッシュダンプを作った後、リブートします(NetBSD
    1.4.X <em>より後</em>で導入されました)。
</ul>

</dd></dl>
<p><h3>
<a name="generating-a-crash-dump">カーネルのクラッシュダンプを作るには</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
通常、カーネルはパニックした時に自動的にクラッシュダンプを生成し、
リブート時に <a href="http://man.netbsd.org/man/savecore+8+NetBSD-current">savecore(8)</a> によって回収されます。
しかし、 <a href="http://man.netbsd.org/man/ddb+4+NetBSD-current">ddb(4)</a> で <tt><b>'reboot&nbsp;0x100'</b></tt>
(NetBSD 1.5以降では <tt><b>sync</b></tt>) を用いると
強制的にクラッシュダンプを作る事ができます。もし、
カーネルが buffer キャッシュをシンク(同期)しようとしている間に panic したり
ハングするならば、シンクを行わない
<tt><b>'reboot&nbsp;0x104'</b></tt>を使うことができます。

</dd></dl>
<p><h3>
<a name="adding_a_kernel_to_a_boot_floppy">ブートフロッピーにカーネルを追加する方法</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
いくつかのポートでは既に
"<b><tt>cd /usr/src/distrib/<em>&lt;ARCH&gt;</em>/floppies ; make </tt></b>"
としてブートフロッピーを構築することができます。
(これを実行する前に INSTALL カーネルを手動で構築する必要があるかもしれません。)
既に <b>boot.fs</b> ファイルがあるのなら、次の手順でカーネルを置き換え
ることもできます:
<ol>
<li><b><tt>vnconfig -c vnd0 boot.fs</tt></b>
<li><b><tt>mount /dev/vnd0a /mnt</tt></b>
<li><b><tt>gzip -c -9 &lt; netbsd &gt; /mnt/netbsd.gz</tt></b>
<li><b><tt>umount /mnt</tt></b>
<li><b><tt>vnconfig -u vnd0</tt></b>
</ol>
この手順は、コンフィグファイルに "<tt>pseudo-device vnd</tt>" を指定して
作成したカーネルを、現在利用していることを前提としています。

</dd></dl>
<p><h3>
<a name="scsi_device_numbers">新しく SCSI デバイスを増設したら、今までマウントできていたデバイスがマウントできなくなってしまいました。いったいどういう規則でデバイスに番号をつけてるんですか?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
<!-- I'm having trouble mounting the SCSI device for a new partition I've just created.  What's up with this device-numbering scheme? -->
<!-- 今作ったばかりの新しいパーティションを含む SCSI デバイスをマウントしようとしたのにできません。いったいどういう規則でデバイスに番号をつけてるんですか? -->
<p>
デフォルトでは、NetBSD での SCSI デバイスは SCSI ID 番号の順に 0 から
番号付けされます。いいかえると、一番小さな番号の SCSI デバイスが
<tt>/dev/sd0</tt> となり、次のデバイスが <tt>/dev/sd1</tt> という
ふうになります。これはブートプロセスの間に対応づけられる事に
注意してください。
</p><p>
もし、あなた専用のカーネルをコンパイルするならば、
お好きな SCSI ID 番号を示す SCSI デバイスをセットすることができます。
そのためのカーネル設定ファイルは次のようになります:
<blockquote><pre>
sd0             at scsibus0 target 4 lun 0
sd*             at scsibus? target ? lun ?
</pre></blockquote>
上の 2行を用いると sd0 は SCSI ID 番号が 4 のディスクとなり、
残りのデバイスは上で述べられたルールで対応づけられます。
これは、しばしば、SCSI デバイスの "hardwiring" と呼ばれ、
RAID や <tt>ccd</tt> を使う場合には使用することをお勧めします。
こうしておくと、一つのデバイスの電源が入っていなかったり
故障した場合にデバイス ID が変わってしまうことを避けることができます。


</dd></dl>
<hr>
<h2>よくあるハードウェアに関する質問</h2><hr>

<p><h3>
<a name="device-not-configured"><tt><b>device not configured</b></tt> ってどういう意味ですか?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
<ul><li><p>
このメッセージがシステムブートの autoconfiguration の出力中に
現れたのならば、それはカーネルがシステム中に、あるハードウェアを
検出したがそれに対応するデバイスドライバが無いことを意味します。
これにはデバイスドライバは存在するがブートに使用したカーネルには
含まれていない場合と、デバイスドライバが本当に存在しない場合の
両方の可能性があります。
(後者の場合、優しい開発者に連絡を取り、テスト用のハードウェアを
提供してデバイスドライバーを書いてもらいましょう)
</p><p>
GENERIC カーネルは基本インストールに用いられるので、
安定で動くことが保証されている事が重要です。そのため、
まだ安定ではないデバイスドライバーは GENERIC カーネルに含まれていません。
あなたのシステム用の GENERIC カーネルの設定ファイルを見てみると
「コメントアウト」されている実験的なデバイスドライバーが見つかるかも
しれません。もしあなた用のカーネル(それを GENERIC とは呼ばないでください)を
コンパイルするならば、実験的なデバイスドライバーを試すことができます。
</p></li>
<li><p>
もし、このメッセージが <tt>/dev</tt>にあるデバイスノード
(例えば SCSI ディスク)へアクセスしようとしたときに出力されたならば、
それはアクセスしようとしたそのデバイスユニットを見つけられなかった
事を意味します。例えば、存在しない SCSI ディスクにアクセスしようと
した場合です。
</p><p>
しばしば、これは <tt>/etc/fstab</tt> に書かれたデバイスノードと
カーネルがブート時の autoconfiguration で見つけたものが一致しない状態で、
<tt>/etc/rc</tt>中の "mount" コマンドが全てのファイルシステムを
マウントしようとした時に起ります。いま一度、使用しようとした
デバイスがブート時にカーネルによって検出されているかを確認してください。
確認には <tt>/var/run/dmesg.boot</tt> (ブート時の autoconfiguration の
出力のコピーが保存されています) を用いることができます。
</p></li></ul>


</dd></dl>
<p><h3>
<a name="atapi_devices">ATAPI や ATA (IDE) デバイスのデバッグ</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
もしカーネルが <tt>WDCDEBUG</tt> を有効にしてコンパイルされていれば、
gdb が <code>wdcdebug_atapi_mask</code> と <code>wdcdebug_mask</code> 
の値の変更に使用できます。
これらの変数中の適切なビットを設定することで、カーネルは ATAPI と ATA 操作に
ついての詳しい情報を出力するようになります。<br>
(現在 NetBSD のデフォルトでは <tt>WDCDEBUG</tt> は有効になっています。)<p>
最高レベルの出力を得るには次の手順に従ってください:
<pre>	# <strong>gdb --write /netbsd</strong>
	(gdb) <strong>set wdcdebug_atapi_mask=0xff</strong>
	(gdb) <strong>set wdcdebug_mask=0xff</strong>
	(gdb) <strong>quit</strong>
</pre>
註: この例の設定は<em>非常に</em>大量の出力を行います。
個々のオプションを選択するためには、次に掲げる行のすぐ上に
ある、ビットフラグのリストを見てください:
<ul>
<li>
<a href="http://cvsweb.netbsd.org/bsdweb.cgi/src/sys/dev/scsipi/atapi_wdc.c?rev=HEAD&amp;content-type=text/x-cvsweb-markup">/sys/dev/scsipi/atapi_wdc.c</a> 中の <tt>wdcdebug_atapi_mask</tt>
<li>
<a href="http://cvsweb.netbsd.org/bsdweb.cgi/src/sys/dev/ic/wdc.c?rev=HEAD&amp;content-type=text/x-cvsweb-markup">/sys/dev/ic/wdc.c</a> 中の <tt>wdcdebug_mask</tt> 
</ul>

</dd></dl>
<p><h3>
<a name="usb-debugging">USB デバイスのデバッグ</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
USB デバイスの問題が起きた場合、USB ドライバのメッセージを冗長にすることが
できます。
<ul>
<li><tt>USB_DEBUG</tt> と <tt>DDB</tt> を含むカーネルをコンパイルする。
<li><tt><b>-d</b></tt> をつけてブートし、<a href="http://man.netbsd.org/man/ddb+4+NetBSD-current">ddb(4)</a> に入る。
<li>ddb で変数 usbdebug と uhcidebug を 5 にセットする。 ("<b>write
usbdebug 5</b>" と "<b>write uhcidebug 5</b>")
<li>デバイスを挿入して<b><tt>continue</tt></b> と入力する。
</ul>

</dd></dl>
<p><h3>
<a name="new_pnp_device">あたらしい PnP デバイスを認識させるには</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
この手順は対応する汎用のデバイスがすでにサポートされており、
デバイス ID が認識されないだけである時のみ有効です。
動作の異なるデバイスを加えるにはソースコードを書く必要があります。
<ol>
<li>デバイスは、ブートメッセージ中に '<tt>not configured</tt>' として
表示されているはずです。出力中に含まれる
デバイス ID を記録して下さい(この例だと <tt><b>USR3031</b></tt>です):
<pre>	isapnp0: &lt;U.S. Robotics 56K FAX INT, <b>USR3031</b>, , &gt; port 0x3e8/8 irq 5 not configured</pre>
<li>適切なエントリーを<tt>
<a href="http://cvsweb.netbsd.org/bsdweb.cgi/src/sys/dev/isapnp/isapnpdevs?rev=HEAD&amp;content-type=text/x-cvsweb-markup">/sys/dev/isapnp/isapnpdevs</a></tt> に加えて下さい:
<pre>	devlogic       com     USR3031         USR 56k Faxmodem</pre>
<li><tt>isapnpdevs.{c,h}</tt> を
	'<tt>make -f Makefile.isapnpdevs</tt>'
として作り直します。
<li><a href="#how_to_build_a_kernel">カーネルの再構築</a>をしてください。
<li>変更点を <a href="http://man.netbsd.org/man/send-pr+1+NetBSD-current">send-pr(1)</a> または <a href="../../Misc/send-pr.html#submitting">オンラインフォーム</a>を用いて
    報告して下さい。
</ol>

</dd></dl>
<p><h3>
<a name="new_pcmcia_device">あたらしい PCMCIA デバイスを認識させるには</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
この手順は対応する汎用のデバイスがすでにサポートされており、
デバイス ID が認識されないだけである時のみ有効です。
動作の異なるデバイスを加えるにはソースコードを書く必要があります。
<ol>
<li>カーネルを <a href="http://man.netbsd.org/man/options+4+NetBSD-current">options(4)</a> <tt>PCMCIAVERBOSE</tt> を有効にしてコンパイルします。
<li>ブートメッセージをチェックします - 該当のカードは '<tt>not configured</tt>' と
    レポートされているはずです。製造元(Manufacturer) とプロダクトコード(例題では
    <tt><b>0x143</b></tt> と <tt><b>0x201</b></tt>です)を記録します:
<pre>pcmcia0: CIS version PCMCIA 2.0 or 2.1
pcmcia0: CIS info: Grey Cell, GCS2000, Gold II, 1
pcmcia0: Manufacturer code <b>0x143</b>, product <b>0x201</b>
pcmcia0: function 0: network adapter, ccr addr 3f8 mask 1
</pre>
<li><tt>ベンダー(vendor)</tt> と <tt>プロダクトコード(product)</tt> を <tt>
<a href="http://cvsweb.netbsd.org/bsdweb.cgi/src/sys/dev/pcmcia/pcmciadevs?rev=HEAD&amp;content-type=text/x-cvsweb-markup">/sys/dev/pcmcia/pcmciadevs</a></tt>に加えます:
<li><tt>pcmciadevs.h</tt> と <tt>pcmciadevs_data.h</tt> を
	'<tt>make -f Makefile.pcmciadevs</tt>'
    として作り直します。
<li>付け加えたエントリーを適切な <tt>/sys/dev/pcmcia/</tt> にある bus attach ファイルの
    先頭部分にあるデバイステーブルに付け加えます。例えば ne2000互換カードの場合には
    <a href="http://cvsweb.netbsd.org/bsdweb.cgi/src/sys/dev/pcmcia/if_ne_pcmcia.c?rev=HEAD&amp;content-type=text/x-cvsweb-markup">/sys/dev/pcmcia/if_ne_pcmcia.c</a> に加えます。
<li><a href="#how_to_build_a_kernel">カーネルの再構築</a>をします。
<li>変更点を <a href="http://man.netbsd.org/man/send-pr+1+NetBSD-current">send-pr(1)</a> または <a href="../../Misc/send-pr.html#submitting">オンラインフォーム</a>を用いて
    報告して下さい。
</ol>

</dd></dl>
<p><h3>
<a name="plip_support">PLIP (Parallel Line IP) をサポートしていますか</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
NetBSD/i386 で PLIP をサポートするための Martin Husemann のパッチが
<a href="http://www.NetBSD.org/cgi-bin/query-pr-single.pl?number=1278">PR 1278</a>
として出ています。
この PR の末尾にあるパッチは、NetBSD 1.3.3 ソースツリーに対して適用す
ることができます。


</dd></dl>
<p><h3>
<a name="ubc">UBC ってなんですか?</a>
<font size="-1">(<a href="#top">top</a>)</font>
</h3><dl><dt><dd>
UBC とは統合されたバッファーキャッシュ(Unified Buffer Cache) プロジェクトを
意味します。これは Chuck Silvers によって書かれ、1.5L(2000年11月)以降の
NetBSD に統合されています。UBC でない状態からセットアップする際には
config を再実行する必要がありますが、その前に "BUFCACHE", "NBUF" や
"BUFPAGES" の設定を消去して、バッファーキャッシュのサイズをデフォルトに
戻した方が良いかもしれません。UBC のもとでは、伝統的な
バッファーキャッシュは通常ファイルのデータの格納には用いられず、
metadata だけに用いられますので、物理メモリのほとんどを
仮想記憶システムに任せてしまった方が良いでしょう。デフォルトの
バッファーキャッシュサイズはマシンのメモリ量に関わらず、
ほとんどの場合、最適となります。ブートメッセージ中の
メモリ量を示している "using X buffers containing Y memory" は
ファイルデータのキャッシュ用のメモリ量を示していませんので
数字が変わらなくても心配しないでください。
<p>

重要な変更点はより多くのメモリーを通常ファイルデータのキャッシュに
用いることができるということです。このためアクセスしようとした
ファイルのデータがすでにメモリ中に存在することが多くなり、結果として
ファイルシステムの入出力が速くなります。速くなる割合は何をするかにも
よりますが、多くの場合その違いに気付くことができるでしょう。<p>
<p>

以下も参照してください:
Chuck Silvers の論文
<a href="http://www.usenix.org/publications/library/proceedings/usenix2000/freenix/full_papers/silvers/silvers_html/">UBC: An Efficient Unified I/O and
Memory Caching Subsystem for NetBSD</a>


</dd></dl>
<hr>

<table width="100%"><tr><td>
  <table><tr><td>
    <a href="../../"><img
	src="../../../images/NetBSD-flag.gif" origlink="../../images/NetBSD-flag.gif" border="0"
	width="91" height="42" alt=""></a>
  </td><td>
    <a href="../../"><img
	src="../../../images/empty.gif" origlink="../../images/empty.gif" border="0"
	width="1" height="1" alt="NetBSD ">ホームページ</a>
  </td></tr></table>
</td><td>
  <table><tr><td>
    <a href="../../Documentation/"><img
	src="../../../images/NetBSD-flag.gif" origlink="../../images/NetBSD-flag.gif" border="0"
	width="91" height="42" alt=""></a>
  </td><td>
    <a href="../../Documentation/"><img
	src="../../../images/empty.gif" origlink="../../images/empty.gif" border="0"
	width="1" height="1" alt="NetBSD ">Documentation top level</a>
  </td></tr></table>
</td></tr></table>

<hr>
<address>
  <small>
  (連絡先 - <a href="http://www.netbsd.org/cgi-bin/feedback.cgi">英語</a>,
       <a href="mailto:www@JP.NetBSD.ORG">日本語:
       www@JP.NetBSD.ORG</a>)<br>
  $NetBSD: index.list,v 1.70 2003/05/11 04:41:07 gson Exp $<br>
  <a href="../../Misc/disclaimer.html">Copyright &copy; 1994-2003
  The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED.</a>
  </small>
</address>

</body>
</html>
