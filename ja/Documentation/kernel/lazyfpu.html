<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>

<!-- DO NOT EDIT THIS FILE. EDIT 'scsidma.list' AND RUN 'make' -->

<!-- Copyright (c) 2000
        The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED. -->
<link rev="made" href="mailto:www@NetBSD.ORG">
<title>How lazy FPU context switch works</title>
</head>
<body bgcolor="#FFFFFF" text="#000000">


<table><tr><td>
<a href="../../Misc/daemon-copy.html">
<img align="middle" src="../../images/BSD-daemon.jpg" border=0
width=146 height=129 alt="BSD daemon"></a>
</td><td align=center>
<h1>NetBSD Documentation:</h1>
<h1>How lazy FPU context switch works</h1>
</td></tr></table>
<p>

<center>
<table border=0 cellpadding=0 cellspacing=0 width="98%"><tr><td bgcolor="#000000">
<table border=0 cellpadding=4 cellspacing=1 width="100%"><tr><td bgcolor="#ffffff">
<font face="helvetica, arial, sans-serif" size="-1">
Here goes the explanation of how lazy FPU context switch works.<br>
<br>
Tohru Nishimura<br>
Nara Insititute of Science and Technology<br>
</font>
</td></tr></table>
</td></tr></table>
</center>

<p><h3>
<font face="helvetica, arial, sans-serif">How lazy FPU context switch
works</font>
</h3><dl><dt><dd>
FPU is troublesome in saving and loading entire hardware context
to/from reserved memory area hold by each process (it resides in
u_pcb in NetBSD/mips).   It's unrealistic to switch whole FPU
context from process to process upon every cpu_switch() is taken
because FPU context save and reload operation consumes significant
CPU cycles.
<p>
Modern CPUs provide the way to disable itself to execute any FP
insns.  When CPU is about to execute FP insn, an exception is posted
and operating system starts processing 'FPU was unavailable for
me' circumstance for the executing process.  It checks and prepares
to allow the process to use FPU, then restarts the process to
execute the FP insn once posted the exception.  This time FP insns
will be executed normally and never make 'FPU is unavailable'
condition until another process snatchs FPU from this process later.
<p>
Every process is created to have no FPU ownership and inhibited to
use FPU.   Unless the process ever executes any FP insns, nothing
special happens to it and the process terminates peacefully.
<p>
If a process inhibited to use FPU is about to execute a FP insn,
CPU posts 'unavailable' exception.  Global variable fpcurproc points
which process has the ownership of FPU.  At the moment upon
'unavailable' exception, FPU hardware should contain the snapshot
of 'runtime image' for the owner process, which is different from
curproc that has posted the exception.  Unavailable handler saves
the FPU hardware context made with a large number of FP registers
for the sake of fpcurproc, and load the curproc's FPU hardware
context into FPU registers.  The initial load of process FPU context
clears entire FPU.  In this way, FPU context switch is deferred
until another process is found requesting to use FPU.  Because the
vast majority of programs run no FP insn during process life time,
deferred lazy FPU context switch works handsomely avoiding rather
burdensome tasks of FPU save/load operations.
<p>
<em>Matt Thomas adds that you need to be careful to properly cleanup
tbe lazy FP context with the fpcurproc exits.</em>
<p>
The burdensome FPU context switch syndrome is similar to one in
which MMU faces on process context switch.   MMU is a rather
complicated machinary may hold a complex internal 'state' to describe
the process' address space, or more weirdly, 'task description'
for runtime environment, nature and feature of processes defined
by CPU hardware foundation.  Some of MMU have dedicated register(s)
to point the memory region which describes process address space.
In that case MMU context switch is done handsomely by reloading
another value for the new process to the dedicated register by
executing a special MMU insn.  A certain CPU design is widely known
to run hilariously spectacular job for MMU context switch by
saving/loading handful numbers of register, traversing memory region
to establish new process runtime context, with the cost of
astonishingly long CPU cycle.   The costy hardware supported context
switch capability is seldom used in practice and many consider it
as CISCy or the waste of silicon.
</dd></dl>

<hr>
<a href="">Up to <em>NetBSD Documentation: Kernel</em></a>
<hr>

<table width="100%"><tr><td>
  <table><tr><td>
    <a href="../../"><img
        src="../../images/NetBSD-flag.gif" border="0"
        width="91" height="42" alt=""></a>
  </td><td>
    <a href="../../"><img
        src="../../images/empty.gif" border="0"
        width="1" height="1" alt="NetBSD ">Home Page</a>
  </td></tr></table>
</td><td>
  <table><tr><td>
    <a href="../../Documentation/"><img
        src="../../images/NetBSD-flag.gif" border="0"
        width="91" height="42" alt=""></a>
  </td><td> 
    <a href="../../Documentation/"><img
        src="../../images/empty.gif" border="0"
        width="1" height="1" alt="NetBSD ">Documentation top level</a>
  </td></tr></table>
</td></tr></table>

<hr>
<address>
  <small>
  <a href="../../Misc/feedback.html">(Contact us)</a>
  $NetBSD: lazyfpu.html,v 1.3 2000/10/21 00:04:00 dent Exp $<br>
  <a href="../../Misc/disclaimer.html">Copyright &copy; 2000
    The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED.</a>
  </small>
</address>

</body>
</html>
