<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<!-- Copyright (c) 1994-2001
        The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED. -->
<link rev="made" href="mailto:www@JP.NetBSD.ORG">
<title>NetBSD Documentation: How lazy FPU context switch works</title>
</head>
<body bgcolor="#FFFFFF" text="#000000">

<table><tr><td>
<a href="../../Misc/daemon-copy.html">
<img align="middle" src="../../images/BSD-daemon.jpg" border=0
width=146 height=129 alt="BSD daemon"></a>
</td><td align=center>
<h1>NetBSD ドキュメンテーション:</h1>
<h1>どのように lazy FPU コンテキストスイッチは動作するのか</h1>
</td></tr></table>
<p>

<center>
<table border=0 cellpadding=0 cellspacing=0 width="98%"><tr><td bgcolor="#000000">
<table border=0 cellpadding=4 cellspacing=1 width="100%"><tr><td bgcolor="#ffffff">
<font size="-1">
ここでは、どのようにlazy FPU コンテキストスイッチは動作するのかについて
説明します。<br>
<br>
Tohru Nishimura<br>
Nara Insititute of Science and Technology<br>
</font>
</td></tr></table>
</td></tr></table>
</center>

<p><h3>
<font>どのように lazy FPU コンテキストスイッチは動作するのか</font>
</h3><dl><dt><dd>
FPU が、各プロセス毎の予約済みのメモリー領域(NetBSD/mips では、
これは u_pcb の中にあります)へ/から、ハードウェアコンテキスト
全体を保存したりロードしたりすることは困難です。cpu_switch() が
発生するたびに、プロセスからプロセスへ FPU コンテキスト全体を
スイッチするのは現実的ではありません。なぜなら、FPU コンテキスト
の保存と再ロードのオペレーションは、著じるしい CPU サイクルを消費
するからです。
<p>
最近の CPU は、FP インストラクションを実行するために、この機能を
無効にする方法を提供しています。CPU が FP インストラクションを
実行しようとしている時、例外が投げられ、オペレーティングシステム
は実行中のプロセスに「自分が使う事のできる FPU がない」という状況
の処理を開始します。OS は、プロセスが FPU を使う事ができるように
チェック、準備をおこないます。そして、例外が投げられた時、FP イン
ストラクションを実行するためにプロセスを再スタートさせます。今度は、
FP インストラクションは通常通りに実行され、後で他のプロセスが、この
プロセスから FPU を取得するまで、「FPU が使用不可能」という状況は
発生しません。
<p>
すべてのプロセスは、FPU の所有権無しで生成され、かつ FPU の使用を
禁じられています。プロセスが FP インストラクションを実行しなけ
れば、何も特別な事はおこらず、プロセスはおだやかに終了します。
<p>
もし、FPU の使用を禁止されたプロセスが、FP インストラクションを
実行しようとすると、CPU は、「使用不可能」例外を投げます。グロー
バルな変数 fpcurprocはどのプロセスが FPU を所有しているかを示します。
「使用不可能」例外が発生した時、FPU ハードウェアは所有プロセスの
「実行イメージ」のスナップショットを持っていなればなりません。
これは、例外を投げた curproc とは異なります。使用不可能ハンドラー
は、fpcurproc のために、多くの FP レジスターで構成される FPU ハード
ウェアコンテキストを保存します。そして、curproc の FPU コンテキスト
を FPU レジスターにロードします。プロセスの FPU コンテキストが最初
にロードされると、すべての FPU はクリアーされます。このように、FPU 
の使用を要求する他のプロセスが見つかるまで、FPU コンテキストスイッチ
は延期されます。なぜなら、大多数のプログラムは、プロセスが生存して
いる間、FP インストラクションを実行しません。延期された lazy FPU 
コンテキストスイッチは、やっかいな FPU の保存/ロードの操作の仕事を
できるだけ避けて、きちんと動作します。
<p>
<em> fpcurproc が指すプロセスが終了するときに、lazy に割り当てられ
ている FP context を、正しく解放するように注意しなければいけないこ
とを Matt Thomas が指摘してくれました。</em>
<p>
この厄介な FPU コンテキストスイッチシンドロームは、MMU がプロセス
コンテキストスイッチに直面した時の状況に似ています。
MMU は、プロセスのアドレススペースを表現するための複雑な内部「状態」、
あるいは、もっと奇妙な実行環境の「タスクディスクリプション」を持つ、
より複雑な機構です。プロセスの本質と特徴(nature and feature)は、CPU 
ハードウェアにより定義されます。いくつかの MMU は、プロセスのアドレス
スペースを示すメモリ領域をさすレジスターを使います。このような場合、
MMU コンテキストスイッチは、特別な MMU インストラクションを実行する
し、新しいプロセスのために他の値をレジスタに再ロードすることにより、
きちんと動作します。ある種の CPU デザインは、MMU コンテキストスイッチ
のためにさわがしい見せ物のような仕事をおこなうことで有名です。おどろ
くべき長さの CPU サイクルを消費して、ごく小数のレジスターの保存/ロード
し、新しいプロセスの実行コンテキストを確立するためにメモリ領域をいった
りきたりします。ハードウェアによるコンテキストスイッチのケーパビリティ
のサポートは非常にコストが高く、実際問題めったに使われることはありません。
そして、多くの人は、それは CISC 風、あるいはシリコンの浪費だと考えています。
</dd></dl>

<hr>
<a href=""><em>NetBSD ドキュメンテーション: カーネル</em>にもどる</a>
<hr>

<table width="100%"><tr><td>
  <table><tr><td>
    <a href="../../"><img
        src="../../images/NetBSD-flag.gif" border="0"
        width="91" height="42" alt=""></a>
  </td><td>
    <a href="../../"><img
        src="../../images/empty.gif" border="0"
        width="1" height="1" alt="NetBSD ">ホームページ</a>
  </td></tr></table>
</td><td>
  <table><tr><td>
    <a href="../../Documentation/"><img
        src="../../images/NetBSD-flag.gif" border="0"
        width="91" height="42" alt=""></a>
  </td><td> 
    <a href="../../Documentation/"><img
        src="../../images/empty.gif" border="0"
        width="1" height="1" alt="NetBSD ">Documentation top level</a>
  </td></tr></table>
</td></tr></table>

<hr>
<address>
  <small>
  <a href="../../Misc/feedback.html">(Contact us)</a>
  $NetBSD: lazyfpu.html,v 1.6 2001/03/16 14:50:44 dent Exp $<br>
  <a href="../../Misc/disclaimer.html">Copyright &copy; 1994-2001
  The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED.</a>
  </small>
</address>

</body>
</html>
