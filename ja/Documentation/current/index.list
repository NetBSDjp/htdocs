<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="ja">
<head>
<!-- Copyright (c) 1994-2004
	The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED. -->
<meta http-equiv="Content-Type" content="text/html; charset=ISO-2022-JP">
<link rev="made" href="mailto:www@jp.NetBSD.org">
<link rel="shortcut icon" href="../../../favicon.ico" origlink="/favicon.ico" type="image/x-icon">
    <title>NetBSD-currentの追跡</title>
  </head>

<body bgcolor="#FFFFFF" text="#000000">

<HEADING>NetBSD-currentの追跡

<LIST>

<SECTION>よくある質問

<ENTRY>why-track なぜ NetBSD-current を追跡するのか?

NetBSDの開発者はそのときどきの開発中のソースをいくつかの理由から一般に
公開してきました。まず、NetBSD-currentを用意することで、より安定した、
利用しやすいシステムを作ることができます。
<p>
これにより、NetBSDの開発に熱中するのが容易になります。最新の開発中ソー
スを配布することで、システムが今どうなっているのかが多くの人に明らかに
なりますし、新機能が実装されればすぐにそれを試してみることができます。
<p>
また、利用者からの変更を統合するのも楽になります。もし利用者が最新の開
発中ソースに対して変更を加えたならば、その変更をマスターソースツリーに
取り込むための作業は事実上要らなくなります。
<p>
また、そうすることでソフトウェアが開発されてすぐに広い範囲のテストをす
ることができます。NetBSD-currentの利用者は最新のソースについての<a
href="../../Misc/send-pr.html">バグレポート</a>を出すことが奨励されます。
これはバグを見つけたり修正したりする助けになります。ソフトウェアが書か
れてからすぐに多くの人がそれをテストするために、より多くのバグを見つけ
出して退治することができます。

<ENTRY>installing current スナップショットのインストール

current を手っ取り早く使い始めるには、
リリースエンジニアリングサーバーで作られるスナップショットから始めます。
各プラットフォームの最新の構築状況は、
<a href="http://releng.NetBSD.org/ab/global.html">
NetBSD Autobuild
</a>
で見ることができ、実際に構築されたものは、日付およびプラットフォーム別に
<a href="ftp://releng.NetBSD.org/pub/NetBSD-daily/current/">
pub/NetBSD-daily/current/
</a>
以下に置かれています。
<p>
<ol>
<li> 必要な <code>binary/sets</code> ディレクトリーを探し、
ファイルを <tt><b>mget *.tgz</b></tt>
して、ローカルの管理用ディレクトリー
(たとえば <em><code>$HOME/current</code></em> ) に置きます。
ディスクスペースや時間が足りない場合は、
必要不可欠なのは kern-GENERIC, etc, base, comp (コンパイラーが必要な場合) だけです。
<li> <code>/etc</code> およびカーネルを展開します。
<br>
    <tt><b>su</b></tt><br>
    <tt><b>cd /root</b></tt><br>
    <tt><b>tar -zxpf ~/etc.tgz</b></tt><br>
    <tt><b>tar -zxpf ~/kern-GENERIC.tgz</b></tt><br>
    <tt><b>ln -fh /netbsd /netbsd.old</b></tt><br>
    <tt><b>mv netbsd /netbsd</b></tt><br>
    <tt><b>shutdown -r now</b></tt><br>
<li> 基本的なユーティリティーの前に、 <code>/etc</code>
を <a href="#etcupdate">更新</a> します。
<br>
    <tt><b>su</b></tt><br>
    <tt><b>cd /root/etc</b></tt><br>
    <tt><b>./postinstall -s /root check</b></tt><br>
    <tt>システムファイルおよび構成を修正するため、ここで行なわれる指示にすべて従ってください</tt><br>
<li> <code>base</code> ほか一連の必要なものを展開し、
配置します。
<br>
    <tt><b>cd /</b></tt><br>
    <tt><b>tar -zxpf ~/comp.tgz</b></tt><br>
    <tt><b>...</b></tt><br>
    <tt><b>tar -zxpf ~/base.tgz</b></tt><br>
    <tt><b>/usr/sbin/etcupdate -b /root</b></tt><br>
    <tt><b>shutdown -r now</b></tt><br>
</ol>
<p>
以上で、
current に近い状態になり、
current のソースを構築する準備ができました。

<ENTRY>downloading current ソースのダウンロード

伝統的に、
システムソースファイルは <code>/usr/src</code> に置くものですが、
これには一般的に root 権限が必要です。
現在の <tt><b>build.sh</b></tt> プロセスは、特権がまったくなくても実行可能です。
ただし、インストールについては root 権限が必要です。
このドキュメントの例示で <code>/usr/src</code> としているところはすべて、
(<em><code>$HOME/current</code></em> のような)
別の場所に置き換えてもかまいません。
<p>
<ol>
<li> ソースツリーの置き場を選びます。
<br>
    <tt><b>cd /usr</b></tt><br>
    <tt><b>su</b></tt><br>
<li> -current ソースを、最寄りの
<a href="../../mirrors/">NetBSD ミラーサイト</a>
からダウンロードします。
<ul>
<li> <a
href="ftp://ftp.NetBSD.org/pub/NetBSD/NetBSD-current/tar_files/src/">
/pub/NetBSD/NetBSD-current/tar_files/src/</a> から ftp で、
または、
<li> <a href="ftp://ftp.NetBSD.org/pub/NetBSD/README.sup">sup</a> を使って。
</ul>
<p>
ダウンロードしたファイルは、ソースツリーのスナップショットになっています。
最新のファイルにするために、
<a
href="#using-anoncvs">anoncvs</a> を使って以下のようにします。<br>
    <tt><b>cd /usr/src</b></tt><br>
    <tt><b>cvs -q -d $CVSROOT update -dP</b></tt><br>
<p>
<code>-d $CVSROOT</code> は、あなたが選んだミラーサイトの CVS
タグをつけるため、初めて update する場合のみ必要です。
<code>-P</code> フラグは必ず毎回指定するか、または .cvsrc ファイルに追加してください。
<p>
もし、NetBSD のソースに対するローカルな変更を追跡したいならば、
ローカルな CVS ツリーをセットアップし、<a href="#using-sup-into-cvs">sup 
で行なわれた変更を import</a> した方が良いでしょう。

<li>
パーミッションを修正します。<br>
ソースツリーを、 (伝統的な) wsrc グループに属する
root 以外のユーザーが保守できるようにしたい場合は、
(root になって) 以下のようにします。<br>
<tt><b>chown -R <em>user</em>:wsrc /usr/src</b></tt><br>
<tt><b>chmod -R u=rwX,g=rwX,o=rX /usr/src</b></tt><br>

</ol>

<ENTRY>building ソースからリリースの構築

<em><a
href="http://cvsweb.NetBSD.org/bsdweb.cgi/src/BUILDING">src/BUILDING</a> を見て、
最新の変更点を確認するのを忘れないようにしてください。</em>
<p>
伝統的に、
システムオブジェクトファイルは <code>/usr/obj</code> に置くものですが、
これには一般的に root 権限が必要です。
そうするかわりに、オブジェクトファイルを別のファイルシステムに置くことで、
コンパイルにおける速度をかなり向上させることができます。
このドキュメントの例示で <code>/usr/src</code> としているところはすべて、
(<em><code>$HOME/current</code></em> のような)
別の場所に置き換えてもかまいません。
<ol>
<li> オブジェクトツリーの置き場を選ぶ。
フルインストールに加えてリリース用の tarfile 一式を置けるだけの
十分な容量が必要です。<br>
    <tt><b>cd /usr/src</b></tt><br>
    <tt><b>su</b></tt><br>
    <tt><b>mkdir ../tools</b></tt><br>
    <tt><b>mkdir ../obj</b></tt><br>
<li> ソースツリーのルートに移動し、そこで実行する。<br>
    <tt><b>cd /usr/src</b></tt><br>
    <tt><b>./build.sh -O ../obj -T ../tools -u -U release
</b></tt><br>
</ol>
<p>
この例において、
<code>-u</code> オプションは、構築開始前に <code>make clean</code>
を実行する必要がないことを表しています。これは、以前構築したものの更新や、
新規の構築をおこなう場合に便利です。
<p>
<code>-U</code> オプションは、 root でないユーザーによる完全なビルドができるようにするものです。
<p>
完了すると、
インストールメディアとノートを含む、インストールに必要なものがすべて、
<code>build.sh</code> が指定 (表示されます) したディレクトリー
以下に出来上がります。
<p>
異なるアーキテクチャー用に
<a href="../cross/">クロスコンパイル</a>
をおこないたい場合は、 build.sh 実行時に
'<code>-m MACHINE -a ARCH</code>' オプションをつけます。
<p>
より詳しくは、
'<code>./build.sh -h</code>' を実行するとともに、
<a href="ftp://ftp.NetBSD.org/pub/NetBSD/NetBSD-current/src/BUILDING">
/usr/src/BUILDING</a> を参照してください。

<ENTRY>updating 既存システムのアップデート

<em><a
href="http://cvsweb.NetBSD.org/bsdweb.cgi/src/UPDATING">src/UPDATING</a> を見て、
最新の変更点を確認するのを忘れないようにしてください。</em>
<p>
<ol>
<li> ソースツリーのルートに移動する。<br>
    <tt><b>cd /usr/src</b></tt><br>
<li>toolchain を構築する。<br>
    <tt><b>./build.sh -O ../obj -T ../tools -U -u tools</b></tt><br>
<li>配布物を構築する。<br>
    <tt><b>./build.sh  -O ../obj -T ../tools -U -u distribution</b></tt><br>
<li>カーネルを構築する。<br>
    <tt><b>./build.sh  -O ../obj -T ../tools -U -u kernel=GENERIC</b></tt><br>
<li>カーネルをインストールする。<br>
    <tt><b>cd ../obj/sys/arch/&lt;ARCH&gt;/compile/GENERIC</b></tt><br>
    <tt><b>su</b></tt><br>
    <tt><b>mv /netbsd /netbsd.old</b></tt><br>
    <tt><b>cp netbsd /netbsd</b></tt><br>
<li>新しいカーネルでリブートする。<br>
    <tt><b>shutdown -r now</b></tt><br>
<li>新しいユーザーランドをインストールする。<br>
    <tt><b>cd /usr/src</b></tt><br>
    <tt><b>su</b></tt><br>
    <tt><b>./build.sh -O ../obj -T ../tools -U install=/</b></tt><br>
<li>古くなったファイルの修正のため、出力される説明に従う。たとえば以下のように。
<br>
    <tt><b>/usr/src/etc/postinstall -s /usr/src -d // fix defaults mtree obsolete</b></tt><br>
<li>/etc の<a href="#etcupdate">更新</a><br>
    <tt><b>/usr/sbin/etcupdate -s /usr/src/etc</b></tt><br>
<li>動作中のサービス群がすべて新しいバイナリーを使うようにするため、リブートする。 (これはしなくてもよい)<br>
    <tt><b>shutdown -r now</b></tt><br>
</ol>
<p>
この例において、
<code>-u</code> オプションは更新プロセスを表し、
<code>-U</code> オプションは、 root でないユーザーによる完全なビルドができるようにする
(その後に root でインストールする) ものです。
<p>
構築の順序 (tools, distribution, kernel) は、問題が起きた場合に、
ソース更新にかかる時間を常に最適化するために選ばたものです。
一貫性を保つため、
エラーが起きた場合や cvs update した場合は、
必ず上述の過程の最初からやり直してください。
<p>
より詳しくは、
<a href="ftp://ftp.NetBSD.org/pub/NetBSD/NetBSD-current/src/UPDATING">
/usr/src/UPDATING</a> を参照してください。

<ENTRY>what-to-do 覚えておくべきこと

<ul>
 <li>
  より新しいバージョンの-currentにアップグレードするときは、どれかの新しい
  ライブラリー(<a href="#star">*</a>)をインストールする前に<em>必ず</em>
  新しいカーネルをコンパイルし、それで起動していなければなりません。
  一般的にもっともよいのは他のどれよりも先に新しいカーネルを試し、何か問
  題にぶつかったら<a
  href="../kernel/#problems_compiling_a_current_kernel">
  カーネル FAQ</a>を参照することです。
  <p>
  カーネルが動き出したらソースツリーの一番上の
  <a href="ftp://ftp.NetBSD.org/pub/NetBSD/NetBSD-current/src/BUILDING">BUILDING</a>.

  ファイルを一読し、 build.sh スクリプトを使って新しいユーザーランドを
  作るといいでしょう。
  <p>

 <li>
  -current のカーネルをコンパイルする際には、常に
  COMPAT_&lt;最新のリリース&gt; オプション (例えば COMPAT_16)
  を含めるのを忘れないでください。current が最新の安定版リリース
  からかけはなれていくと互換性のコードが加えられますが、
  このオプションが設定されている時だけ有効になります。
  少なくとも、この互換性のためのコードは、新しいカーネルをブートして、
  <code>build.sh</code> による構築が終了するまでは必要です。
  <p>

 <li>
  NetBSD-currentを使っている人は<b><a
  href="../../MailingLists/#current-users">current-users</a></b>
  メーリングリストに参加することを強く薦めます。<b><a
  href="../../MailingLists/#source-changes">source-changes</a></b>
  を読むのも興味深いでしょう。
</ul>
<p>

<a name="star">*</a>: もし新たなシステムコールが追加されていないことが
確かでなければ、とりあえずこうしてください。それがより安全です。

<ENTRY>build-targets Makefileのいろいろなターゲットは?

'build.sh' スクリプト (ソースディレクトリーの最上層にあります)
を使った新しい toolchain の使い方に関する詳しいドキュメンテーションについては、
'<code>./build.sh -h</code>' を実行するとともに、
<a href="ftp://ftp.NetBSD.org/pub/NetBSD/NetBSD-current/src/BUILDING">
/usr/src/BUILDING</a> を参照してください。
<p>
<b>注意:</b>
<em>
toolchain が新しくなったことにより、 'make build' という使い方はもはや無用のものになりました。
使ってはいけません。
</em>
<p>
<code>build.sh</code> を使って初めてシステムの構築をする場合には、
この先でコンパイルに使うツール一式も構築されます。
その後に作られるものはすべて、すでに構築済のツールを再利用することになるので、
所要時間は初回より短くなります。
<p>
もちろん、 <code>./build.sh build</code> が成功しない限り
<code>./build.sh install=/</code> を実行してはいけません。
さもないと、動作しないシステムをもとに作業が進められてしまう可能性があります。

<ENTRY>using-anoncvs-pserver anoncvs の使用
 
<em>
ここでは暗号化されていない anoncvs 接続について説明します。
暗号化プロトコルを使いたい場合は、
<a href="#using-anoncvs-over-ssh">後述の項目</a>を参照してください。
</em>
<ol>
<li><PKGSRC>devel/cvs をインストールします。
<em>もし NetBSD が 2000-09-04 以降の -current のソースから構築されていれば、
cvs はすでにインストールされています。</em> 注意: cvs のバージョンによっては
(特に、バージョン 1.11.5 では)、 '-z' フラグ使用時にエラーを起こすことがあります。後述の<a
href="#hints">useful hints</a>を参照してください。
<p>

<li>環境変数 CVSROOT を お好きな <a href="../../mirrors/#anoncvs">anoncvs
サーバー</a>を指すように設定します。
<ul>
    <li>csh(1) または <PKGSRC>shells/tcsh ユーザーの方:
<blockquote><pre><code>% setenv CVSROOT :pserver:anoncvs@anoncvs.NetBSD.org:/cvsroot
</code></pre></blockquote>
    <li>sh(1), ksh(1), または <PKGSRC>shells/bash2 ユーザーの方:<br>
<blockquote><pre><code>$ CVSROOT=:pserver:anoncvs@anoncvs.NetBSD.org:/cvsroot; export CVSROOT
</code></pre></blockquote>
    </li><br>
</ul>
<li>
<blockquote><pre><code>$ cd /usr
$ cvs login
</code></pre></blockquote>
(パスワードとして "anoncvs" を使用してください)<br>
</ol>
<p>
最初の checkout の際にはディレクトリーに対する書き込み権限が必要です。
その後、ソースツリーの所有者を他のユーザーに変更できます。一つの方法は
最初のチェックアウトは root で行ない、その後の使用のために
ソースツリー全体を他のユーザーの所有に変更することです。

<ENTRY>using-anoncvs-over-ssh anoncvs over ssh の利用

<a href="#using-anoncvs-pserver">using anoncvs</a>で説明した手順は、

<a href="#using-anoncvs">anoncvs の利用</a>で説明した方法は、取り寄せた
ソースが正しいものであることを保証するため、 ssh 上でも使うことができます。
ただし、
そうすることで anoncvs サーバーにはかなりのオーバーヘッドがかかります。
<p>
<a href="../../mirrors/#anoncvs">ミラー一覧</a>に載っている
ssh 接続に対応したサーバーでは、各項目ごとに、必要な情報を列挙しています。
<p>
通常、 cvsroot の冒頭の ':pserver:' を削除し、
お使いのシェルに応じた方法で、変数 CVS_RSH を
'ssh' に設定します。

<ENTRY>using-anoncvs anoncvs を用いた NetBSD-current の追跡

<h4>セットアップ</h4>

<ol>
<li>カーネルのみをチェックアウトする<br>
<blockquote><pre><code>$ cd /usr
$ cvs checkout -P src/sys
</code></pre></blockquote>
</ol>
<p>
これにより、カーネルのソースは <tt>/usr/src/sys</tt> に用意されます。
<a href="../kernel/#how_to_build_a_kernel">カーネルの作り方</a>に
関する情報は別のページで提供されています。

<li>ソースツリー全体をチェックアウトする(カーネルも含みます)<br>
<blockquote><pre><code>$ cd /usr
$ cvs checkout -P src
</code></pre></blockquote>
</ol>
これにより、NetBSD ソースの全体が /usr/src に用意されます。
<p>注意: 最初に「ソース全体」のチェックアウトをするときは、
<a href="#downloading">tarball を FTP で取得</a>してローカルで展開するほうが、
たいてい速くなります。こちらのほうがネットワークリンクをもっともよく使うからです。
そうした後に cvs checkout/update を使うと、変更部分のみを送ることになり、
送られるバイト数が最小限になります。

<li>パーミッションの修正<br>
    もしソースツリーを root 以外のユーザーの所有にしたければ
    (root で)次のようにして下さい。
<blockquote><pre><code># chown -R <em>user</em> /usr/src
</code></pre></blockquote>
</ol>

<h4>ソースの更新</h4>

<ol>
<li>カーネルソースのみを更新する<br>
<blockquote><pre><code>$ cd /usr/src/sys
$ cvs update -dP
</code></pre></blockquote><br>
<li>ソースツリー全体を更新する<br>
<blockquote><pre><code>$ cd /usr/src
$ cvs update -dP
</code></pre></blockquote>
</ol>
<p>
<b>注意:</b> <tt>cvs checkout -d dir src</tt> (あるいは、他の src*
モジュールに対する同様のコマンド) を実行しても動作しません。
"existing repository ... does not match ...; ignoring module _gnusrc-cmp"
等のエラーメッセージが出ます。回避するには、 <tt>-d</tt> オプションを外して
cvs がデフォルトのディレクトリーを作るようにします。

<h4>特定の日付のソースをチェックアウトするには次のようにして下さい</h4>
<blockquote><pre><code>$ cvs checkout -D 20020501-UTC src
</code></pre></blockquote>

<h4>特定の枝のソースをチェックアウトするには</h4>
<blockquote><pre><code>$ cvs checkout -rnetbsd-1-6 src
</code></pre></blockquote>
CVS リポジトリーに含まれる各ブランチの説明については、
<CURRENTSRC>src/doc/BRANCHES
を参照してください。

<h4><a name="hints">有用なヒント</a></h4>
<p>
<ul>
<li>ツリー内のあるブランチをチェックアウトしたい場合に、
このブランチ用に新しいディレクトリーを作って、既存のディレクトリーが上書きされないように
慎重を期したい方もいるでしょう:

<blockquote><pre><code>$ cd /parent/dir/to/checkout/into
$ mkdir NewName-temp
$ cd NewName-temp
$ cvs checkout ... src
$ mv src ../NewName
$ cd ..
$ rmdir NewName-temp
</code></pre></blockquote>
</li>
<li>
cvs による更新が正しく実行できるようにするためには objdirs を
使用する必要があります。もし、cvs から
<blockquote><pre><code>   cvs [update aborted]: could not chdir to gnu/usr.bin/gdb/gdb: Not a directory
</code></pre></blockquote>
のようなエラーメッセージを受けたならば、 <code>make cleandir</code> を
実行して、もう一度試して下さい。cvs による更新の後、
<code>make obj</code> を実行するのを忘れないように。
</li>
<li>
使用している回線が非常に細い場合、コマンドラインでコマンドの<em>前に</em>
<code>-z5</code> (あるいは 1 から 9の間の他の数字)をつけると良いかも知れません
(例 "<code>cvs -z5 update -dP</code>"); こうすると、
全てのデータは圧縮されて転送されます。これは、cvs サーバーにとっては、余分な
負荷を与えることを心に止めておいてください!
<p>
注意: cvs のバージョンによっては (特に、バージョン 1.11.5 では)、 '-z'
フラグ使用時にエラーを起こすことがあります。エラーが起きた場合は、 cvs
をアップグレードするか、 '-z' フラグを外して圧縮させないようにしてください。
<p>

特定のコマンドに対するスイッチはホームディレクトリーの .cvsrc に
記述しておけば、自動的に使われます。.cvsrc ファイルの例を
掲げておきます。

<blockquote><pre><code>   cvs -q -z5
   update -dP
   checkout -P
   diff -u
</code></pre></blockquote>
</li>
</ul>

<h4>ソースからの NetBSD の構築</h4>

<I>(すでに、最新の NetBSD バイナリースナップショットと /usr/src に
ソースがインストールされていると仮定します; また、 BSDOBJDIR は
/usr/obj であると仮定します。):</I><p>

はじめてユーザーランドを構築する場合:<p>
<blockquote><pre><code># mkdir /usr/obj
# cd /usr/src</code><br>
<code># ./build.sh -O /usr/obj -D /usr/NetBSD-new-build -T /usr/tools build
# ./build.sh -O /usr/obj -D /usr/NetBSD-new-build -T /usr/tools install=/
</code></pre></blockquote>
<br>

build.sh を使って初めてシステムの構築をする場合には、
この先でコンパイルに使うツール一式も構築されます。
その後に作られるものはすべて、すでに構築済のツールを再利用することになるので、
所要時間は初回より短くなります。
<br>
もちろん、 <tt>./build.sh build</tt> が成功しない限り
<tt>./build.sh install=/</tt> を実行してはいけません。
さもないと、動作しないシステムをもとに作業が進められてしまう可能性があります。
<p>

CVS update の後、ユーザーランドのバイナリーを更新する場合:

<blockquote><pre><code># cd /usr/src
# ./build.sh -D /usr/NetBSD-new-build -O /usr/obj -T /usr/tools -u build
# ./build.sh -D /usr/NetBSD-new-build -O /usr/obj -T /usr/tools -u install=/
</code></pre></blockquote>

これらによって、新しいバイナリーが実行されたシステムにインストールされます。
新しいバイナリーが全て有効になるようにリブートしてください。
<p>
あなたがシステムを頻繁に更新しており、動作中のシステムを直接更新したい場合は、
<em>熟練者</em>モードを使って DESTDIR=/ で構築することができます。
たとえば次のようにします:

<blockquote><pre><code># ./build.sh -E -O /usr/obj -T /usr/tools -u build
</code></pre></blockquote>

これは<strong>熟練</strong>ユーザー専用の方法であり、これを実行するだけで
システムが何も構築できない状態になってしまう可能性があることに注意してください。
構築が最後まで成功すると<strong>確信できる</strong>
場合にのみ、この方法を使ってください。

<ENTRY>using-sup-into-cvs SUP と CVS の組合せによる NetBSD-current の追跡

    <h4>概要</h4>

    <p>currentは次の方法により追跡できます。基準となるソースのコピーを、
       標準的にはほぼ週に一回SUPを使い最新の状態に維持します。そして、
       この基準となるソースツリーを、ローカルのCVSリポジトリーにインポー
       トします。そして、リポジトリーのコピーをチェックアウトし、それ
       からcurrentを作成します。

    <p>このアプローチには3つの主要な理由があります。
    <p>
    <ol>
      <li>いつどのようにcurrentが更新されたか追跡するため。</li>
      <li>ローカルの変更をほとんど自動的に更新されたcurrentソースにマー
        ジできるようにするため。</li>
      <li>構築するときの問題に備えて、いつもまったく変更していない
	NetBSD-currentのソースツリーがあることを保証するため。</li>
    </ol>
    
    <p>このアプローチの短所は、3つの独立のソースツリーのために、実際の
      currentの構築に必要な空きを含めないで、およそ150MBのディスクスペー 
      スが必要なところです。

    <h4>必要なもの</h4>
    <ul>
      <li>CVS 1.9かそれ以降(もし、あなたが 2000-09-04 以降の -current 
	を使用していればすでにインストールされていますし、
	そうでない場合は pkgsrcか、ソースから構築のどちらでも構いません)。
	マージが上手なのでCVS 1.10かそれ以降が望ましいでしょう。</li>
      <li>SUP</li>
      <li>Perl 5(任意)附属スクリプトのため</li>
    </ul>
    <h4>詳説</h4>
    <p>currentの追跡と構築は、6つの段階からなります:
    <p>
    <ol>
      <li>マスターソースツリーにSUPでソースを更新します。</li>
      <li>SUPしたファイルをCVSにインポートし、ソースの作業用コピーを更
        新します。</li>
      <li>作業用ソースとSUPしたソースとをマージします。</li>
      <li>currentを構築してインストールします。</li>
      <li>構築に成功したソースにタグをつけます。</li> 
    </ol>
    <h3>ソースのSUP</h3>
    <p>ソースは、どのNetBSD SUPサーバーからもSUP可能です。またSUPの出
      力は後の参照のためにファイルに保存するべきです。

    <h3>ソースのインポートとマージ</h3>
    <p>ソースのインポートは次のように行ないます:
<blockquote><pre><code>$ cvs -d /misc/cvsrep import -I ! -I CVS netbsd netbsd current-<i>date</i>
</code></pre></blockquote>
    <p><i>date</i>は追跡のためにSUP時の日付と置き換えます。
      <code>-I ! -I CVS</code> オプションは、
      ソースツリー中の 'CVS' ディレクトリーを除く全てのファイルが
      無視されないことを保証します。これはNetBSDのソースファイルに、通
      常CVSにより無視される拡張子のものがいくつかあるからです。もしロー
      カルのパッチと衝突がある場合、importコマンドはそれらを出力し、衝
      突をマージするためのコマンドを次のように出力します:<br>
<blockquote><pre><code>$ cvs checkout -jnetbsd:yesterday -jnetbsd netbsd
</code></pre></blockquote>
    <p>このマージコマンドは、インポートされたNetBSDソースを正確にマー
      ジするためのものですが、SUPにより削除されたファイルは、ローカル
      に反映されません。これを行なうためのマージコマンドはこうなるでしょ
      う:<br>
<blockquote><pre><code>$ cvs update -j<i>previous import tag</i> -j current-<i>date</i>
</code></pre></blockquote>
    <p><i>previous import tag</i>は前回のCVSインポートで使用したタグ名
      と置き換えます。<i>date</i>は、今マージしたばかりのcurrentのイン
      ポートに使用したタグ名を利用できるようにするために、現在の日付と
      置き換えます。
    <p>importコマンドにより表示される衝突は、衝突の可能性のあるもので
      す。これらは、通常updateコマンドによりマージされますが、いくつか
      の場合、実際に衝突を引き起こします。この場合、衝突行を手動でマー
      ジすることが必要です。実際に衝突がある場合、cvs update時に、
      <code>C</code>に続きファイルネームが表示されます。
    <p>手作業による衝突のマージは単純作業ではありませんが、多くの場合、
      ファイルへ行なったローカルの変更を削除し、元のNetBSDソースコード
      に似せてやることで解決します。
    <p>CVSは衝突を次のように表します:
<pre>
&lt;&lt;&lt;&lt;&lt;&lt;
  <i>ローカルファイルのコード</i>
======
  <i>インポートしたファイルのコード</i>
&gt;&gt;&gt;&gt;&gt;&gt; <i>新たにインポートされるリビジョンのローカルリビジョン番号</i>
</pre>

    <p>もしimportコマンドが何の衝突を表示しない場合でも、チェックアウ
      トしたツリーのコピーは衝突した場合と同じ方法で更新できます。
    <p>updateとcheckoutコマンドはすべて、チェックアウトしたソースのディ
      レクトリーで行なってください。私のシステムでは、これは
      <code>/usr/src/netbsd</code>です。
    <p>もし、これが最初のインポートならば、チェックアウトしたソースは
      ないでしょう。'<code>/usr/src/netbsd</code>'にソースツリーを作り
      たいと仮定すると、次のコマンドでソースをチェックアウトします。マー
      ジ作業は必要ありません。
<blockquote><pre><code>$ cd /usr/src
$ cvs -d /misc/cvsrep checkout netbsd
</code></pre></blockquote>
    <h3>currentの構築</h3>
    <ol>
    <li>configure の後、<a href="../kernel/#how_to_build_a_kernel">
	カーネルの構築</a>を行ない、できた新しいカーネルでリブートします。
    <li>-current のソースツリーのベースディレクトリーに移動し、
	<code>./build.sh -T /usr/tools -O /usr/obj </code>.
       とタイプします。
    <li>必要ならば、/etc の中のファイルに対する変更を merge します。
    </ol>

    <h3>構築に成功したものへのタグ付け</h3>
    <p> もし、<a href="#building">構築</a>がうまくいって
      動作するバイナリーセットを作成できたのならば、
      動作するソースにタグ付けすることで使いやすくできます。
      これは、万一なにかの原因で構築できないcurrentツリーになっても、
      ひとつのCVSコマンドで、構築できるツリーに巻き戻すことを可能にします。
      タグ付けは次のコマンドで行えます:
<blockquote><pre><code>$ cvs tag successful-build-<i>build date</i>
</code></pre></blockquote>
    <h4>註</h4>
    <ul>
      <li>もし、ファイル中の<b>$Net</b><b>BSD$</b>マーカーを認識する
        NetBSDカスタムバージョンのCVSを使用しない場
        合、ファイルのNetBSDリビジョン番号を、構築時に問題が起きた場合
        に参照の目的に使用することができます。</li>
      <li>上記のSUP/インポート/マージの作業は、まったく簡単に自動化で
        きます。以下のPerlスクリプトがこの作業を自動的に行ないます。
<blockquote><pre><code>#!/usr/pkg/bin/perl
#
# NetBSD-currentをSUPしてそれをCVSに取り込み、手元の変更とマージする
# スクリプト
#
# 原註:
# このスクリプトはエラー処理をしていないので、対話的でない用途には向い
# ていない。
#
# このスクリプトはcvs-1.10.1とcvs-1.9.18でのみテストされている。
#
$SRCROOT="/usr/src/netbsd";
$IMPORTROOT="/misc/import";
$CVSROOT="/misc/cvsrep";
# supを実行してその標準出力をperlに取り込む
system "/usr/sbin/sup -zsv" ; # ここは最新のシステム以外では変更する
                              # 必要がある

# 新しいファイルをCVSに取り込む

chdir $IMPORTROOT or die "Could not cd to $IMPORTROOT\n";

($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime;
$date = localtime;
$shortdate = sprintf "%02d%02d%04d",$mday,$mon+1,1900+$year;
system "/usr/local/bin/cvs -d$CVSROOT import -I ! -m\"SUP Import $date\" netbsd netbsd current-$shortdate ";

# 作業ディレクトリーを手元のNetBSDソースツリーにする
chdir $SRCROOT or die "Could not change to $SRCROOT directory\n";

# 取り込みを始める
$lastimport = `cat /usr/src/netbsd/.tag`; # `はバッククォート
$lastimport =~ s/\n//; # 文字列の終りの改行をすべて取り去る
system "/usr/local/bin/cvs update -j $lastimport  -j
current-$shortdate ";
# tag保存ファイルに最新のファイルを書き込む
open TAG,"&gt;$SRCROOT/.tag" or die "Could not open new tag file";
 print TAG "current-$shortdate";
close TAG;
</code></pre></blockquote>
    <p>このスクリプトは作者がもっともよく使っているスクリプティングツー
          ルであるという理由からPerlでかかれていますが、同じことをする
          shellスクリプトを書くのはとても簡単でしょう。</li>
      <li>CVSを用いてcurrentを追跡するテクニックについてはNetBSDの
        current-usersメーリングリストで何度か議論されています。他のテ 
        クニックについてはNetBSDメーリングリストを検索してみてください。</li>
    </ul>
    <p>
    何かコメントや提案があれば、この部分を担当しているMike Pumford <a
    href="mailto:mpumford@black-star.demon.co.uk">
    mpumford@black-star.demon.co.uk</a>(訳註:英語で)、または<a
    href="mailto:www@jp.NetBSD.org">www@jp.NetBSD.org</a>までメールし
    てください。

<ENTRY>getrepos リポジトリー全体の入手

以上で説明した方法では、あなたが独自に行なった変更を自分用のリポジトリーに
保存することができます。これは、あなたが NetBSD をもとにしたソフトウェアの
開発をしている場合には便利でしょう。あなたが自分の CVS リポジトリーの
保守をしているわけでなく、単に NetBSD の CVS リポジトリーをミラーしたい
だけならば、それ用の方法が四つあります。
<p>

以下に簡単に説明するいずれの方法でも、 NetBSD CVS リポジトリーのコピー
(つまり、チェックアウトされたファイルでは*なく*、 RCS の ,v ファイル)
を取得できます。その後は、自分の anoncvs サーバーをセットアップしたり、
ローカルハードディスクにチェックアウトしたりできます。また、
リポジトリーに記録されている履歴にすぐにアクセスするのにも便利です。
<p>

リポジトリー全体を取得する方法は、次のとおりです:

<dl>
<dt> sup: 
<dd> すでに sup を使って NetBSD のソースの一部をミラーしている場合は、
     sup の設定ファイルに下記の行を追加します:
<blockquote><pre><code>anoncvs release=all  host=sup.NetBSD.org hostbase=/ftp/pub \
base=/usr prefix=/usr backup use-rel-suffix compress
</code></pre></blockquote>
     それから、 "sup /path/to/supfile anoncvs" を実行してファイルを取得します。
     <p>

     sup ファイルの例が <tt>/usr/share/examples/supfiles</tt> にいくつかあります。
     また、 <a href="../../mirrors/#sup">SUP ミラーのリスト</a> で、
     あなたの近所のサーバーを探すようにしてください。

<dt> ftp:
<dd> お好みのミラープログラム (たとえば <PKGSRC>net/mirror) をセットアップし、
     ftp://ftp.NetBSD.org/pub/NetBSD-cvs/main/ からファイルを取得します。
     <p>

     <a href="../../mirrors/#ftp">FTP ミラーのリスト</a>をご覧ください !
<dt> rsync:
<dd> rsync は rsync サーバーに大きな負荷をかけることに注意してください。
     このため、同時に利用できる rsync ユーザー数に制限があります。それでもなお
     rsync したい場合、リポジトリー取得のコマンドは次のとおりです:
<blockquote><pre><code>rsync -v -a rsync://rsync.NetBSD.org/anoncvs/
</code></pre></blockquote>

     <a href="../../mirrors/#rsync">rsync ミラーのリスト</a>をご覧ください !
<dt> cvsup:
<dd> M3 コンパイラーが移植されていないため、現在、 CVSup はすべての NetBSD
    アーキテクチャーで使えるわけではありません。 i386 では、 <PKGSRC>devel/cvsup
     パッケージと下記の設定ファイルを使って、 cvsup.de.NetBSD.org から
     リポジトリーをミラーできます:
<blockquote><pre><code>*default host=cvsup.de.NetBSD.org
*default base=/usr
*default prefix=/local/NetBSD-cvs
*default release=cvs
*default delete use-rel-suffix
*default compress

netbsd
</code></pre></blockquote>

     <a href="../../mirrors/#cvsup">CVSup ミラーのリスト</a>をご覧ください!
</dl>

<ENTRY>error エラーが出た場合は ?

スナップショットや以前の -current をもとに -current の構築をしようとして
うまくいかなくても、慌てないでください。次の手順を踏んでみてください:
<ol>
<li>構築をしようとしているリリースの <a
    href="http://cvsweb.NetBSD.org/bsdweb.cgi/src/UPDATING">UPDATING</a>
    ファイルを読みます。
<li>手がかりを得るために <a
    href="http://mail-index.NetBSD.org/current-users/">current-users
    アーカイブ</a>を読みます。
<li>再度アップデートします。関連あるファイル群のコミットの合間に
    リポジトリーを受け取っていた可能性もありますし、あるいは問題が修正
    されているかもしれません。
<li>どれも失敗した場合、 current-users にメールを送って、
    問題を説明してください。これには、日付、時刻、 -current のソースの
    入手方法と、あなたが加えた変更点をすべて含めてください。それから、
    出たエラーメッセージを含む<b>短い</b>スクリプトを入れてください。
    おそらく、誰かがすぐに問題を解決してくれるでしょう。
</ol>

<ENTRY>etcupdate etcupdate を使った設定ファイルと起動ファイルの更新

<h4>概観</h4>

etcupdate は、オペレーティングシステムのアップグレード後の、 /dev、 /etc、
/root 以下の新しい設定ファイルや起動ファイル (etc.tgz
配布セットに含まれるファイル) の比較・マージ・インストールを
手伝ってくれるスクリプトです。オペレーティングシステムのアップグレードは、
ソースからのコンパイル、バイナリー配布物の展開の、いずれの方法でも
おこなうことができます。

<h4>etcupdate のインストール</h4>

<ol>
<li>etcupdate の最新バージョンを入手します
<em>NetBSD が -current ソースから構築されたものの場合は、
etcupdate はすでにインストールされています。</em>
<blockquote><pre><code># cd /usr/pkgsrc/sysutils
# cvs update -dP etcupdate
</code></pre></blockquote>

<li>pkgsrc からインストールします
<blockquote><pre><code># cd /usr/pkgsrc/sysutils/etcupdate
# make install clean
</code></pre></blockquote>
</ol>

<h4>ソースファイルに etcupdate を使う</h4>

ソースが /usr/src 以下に置かれている場合は、
下記のコマンドで十分なはずです:

<blockquote><pre><code># etcupdate
</code></pre></blockquote>

しかし、 NetBSD のソースがこれ以外の場所、たとえば /home/jdoe/netbsd/src
にある場合はどうでしょうか? 案ずることはありません。ソースツリーの場所を
-s srcdir を使って etcupdate に教えてやれば、うまくいきます:

<blockquote><pre><code># etcupdate -s /home/jdoe/netbsd/src/etc
</code></pre></blockquote>

<h4>バイナリー配布セットに etcupdate を使う</h4>

時には、ソースが用意されていないけれども設定ファイルや起動ファイルを
更新したいときがあるでしょう。この場合の解決法は、必要な配布セット
(少なくとも etc.tgz) を展開し、 -b srcdir を使って etcupdate に
「ソースはなく公式配布セットがあるだけである」ことを伝えます。

<blockquote><pre><code># mkdir /tmp/temproot
# cd /tmp/temproot
# tar xpzf /some/where/etc.tgz
# etcupdate -b /tmp/temproot
</code></pre></blockquote>

<SECTION>特定の問題

<ENTRY>wscons wsconsにアップデートした後コンソールが使えない

以下の手順が必要です。<a
href="ftp://ftp.jp.NetBSD.org/pub/NetBSD/NetBSD-current/src/etc/">src/etc</a>
にある適切なetc.<i>port</i>ディレクトリーから最新のMAKEDEVファイルを
<tt>/dev</tt>にコピーしてシングルユーザーで起動してください。そのあと
以下をタイプします:
<blockquote><pre><code># fsck -p
# mount -vt nonfs
# cd /dev
# ./MAKEDEV wscons
</code></pre></blockquote>

<ENTRY>rebuild-nbmake build.sh が常に nbmake を最初に再構築するのは、なぜか?

たとえ、 <code>./build.sh tools</code> を実行しておき、その後に <code>-u</code>
フラグを使ったり <code>/etc/mk.conf</code> で <em>TOOLDIR</em> を指定していたとしても、
<tt>nbmake</tt> は常に <code>build.sh</code> によって再構築されます。これは正常な挙動です。
その理由は <code>./build.sh</code> 自体の中の <code>rebuildmake</code>
関数に書いてあります:
<blockquote><pre><code>        # なお、ここでは "mk.conf" に TOOLDIR が設定されていても、
        # それに従おうとは *しません* 。なぜなら、ここに設定されている make
        # 変数の展開その他のことは、 ${toolprefix}make を行なった *後に* のみ、
        # パース可能となるからです。このため、このような TOOLDIR 指定が有効となるのは、
        # ユーザーが環境変数 TOOLDIR をあらかじめ設定しているか、 build.sh に
        # -T オプションが使われたときだけです。
        #               
</code></pre></blockquote>
よって、 <tt>nbmake</tt> を再構築したくない場合は、
<code>-T tooldir</code> を build.sh へ渡すか、環境変数 <em>TOOLDIR</em>
を設定しておく必要があります。

</LIST>

<DOCLINK>

<hr>
<address>
  <small>
  (連絡先 - <a href="http://www.NetBSD.org/cgi-bin/feedback.cgi">英語</a>,
       <a href="mailto:www@jp.NetBSD.org">日本語:
       www@jp.NetBSD.org</a>)<br>
  $NetBSD: index.list,v 1.70 2004/08/28 21:31:07 daniel Exp $<br>
  <!-- based on english translation: -->
  <!-- NetBSD: index.list,v 1.70 2004/08/28 21:31:07 daniel Exp   -->
  <a href="../../Misc/disclaimer.html">Copyright &copy; 1994-2004
    The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED.</a>
  </small>
</address>

</body>
</html>
