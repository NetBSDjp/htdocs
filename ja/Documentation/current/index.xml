<?xml version="1.0"?>
<!DOCTYPE webpage
 PUBLIC "-//NetBSD//DTD Website-based NetBSD Extension//EN"
        "http://www.NetBSD.org/XML/htdocs/lang/share/xml/website-netbsd.dtd">

<webpage id="Documentation-current-index">
<config param="desc" value="Tracking NetBSD-current"/>
<config param="cvstag" value="$NetBSD: index.xml,v 1.7 2006/01/27 06:25:59 reed Exp $"/>
<config param="rcsdate" value="$Date: 2006/01/27 06:25:59 $"/>
<head>

<!-- Copyright (c) 1994-2005
	The NetBSD Foundation, Inc.  ALL RIGHTS RESERVED. -->

    <title>Tracking NetBSD-current</title>
</head>

<sect1 role="toc">

<sect2 id="faq">
<title>Frequently asked questions</title>

<sect3 id="why-track">
<title>Why track NetBSD-current?</title>
<para>
The developers of NetBSD have made the current development sources
available to the public for several reasons.  Overall, providing
NetBSD-current helps us to create a more stable, accessible system.
</para>
<para>
It makes it easier for people to become involved in the development of
NetBSD.  Distributing the current development sources allows a greater
number of people to see where the system is going, and to become
involved with new features as they are implemented.
</para>
<para>
It also makes changes from users easier to integrate.
If users make changes against
the current development sources, then virtually no integration is
needed to get them into the master source tree. 
</para>
<para>
It also allows wider testing of the software as it is developed.  Users
of NetBSD-current are encouraged to send in <ulink
url="../../Misc/send-pr.html">bug reports</ulink> about the current sources,
and that helps find and fix bugs.  Because people are testing the
software soon after it's written, more bugs can be found and
eliminated.
</para>
</sect3>

<sect3 id="installing">
<title>Installing a current snapshot</title>
<para>
To quickly begin using current,
start with a snapshot generated by release engineering.
The current status of each platform can be seen at
<ulink url="http://releng.NetBSD.org/cgi-bin/builds.cgi">
NetBSD Autobuild
</ulink>
and the corresponding releases found in
<ulink url="ftp://ftp.NetBSD.org/pub/NetBSD-daily/HEAD/">
ftp://ftp.NetBSD.org/pub/NetBSD-daily/HEAD/
</ulink>
by date and platform.
</para>
<para>
<orderedlist>
<listitem> Hunt down to the desired <code>binary/sets</code> directory,
and <code><emphasis role="bold">mget *.tgz</emphasis></code> files
into your favorite local administrative directory
(for example, <emphasis><code>$HOME/current</code></emphasis>);
when limited by disk space and/or time,
only kern-GENERIC, etc, base, and comp (if you want a compiler) are
essential.</listitem>
<listitem> Extract the desired <code>/etc</code> and kernel:
<programlisting>
    $ su
    $ cd /root
    $ tar -zxpf ~/etc.tgz
    $ tar -zxpf ~/kern-GENERIC.tgz
    $ ln -fh /netbsd /netbsd.old
    $ mv netbsd /netbsd
    $ shutdown -r now
</programlisting>
</listitem>
<listitem> <ulink url="#etcupdate">Update</ulink> <code>/etc</code>
before replacing basic utilities:
<programlisting>
    $ su
    $ cd /root/etc
    $ ./postinstall -s /root check
</programlisting>
Now follow any instructions to fix your system files/config.
</listitem>
<listitem> Extract the matching <code>base</code>,
and any other desirable feature sets:
<programlisting>
    $ cd /
    $ tar -zxpf ~/comp.tgz
    $ ...
    $ tar -zxpf ~/base.tgz
    $ /usr/sbin/etcupdate -b /root
    $ shutdown -r now
</programlisting>
</listitem>
</orderedlist>
</para>
<para>
At this point,
you are relatively current
and ready to build your own current source.
</para>
</sect3>

<sect3 id="downloading">
<title>Downloading current source</title>
<para>

Traditionally,
the system source files are kept at <code>/usr/src</code>,
but this generally requires root privileges.
The current <code><emphasis role="bold">build.sh</emphasis></code> process can run entirely unprivileged,
although installation still requires root priviledges.
Whenever examples in this document assume <code>/usr/src</code>,
you can substitute another location
(such as <emphasis><code>$HOME/current</code></emphasis>).
</para>
<para>
<orderedlist>
<listitem> Select a location for the source tree:
<programlisting>
    $ cd /usr
    $ su
</programlisting>
</listitem>
<listitem> Download the -current source from a
<ulink url="../../mirrors/">NetBSD mirror site</ulink>
near to you:
<itemizedlist>
<listitem> via ftp from <ulink
url="ftp://ftp.NetBSD.org/pub/NetBSD/NetBSD-current/tar_files/src/">
/pub/NetBSD/NetBSD-current/tar_files/src/</ulink>,
or</listitem>
<listitem> using <ulink url="ftp://ftp.NetBSD.org/pub/NetBSD/README.sup">sup</ulink>.
</listitem>
</itemizedlist>
<para>
These files represent a snapshot of the source tree.
For the most up-to-date files
using <ulink
url="#using-anoncvs">anoncvs</ulink>,
<programlisting>
    $ cd /usr/src
    $ cvs -q -d $CVSROOT update -dP
</programlisting>
</para>
<para>
The <code>-d $CVSROOT</code> is only needed on the first update,
to populate the CVS tags with your selected mirror.
Remember to always use the <code>-P</code> flag or add it to your .cvsrc file.
</para>
<para>
If you wish to track local changes to the NetBSD source you might want
to setup a local CVS tree, and then <ulink url="#using-sup-into-cvs">import the
sup changes</ulink>.
</para>
</listitem>

<listitem>
Fix permissions<html:br/>
If you wish for the source tree to be maintained by a non-root user
that is a member of the (traditional) wsrc group,
do (as root):
<programlisting>
$ chown -R <emphasis>user</emphasis>:wsrc /usr/src
$ chmod -R u=rwX,g=rwX,o=rX /usr/src</programlisting>
</listitem>

</orderedlist>
</para>
</sect3>

<sect3 id="building">
<title>Building a release from source</title>
<para>

<emphasis>Please remember to check <ulink
url="http://cvsweb.NetBSD.org/bsdweb.cgi/src/BUILDING">src/BUILDING</ulink>
for the latest changes.</emphasis>
</para>
<para>
Traditionally,
the system object files were kept at <code>/usr/obj</code>,
but this generally requires root privileges.
Alternatively,
keeping the object files on another filesystem
can significantly speed compilation time.
Whenever examples in this document assume <code>/usr/src</code>,
you can substitute another location
(such as <emphasis><code>$HOME/current</code></emphasis>).
<orderedlist>
<listitem> Select a location for the object tree,
where there is enough space for a full install,
plus a set of release tarfiles:
<programlisting>
    $ cd /usr/src
    $ su
    # mkdir ../tools
    # mkdir ../obj
</programlisting>
</listitem>
<listitem> From the root of the source tree:
<programlisting>
    $ cd /usr/src
    $ ./build.sh -O ../obj -T ../tools -u -U release
</programlisting>
</listitem>
</orderedlist>
</para>
<para>
In this example,
the <code>-u</code> option indicates that a <code>make clean</code>
operation should not be run before starting the build. This is useful when
doing an update from a previous build and/or a fresh build.
</para>
<para>
The <code>-U</code> option allows the entire build by a non-root user.
</para>
<para>
When completed,
you should have everything you need to install
in a directory that <code>build.sh</code> selects (and will display),
including install media and notes.
</para>
<para>
If you wish to
<ulink url="../../guide/en/chap-build.html">cross compile</ulink>
for a different architecture,
include '<code>-m MACHINE -a ARCH</code>' when running build.sh.
</para>
<para>
For more details,
run '<code>./build.sh -h</code>',
and see <ulink url="ftp://ftp.NetBSD.org/pub/NetBSD/NetBSD-current/src/BUILDING">
/usr/src/BUILDING</ulink>.
</para>
</sect3>

<sect3 id="updating">
<title>Updating an existing system</title>
<para>

<emphasis>Please remember to check <ulink
url="http://cvsweb.NetBSD.org/bsdweb.cgi/src/UPDATING">src/UPDATING</ulink>
for the latest changes.</emphasis>
</para>
<para>
<orderedlist>
<listitem> From the root of the source tree:
<programlisting>$ cd /usr/src</programlisting>
</listitem>
<listitem>Build the toolchain:
<programlisting>$ ./build.sh -O ../obj -T ../tools -U -u tools</programlisting>
</listitem>
<listitem>Build the distribution:
    <programlisting>$ ./build.sh  -O ../obj -T ../tools -U -u distribution</programlisting>
</listitem>
<listitem>Build the kernel:
    <programlisting>$ ./build.sh  -O ../obj -T ../tools -U -u kernel=GENERIC</programlisting>
</listitem>
<listitem>Install the kernel:
<programlisting>
    $ cd ../obj/sys/arch/&lt;ARCH&gt;/compile/GENERIC
    $ su
    # mv /netbsd /netbsd.old
    # cp netbsd /netbsd
</programlisting>
</listitem>
<listitem>Reboot into the new kernel:
    <programlisting># shutdown -r now</programlisting>
</listitem>
<listitem>Install the new userland:
<programlisting>
    $ cd /usr/src
    $ su
    # ./build.sh -O ../obj -T ../tools -U install=/
</programlisting>
</listitem>
<listitem>Follow the instruction in the output for fixing obsolete files, for example:
<programlisting>
    # /usr/src/usr.sbin/postinstall -s /usr/src -d // fix defaults mtree obsolete
</programlisting>
</listitem>
<listitem><ulink url="#etcupdate">Update</ulink> /etc:
<programlisting># /usr/sbin/etcupdate -s /usr/src/etc</programlisting>
</listitem>
<listitem>Optionally reboot to ensure all running services are using the new binaries:
    <programlisting># shutdown -r now</programlisting>
</listitem>
</orderedlist>
</para>
<para>
In this example,
the <code>-u</code> option indicates an update process,
and the <code>-U</code> option allows the entire build by a non-root user
followed with an install by root.
</para>
<para>
The build order (tools, distribution, kernel) is chosen to optimize the time
for updating the source whenever problems occur.
To ensure consistency,
the process should be restarted from the beginning in the case of errors/cvs
updates.
</para>
<para>
For more details,
see <ulink url="ftp://ftp.NetBSD.org/pub/NetBSD/NetBSD-current/src/UPDATING">
/usr/src/UPDATING</ulink>.
</para>
</sect3>

<sect3 id="what-to-do">
<title>Things you need to remember</title>

<itemizedlist>
 <listitem>
  <para>
  When upgrading to a more recent version of -current you should
  <emphasis>always</emphasis> compile and boot a new kernel before installing any
  new libs (<ulink url="#star">*</ulink>). In general the best approach is to
  try the new kernel before anything else, and if you hit any problems see
  the entry in the <ulink
  url="../kernel/#problems_compiling_a_current_kernel">
  Kernel FAQ</ulink>.
  </para>
  <para>
  Once the kernel is running, you should have a look at the 
  <ulink url="ftp://ftp.NetBSD.org/pub/NetBSD/NetBSD-current/src/BUILDING">BUILDING</ulink>.

  file at the base of the source tree, and use the build.sh script
  to build a new userland.
  </para>
 </listitem>
 <listitem>
  When compiling a -current kernel, always remember to include the
  COMPAT_&lt;lastrelease&gt; option (e.g., COMPAT_16).  As current
  diverges from the last stable release, compatibility code will be
  added, but it will only be enabled if this option is present.  At a
  bare minimum, you will need this compatibility code for the time
  between booting the new kernel and finishing your build via 
  <code>build.sh</code>
 </listitem>
 <listitem>
  People using NetBSD-current are strongly encouraged to subscribe to
  the <emphasis role="bold"><ulink
  url="../../MailingLists/#current-users">current-users</ulink></emphasis>
  mailing list.  The <emphasis role="bold"><ulink
  url="../../MailingLists/#source-changes">source-changes</ulink></emphasis>
  mailing list is also of interest.
  </listitem>
</itemizedlist>
<para>

<ulink name="star">*</ulink>: Unless you are certain there have been no new
system calls added, but do it anyway; it's safer.
</para>
</sect3>

<sect3 id="build-targets">
<title>What are the various Makefile targets?</title>
<para>

For further documentation concerning usage of the new toolchain
through the script 'build.sh' (in the toplevel source directory),
run '<code>./build.sh -h</code>',
and see <ulink url="ftp://ftp.NetBSD.org/pub/NetBSD/NetBSD-current/src/BUILDING">
/usr/src/BUILDING</ulink>.
</para>
<para>
<emphasis role="bold">WARNING:</emphasis>
<emphasis>
The usage of 'make build' has been deprecated by the updated toolchain,
and is strongly discouraged.
</emphasis>
</para>
<para>
When you build your system for the first time using <code>build.sh</code>,
a set of tools for future use of compilations will be built, too.
Any subsequent compilation should reuse the already compiled tools,
and thus take less time.
</para>
<para>
Of course, don't invoke <code>./build.sh install=/</code>
unless the <code>./build.sh build</code> has succeeded previously or it's
entirely possible to end up with a non-working system.
</para>
</sect3>

<sect3 id="using-anoncvs-pserver">
<title>Using anoncvs</title>
<para>
 
<emphasis>
These instructions cover unencrypted anoncvs connections.
If you wish to use encryption protocols,
see <ulink url="#using-anoncvs-over-ssh">below</ulink>.
</emphasis>
<orderedlist>
<listitem>Install <filename role="pkg">devel/cvs</filename>.  
<emphasis>If NetBSD is built from -current sources
past 2000-09-04, cvs is already installed.</emphasis>
</listitem>
<listitem>Set the CVSROOT environment variable to point to the
<ulink url="../../mirrors/#anoncvs">anoncvs server</ulink> of your choice:
<itemizedlist>
    <listitem>For &man.csh.1; or <filename 
    role="pkg">shells/tcsh</filename> users:
<programlisting># setenv CVSROOT :pserver:anoncvs@anoncvs.NetBSD.org:/cvsroot</programlisting>
</listitem>
    <listitem>For &man.sh.1;, &man.ksh.1;, or <filename 
    role="pkg">shells/bash2</filename> users:
<programlisting>$ CVSROOT=:pserver:anoncvs@anoncvs.NetBSD.org:/cvsroot; export CVSROOT</programlisting>
    </listitem>
</itemizedlist>
</listitem>
<listitem>
<programlisting>$ cd /usr
$ cvs login</programlisting>
(use password "anoncvs")
</listitem>
</orderedlist>
</para>
<para>
You have to have write permission on the directory for the initial
checkout; after that you can just change the owner of the source tree
to some other user. One of the possible ways is to do the initial
checkout as root, and then give the source tree to a different user
for later use.
</para>
</sect3>

<sect3 id="using-anoncvs-over-ssh">
<title>Using anoncvs over ssh</title>
<para>
The methods described in <ulink url="#using-anoncvs-pserver">using anoncvs</ulink> can
be used over ssh to ensure the integrity of the sources you receive.
However,
this adds substantial overhead to the anoncvs servers.
</para>
<para>
Those servers in the <ulink url="../../mirrors/#anoncvs">mirrors</ulink>
that support ssh connections show the required information with
each entry.
</para>
<para>
In general,
remove the ':pserver:' prefix on the cvsroot,
and set the variable CVS_RSH to 'ssh',
using the method appropriate for your shell.
</para>
</sect3>

<sect3 id="using-anoncvs">
<title>Tracking NetBSD-current with anoncvs</title>

<sect4 id="setting-up">
<title>Setting up</title>

<itemizedlist>
<listitem>To checkout only the kernel sources
<programlisting>$ cd /usr
$ cvs checkout -P src/sys</programlisting>
<para>
This gives you the kernel sources in <code>/usr/src/sys</code>. Information
on <ulink url="../kernel/#how_to_build_a_kernel">how to build a
kernel</ulink> is also available.
</para>
</listitem>
<listitem><para>Checkout the entire source tree (including kernel)
<programlisting>$ cd /usr
$ cvs checkout -P src</programlisting>
</para>
<para>
You should now have a full set of NetBSD sources in /usr/src.
</para>
<note>
<para>It is almost always faster for a first-time "whole
source" checkout to <ulink url="#downloading">FTP the tarballs</ulink> and untar
them locally because that makes best use of the network link. After that,
using cvs checkout/update works to minimize the number of bytes coming over
by sending only the changes.
</para>
</note>
</listitem>

<listitem>Fix permissions<html:br/>
    If you wish for the source tree to be owned by a non-root user,
    do (as root):
<programlisting># chown -R <emphasis>user</emphasis> /usr/src</programlisting>
</listitem>
</itemizedlist>
</sect4>

<sect4 id="update-sources">
<title>To update the sources</title>

<orderedlist>
<listitem>To update only the kernel sources
<programlisting>$ cd /usr/src/sys
$ cvs update -dP</programlisting>
</listitem>
<listitem>To update the entire source tree
<programlisting>$ cd /usr/src
$ cvs update -dP</programlisting>
</listitem>
</orderedlist>
<para>
<emphasis role="bold">Note:</emphasis> Running <code>cvs checkout -d dir src</code> (or similar commands
with the other src* modules) does not work.  You will get error messages saying
"existing repository ... does not match ...; ignoring module _gnusrc-cmp" etc.
The workaround is to drop the <code>-d</code> option and let cvs create the
default directory.
</para>
</sect4>

<sect4 id="checkout-by-date">
<title>To check out the sources from a certain date</title>
<programlisting>$ cvs checkout -D 20020501-UTC src</programlisting>
</sect4>

<sect4 id="checkout-by-branch">
<title>To check out the sources from a certain branch</title>
<programlisting>$ cvs checkout -rnetbsd-1-6 src</programlisting>
See
<ulink url="http://cvsweb.NetBSD.org/bsdweb.cgi/src/doc/BRANCHES?rev=HEAD&amp;content-type=text/x-cvsweb-markup">src/doc/BRANCHES</ulink>
for a description of the branches in the CVS repository.
</sect4>

<sect4 id="hints">
<title>Useful hints</title>
<itemizedlist>
<listitem>
Do not use the cvs '-z' flag.  The data stream gets out of sync,
leading to corruption on the client, or causing the client to hang
completely.  The additional load is also hard on the cvs server.
</listitem>
<listitem>If you want to check out a certain branch of the tree, you may
want to take caution not to overwrite any existing directories by creating a
new directory for this branch:

<programlisting>$ cd /parent/dir/to/checkout/into
$ mkdir NewName-temp
$ cd NewName-temp
$ cvs checkout ... src
$ mv src ../NewName
$ cd ..
$ rmdir NewName-temp</programlisting>
</listitem>
<listitem>
You will have to use objdirs in order for cvs updates to work
correctly.  If you happen to get errors from cvs saying things like:
<programlisting>   cvs [update aborted]: could not chdir to gnu/usr.bin/gdb/gdb: Not a directory</programlisting>
you should do a <code>make cleandir</code> and try again.  Make sure to
run <code>make obj</code> after the cvs update.
</listitem>
<listitem>
<para>

You can put switches for specific commands in a .cvsrc in your home
directory, and they will be automatically used. A sample .cvsrc would be:
</para>

<programlisting> update -dP
   checkout -P
   diff -u</programlisting>
</listitem>
</itemizedlist>
</sect4>

<sect4 id="building-from-source">
<title>Building NetBSD from source</title>
<para>
<emphasis>(assuming you have an up-to-date NetBSD binary
snapshot, and source in /usr/src, on your machine already; further
assuming your BSDOBJDIR should be /usr/obj):</emphasis>
</para>
<para>
To build userland the first time:
<programlisting># mkdir /usr/obj
# cd /usr/src
# ./build.sh -O /usr/obj -D /usr/NetBSD-new-build -T /usr/tools build
# ./build.sh -O /usr/obj -D /usr/NetBSD-new-build -T /usr/tools install=/
</programlisting>
</para>
<para>
When you build your system for the first time using build.sh,
a set of tools for future use of compilations will be built, too.
Any subsequent compilation should reuse the already compiled tools,
and thus take less time.
</para>
<para>
Of course, don't invoke <code>./build.sh install=/</code>
unless the <code>./build.sh build</code> has succeeded previously or it's
entirely possible to end up with a non-working system.
</para>
<para>

To update userland binaries after a CVS update:

<programlisting># cd /usr/src
# ./build.sh -D /usr/NetBSD-new-build -O /usr/obj -T /usr/tools -u build
# ./build.sh -D /usr/NetBSD-new-build -O /usr/obj -T /usr/tools -u install=/
</programlisting>

These will install the new binaries on the running system - reboot to make
sure they all take effect.
</para>
<para>

If you update system frequently and want the build to directly update
your running system, you can use <emphasis>expert</emphasis> mode and build
with DESTDIR=/, eg:

<programlisting># ./build.sh -E -O /usr/obj -T /usr/tools -u build</programlisting>

Note this is for <emphasis role="bold">expert</emphasis> users only and you can
very easily render your system into state where it won't be able
to compile anything anymore. Use only if you are <emphasis role="bold">sure</emphasis>
the build will finish successfully.
</para>
</sect4>
</sect3>

<sect3 id="using-sup-into-cvs">
<title>Tracking NetBSD-current with SUP into CVS</title>

    <sect4 id="sup-overview">
<title>Overview</title>

    <para>Current can be tracked in the following way. The baseline copy of
      the sources is kept up to date using sup approximately once a week.
      as normal. This baseline source tree is then imported into a local
      CVS repository. Current is then built from a checked out copy of
      the repository.</para>

    <para>There are 3 major reasons for this approach
    <orderedlist>
      <listitem>It keeps track of how current changes over time.</listitem>
      <listitem>It allows for local changes to be almost automatically merged
	into the updated current sources.</listitem>
      <listitem>It ensures there is always a clean unmodified copy of the
	NetBSD-current source tree is available in case of problems when
	building.</listitem>
    </orderedlist>
    </para>
    
    <para>The only downside to this approach is that 3 independent copies 
      of the source tree are needed which amounts to about 150MB of
      disk space not including the space required to actually build
      current.
    </para>
    </sect4>

    <sect4 id="sup-requirements">
<title>Requirements</title>
    <itemizedlist>
      <listitem>CVS 1.9 or later (either already installed if you're running
          -current after 2000-09-04, installed from pkgsrc or just
          built from source). CVS 1.10 or later is preferred as it
          handles merging better.</listitem>
      <listitem>SUP installation</listitem>
      <listitem>Perl 5 installation for supplied script (optional)</listitem>
    </itemizedlist>
    </sect4>
    <sect4 id="sup-details">
<title>Details</title>
    <para>Tracking and building current consists of 6 phases:
    <orderedlist>
      <listitem>Supping updated sources into master source tree.</listitem>
      <listitem>Importing supped sources into CVS and updating working copy
	of sources.</listitem>
      <listitem>Merging supped sources with local working sources.</listitem>
      <listitem>Building and installing current.</listitem>
      <listitem>Tagging the sources for a successful build in the
	repository.</listitem> 
    </orderedlist>
    </para>
    </sect4>
    </sect3>

    <sect3 id="supping-sources">
<title>Supping sources</title>
    <para>Sources can be supped from any NetBSD sup server and the output 
      from the SUP should be stored in a file for later reference.
    </para>
    </sect3>

    <sect3 id="import-merge">
<title>Importing and merging sources.</title>
    <para>Sources are imported as follows:</para>
<programlisting>$ cvs -d /misc/cvsrep import -I ! -I CVS netbsd netbsd current-<emphasis>date</emphasis></programlisting>

    <para><emphasis>date</emphasis> is replaced by the date of the SUP for tracking
      purposes. The <code>-I ! -I CVS</code> options ensure that no file in
      the source tree is ignored except 'CVS' directories.  This is because
      some NetBSD source files have extensions which are normally ignored by
      CVS. If there are any conflicts with local patches the import command
      will report them and will describe a command to merge the conflicts
      something like:</para>
<programlisting>$ cvs checkout -jnetbsd:yesterday -jnetbsd netbsd</programlisting>
    <para>This merge command will correctly merge the imported NetBSD
      sources but it will not handle the removal of files locally
      which have already been removed by the SUP process. To do this the
      merge command would be:</para>
<programlisting>$ cvs update -j<emphasis>previous import tag</emphasis> -j current-<emphasis>date</emphasis></programlisting>
    <para><emphasis>previous import tag</emphasis> should be replaced with the name of
      the tag used for the previous cvs import. <emphasis>date</emphasis> should be
      replaced with the current date to yield the same tag used on
      the current import that has just been merged.</para>
    <para>The conflicts reported by the import command are potential
      conflicts. These are usually merged by the update command but in
      some cases a real conflict occurs. In these cases a manual merge
      of the conflicting lines will be required. A real conflict will
      be reported in the cvs update output as a <code>C</code>
      followed by a filename.</para>
    <para>Merging conflicts manually is not a simple process but in most
      cases it should be resolved by removing the local changes and
      making the file like the original NetBSD source code.  </para>
    <para>CVS marks conflicts as follows:</para>
<programlisting>
&lt;&lt;&lt;&lt;&lt;&lt;
  <emphasis>code from local file</emphasis>
======
  <emphasis>code from imported file</emphasis>
&gt;&gt;&gt;&gt;&gt;&gt; <emphasis>local revision number of newly imported revision</emphasis>
</programlisting>

    <para>If the import reports no conflicts the checked out copy of the
      tree should be updated in exactly the same way as for the
      conflicts case.</para>
    <para> All update and checkout commands should be done in the
      directory where the sources have been checked out. On my system
      this is <code>/usr/src/netbsd</code>.</para>
    <para>If this is the first import then there will be no sources
      checked out. Assuming you wish to create the source tree in
      '<code>/usr/src/netbsd</code>' The following commands will check
      out the source and no merge step is required.</para>
<programlisting>$ cd /usr/src
$ cvs -d /misc/cvsrep checkout netbsd
</programlisting>
    </sect3>

    <sect3 id="building-current">
<title>Building current.</title>
    <orderedlist>
    <listitem>Configure, <ulink url="../kernel/#how_to_build_a_kernel">
	build</ulink>, and reboot into a new kernel.</listitem>
    <listitem>cd to the base of your -current source tree and type
	<code>./build.sh -T /usr/tools -O /usr/obj </code>.</listitem>
    <listitem>You may need to merge in any changes that have been made to files in
	/etc.</listitem>
    </orderedlist>
    </sect3>

    <sect3 id="tagging">
<title>Tagging a successful build</title>
    <para> If the <ulink url="#building">build</ulink> completes successfully,
      and produces a working set of binaries,
      it can be useful to tag the working sources.
      This allows rewinding to a working build tree with a single CVS
      command in the event that the current tree becomes unbuildable
      for any reason. This can be performed by issuing the following
      command:</para>
<programlisting>$ cvs tag successful-build-<emphasis>build date</emphasis></programlisting>

    <sect4 id="tag-notes">
<title>Notes</title>
    <itemizedlist>
      <listitem>If the NetBSD customised version of CVS, which recognises
	<emphasis role="bold">$Net</emphasis><emphasis role="bold">BSD$</emphasis> markers in files, is not used, the
	NetBSD revision number of the file is available for reference
	purposes when build problems occur.</listitem>
      <listitem>The sup/import/merge sequence described above is quite
	easily automatable. The following Perl script automates this
	process.
<programlisting>#!/usr/pkg/bin/perl
#
# Script to SUP NetBSD-current, import it into CVS and merge it with
# any local changes.
#
# NOTES:
# This script does no error handling so is not really suitable for 
# non-interactive use.
#
# This script has only been test with cvs-1.10.1 and cvs-1.9.18.
#
$SRCROOT="/usr/src/netbsd";
$IMPORTROOT="/misc/import";
$CVSROOT="/misc/cvsrep";
#run the sup into a perl stream
system "/usr/sbin/sup -zsv" ; # This may need to change for none
                              # current systems

# now import the new files into CVS 

chdir $IMPORTROOT or die "Could not cd to $IMPORTROOT\n";

($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime;
$date = localtime;
$shortdate = sprintf "%02d%02d%04d",$mday,$mon+1,1900+$year;
system "/usr/local/bin/cvs -d$CVSROOT import -I ! -m\"SUP Import $date\" netbsd netbsd current-$shortdate ";

# make the working directory the local NetBSD Tree
chdir $SRCROOT or die "Could not change to $SRCROOT directory\n";

# Now do the import.
$lastimport = `cat /usr/src/netbsd/.tag`; # `s are backquotes
$lastimport =~ s/\n//; # strip off any trailing newline in the string
system "/usr/local/bin/cvs update -j $lastimport  -j
current-$shortdate ";
# Now write the current file into tag save file
open TAG,"&gt;$SRCROOT/.tag" or die "Could not open new tag file";
 print TAG "current-$shortdate";
close TAG;
</programlisting>
    <para>This script was written in Perl since it is the scripting tool
	  which the author has the most experience with. It should
	  be fairly straightforward to write a shell script to perform 
      the same task.</para></listitem>
      <listitem>Techniques for tracking current with CVS have been discuss several
	times on the NetBSD current-users mailing list. For
	alternative techniques try searching the NetBSD mailing lists.</listitem>
    </itemizedlist>
    <para>
    If you have any comments or suggestions please send them to
    Mike Pumford <email>mpumford@black-star.demon.co.uk</email> (who maintains this entry) or
    <email>www@NetBSD.org</email>.
</para>
</sect4>
</sect3>

<sect3 id="getrepos">
<title>Getting the whole repository</title>
<para>

All the procedures described above allow you keeping your own
changes in your repository, which has its advantages if you develop
your own software based on NetBSD. If you don't want to maintain your
own CVS repository, but just want to mirror NetBSD's CVS repository,
there are four ways to do so.
</para>
<para>

Each of the methods described briefly below will get you a copy
of the NetBSD CVS repository (i.e. the RCS ,v files, not the checked
out files!). You can then setup your own anoncvs server or check
out to a local harddisk. It's also useful for fast access to the history
information stored in the repository.
</para>
<para>

The methods to retrieve the whole repository are:

<variablelist>
<varlistentry>
  <term>sup</term>
<listitem><para>If you use sup already to mirror other parts of the NetBSD source,
     you will want to add the following lines to your sup config file:</para>
<programlisting>anoncvs release=all  host=sup.NetBSD.org hostbase=/ftp/pub \
base=/usr prefix=/usr backup use-rel-suffix compress
</programlisting>
     <para>
     After that, run "sup /path/to/supfile anoncvs" to retrieve the files.
     </para>
     <para>
     Some example sup files are available in <code>/usr/share/examples/supfiles</code>. 
     Also, check our <ulink url="../../mirrors/#sup">list of SUP mirrors</ulink>
     to find the server closest to you!
     </para>
</listitem>
</varlistentry>

<varlistentry>
<term>ftp</term>
<listitem><para>Setup your favourite mirror program (e.g. <filename 
     role="pkg">net/mirror</filename>)
     and retrieve the files from <ulink url="ftp://ftp.NetBSD.org/pub/NetBSD-cvs/main/"/></para>
     <para>
     Please see our <ulink url="../../mirrors/#ftp">list of FTP mirrors</ulink>!
     </para>
</listitem>
</varlistentry>

<varlistentry>
  <term>rsync</term>
<listitem><para>Note that rsync puts quite a heavy load on our rsync server, and
     as such the number of concurrent rsync users is restricted. If you
     still want to try rsync, the command to retrieve the repository
is:</para>
<programlisting>rsync -v -a rsync://rsync.NetBSD.org/anoncvs/</programlisting>
     <para>Please see our <ulink url="../../mirrors/#rsync">list of rsync mirrors</ulink>!</para>
</listitem>
</varlistentry>

<varlistentry>
  <term>cvsup</term>
<listitem><para>CVSup is not currently available for all NetBSD architectures, since the M3
     compiler has not been ported. On i386, you can mirror the repository
     from cvsup.de.NetBSD.org with the 
     <filename role="pkg">devel/cvsup</filename> package and the 
     following config file:
<programlisting>*default host=cvsup.de.NetBSD.org
*default base=/usr
*default prefix=/local/NetBSD-cvs
*default release=cvs
*default delete use-rel-suffix
*default compress

netbsd
</programlisting>
     </para>
     <para>
     Please see our <ulink url="../../mirrors/#cvsup">list of CVSup mirrors</ulink>!
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</sect3>

<sect3 id="error">
<title>What if I get an error?</title>
<para>

If you try to build -current, either from a snapshot or an earlier
-current, and it doesn't work, don't panic.  Try these steps:
<orderedlist>
<listitem>Read the <ulink
    url="http://cvsweb.NetBSD.org/bsdweb.cgi/src/UPDATING">UPDATING</ulink>
    file from the release you're trying to build.
</listitem>
<listitem>Read the <ulink
    url="http://mail-index.NetBSD.org/current-users/">current-users
    archive</ulink> for hints.
</listitem>
<listitem>Update again.  You may have caught the repository in the middle of
    a commit to several related files, or the problem might have
    already been fixed.
</listitem>
<listitem>If all else fails, send email to current-users explaining the
    problem.  Include the date, time, and method you used to get your
    -current sources, as well as any local changes you've made.  Then
    put in a <emphasis role="bold">short</emphasis> script that includes the error messages
    you're getting.  Somebody will probably fix the problem
    momentarily.
</listitem>
</orderedlist>
</para>
</sect3>

<sect3 id="etcupdate">
<title>Updating the configuration and startup files with etcupdate</title>

<sect4 id="etcupdate-overview">
<title>Overview</title>

etcupdate is a script to help users compare, merge and install new
configuration and startup files (files found in the etc.tgz
distribution set) in /dev, /etc and /root after performing an operating
system upgrade. The upgrade of the operating system could have
been performed either by compiling sources or by extracting
the distribution binaries. 
</sect4>

<sect4 id="using-etcupdate-source">
<title>Using etcupdate with source files</title>
<para>
In case where the sources are in /usr/src the following command should be
enough:
</para>
<programlisting># etcupdate</programlisting>
<para>
But what if your NetBSD sources are in an alternative location, such as
in /home/jdoe/netbsd/src? Don't worry, tell etcupdate the location of
your source tree with -s srcdir and it will work just fine:
</para>
<programlisting># etcupdate -s /home/jdoe/netbsd/src/etc</programlisting>
</sect4>

<sect4 id="using-etcupdate-binary">
<title>Using etcupdate with binary distribution sets</title>
<para>
Sometimes it's not possible have the sources around but you still want
to update the configuration and startup files. The solution is to extract
the desired distribution files (at least etc.tgz) and use the -b
srcdir switch to tell etcupdate that we don't have the sources but
only the official distribution sets.
</para>
<programlisting># mkdir /tmp/temproot
# cd /tmp/temproot
# tar xpzf /some/where/etc.tgz
# etcupdate -b /tmp/temproot</programlisting>
</sect4>
</sect3>
</sect2>

<html:hr/>

<sect2 id="specific-problems">
<title>Specific problems</title>

<sect3 id="wscons">
<title>Console dead after updating to wscons</title>
<para>

You should copy a current MAKEDEV from the appropriate etc.<emphasis>port</emphasis>
directory in <ulink
url="ftp://ftp.NetBSD.org/pub/NetBSD/NetBSD-current/src/etc/">src/etc</ulink>,
into <code>/dev</code>, boot single user, then type:
<programlisting># fsck -p
# mount -vt nonfs
# cd /dev
# ./MAKEDEV wscons
</programlisting>
</para>
</sect3>

<sect3 id="rebuild-nbmake">
<title>Why does build.sh always rebuild nbmake first?</title>
<para>

Even after running <code>./build.sh tools</code> and using the <code>-u</code>
flag or specifing <emphasis>TOOLDIR</emphasis> in <code>/etc/mk.conf</code>,
<code>nbmake</code> is always rebuilt by <code>build.sh</code>.  This is normal.
The reason for this can be found in <code>./build.sh</code> itself, in the
function <code>rebuildmake</code>:
<programlisting>        # Note that we do NOT try to grovel "mk.conf" here to find out if
        # TOOLDIR is set there, because it can contain make variable
        # expansions and other stuff only parsable *after* we have a working
        # ${toolprefix}make.  So this logic can only work if the user has
        # pre-set TOOLDIR in the environment or used the -T option to
        # build.sh.
        #               
</programlisting>
So, if you do not want to rebuild <code>nbmake</code>, you will need to pass
<code>-T tooldir</code> or set the <emphasis>TOOLDIR</emphasis> variable in the
environment.
</para>

</sect3>
</sect2>
</sect1>
</webpage>
