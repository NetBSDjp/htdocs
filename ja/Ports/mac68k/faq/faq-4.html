<HTML>
<HEAD>
<TITLE>NetBSD/mac68k F.A.Q.とその回答: インストレーションとアップグレード</TITLE>
</HEAD>
<BODY>
<A HREF="faq-3.html">Previous</A>
<A HREF="faq-5.html">Next</A>
<A HREF="faq.html#toc4">Table of Contents</A>
<HR>
<H2><A NAME="install"></A> <A NAME="s4">4. インストレーションとアップグレード</A></H2>

<P>
<A HREF="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.3/mac68k/INSTALL">INSTALL</A>文書をよく読むと、ここにある質問の多くはたずねる必要がなくなるでしょう。</P>
<P>アップグレードに関するトラブルやINSTALLノートが役に立たないと思うときは、Mark Andres (mark@giganet.net)のアップグレードHOWTOを見るのもよい考えです:</P>
<P>
<A HREF="http://www2.giganet.net/~mark/NetBSD/howtos/upgrade-howto.html">http://www2.giganet.net/~mark/NetBSD/howtos/upgrade-howto.html</A></P>

<H2><A NAME="B.A"></A> <A NAME="ss4.1">4.1 どれくらいのRAMが必要ですか？</A></H2>

<P>4MB RAMが絶対的下限値ですが、4MBではほとんど使いものにならないことが予想されます。推奨下限値は8MBです。RAMはいくらあってもあり過ぎということはありません。望ましいのは16MB以上です。</P>


<H2><A NAME="B.B"></A> <A NAME="ss4.2">4.2 どれくらいのディスクスペースが必要ですか？</A></H2>

<P>たぶん、ごく基本的なシステム(baseとetc配付セットのみ)を80MB以内に押し込めることができるでしょうが、以下はBill Studenmund (wrstuden@loki.stanford.edu)からのwords of wisdomです:
<BLOCKQUOTE>
100メガあればルートパーティションには何とかなるでしょうが、(載せたい)おもちゃによってはもっと欲しくなるでしょう。私のセットアップでは約100メガをルートパーティションに、約350メガをUSRパーティションに当てています。実はルートパーティションにすべてインストールしてあって(NetBSDは学校のラボにあるような売り物のUN*Xよりもずっとスリムなんです :-) )、USRパーティションではカーネルのコンパイル、ghostscript関連の作業その他を行っています。
</BLOCKQUOTE>

<BLOCKQUOTE>
カーネルコンパイルに打ち込むつもりならもっとスペースが必要になるでしょう。
</BLOCKQUOTE>
</P>
<P>もっと詳しい推奨値や無圧縮状態でのNetBSD配付セットの大きさ等については、
<A HREF="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.3/mac68k/INSTALL">INSTALL</A>を参照してください。</P>


<H2><A NAME="B.C"></A> <A NAME="ss4.3">4.3 スワップパーティションはどうしても必要ですか？</A></H2>

<P>いいえ、ですがあった方がいいでしょう。メモリが枯渇してしかもスワップパーティションがないとNetBSDは警告なしでハングしてしまいます。</P>
<P>スワップスペースの大きさを決めるためのよく利用される手法として、RAMサイズの2倍というのがあります。また、RAMとスワップの合計サイズが少くとも20MBはあることも推奨されています。David W. Rankin Jr. (rankin@ewl.uky.edu)は:
<BLOCKQUOTE>
私が5メガのRAMと12メガのスワップを持ったIIsiで1.0を動かしていた時は、週毎のcronジョブでシステムが落ちてしまいました。もちろんそれは80メガのドライブだったので、ファイルシステムとスワップのトレードオフを取らなくちゃいけないとかいう話ではなかったんですが :)[訳註:意味がよくわからない…。まあ、あまり深く考えるようなことでもないと思います]
</BLOCKQUOTE>

<BLOCKQUOTE>
さらに、もし使っていない小さなSCSIディスクがそこいらにころがっていたら、他の目的には一切使われないディスクにスワップパーティションを作るのは絶対に損にはなりません。
</BLOCKQUOTE>

とつけ加えてくれました。感謝します。</P>
<P>NetBSDがRAMの2倍のスワップを要求する訳では<EM>ありません</EM>(例えば、40MBのRAMがあったら恐らく80MBのスワップは必要ないでしょう[訳註:余談ですが訳者(中田)の構成はまさにその通り＝40MB RAM+80MB swap、です])。NetBSDではスワップは加算的なので、合計仮想メモリサイズはRAMとスワップの合計となります。したがって、スワップの方がRAMサイズより小さくても構わないのです(ただしカーネルの完全なクラッシュダンプは、主スワップパーティションが物理メモリサイズよりも大きくないと取ることができませんが)。しかし、スワップが足りなくなったときのNetBSDの振舞いはあまり優雅なものではないので、必ずスワップには通常のロードをこなすのに十分な領域を与えましょう。</P>
<P>NetBSD 1.3からスワップデバイスはブート時に動的にコンフィギュアされるようになり、任意のパーティションをスワップとして指定できるようになりました。<CODE>/etc/fstab</CODE>ファイルにスワップパーティションを登録するだけで次のブート時から使えるようになります。最低ひとつのスワップデバイスは必ず持つようにします。さもないとNetBSDはブート時にひとつもスワップデバイスをコンフィギュアしないでしょう。詳しくは<CODE>swapctl</CODE>(8)マニュアルページを参照してください。</P>



<H2><A NAME="B.D"></A> <A NAME="ss4.4">4.4 MacOSパーティションはどうしても必要ですか？</A></H2>

<P>いいえ。もしパーティションソフトウェアが許せば全部のスペースをNetBSDパーティションに割り付けてしまっても構いません。注意:そのようにするとこのドライブはMacOSのデスクトップには現れません。したがってBooterをブート可能なフロッピーか別のドライブのMacOSパーティションに入れる必要はあります。[訳註:結局これって、ブートフロッピーを作る方法以外には、ひとつもMacOSを作らない、という訳ではないような気がしますが…]</P>



<H2><A NAME="B.E"></A> <A NAME="ss4.5">4.5 Mkfs (Newfs)はスワップパーティションにもかけるのでしょうか？</A></H2>

<P>いいえ。[訳註:スワップパーティションの管理の仕方は通常のファイルシステムの管理とは全く異っていて、i-nodeなどは使用しないので、ルートパーティションのようにMkfsでファイルシステムを初期化する必要は全くありません。以上でこの質問に対する回答は終了で、以下質問そのものとはあまり関係ない話が続くような気もするのですが、翻訳を続けます]Installerの"Build Devices"メニューによって適切なスワップパーティションのエントリを持った<CODE>/etc/fstab</CODE>が作成されます。NetBSDをブートすると<CODE>/etc/rc</CODE>が<CODE>swapctl</CODE>を実行してスワップパーティションの使用を開始します。</P>
<P>バージョン1.1aから1.1cまでのInstallerでは、スワップが常にsd0bになった、状況によっては間違っているかも知れない<CODE>/etc/fstab</CODE>を作ることに注意してください。これを解決するには1.1d以降のInstallerを使用します。</P>


<H2><A NAME="B.F"></A> <A NAME="ss4.6">4.6 なぜInstallerは<CODE>"Trap not implemented error"</CODE>で何度もクラッシュしてしまうのでしょうか？</A></H2>

<P>恐らくInstallerバージョン1.0を使っているのだと思います。Installerに十分大きなメモリを与えると、つまり「情報を見る」で表示されるウィンドウの推奨メモリサイズを1500K程度まで増やしてやると、うまく動くようになるはずです。残念ながらこのバージョンのInstallerは小さすぎるメモリサイズを使ってコンパイルされているのです。</P>
<P>バージョン1.1以降を使った方がいいかも知れません。Installer 1.1以降ではやや機能が豊富になっています。以下の場所から入手できます:
<BLOCKQUOTE><CODE>
<A HREF="ftp://ftp.macbsd.com/pub/NetBSD/installer/">ftp://ftp.macbsd.com/pub/NetBSD/installer/</A></CODE></BLOCKQUOTE>

または
<BLOCKQUOTE><CODE>
<A HREF="ftp://ftp.netbsd.org/pub/NetBSD/arch/mac68k/utils/Installer.sea.hqx/">ftp://ftp.netbsd.org/pub/NetBSD/arch/mac68k/utils/Installer.sea.hqx/</A></CODE></BLOCKQUOTE>
</P>
<P>こちらのバージョンのInstallerはSystem 6以前のMacOSでは動作しませんので注意してください。</P>
<P>Installerがクラッシュするとたまにファイルシステムが壊れることがあります。ですから再インストールの前に安全のためにMkfsを再度実行することをお薦めします。</P>
<P>Installerユーティリティを保守・更新してくれている(また上の回答も寄せてくれた)Steve Brown (sbrown@shellx.best.com)に感謝したいと思います。</P>
<P>(注意: 最新版のInstallerでさえ、とても大きなアーカイブファイルに対してはクラッシュすることがあるようです。推奨メモリサイズを2倍にすれば問題を緩和するはずです。)</P>


<H2><A NAME="B.G"></A> <A NAME="ss4.7">4.7 MacBSDパーティションを作成するのにどのソフトウェアを使うべきでしょうか？</A></H2>

<P>もし
<A HREF="#Mkfs1.2">Mkfs 1.2</A>以降を使っているなら(現時点ではMkfs 1.45が最新バージョンです)ほとんどどんなフォーマッタ/パーティションユーティリティでも使用できるはずです。たとえそのソフトウェアがA/UXパーティションの作成に対応していなかった場合でも、任意のパーティションのタイプをNetBSDが使用可能なものに変換してしまう機能が新しいMkfsにはあります。詳しくは
<A HREF="#Mkfs1.2">Mkfs 1.2以降</A>で
<A HREF="#B.K">追加パーティションを作成する</A>のQ&amp;Aを参照してください。</P>
<P>Mkfsの古いバージョンを使っている場合は、A/UX 2.0用パーティションを作成できるフォーマッタ/パーティションソフトウェアならどれでも使えるはずです。A/UX 3.0用パーティションはNetBSD/mac68kでは使用できませんから注意してください。FWBハードディスクツールキットとLaCieのシルバーライニングは推奨されている商用パーティションソフトウェアのうちのふたつです。</P>
<P>メーリングリストに投稿された情報によれば、APSのAlliance Power Tools 2.x.xは商用の製品SCSI Directorを再パッケージしたものであることがわかりました。ですから、APT 2.x.xのftpサイト名はもはやここで公開することはしません。[訳註:APT 2.7.3は以前anonymous ftpで公開しているサイトがありました。というか現在でも日本のサイトではまだ公開していそうな気がします]</P>
<P>AppleのHDSC Setupを他社製ドライブに対して使用するためのパッチも出回っています。パッチ済みバージョンはここから入手できます(今このバージョンは手に入らないようです―nigel@ind.tansu.com.au)。
</P>
<P>さらに、もうひとつのパッチ済みバージョンでHDSC Setup 3.0.1 (A/UX)と呼ばれるものが、
<A HREF="http://www.euronet.nl/users/ernstoud/hdsetup.html">http://www.euronet.nl/users/ernstoud/hdsetup.html</A>で入手できます。</P>
<P>自分でApple HDSC Setup 7.3.5にパッチを当てるための情報は
<A HREF="http://www.euronet.nl/users/ernstoud/patch.html">http://www.euronet.nl/users/ernstoud/patch.html</A>にあります。</P>
<P>HDSC SetupのA/UX自動設定では
<A HREF="faq-3.html#A.C">Eschatology</A>パーティションが作成されるでしょう。これは削除してしまって構いません。インストールされるAppleのドライバは他の製品よりも高速であるということです。[訳註:ドライバの性能はNetBSDにとっては無関係なことですが]</P>
<P>Apple HDSC Setupに関する情報は以下の方々の協力によります:
<UL>
<LI>David A. Gatwood (davagatw@mars.utm.edu)</LI>
<LI>Dietmar Grabowski (Dietmar.Grabowski@hamburg.netsurf.de)</LI>
<LI>Henry B. Hotz (h.b.hotz@jpl.nasa.gov, hbhotz@oxy.edu)</LI>
<LI>Bob Nestor (rnestor@metronet.com)</LI>
</UL>
</P>
<P>APS フォーマッタに関する情報はMonroe Williams (monroe@teleport.com)が提供してくれました。</P>
<P>また、パーティショニングソフトウェアに関する追加情報を寄せてくれたBen Cottrell (benco@ucsee.EECS.Berkeley.EDU)にも感謝します。</P>


<H2><A NAME="B.H"></A> <A NAME="ss4.8">4.8 ルートとusr別々のパーティションが必要でしょうか？</A></H2>

<P>Bill Studenmund (wrstuden@loki.stanford.edu)曰く:
<BLOCKQUOTE>
これは趣味の問題です。別々のパーティションを使う理由は二重です。<CODE>/var</CODE>や<CODE>/tmp</CODE>、<CODE>/home</CODE>などのパーティションは他のファイルシステムから独立に保ちたい場合があります(それによって、どれかのパーティションが一杯になってもシステム全体としてはまだ空きがあるという状態でいられます)。
</BLOCKQUOTE>

<BLOCKQUOTE>
さて、上はスタイルの問題です。私のホームマシンは独立した<CODE>/home</CODE>、<CODE>/tmp</CODE>、<CODE>/var</CODE>パーティションは持っていません。大学のラボのワークステーションはどれも持っています。これらが分離していなくてもどうということはありません。特にあなたが唯一のユーザーである場合はそうです。
</BLOCKQUOTE>

<BLOCKQUOTE>
分離パーティションを持つもうひとつの理由は、それによって、停電などの時にダメージを受けるファイルシステムを制限することです。書き換えの発生しないファイルシステムでは、停電などで突然システムがダウンしてもファイルシステムが壊れることはありません。ちょうどMacOSで、(ほとんど書き換えの起こらない)アプリケーションだけあるパーティションへ、データだけ別のパーティションへ保存するのに似ています。こうするとマシンがクラッシュしたあともNortonが必要になるのはデータ用パーティションだけです。:-)
</BLOCKQUOTE>

<BLOCKQUOTE>
本当にこれはあなたが何をしたいかによります。私の場合単一のパーティションにシステムのほとんどが入っています(あ、これによってインストールも簡単になります―ルートパーティションだけで済みますから)。そしてコンパイルや遊びのスペースは別にとってあります。
</BLOCKQUOTE>
</P>


<H2><A NAME="B.K"></A> <A NAME="ss4.9">4.9 追加のパーティションを使いたいのですが、パーティションの種類は何にすべきでしょうか？</A></H2>

<P>最低ひとつの"A/UX root"または"Root slice 0"(または"root&amp;usr")タイプのパーティションが必要ですが、残りのファイルシステム(つまりスワップ以外)は"A/UX Root"と"A/UX root&amp;usr"以外にも"A/UX User"(かまたは"A/UX Usr slice 2")タイプにもできます。これは<CODE>/usr</CODE>階層に使うためのパーティションかどうかには全く無関係です。明らかに、"root"と名のつくパーティションが、"usr"だけのもの(gとh)より先に(eとf)認識されるようです。"Free Unix slice"パーティションやその他のパーティションはNetBSD/mac68kでは使えません。</P>
<P>もうひとつの重要なポイントとして、A/UX 3.0のファイルシステムも使えないことです。代わりにA/UX 2.0パーティションを使用する必要があります。</P>
<P>上の情報を寄せてくれたBen Hockenhull (benh@inlink.com)とSteve Ihde (sihde@cs.stanford.edu)に感謝します。</P>
<P>
<A NAME="Mkfs1.2"></A> 

しかし、Mkfsの最新版によって上の情報はほとんど旧式にされてしまいました。Bob Nestor (rnestor@metronet.com)によれば:
<BLOCKQUOTE><CODE>
<PRE>

パーティションマップとドライバパーティションを除けばどんなタイプのパー
ティションでもNetBSD Root & Usr、NetBSD Swap、MacOS HFS、またはApple_
Freeタイプのパーティションに変換するためのコードが追加されました。これ
によってたとえA/UXパーティションの作成に対応していないディスクフォーマッ
タでもNetBSDボリュームを準備するために使うことができるはずです。Apple_
Freeパーティションとは割り付けはされていても使用はされないパーティショ
ンです。MacOSでも認識されないので将来必要になるかも知れないディスクス
ペースを取っておくにはちょうどいいタイプです。

実際にはパーティションタイプを変更せずに、いかなるタイプでもBSDパーティ
ション(A/UX、NetBSD、RootまたはSwap)をタイプ変更のために選択するとパー
ティション名がNetBSDのパーティション名に書き換えられます。Apple_HFSの
パーティションには、ユーザーがApple_HFS以外のパーティションタイプを選
択しない限り一切の変更は行われません。

NetBSD用パーティションへ変換する際、マウントされているMacOS HFSパーティ
ションの不適切な使用はチェックされません。ユーザーはマウントされたHFS
パーティションの変換について警告を受けますが、この警告に従わないとファ
イルシステム破壊、システムクラッシュ、またはそれよりも悪い事態に陥るこ
ともあり得ます。

ディスクやパーティションが正常にフォーマットできずにハングすることもあ
ります。これはパーティションのブロック数がシリンダあたりブロック数で割
り切れないことと関係があるかも知れません。どういうわけかデバッグ用ステー
トメントをイネーブルして実行すると、この問題も発生せず、問題のパーティ
ションのフォーマットも可能なようです。

MacOSディスクパーティション名をパーティションに記録されている情報から
引き出すようになっています。ディスクパーティションに関連するパーティショ
ンマップブロックはMacOSパーティション名を常に含むわけではありません。
これはマップブロックのオプショナルなエントリで、すべてのパーティショニ
ングソフトウェアがこのフィールドを初期化する手間をかけてはいません。
MacOSパーティションのディスクパーティション名はファインダで変更するこ
とができますが、この変更はマップブロックには反映されません。

ある種のディスクフォーマッタは、それらがフォーマット時に使用する「標準」
パーティション名以外の名前を認識すると文句を言います。これは大した問題
ではないはずですが、Mkfsで変更を行ったディスクを同じフォーマッタで再パー
ティションする時に欝陶しいのは確かです(ぎょっとします)。
    
マウントして利用できるはずと思うような、しかし正しく初期化されていない
パーティションに出喰わした時のNetBSDはとても反社会的な振舞いをすること
があります。ですから、Mkfsを実行しないNetBSD Root&amp;Usrパーティションを
作らないのは非常に良い習慣です。こういう時こそApple_Freeパーティション
が活きるときでしょう。というのはNetBSDはApple_FreeパーティションはFFS
ディスクとして認識しないからです。[訳註:恐らくここはまるで意味不
明だと思いますが、訳者としても意味不明なのです。原文でもちょっと論理が
飛躍気味で…。恐らく、使わないディスクスペースをA/UX Root&amp;Usrなど
NetBSDがFFSとして認識するようなパーティションタイプでとっておくのは良
くない。そのようなことをするならApple_Freeを使うべきだ、といった意味だ
と思うのですが…]
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>最近のMkfs(つまり1.4以降)の更新によって、以前からの"Root"パーティションに加え、正しくNetBSD "Root&amp;Usr"と"Usr"パーティションも作れるようになりました。Installerも今はMkfsによって作られたこれらのタイプのパーティションすべてを認識するはずです。</P>
<P>Mkfsの最新版は:
<A HREF="ftp://ftp.netbsd.org/pub/NetBSD/arch/mac68k/utils/">ftp://ftp.netbsd.org/pub/NetBSD/arch/mac68k/utils/</A>
から入手可能です。</P>
<P>NetBSDはドライブあたり最大8個までのパーティションしか扱えないことに注意してください。しかも、実際にファイルシステムをマウントするために使えるのはそのうち6個までです(すなわちa、d、e、f、g、およびhです。bはスワップ用として、またcはディスク全体を現すパーティションです)。</P>


<H2><A NAME="B.I"></A> <A NAME="ss4.10">4.10 currentのバイナリスナップショットをインストールする一番の方法はなんですか？</A></H2>

<P>MacOSで動作するInstallerユーティリティを使ってもgzip圧縮tarファイルのインストールはできますが、もっと高速にインストールできる方法が他にあります。</P>
<P>まず、スナップショットを入手してNetBSDからアクセス可能な場所に置く必要があります。これには色々なやり方があります。ftp(またはzmodemなど)で直接NetBSDファイルシステムへスナップショットを転送することができますし、MacOSファイルシステムへ転送したあと(どのような方法でも構いませんが、バイナリモードで転送するのを忘れないように。さもないとファイルが壊れてしまいます)<CODE>hfs</CODE>ユーティリティかhfsutilsパッケージを使ってNetBSDパーティションへコピーすることもできます。また、InstallerユーティリティのミニシェルcpinコマンドでNetBSDパーティションへコピーすることも可能ですが、hfsプログラムの方が高速だと思います(そして、よりNetBSDの精神にかなっているとも言えるでしょう)。MacOSパーティションをアクセスするには、hfsユーティリティはrootの権限で実行することを忘れないでください。</P>
<P>第二に、スナップショットをインストールするにはシングルユーザーモードで行うのが最良です。[訳註:正式リリースをアップグレードする場合にも、NetBSDから行うのであればシングルユーザーモードでやるのが良いです]ですから、シングルユーザーモードでブートするか、<CODE>shutdown now</CODE>コマンドでマルチユーザーからシングルユーザーにモードを切り替えます。もしこの時点でファイルシステムが読み書き両用でマウントされていなければ、<CODE>mount -a</CODE>コマンドを実行して<CODE>/etc/fstab</CODE>に指定されたすべてのファイルシステムをマウントします。</P>
<P>いよいよ実際にスナップショットをインストールします。ルートディレクトリにいることを確認し、<CODE>etc.tar.gz</CODE>以外のスナップショットファイルそれぞれに対し、次のコマンドを実行します:
<BLOCKQUOTE><CODE>
<PRE>
tar --unlink -xvzpf file.tar.gz
</PRE>
</CODE></BLOCKQUOTE>

この<CODE>--unlink</CODE>オプションによって、現在既に実行中のプログラムファイル(例えばシェル、<CODE>tar</CODE>それ自身、<CODE>init</CODE>などです)が安全に上書きできるようになります。<CODE>z</CODE>オプションはgzip圧縮されたtarファイルを扱うときのオプションで、<CODE>p</CODE>によってアーカイブに保存された元ファイルのパーミッションすべてが復元されます。</P>
<P><CODE>etc.tar.gz</CODE>については、恐らく<CODE>/tmp</CODE>か<CODE>/usr/tmp</CODE>に一旦展開した方が良いでしょう。そこで内容を吟味し、更新が必要なファイルを確かめます。そして更新が必要なファイルだけを<CODE>/etc</CODE>に手動でコピーしてください。他のスナップショットファイルと同様にインストールしてしまうと、ローカルに行われた設定のほとんどが失われてしまいます。</P>
<P>ところで、currentカーネルを使っているのでない限り、とくにcurrentバイナリスナップショットをインストールする理由はありません。currentカーネルを正式リリース版バイナリと併用していると、<CODE>ps</CODE>や<CODE>netstat</CODE>などのプログラムが正常に動作しない問題が起きることがあります。[訳註:この問題については
<A HREF="faq-10.html#H.M">カーネルアップグレード時の障害の項</A>を参照してください]</P>
<P>この回答に関して協力してくれた以下の人々に感謝します:
<UL>
<LI>Allen Briggs (briggs@puma.macbsd.com)</LI>
<LI>Steve Allen (wormey@eskimo.com)</LI>
<LI>David Brownlee (david@mono.org)</LI>
<LI>Scott Reynolds (scottr@og.org)</LI>
</UL>
</P>


<H2><A NAME="B.J"></A> <A NAME="ss4.11">4.11 どうやって新しいカーネルをインストールするのでしょうか？</A></H2>

<P>カーネルとはNetBSDの<B>本体</B>ですから、正しいやり方でカーネルをインストールするのは極めて重要なことです。カーネルファイルは通常、以下の３つの方法で配付されます:
<OL>
<LI>生カーネルファイルとして</LI>
<LI>gzip圧縮されたバイナリファイルとして</LI>
<LI>gzip圧縮されたtarアーカイブファイルとして</LI>
</OL>

上の形式のいずれもバイナリモードで、できればUNIX->Mac変換などまったくなしで転送しないとファイル内容が壊れてしまいます。[訳註:もちろんBinHex形式のテキストファイルとして配付する人がいても構わない訳で、その場合はテキスト(ASCII)転送でもOKのですが、1.0以前の古い話を除けば、今のところそういう話は聞いたことがありません]</P>
<P>新しいカーネルをブートする時は、MacOSボリュームからカーネルをロードして、シングルユーザーモードで起動してみて、ハードウェアを正常に認識するかどうか試してみることを考慮すべきかも知れません。いきなり飛び込むのは時に恐しいものです。</P>
<P>NetBSD上で以下の手順を踏む際には、rootの権限で行うべきでしょう。</P>
<P>(新しいカーネルファイルを転送したあとで)まず最初に行うことは、現在使用中のカーネルのバックアップを作ることです。どのカーネルであってもあなたのマシンで動作するという保証はないので、新しいカーネルでうまくいくことがわかるまで、古い方もとっておくのが正解です。</P>
<P>次に、(もし必要なら)アーカイブファイルを展開してカーネルファイルを取り出し、ルートディレクトリへコピーします。MacOS側Installerユーティリティはgzip圧縮tarファイルを直接取り扱うことができます(実際、Installerがインストールできるのはtarファイルかgzip圧縮tarファイルだけです)。他のフォーマットの場合はNetBSDパーティションへコピーしてください。InstallerユーティリティではなくNetBSD側でtar.gzファイルを展開する場合は次のコマンドを使用します:
<BLOCKQUOTE><CODE>
<PRE>
tar xvzpf filname.tar.gz
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>さて、新しいカーネルを<CODE>/netbsd</CODE>とリネームした方がたぶん良いでしょう(まだしていなければ)。その理由はいくつかのプログラムは現在実行中のカーネルファイルをオープンするのですが、その時<CODE>/netbsd</CODE>というファイル名を仮定するからです。[訳註:その場合でもカーネルファイル名のデフォルトをオーバーライドするオプションが通常あるのですが、<CODE>ps</CODE>や<CODE>netstat</CODE>など実行するたびいちいちカーネルファイルを指定するのはいかにも面倒です]もし他の名前でインストールする選択を決めた場合は、Booterユーティリティの「Booting...」ダイアログボックスでカーネルファイル名を指定し直すのを忘れないように。</P>
<P>NetBSD実行中であれば、新しいカーネルを使うにはマシンのリブートが必要です。MacOS動作中なら、次のNetBSDブート時から新しいカーネルが使用されます。</P>
<P>この回答でヒントを与えてくれたScott Reynolds (scottr@og.org)に感謝します。</P>


<H2><A NAME="B.L"></A> <A NAME="ss4.12">4.12 Installerプログラムを使うと<CODE>Error on SCSIRead(), #5</CODE>というエラーになってしまうのですが</A></H2>

<P>これはタイプ5エラー(フェーズエラー)が起きたことを示しています。過去にはInstallerの古いバージョンのバグがこのエラーを引き起こしたこともあります(とくにCD-ROMからディスクラベルを読み込もうとした結果)。Mkfsユーティリティでも起こります。これが原因であれば無害ですからこのエラーメッセージは無視してしまって構いません。Installerの比較的新しいバージョンではこのバグは修正されていますが、Mkfsの最新版ではまだ残っているかも知れません。</P>
<P>しかし、最近の報告によれば、最新版のInstaller(現時点では1.1g)でさえ、大容量ディスク上のパーティション(1Gを超えるサイズ)を取り扱う際にこのトラブルが発生しているようです。この問題は他の製品よりもQuantum Fireballでより頻繁に発生するようです(Fireballだけに起こるものではないと思います)が、鍵となる要素は、大容量パーティションがディスクの後方(最初の1Gを越えた部分)にあることと、大きな配付セットをそうしたパーティションへ書き込むことにあるようです(小さなセットのインストールは正常に完了しますが大きなセットだと途中で異常終了してしまう)。似たようなInstallerのバグがしばらく前に修正されましたが、これはちょっとだけ違うようです。</P>
<P>Installerに与えるメモリを増やしてもこの問題が続くようなら、いくつか回避策があります。一番いいのはNetBSDパーティションをディスクの先頭へ(またはできるだけ先頭近くへ)移動することです。もしこれでうまくいかなければ、以下のMark Andres (mark@giganet.net)の提案を試してみてください:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
base.tgzをインストールするとき、恐らくInstallerが諦める前にファイルの大部分はインストールされているのではないでしょうか。もし私の記憶が正確なら、一番最近の儀牲者は/usr/share/man/あたりで止まっていたようです。これならtarは/usr/binですから既にインストールされていることでしょう。で、次のようにします:

1) できるところまでbase.tgzをインストールする

2) kern.tgz(またはSBCカーネル)、etc.tgz、そしてその他のファイルをできるところまでインストールします。

3) Installerのミニシェルcpinコマンドを使って、インストールできなかったファイルとbase.tgzをNetBSD側へコピーします。もしルートファイルシステムに十分空き領域がなければ別のファイルシステムへコピーする必要があります。

4) シングルユーザーモードでブートし、fsck -fを実行、そしてファイルシステムをmount -aコマンドでマウントします。

5) tarコマンドで残りのファイルをインストールします。ルートディレクトリにいることを確認して次のコマンドを実行します:

  tar --unlink -zxvpf /path/to/base.tgz

同様に他のtgzファイルもインストールすれば、完全なNetBSDシステムができあがりです。
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>このバグを修正するには全面的に改造されたインストール手順が必要になるかも知れません。</P>
<P>この質問に回答するのに協力してくれたStephen Brown (sbrown@shellx.best.com)、Charles Sebold (pretender@macstore.com)、そしてStuart McLuckie (mcluckie@mailhost.abel.net.uk)に感謝します。</P>


<H2><A NAME="B.M"></A> <A NAME="ss4.13">4.13 私のNetBSDパーティションがInstallerユーティリティに認識されず、マウントできないのですが</A></H2>

<P>古い版のInstaller(およびNetBSDカーネル)では、ディスク上のはじめの8パーティションしかNetBSDパーティションを探すためにチェックしなかったのです。もしたくさんのパーティションのあるドライブ(パーティションマップとドライバパーティションも含む)だと、NetBSDパーティションが最初の8エントリに入れないことがあり得ます。そうするとInstallerはそのパーティションを認識しません。パーティションの順番を入れ換えて症状が収まるか試してみてください。</P>
<P>より最近のカーネルでは最初の32パーティションをサーチするようになっていますから、必ず1.2リリース以降のカーネルにアップグレードするようにしてください。</P>
<P>もし大部分のパーティションの順序を入れ換えられない場合、Installerがアクセスできるよう先頭に近い場所にひとつだけNetBSDパーティションを作り、それ以外のパーティションにインストールしたいファイルを、そのパーティションにコピーします。それからNetBSDをブートし、目的のパーティションへファイルを展開すれば良いのです。</P>
<P>NetBSDはディスク一台あたり8個までのパーティションしか扱えないことに注意してください(そしてファイルシステムをマウントするのに使えるのはそのうち6個だけです)。</P>


<H2><A NAME="B.N"></A> <A NAME="ss4.14">4.14 InstallerとMkfsがMacOSパーティションを壊してしまうのはなぜですか？</A></H2>

<P>これは恐らく、あなたが大容量ハードドライブ(通常、1GB超)を持っており、Mkfsをとくに大きなパーティションに対して実行しようとしたからでしょう。Bob Nestor (rnestor@metronet.com)によるコメント:
<BLOCKQUOTE>
Mkfsはあるポイントを超えたところにあるディスクブロックの指定で問題を抱えています。SCSIマネジャーと、6バイト長CMDだけを使ってやりとりを行うため、ブロックアドレス長は21ビットに制限されてしまいます。この制限を超えるブロックをアクセスしようとすると上位ビットが切り捨てられ、ブロックアドレスが0へラップアラウンドしてしまうのです。
</BLOCKQUOTE>

ということで、Mkfsを大きなパーティションに対して実行することで他のパーティションを、パーティションマップやドライバパーティションも含め、破壊してしまうことは十分考えられることです。これが起きるとドライブはほとんど使用不可能になってしまいます(再初期化が必要になるでしょう)。この問題はドライブの先頭1ギガバイトを超えたパーティションをアクセスする場合にもに起きるようです。</P>
<P>また、この問題はInstallerユーティリティでも発生します。</P>
<P>幸いなことに、これは簡単に解決することができます。MkfsとInstallerの最新版を入手すれば良いのです:
<BLOCKQUOTE><CODE>
<A HREF="ftp://ftp.netbsd.org/pub/NetBSD/arch/mac68k/utils/">ftp://ftp.netbsd.org/pub/NetBSD/arch/mac68k/utils/</A><BR>
<A HREF="ftp://ftp.macbsd.com/pub/NetBSD/installer/">ftp://ftp.macbsd.com/pub/NetBSD/installer/</A></CODE></BLOCKQUOTE>
</P>
<P>これに比べてやや複雑な解決策は、NetBSDパーティションが最初の1Gを超えた場所に置かれないように確認することです。</P>


<H2><A NAME="B.O"></A> <A NAME="ss4.15">4.15 配付セットをインストールしようとするとInstallerがタイプ10のエラーでクラッシュしてしまいます</A></H2>

<P>この問題は、Installerバージョン1.1cがFPU命令入りでコンパイルされたのが原因です。FPUを持たない機種でのみこの問題は現れます。この問題を取り除くため1.1cは再コンパイルされましたし、また1.1dではこの問題は生じないので、1.1d以降へバージョンアップすることが最も簡単な解決策です。別の解決策はSoftware FPUをインストールすることです。</P>
<P>この問題に気づいたSteven Campbell (scampbel@osha.igs.net)と修正したStephen C. Brown (sbrown@shellx.best.com)に感謝します。</P>


<H2><A NAME="B.P"></A> <A NAME="ss4.16">4.16 NetBSD用に変換したいパーティションをMkfs 1.4が認識しないのですが</A></H2>

<P>この問題(といくつかのフォーマッタソフトウェアに対する小さな非互換性)はMkfs 1.45で修正されました。最新版を入手して試してみてください。この問題の背後にある理由(ともう旧式の回避策)を以下に述べます。</P>
<P>Bob Nestor (rnestor@metronet.com)より:
<BLOCKQUOTE>
Mkfs 1.2ではディスクパーティションマップは20エントリの大きさという仮定のもので、有効エントリのように見えるエントリは何でも使うようなっていました。Mkfs 1.4ではパーティションマップそのものに記録されたパーティションマップサイズを使うように変更されています。不幸なことに、いくつかのディスクフォーマッタがパーティションマップを作る上で少し知られたバグがあるのです。フォーマッタの中にはパーティションマップサイズを、実際の大きさよりも1だけ小さい値としてディスク上に記録するものがあるのです。最新のApple HDSC Setupにもこのバグがあると記憶しています。特定のサードパーティーディスクフォーマッタはこれを検出してディスクに修正可能なダメージがあるとして報告します。パーティションマップに続くブロックがマップエントリのように見える場合は、このブロックもエントリとして扱うことでこのエラーを「修正」することもできなくはありませんが、パーティションマップ直後のブロックはMacOSのSCSIドライバが使用していることが多いのでやや危険な方法に思えます。このパーティション[訳註:＝ドライバ]が損われてしかもこのディスクがブートディスクだったら、MacのROMはエラー音を出し、フロッピーからのブートができる以前にブート処理を途中でアボートしてしまいます！Mkfsの開発中に自分でこれをやってしまったので、同じ辛い教訓を他人には味あわせないことにし、パーティションマップの「1ずれ」エラーはMkfsでは「修正」しないことにしました。もしかしたらこれは正しい決断ではなかったかも知れませんが、その時は正しく思えたのです。
</BLOCKQUOTE>

<BLOCKQUOTE>
たくさんの人が報告しているように、別の回避策は最小サイズのMacOSパーティションをディスクの最後に作ることです。これによって、たとえ「1ずれ」バグを持ったフォーマッタを使用していても、パーティションマップ直後のドライバパーティションをマップエントリであるかのように処理することがなくなります。このパーティションはBooterその他を置いておくにもちょうどいい場所です。
</BLOCKQUOTE>

(1KB大のスクラッチパーティションをディスクの最後につくるのも、無駄になるディスク領域が少いのでよい手です―Colin)
<BLOCKQUOTE>
Mkfs 1.2ではパーティションマップは読み込まれるだけで書き込まれることはなかったので、マップの最後を通り過ぎたとしても大した問題ではなかったのです。ところがMkfs 1.4ではMacOSパーティションをNetBSDタイプのパーティションに変えてしまうことができます。このためパーティションマップエントリブロックはディスクに書き込まれなければならなくなりました。バグつきパーティションマップのせいでSCSIドライバパーティションを上書きしてしまう可能性は十分あり、実際、Mkfsのテスト中、私に一度起きてもいます。パーティションマップエントリでも有効とわかっているものに対してのみMkfsを動作させるようにするのは、このエラーから身を守る簡単な手段でした。
</BLOCKQUOTE>
</P>


<H2><A NAME="B.Q"></A> <A NAME="ss4.17">4.17 なぜシリアルコンソールの電源を切るとデバッガに落ちてしまうのですか</A></H2>

<P>原因はNetBSDがブレークシグナルを受信したと勘違いするからで、ブレークシグナルは慣習的なデバッガ起動法なのです。この機能を無効化する場合にはカーネルコンフィギュレーションファイルの以下の行をコメントアウトしてカーネルを再構築します:
<BLOCKQUOTE><CODE>
<PRE>
options         ZS_CONSOLE_ABORT
</PRE>
</CODE></BLOCKQUOTE>
</P>


<H2><A NAME="B.R"></A> <A NAME="ss4.18">4.18 <CODE>newfs</CODE>を使ってパーティションをフォーマットしたのですが、Installerからこのパーティションに何かインストールしようとするとクラッシュしてしまいます</A></H2>

<P>Installerはレベル1 FFSファイルシステムのみを認識します。一方<CODE>newfs</CODE>はデフォルトでレベル2 FFSファイルシステムを作るのです。レベル2ファイルシステムはレベル1にはない機能がいくつかあります。詳しい違いについては<CODE>newfs</CODE>(8)マニュアルページを参照してください。</P>
<P>ふたつ解決策が考えられます。ひとつは問題のパーティションをMkfsユーティリティで再フォーマットすること(パーティションの内容はすべて失われてしまいますが)、もうひとつは<CODE>hfs</CODE>またはhfsutilsパッケージを使ってファイルをMacOSパーティションからNetBSDへコピーし、
<A HREF="#B.I">前述したように</A>NetBSD側でインストールを行うことです。</P>


<H2><A NAME="B.S"></A> <A NAME="ss4.19">4.19 アップグレード作業を楽にするため、NetBSDリリース毎の違いが知りたいのですが</A></H2>

<P>比較的最新の全変更リストは(currentでの変更も含めて)、ここにあります:</P>
<P>
<A HREF="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-current/doc/CHANGES">ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-current/doc/CHANGES</A></P>
<P>各NetBSDリリースディレクトリには同様のファイルがあり、前回のリリースからの変更点が列挙されているはずです。</P>


<H2><A NAME="B.T"></A> <A NAME="ss4.20">4.20 NetBSD 1.3にアップグレードしたら<CODE>fsck</CODE>の使用法メッセージの後ブートがハングしてしまいます</A></H2>

<P>ふたつの可能性が考えられます。ひとつには<CODE>/etc/fstab</CODE>中の<CODE>ufs</CODE>をすべて<CODE>ffs</CODE>に変更する必要があること。もうひとつは何らかの理由で<CODE>/sbin/fsck</CODE>と<CODE>/sbin/fsck_ffs</CODE>の旧バージョンが新バージョンによって上書きされなかったことです。この問題を避けるため
<A HREF="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.3/mac68k/INSTALL">INSTALL</A>ノートの手順を踏んでNetBSDの中でアップグレードしてください。</P>


<H2><A NAME="B.U"></A> <A NAME="ss4.21">4.21 2GBディスクにインストールしようとするとInstallerが<CODE>unimplemented trap</CODE>エラーでクラッシュしてしまいます</A></H2>

<P>大容量パーティションへの大量データ書き込みについてInstallerには問題があるようです。回避策としては、複数の小さなパーティションを使うか、またはInstallerでできるところまでインストールし、なんとか<CODE>tar</CODE>[訳註:それと<CODE>gzip</CODE>も必要でしょう]がインストールできたらアーカイブファイルをNetBSDファイルシステムにコピーして残りのインストールはNetBSDから行います。この問題への対処法としては前者の方がよいかも知れません。</P>
<P>回避策を寄せてくれたPaul Forgey (paulf@aphrodite.com)に感謝します。</P>


<H2><A NAME="B.V"></A> <A NAME="ss4.22">4.22 NetBSD 1.3へのフルアップグレードが完了したのですが、なぜ<CODE>/etc/rc.conf is not configured. Multiuser boot aborted.</CODE>というメッセージが出るのでしょうか？</A></H2>

<P>INSTALLノートのアップグレードの項にもありますが、最低でも<CODE>/etc/rc.conf</CODE>ファイルだけは好みの設定に編集し、次の行を加える必要があります:
<BLOCKQUOTE><CODE>
<PRE>
rc_configured=YES
</PRE>
</CODE></BLOCKQUOTE>

これによってマルチユーザーブートが完了するようになります。NetBSD 1.2以前ではこのファイルは存在しませんが、この中には数々の有用な機能が含まれており、許可すると良いかも知れません。ファイルをよく読み、また様々なオプションについては<CODE>rc.conf</CODE>(5)マニュアルページを参照してください。このファイルの編集に何か問題がある場合は
<A HREF="ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-1.3/mac68k/INSTALL">INSTALL</A>ノートにある詳しい説明を参照してください。</P>



<HR>
<A HREF="faq-3.html">Previous</A>
<A HREF="faq-5.html">Next</A>
<A HREF="faq.html#toc4">Table of Contents</A>
</BODY>
</HTML>
